#2 "backend/arm64/emit.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Gallium, INRIA Rocquencourt           *)
(*                 Benedikt Meurer, University of Siegen                  *)
(*                                                                        *)
(*   Copyright 2013 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*   Copyright 2012 Benedikt Meurer.                                      *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Emission of ARM assembly code, 64-bit mode *)

open Misc
open Cmm
open Arch
open Proc
open Reg
open Mach
open Linear
open Emitaux

(* Tradeoff between code size and code speed *)

let fastcode_flag = ref true

(* Names for special regs *)

let reg_domain_state_ptr = phys_reg Int 25 (* x28 *)
let reg_trap_ptr = phys_reg Int 23 (* x26 *)
let reg_alloc_ptr = phys_reg Int 24 (* x27 *)
let reg_tmp1 = phys_reg Int 26 (* x16 *)
let reg_x8 = phys_reg Int 8 (* x8 *)
let _reg_stack_arg_begin = phys_reg Int 17  (* x20 *)
let _reg_stack_arg_end  = phys_reg Int 18 (* x21 *)


(* Output a label *)

let label_prefix =
  if macosx then "L" else ".L"

let emit_label lbl =
  emit_string label_prefix; emit_int lbl

(* Symbols *)

(* CR sdolan: Support local symbol definitions & references on arm64 *)

let emit_symbol s =
  if macosx then emit_string "_";
  Emitaux.emit_symbol s

(* Object types *)

let emit_symbol_type emit_lbl_or_sym lbl_or_sym ty =
  if not macosx then begin
    `	.type	{emit_lbl_or_sym lbl_or_sym}, %{emit_string ty}\n`
  end


let emit_symbol_size sym =
  if not macosx then begin
    `	.size	{emit_symbol sym}, .-{emit_symbol sym}\n`
  end

(* Output a pseudo-register *)

let emit_reg = function
    {loc = Reg r; typ} -> emit_string (register_name typ r)
  | _ -> fatal_error "Emit.emit_reg"

(* Likewise, but with the 32-bit name of the register *)

let int_reg_name_w =
  [| "w0";  "w1";  "w2";  "w3";  "w4";  "w5";  "w6";  "w7";
     "w8";  "w9";  "w10"; "w11"; "w12"; "w13"; "w14"; "w15";
     "w19"; "w20"; "w21"; "w22"; "w23"; "w24"; "w25";
     "w26"; "w27"; "w28"; "w16"; "w17" |]

let emit_wreg = function
    {loc = Reg r} -> emit_string int_reg_name_w.(r)
  | _ -> fatal_error "Emit.emit_wreg"

(* Layout of the stack frame *)

let stack_offset = ref 0

let num_stack_slots = Array.make Proc.num_stack_slot_classes 0

let prologue_required = ref false

let contains_calls = ref false

let initial_stack_offset () =
    8 * num_stack_slots.(0) +
    8 * num_stack_slots.(1) +
    (if !contains_calls then 8 else 0)

let frame_size () =
  let sz =
    !stack_offset +
    initial_stack_offset ()
  in Misc.align sz 16

let slot_offset loc cl =
  match loc with
    Incoming n ->
      assert (n >= 0);
      frame_size() + n
  | Local n ->
      !stack_offset +
      (if cl = 0
       then n * 8
       else num_stack_slots.(0) * 8 + n * 8)
  | Outgoing n ->
      assert (n >= 0);
      n
  | Domainstate _ -> assert false (* not a satck slot *)

(* Output a stack reference *)

let emit_stack r =
  match r.loc with
  | Stack (Domainstate n) ->
      let ofs = n + Domainstate.(idx_of_field Domain_extra_params) * 8 in
      `[{emit_reg reg_domain_state_ptr}, #{emit_int ofs}]`
  | Stack s ->
      let ofs = slot_offset s (stack_slot_class r.typ) in
      `[sp, #{emit_int ofs}]`
  | _ -> fatal_error "Emit.emit_stack"

(* Output an addressing mode *)

let emit_symbol_offset s ofs =
  emit_symbol s;
  if ofs > 0 then `+{emit_int ofs}`
  else if ofs < 0 then `-{emit_int (-ofs)}`
  else ()

let emit_addressing addr r =
  match addr with
  | Iindexed ofs ->
      `[{emit_reg r}, #{emit_int ofs}]`
  | Ibased(s, ofs) ->
      assert (not !Clflags.dlcode);  (* see selection.ml *)
      `[{emit_reg r}, #:lo12:{emit_symbol_offset s ofs}]`

(* Record live pointers at call points *)

let record_frame_label live dbg =
  let lbl = new_label () in
  let live_offset = ref [] in
  Reg.Set.iter
    (function
      | {typ = Val; loc = Reg r} ->
          live_offset := ((r lsl 1) + 1) :: !live_offset
      | {typ = Val; loc = Stack s} as reg ->
          live_offset := slot_offset s (stack_slot_class reg.typ) :: !live_offset
      | {typ = Addr} as r ->
          Misc.fatal_error ("bad GC root " ^ Reg.name r)
      | _ -> ())
    live;
  record_frame_descr ~label:lbl ~frame_size:(frame_size())
    ~live_offset:!live_offset dbg;
  lbl

let record_frame live dbg =
  let lbl = record_frame_label live dbg in `{emit_label lbl}:`

(* Record calls to the GC -- we've moved them out of the way *)

type gc_call =
  { gc_lbl: label;                      (* Entry label *)
    gc_return_lbl: label;               (* Where to branch after GC *)
    gc_frame_lbl: label }               (* Label of frame descriptor *)

let call_gc_sites = ref ([] : gc_call list)

let emit_call_gc gc =
  `{emit_label gc.gc_lbl}:	bl	{emit_symbol "caml_call_gc"}\n`;
  `{emit_label gc.gc_frame_lbl}:	b	{emit_label gc.gc_return_lbl}\n`

(* Record calls to local stack reallocation *)

type local_realloc_call =
  {  lr_lbl: label;
     lr_return_lbl: label;
     lr_dbg: Debuginfo.t
  }

let local_realloc_sites = ref ([] : local_realloc_call list)

let emit_local_realloc lr =
  `{emit_label lr.lr_lbl}:\n`;
  `	{emit_debug_info lr.lr_dbg}\n`;
  `	bl	{emit_symbol "caml_call_local_realloc"}\n`;
  `	b	{emit_label lr.lr_return_lbl}\n`

(* Names of various instructions *)

let name_for_comparison = function
  | Isigned Ceq -> "eq" | Isigned Cne -> "ne" | Isigned Cle -> "le"
  | Isigned Cge -> "ge" | Isigned Clt -> "lt" | Isigned Cgt -> "gt"
  | Iunsigned Ceq -> "eq" | Iunsigned Cne -> "ne" | Iunsigned Cle -> "ls"
  | Iunsigned Cge -> "cs" | Iunsigned Clt -> "cc" | Iunsigned Cgt -> "hi"

let name_for_int_operation = function
  | Iadd -> "add"
  | Isub -> "sub"
  | Imul -> "mul"
  | Idiv -> "sdiv"
  | Iand -> "and"
  | Ior  -> "orr"
  | Ixor -> "eor"
  | Ilsl -> "lsl"
  | Ilsr -> "lsr"
  | Iasr -> "asr"
  | _ -> assert false

(* Decompose an integer constant into four 16-bit shifted fragments.
   Omit the fragments that are equal to "default" (16 zeros or 16 ones). *)

let decompose_int default n =
  let rec decomp n pos =
    if pos >= 64 then [] else begin
      let frag = Nativeint.logand n 0xFFFFn
      and rem  = Nativeint.shift_right_logical n 16 in
      if frag = default
      then decomp rem (pos + 16)
      else (frag, pos) :: decomp rem (pos + 16)
    end
  in decomp n 0

(* Load an integer constant into a register *)

let emit_movk dst (f, p) =
    `	movk	{emit_reg dst}, #{emit_nativeint f}, lsl #{emit_int p}\n`

let emit_intconst dst n =
  if is_logical_immediate n then
    `	orr	{emit_reg dst}, xzr, #{emit_nativeint n}\n`
  else begin
    let dz = decompose_int 0x0000n n
    and dn = decompose_int 0xFFFFn n in
    if List.length dz <= List.length dn then begin
      match dz with
      | [] ->
          `	mov	{emit_reg dst}, xzr\n`
      | (f, p) :: l ->
          `	movz	{emit_reg dst}, #{emit_nativeint f}, lsl #{emit_int p}\n`;
          List.iter (emit_movk dst) l
    end else begin
      match dn with
      | [] ->
          `	movn	{emit_reg dst}, #0\n`
      | (f, p) :: l ->
          let nf = Nativeint.logxor f 0xFFFFn in
          `	movn	{emit_reg dst}, #{emit_nativeint nf}, lsl #{emit_int p}\n`;
          List.iter (emit_movk dst) l
    end
  end

let num_instructions_for_intconst n =
  if is_logical_immediate n then 1 else begin
    let dz = decompose_int 0x0000n n
    and dn = decompose_int 0xFFFFn n in
    max 1 (min (List.length dz) (List.length dn))
  end

(* Recognize float constants appropriate for FMOV dst, #fpimm instruction:
   "a normalized binary floating point encoding with 1 sign bit, 4
    bits of fraction and a 3-bit exponent" *)

let is_immediate_float bits =
  let exp = (Int64.(to_int (shift_right_logical bits 52)) land 0x7FF) - 1023 in
  let mant = Int64.logand bits 0xF_FFFF_FFFF_FFFFL in
  exp >= -3 && exp <= 4 && Int64.logand mant 0xF_0000_0000_0000L = mant

(* Adjust sp (up or down) by the given byte amount *)

let emit_stack_adjustment n =
  let instr = if n < 0 then "sub" else "add" in
  let m = abs n in
  assert (m < 0x1_000_000);
  let ml = m land 0xFFF and mh = m land 0xFFF_000 in
  if mh <> 0 then `	{emit_string instr}	sp, sp, #{emit_int mh}\n`;
  if ml <> 0 then `	{emit_string instr}	sp, sp, #{emit_int ml}\n`;
  if n <> 0 then cfi_adjust_cfa_offset (-n)

(* Deallocate the stack frame and reload the return address
   before a return or tail call *)

let output_epilogue f =
  let n = frame_size() in
  if !contains_calls then
    `	ldr	x30, [sp, #{emit_int (n-8)}]\n`;
  if n > 0 then
    emit_stack_adjustment n;
  f();
  (* reset CFA back because function body may continue *)
  if n > 0 then cfi_adjust_cfa_offset n

(* Output add-immediate / sub-immediate / cmp-immediate instructions *)

let rec emit_addimm rd rs n =
  if n < 0 then emit_subimm rd rs (-n)
  else if n <= 0xFFF then
    `	add	{emit_reg rd}, {emit_reg rs}, #{emit_int n}\n`
  else begin
    assert (n <= 0xFFF_FFF);
    let nl = n land 0xFFF and nh = n land 0xFFF_000 in
    `	add	{emit_reg rd}, {emit_reg rs}, #{emit_int nh}\n`;
    if nl <> 0 then
      `	add	{emit_reg rd}, {emit_reg rd}, #{emit_int nl}\n`
  end

and emit_subimm rd rs n =
  if n < 0 then emit_addimm rd rs (-n)
  else if n <= 0xFFF then
    `	sub	{emit_reg rd}, {emit_reg rs}, #{emit_int n}\n`
  else begin
    assert (n <= 0xFFF_FFF);
    let nl = n land 0xFFF and nh = n land 0xFFF_000 in
    `	sub	{emit_reg rd}, {emit_reg rs}, #{emit_int nh}\n`;
    if nl <> 0 then
      `	sub	{emit_reg rd}, {emit_reg rd}, #{emit_int nl}\n`
  end

let emit_cmpimm rs n =
  if n >= 0
  then `	cmp	{emit_reg rs}, #{emit_int n}\n`
  else `	cmn	{emit_reg rs}, #{emit_int (-n)}\n`

(* Name of current function *)
let function_name = ref ""
(* Entry point for tail recursive calls *)
let tailrec_entry_point = ref None
(* Pending floating-point literals *)
let float_literals = ref ([] : (int64 * label) list)

(* Label a floating-point literal *)
let float_literal f =
  try
    List.assoc f !float_literals
  with Not_found ->
    let lbl = new_label() in
    float_literals := (f, lbl) :: !float_literals;
    lbl

(* Emit all pending literals *)
let emit_literals() =
  if !float_literals <> [] then begin
    if macosx then
      `	.section	__TEXT,__literal8,8byte_literals\n`;
    `	.align	3\n`;
    List.iter
      (fun (f, lbl) ->
        `{emit_label lbl}:`; emit_float64_directive ".quad" f)
      !float_literals;
    float_literals := []
  end

(* Emit code to load the address of a symbol *)

let emit_load_symbol_addr dst s =
  if macosx then begin
    `	adrp	{emit_reg dst}, {emit_symbol s}@GOTPAGE\n`;
    `	ldr	{emit_reg dst}, [{emit_reg dst}, {emit_symbol s}@GOTPAGEOFF]\n`
  end else if not !Clflags.dlcode then begin
    `	adrp	{emit_reg dst}, {emit_symbol s}\n`;
    `	add	{emit_reg dst}, {emit_reg dst}, #:lo12:{emit_symbol s}\n`
  end else begin
    `	adrp	{emit_reg dst}, :got:{emit_symbol s}\n`;
    `	ldr	{emit_reg dst}, [{emit_reg dst}, #:got_lo12:{emit_symbol s}]\n`
  end

(* The following functions are used for calculating the sizes of the
   call GC and bounds check points emitted out-of-line from the function
   body.  See branch_relaxation.mli. *)

let num_call_gc_points instr =
  let rec loop instr call_gc =
    match instr.desc with
    | Lend -> call_gc
    | Lop (Ialloc { mode = Alloc_heap; _ }) when !fastcode_flag ->
      loop instr.next (call_gc + 1)
    | Lop (Ipoll _) ->
      loop instr.next (call_gc + 1)
    (* The following four should never be seen, since this function is run
       before branch relaxation. *)
    | Lop (Ispecific (Ifar_alloc _))
    | Lop (Ispecific (Ifar_poll _)) -> assert false
    | _ -> loop instr.next call_gc
  in
  loop instr 0

let max_out_of_line_code_offset ~num_call_gc =
  if num_call_gc < 1 then 0
  else begin
    let size_of_call_gc = 2 in
    let size_of_last_thing = size_of_call_gc in
    let total_size = size_of_call_gc*num_call_gc in
    let max_offset = total_size - size_of_last_thing in
    assert (max_offset >= 0);
    max_offset
  end

module BR = Branch_relaxation.Make (struct
  (* CR-someday mshinwell: B and BL have +/- 128Mb ranges; for the moment we
     assume we will never exceed this.  It would seem to be most likely to
     occur for branches between functions; in this case, the linker should be
     able to insert veneers anyway.  (See section 4.6.7 of the document
     "ELF for the ARM 64-bit architecture (AArch64)".) *)

  type distance = int

  module Cond_branch = struct
    type t = TB | CB | Bcc

    let all = [TB; CB; Bcc]

    (* AArch64 instructions are 32 bits wide, so [distance] in this module
       means units of 32-bit words. *)
    let max_displacement = function
      | TB -> 32 * 1024 / 4  (* +/- 32Kb *)
      | CB | Bcc -> 1 * 1024 * 1024 / 4  (* +/- 1Mb *)

    let classify_instr = function
      | Lop (Ialloc _)
      | Lop (Ipoll _) -> Some Bcc
      (* The various "far" variants in [specific_operation] don't need to
         return [Some] here, since their code sequences never contain any
         conditional branches that might need relaxing. *)
      | Lcondbranch (Itruetest, _)
      | Lcondbranch (Ifalsetest, _) -> Some CB
      | Lcondbranch (Iinttest _, _)
      | Lcondbranch (Iinttest_imm _, _)
      | Lcondbranch (Ifloattest _, _) -> Some Bcc
      | Lcondbranch (Ioddtest, _)
      | Lcondbranch (Ieventest, _) -> Some TB
      | Lcondbranch3 _ -> Some Bcc
      | _ -> None
  end

  let offset_pc_at_branch = 0

  let prologue_size () =
    (if initial_stack_offset () > 0 then 2 else 0)
      + (if !contains_calls then 1 else 0)

  let epilogue_size () =
    if !contains_calls then 3 else 2

  let instr_size = function
    | Lend -> 0
    | Lprologue -> prologue_size ()
    | Lop (Imove | Ispill | Ireload) -> 1
    | Lop (Iconst_int n) ->
      num_instructions_for_intconst n
    | Lop (Iconst_float _) -> 2
    | Lop (Iconst_symbol _) -> 2
    | Lop (Iconst_vec128 _) ->
      (* CR mslater: (SIMD) arm64 *)
      Misc.fatal_error "128-bit vectors are not supported on this architecture"
    | Lop (Iintop_atomic _) ->
      (* Never generated; builtins are not yet translated to atomics *)
      assert false
    | Lop (Icall_ind) -> 1
    | Lop (Icall_imm _) -> 1
    | Lop (Itailcall_ind) -> epilogue_size ()
    | Lop (Itailcall_imm { func; _ }) ->
      if func.sym_name = !function_name then 1 else epilogue_size ()
    | Lop (Iextcall {alloc; stack_ofs} ) ->
      if stack_ofs > 0 then 5
      else if alloc then 3
      else 5
    | Lop (Istackoffset _) -> 2
    | Lop (Iload  { memory_chunk; addressing_mode; is_atomic }) ->
      let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
      and barrier = if is_atomic then 1 else 0
      and single = match memory_chunk with Single -> 2 | _ -> 1 in
      based + barrier + single
    | Lop (Istore (memory_chunk, addressing_mode, assignment)) ->
      let based = match addressing_mode with Iindexed _ -> 0 | Ibased _ -> 1
      and barrier =
        match memory_chunk, assignment with
        | (Word_int | Word_val), true -> 1
        | _ -> 0
      and single = match memory_chunk with Single -> 2 | _ -> 1 in
      based + barrier + single
    | Lop (Ialloc { mode = Alloc_local; _ }) -> 9
    | Lop (Ialloc _) when !fastcode_flag -> 5
    | Lop (Ispecific (Ifar_alloc _)) when !fastcode_flag -> 6
    | Lop (Ipoll _) -> 3
    | Lop (Ispecific (Ifar_poll _)) -> 4
    | Lop (Ialloc { bytes = num_bytes; _ })
    | Lop (Ispecific (Ifar_alloc { bytes = num_bytes; _ })) ->
      begin match num_bytes with
      | 16 | 24 | 32 -> 1
      | _ -> 1 + num_instructions_for_intconst (Nativeint.of_int num_bytes)
      end
    | Lop (Icsel _) -> 4
    | Lop (Ibeginregion | Iendregion) -> 1
    | Lop (Iintop (Icomp _)) -> 2
    | Lop (Ifloatop (Icompf _)) -> 2
    | Lop (Iintop_imm (Icomp _, _)) -> 2
    | Lop (Iintop Imod) -> 2
    | Lop (Iintop (Imulh _)) -> 1
    | Lop (Iintop _) -> 1
    | Lop (Iintop_imm _) -> 1
    | Lop (Ifloatop (Iabsf | Inegf) | Ispecific Isqrtf) -> 1
    | Lop (Ivalueofint | Iintofvalue) -> 1
    | Lop (Ivectorcast _) -> 1
    | Lop (Iscalarcast _) -> 1
    | Lop (Ifloatop (Iaddf | Isubf | Imulf | Idivf) | Ispecific Inegmulf) -> 1
    | Lop (Iopaque) -> 0
    | Lop (Ispecific (Imuladdf | Inegmuladdf | Imulsubf | Inegmulsubf)) -> 1
    | Lop (Ispecific (Ishiftarith _)) -> 1
    | Lop (Ispecific (Imuladd | Imulsub)) -> 1
    | Lop (Ispecific (Ibswap { bitwidth = Sixteen } )) -> 2
    | Lop (Ispecific (Ibswap { bitwidth = (Thirtytwo | Sixtyfour) })) -> 1
    | Lop (Ispecific Imove32) -> 1
    | Lop (Ispecific (Isignext _)) -> 1
    | Lop (Iname_for_debugger _) -> 0
    | Lop (Iprobe _ | Iprobe_is_enabled _) ->
      fatal_error ("Probes not supported.")
    | Lop (Idls_get) -> 1
    | Lreloadretaddr -> 0
    | Lreturn -> epilogue_size ()
    | Llabel _ -> 0
    | Lbranch _ -> 1
    | Lcondbranch (tst, _) ->
      begin match tst with
      | Itruetest -> 1
      | Ifalsetest -> 1
      | Iinttest _ -> 2
      | Iinttest_imm _ -> 2
      | Ifloattest _ -> 2
      | Ioddtest -> 1
      | Ieventest -> 1
      end
    | Lcondbranch3 (lbl0, lbl1, lbl2) ->
      1 + begin match lbl0 with None -> 0 | Some _ -> 1 end
        + begin match lbl1 with None -> 0 | Some _ -> 1 end
        + begin match lbl2 with None -> 0 | Some _ -> 1 end
    | Lswitch jumptbl -> 3 + Array.length jumptbl
    | Lentertrap -> 0
    | Ladjust_stack_offset _ -> 0
    | Lpushtrap _ -> 4
    | Lpoptrap -> 1
    | Lraise k ->
      begin match k with
      | Lambda.Raise_regular -> 1
      | Lambda.Raise_reraise -> 1
      | Lambda.Raise_notrace -> 4
      end
    | Lstackcheck _ -> assert false (* not supported *)

  let relax_poll ~return_label =
    Lop (Ispecific (Ifar_poll { return_label }))

  let relax_allocation ~num_bytes ~dbginfo =
    Lop (Ispecific (Ifar_alloc { bytes = num_bytes; dbginfo }))
end)

let name_for_float_comparison = function
  | CFeq -> "eq"
  | CFneq -> "ne"
  | CFlt -> "cc"
  | CFnlt -> "cs"
  | CFle -> "ls"
  | CFnle -> "hi"
  | CFgt -> "gt"
  | CFngt -> "le"
  | CFge -> "ge"
  | CFnge -> "lt"

(* Output the assembly code for allocation. *)

let assembly_code_for_allocation i ~local ~n ~far ~dbginfo =
  if local then begin
    let r = i.res.(0) in
    let domain_local_sp_offset = Domainstate.(idx_of_field Domain_local_sp) * 8 in
    let domain_local_limit_offset = Domainstate.(idx_of_field Domain_local_limit) * 8 in
    let domain_local_top_offset = Domainstate.(idx_of_field Domain_local_top) * 8 in
    `	ldr	{emit_reg reg_tmp1}, [{emit_reg reg_domain_state_ptr}, #{emit_int domain_local_limit_offset}]\n`;
    `	ldr	{emit_reg r}, [{emit_reg reg_domain_state_ptr}, #{emit_int domain_local_sp_offset}]\n`;
    `	sub	{emit_reg r}, {emit_reg r}, #{emit_int n}\n`;
    `	str	{emit_reg r}, [{emit_reg reg_domain_state_ptr}, #{emit_int domain_local_sp_offset}]\n`;
    `	cmp	{emit_reg r}, {emit_reg reg_tmp1}\n`;
    let lbl_call = new_label () in
    `	b.le	{emit_label lbl_call}\n`;
    let lbl_after_alloc = new_label () in
    `{emit_label lbl_after_alloc}:\n`;
    `	ldr	{emit_reg reg_tmp1}, [{emit_reg reg_domain_state_ptr}, #{emit_int domain_local_top_offset}]\n`;
    `	add	{emit_reg r}, {emit_reg r}, {emit_reg reg_tmp1}\n`;
    `	add	{emit_reg r}, {emit_reg r}, #{emit_int 8}\n`;
    local_realloc_sites :=
      { lr_lbl = lbl_call;
        lr_dbg = i.dbg;
        lr_return_lbl = lbl_after_alloc } :: !local_realloc_sites
  end else begin
    let lbl_frame =
      record_frame_label i.live (Dbg_alloc dbginfo)
    in
    if !fastcode_flag then begin
      let lbl_after_alloc = new_label() in
      let lbl_call_gc = new_label() in
      (* n is at most Max_young_whsize * 8, i.e. currently 0x808,
         so it is reasonable to assume n < 0x1_000.  This makes
         the generated code simpler. *)
      assert (16 <= n && n < 0x1_000 && n land 0x7 = 0);
      let offset = Domainstate.(idx_of_field Domain_young_limit) * 8 in
      `	ldr	{emit_reg reg_tmp1}, [{emit_reg reg_domain_state_ptr}, #{emit_int offset}]\n`;
      `	sub	{emit_reg reg_alloc_ptr}, {emit_reg reg_alloc_ptr}, #{emit_int n}\n`;
      `	cmp	{emit_reg reg_alloc_ptr}, {emit_reg reg_tmp1}\n`;
      if not far then begin
        `	b.lo	{emit_label lbl_call_gc}\n`
      end else begin
        let lbl = new_label () in
        `	b.cs	{emit_label lbl}\n`;
        `	b	{emit_label lbl_call_gc}\n`;
        `{emit_label lbl}:\n`
      end;
      `{emit_label lbl_after_alloc}:`;
      `	add	{emit_reg i.res.(0)}, {emit_reg reg_alloc_ptr}, #8\n`;
      call_gc_sites :=
        { gc_lbl = lbl_call_gc;
          gc_return_lbl = lbl_after_alloc;
          gc_frame_lbl = lbl_frame } :: !call_gc_sites
    end else begin
      begin match n with
      | 16 -> `	bl	{emit_symbol "caml_alloc1"}\n`
      | 24 -> `	bl	{emit_symbol "caml_alloc2"}\n`
      | 32 -> `	bl	{emit_symbol "caml_alloc3"}\n`
      | _  -> emit_intconst reg_x8 (Nativeint.of_int n);
              `	bl	{emit_symbol "caml_allocN"}\n`
      end;
      `{emit_label lbl_frame}:	add	{emit_reg i.res.(0)}, {emit_reg reg_alloc_ptr}, #8\n`
    end
  end

let assembly_code_for_poll i ~far ~return_label =
  let lbl_frame = record_frame_label i.live (Dbg_alloc []) in
  let lbl_call_gc = new_label() in
  let lbl_after_poll = match return_label with
  | None -> new_label()
  | Some lbl -> lbl in
  let offset = Domainstate.(idx_of_field Domain_young_limit) * 8 in
    `	ldr	{emit_reg reg_tmp1}, [{emit_reg reg_domain_state_ptr}, #{emit_int offset}]\n`;
    `	cmp	{emit_reg reg_alloc_ptr}, {emit_reg reg_tmp1}\n`;
  if not far then begin
    match return_label with
    | None ->
        `	b.ls	{emit_label lbl_call_gc}\n`;
        `{emit_label lbl_after_poll}:\n`
    | Some return_label ->
        `	b.hi	{emit_label return_label}\n`;
        `	b	{emit_label lbl_call_gc}\n`;
  end else begin
    match return_label with
    | None ->
        `	b.hi	{emit_label lbl_after_poll}\n`;
        `	b	{emit_label lbl_call_gc}\n`;
        `{emit_label lbl_after_poll}:\n`
    | Some return_label ->
        let lbl = new_label () in
        `	b.ls	{emit_label lbl}\n`;
        `	b	{emit_label return_label}\n`;
        `{emit_label lbl}:	b	{emit_label lbl_call_gc}\n`
  end;
  call_gc_sites :=
    { gc_lbl = lbl_call_gc;
      gc_return_lbl = lbl_after_poll;
      gc_frame_lbl = lbl_frame; } :: !call_gc_sites

(* Output .text section directive, or named .text.caml.<name> if enabled. *)

let emit_named_text_section func_name =
  if !Clflags.function_sections then begin
    `	.section .text.caml.{emit_symbol func_name},{emit_string_literal "ax"},%progbits\n`
  end
  else
    `	.text\n`

(* Emit code to load an emitted literal *)

let emit_load_literal dst lbl =
  if macosx then begin
    `	adrp	{emit_reg reg_tmp1}, {emit_label lbl}@PAGE\n`;
    `	ldr	{emit_reg dst}, [{emit_reg reg_tmp1}, {emit_label lbl}@PAGEOFF]\n`
  end else begin
    `	adrp	{emit_reg reg_tmp1}, {emit_label lbl}\n`;
    `	ldr	{emit_reg dst}, [{emit_reg reg_tmp1}, #:lo12:{emit_label lbl}]\n`
  end


let move src dst =
  if src.loc <> dst.loc then begin
    match (src, dst) with
    | {loc = Reg _; typ = Float}, {loc = Reg _} ->
      `	fmov	{emit_reg dst}, {emit_reg src}\n`
    | {loc = Reg _}, {loc = Reg _} ->
      `	mov	{emit_reg dst}, {emit_reg src}\n`
    | {loc = Reg _}, {loc = Stack _} ->
      `	str	{emit_reg src}, {emit_stack dst}\n`
    | {loc = Stack _}, {loc = Reg _} ->
      `	ldr	{emit_reg dst}, {emit_stack src}\n`
    | _ ->
      assert false
  end
(* Output the assembly code for an instruction *)

let emit_instr i =
    emit_debug_info i.dbg;
    match i.desc with
    | Lend -> ()
    | Lprologue ->
      assert (!prologue_required);
      let n = frame_size() in
      if n > 0 then
        emit_stack_adjustment (-n);
      if !contains_calls then begin
        cfi_offset ~reg:30 (* return address *) ~offset:(-8);
        `	str	x30, [sp, #{emit_int (n-8)}]\n`
      end
    | Lop(Iintop_atomic _) ->
      (* Never generated; builtins are not yet translated to atomics *)
      assert false
    | Lop(Iscalarcast Float_to_int) ->
        `	fcvtzs {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
    | Lop(Iscalarcast Float_of_int) ->
        `	scvtf	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
    | Lop(Ivectorcast _ | Iscalarcast _) ->
      (* Never generated; SIMD instructions are not yet translated *)
      assert false
    | Lop(Imove | Ispill | Ireload) ->
        move i.arg.(0) i.res.(0)
    | Lop(Ispecific Imove32) ->
        let src = i.arg.(0) and dst = i.res.(0) in
        if src.loc <> dst.loc then begin
          match (src, dst) with
          | {loc = Reg _}, {loc = Reg _} ->
              `	mov	{emit_wreg dst}, {emit_wreg src}\n`
          | {loc = Reg _}, {loc = Stack _} ->
              `	str	{emit_wreg src}, {emit_stack dst}\n`
          | {loc = Stack _}, {loc = Reg _} ->
              `	ldr	{emit_wreg dst}, {emit_stack src}\n`
          | _ ->
              assert false
        end
    | Lop(Iconst_int n) ->
        emit_intconst i.res.(0) n
    | Lop(Iconst_float f) ->
        if f = 0L then
          `	fmov	{emit_reg i.res.(0)}, xzr\n`
        else if is_immediate_float f then
          `	fmov	{emit_reg i.res.(0)}, #{emit_printf "%.7f" (Int64.float_of_bits f)}\n`
        else begin
          let lbl = float_literal f in
          emit_load_literal i.res.(0) lbl
        end
    | Lop(Iconst_vec128 _) ->
      (* CR mslater: (SIMD) arm64 *)
      Misc.fatal_error "128-bit vectors are not supported on this architecture"
    | Lop(Iconst_symbol s) ->
        emit_load_symbol_addr i.res.(0) s.sym_name
    | Lop(Icall_ind) ->
        `	blr	{emit_reg i.arg.(0)}\n`;
        `{record_frame i.live (Dbg_other i.dbg)}\n`
    | Lop(Icall_imm { func; }) ->
        `	bl	{emit_symbol func.sym_name}\n`;
        `{record_frame i.live (Dbg_other i.dbg)}\n`
    | Lop(Itailcall_ind) ->
        output_epilogue (fun () -> `	br	{emit_reg i.arg.(0)}\n`)
    | Lop(Itailcall_imm { func; }) ->
        if func.sym_name = !function_name then
          match !tailrec_entry_point with
          | None -> Misc.fatal_error "jump to missing tailrec entry point"
          | Some tailrec_entry_point -> `	b	{emit_label tailrec_entry_point}\n`
        else
          output_epilogue (fun () -> `	b	{emit_symbol func.sym_name}\n`)
    | Lop(Iextcall {func; alloc; stack_ofs = _}) ->
        (* BACKPORT BEGIN *)
        (*if stack_ofs > 0 then begin
          `	mov	{emit_reg reg_stack_arg_begin}, sp\n`;
          `	add	{emit_reg reg_stack_arg_end}, sp, #{emit_int (Misc.align stack_ofs 16)}\n`;
          emit_load_symbol_addr reg_x8 func;
          `	bl	{emit_symbol "caml_c_call_stack_args"}\n`;
          `{record_frame i.live (Dbg_other i.dbg)}\n`
        end else*) if alloc then begin
          emit_load_symbol_addr reg_x8 func;
          `	bl	{emit_symbol "caml_c_call"}\n`;
          `{record_frame i.live (Dbg_other i.dbg)}\n`
        end else begin
          (* store ocaml stack in the frame pointer register
             NB: no need to store previous x29 because OCaml frames don't
             maintain frame pointer *)
          (*`	mov	x29, sp\n`;
          cfi_remember_state ();
          cfi_def_cfa_register ~reg:29;
          let offset = Domainstate.(idx_of_field Domain_c_stack) * 8 in
          `	ldr	{emit_reg reg_tmp1}, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`;
             `	mov	sp, {emit_reg reg_tmp1}\n`; *)
          `	bl	{emit_symbol func}\n`;
          (*`	mov	sp, x29\n`;
          cfi_restore_state ()*)
        end
      (* BACKPORT END *)
    | Lop(Istackoffset n) ->
        assert (n mod 16 = 0);
        emit_stack_adjustment (-n);
        stack_offset := !stack_offset + n
    | Lop(Iload { memory_chunk; addressing_mode; is_atomic }) ->
        assert(memory_chunk = Word_int || memory_chunk = Word_val || is_atomic = false);
        let dst = i.res.(0) in
        let base =
          match addressing_mode with
          | Iindexed _ -> i.arg.(0)
          | Ibased(s, ofs) ->
              assert (not !Clflags.dlcode);  (* see selection.ml *)
              `	adrp	{emit_reg reg_tmp1}, {emit_symbol_offset s ofs}\n`;
              reg_tmp1 in
        begin match memory_chunk with
        | Byte_unsigned ->
            `	ldrb	{emit_wreg dst}, {emit_addressing addressing_mode base}\n`
        | Byte_signed ->
            `	ldrsb	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
        | Sixteen_unsigned ->
            `	ldrh	{emit_wreg dst}, {emit_addressing addressing_mode base}\n`
        | Sixteen_signed ->
            `	ldrsh	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
        | Thirtytwo_unsigned ->
            `	ldr	{emit_wreg dst}, {emit_addressing addressing_mode base}\n`
        | Thirtytwo_signed ->
            `	ldrsw	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
        | Single ->
            `	ldr	s7, {emit_addressing addressing_mode base}\n`;
            `	fcvt	{emit_reg dst}, s7\n`
        | Word_int | Word_val ->
          if is_atomic then begin
            assert (addressing_mode = Iindexed 0);
            `	dmb	ishld\n`;
            `	ldar	{emit_reg dst}, [{emit_reg i.arg.(0)}]\n`
          end else
            `	ldr	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
        | Double ->
                      `	ldr	{emit_reg dst}, {emit_addressing addressing_mode base}\n`
        | Onetwentyeight_aligned | Onetwentyeight_unaligned ->
            (* CR mslater: (SIMD) arm64 *)
            fatal_error "arm64: got 128 bit memory chunk"
        end
    | Lop(Istore(size, addr, assignment)) ->
      (* NB: assignments other than Word_int and Word_val do not follow the
      Multicore OCaml memory model and so do not emit a barrier *)
      let src = i.arg.(0) in
        let base =
          match addr with
          | Iindexed _ -> i.arg.(1)
          | Ibased(s, ofs) ->
              assert (not !Clflags.dlcode);
              `	adrp	{emit_reg reg_tmp1}, {emit_symbol_offset s ofs}\n`;
              reg_tmp1 in
        begin match size with
        | Byte_unsigned | Byte_signed ->
            `	strb	{emit_wreg src}, {emit_addressing addr base}\n`
        | Sixteen_unsigned | Sixteen_signed ->
            `	strh	{emit_wreg src}, {emit_addressing addr base}\n`
        | Thirtytwo_unsigned | Thirtytwo_signed ->
            `	str	{emit_wreg src}, {emit_addressing addr base}\n`
        | Single ->
            `	fcvt	s7, {emit_reg src}\n`;
            `	str	s7, {emit_addressing addr base}\n`;
        | Word_int | Word_val ->
            (* memory model barrier for non-initializing store *)
            if assignment then `	dmb	ishld\n`;
            `	str	{emit_reg src}, {emit_addressing addr base}\n`
        | Double ->
          `	str	{emit_reg src}, {emit_addressing addr base}\n`
        | Onetwentyeight_aligned | Onetwentyeight_unaligned ->
            (* CR mslater: (SIMD) arm64 *)
            fatal_error "arm64: got 128 bit memory chunk"
        end
    | Lop(Ialloc { bytes = n; dbginfo; mode = Alloc_heap }) ->
        assembly_code_for_allocation i ~n ~local:false ~far:false ~dbginfo
    | Lop(Ispecific (Ifar_alloc { bytes = n; dbginfo })) ->
        assembly_code_for_allocation i ~n ~local:false ~far:true ~dbginfo
    | Lop(Ialloc { bytes = n; dbginfo; mode = Alloc_local }) ->
        assembly_code_for_allocation i ~n ~local:true ~far:false ~dbginfo
    | Lop(Ibeginregion) ->
        let offset = Domainstate.(idx_of_field Domain_local_sp) * 8 in
        `	ldr	{emit_reg i.res.(0)}, [{emit_reg reg_domain_state_ptr}, #{emit_int offset}]\n`
    | Lop(Iendregion) ->
        let offset = Domainstate.(idx_of_field Domain_local_sp) * 8 in
        `	str	{emit_reg i.arg.(0)}, [{emit_reg reg_domain_state_ptr}, #{emit_int offset}]\n`
    | Lop(Ipoll { return_label }) ->
        assembly_code_for_poll i ~far:false ~return_label
    | Lop(Ispecific (Ifar_poll { return_label })) ->
        assembly_code_for_poll i ~far:true ~return_label
    | Lop(Iintop_imm(Iadd, n)) ->
        emit_addimm i.res.(0) i.arg.(0) n
    | Lop(Iintop_imm(Isub, n)) ->
        emit_subimm i.res.(0) i.arg.(0) n
    | Lop(Iintop(Icomp cmp)) ->
        `	cmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
        `	cset	{emit_reg i.res.(0)}, {emit_string (name_for_comparison cmp)}\n`
    | Lop(Ifloatop(Icompf cmp)) ->
        let comp = name_for_float_comparison cmp in
        `	fcmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
        `	cset	{emit_reg i.res.(0)}, {emit_string comp}\n`
    | Lop(Iintop_imm(Icomp cmp, n)) ->
        emit_cmpimm i.arg.(0) n;
        `	cset	{emit_reg i.res.(0)}, {emit_string (name_for_comparison cmp)}\n`
    | Lop(Iintop Imod) ->
        `	sdiv	{emit_reg reg_tmp1}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
        `	msub	{emit_reg i.res.(0)}, {emit_reg reg_tmp1}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}\n`
    | Lop(Iintop (Imulh { signed = true })) ->
        `	smulh	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Iintop (Imulh { signed = false })) ->
        `	umulh	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Iintop op) ->
        let instr = name_for_int_operation op in
        `	{emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Iintop_imm(op, n)) ->
        let instr = name_for_int_operation op in
        `	{emit_string instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #{emit_int n}\n`
    | Lop(Ifloatop (Iabsf | Inegf) | Ispecific Isqrtf as op) ->
        let instr = (match op with
                     | Ifloatop Iabsf   -> "fabs"
                     | Ifloatop Inegf   -> "fneg"
                     | Ispecific Isqrtf -> "fsqrt"
                     | _                -> assert false) in
        `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
    | Lop(Ivalueofint | Iintofvalue) ->
        let src = i.arg.(0) and dst = i.res.(0) in
        if src.loc <> dst.loc then begin
          match (src, dst) with
          | {loc = Reg _}, {loc = Reg _} ->
              `	mov	{emit_reg dst}, {emit_reg src}\n`
          | {loc = Reg _}, {loc = Stack _} ->
              `	str	{emit_reg src}, {emit_stack dst}\n`
          | {loc = Stack _}, {loc = Reg _} ->
              `	ldr	{emit_reg dst}, {emit_stack src}\n`
          | _ ->
              assert false
        end
    | Lop(Ifloatop (Iaddf | Isubf | Imulf | Idivf) | Ispecific Inegmulf as op) ->
        let instr = (match op with
                     | Ifloatop Iaddf     -> "fadd"
                     | Ifloatop Isubf     -> "fsub"
                     | Ifloatop Imulf     -> "fmul"
                     | Ifloatop Idivf     -> "fdiv"
                     | Ispecific Inegmulf -> "fnmul"
                     | _                  -> assert false) in
        `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`
    | Lop(Ispecific(Imuladdf | Inegmuladdf | Imulsubf | Inegmulsubf as op)) ->
        let instr = (match op with
                     | Imuladdf    -> "fmadd"
                     | Inegmuladdf -> "fnmadd"
                     | Imulsubf    -> "fmsub"
                     | Inegmulsubf -> "fnmsub"
                     | _ -> assert false) in
        `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}, {emit_reg i.arg.(0)}\n`
    | Lop(Iopaque) ->
        assert (i.arg.(0).loc = i.res.(0).loc)
    | Lop(Ispecific(Ishiftarith(op, shift))) ->
        let instr = (match op with
                       Ishiftadd    -> "add"
                     | Ishiftsub    -> "sub") in
        `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}`;
        if shift >= 0
        then `, lsl #{emit_int shift}\n`
        else `, asr #{emit_int (-shift)}\n`
    | Lop(Ispecific(Imuladd | Imulsub as op)) ->
        let instr = (match op with
                       Imuladd -> "madd"
                     | Imulsub -> "msub"
                     | _ -> assert false) in
        `	{emit_string instr}	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}\n`
    | Lop(Ispecific(Ibswap { bitwidth })) ->
        begin match bitwidth with
        | Sixteen ->
            `	rev16	{emit_wreg i.res.(0)}, {emit_wreg i.arg.(0)}\n`;
            `	ubfm	{emit_reg i.res.(0)}, {emit_reg i.res.(0)}, #0, #15\n`
        | Thirtytwo ->
            `	rev	{emit_wreg i.res.(0)}, {emit_wreg i.arg.(0)}\n`
        | Sixtyfour ->
            `	rev	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}\n`
        end
    | Lop(Ispecific(Isignext size)) ->
        `	sbfm	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #0, #{emit_int (size - 1)}\n`
    | Lop (Iname_for_debugger _) -> ()
    | Lop (Iprobe _ | Iprobe_is_enabled _) ->
      fatal_error ("Probes not supported.")
    | Lop(Idls_get) ->
      (* BACKPORT BEGIN *)
      fatal_error ("Idls_get not supported.")
      (*let offset = Domainstate.(idx_of_field Domain_dls_root) * 8 in
      `	ldr	{emit_reg i.res.(0)}, [{emit_reg reg_domain_state_ptr}, {emit_int offset}]\n`*)
      (* BACKPORT END *)
    | Lop (Icsel tst) ->
      let len = Array.length i.arg in
      let ifso = i.arg.(len - 2) in
      let ifnot = i.arg.(len - 1) in
      if Reg.same_loc ifso ifnot then
        move ifso i.res.(0)
      else
        begin match tst with
        | Itruetest ->
            `	cmp	{emit_reg i.arg.(0)}, #0\n`;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}, ne\n`
        | Ifalsetest ->
            `	cmp	{emit_reg i.arg.(0)}, #0\n`;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}, eq\n`
        | Iinttest cmp ->
            let comp = name_for_comparison cmp in
            `	cmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(2)}, {emit_reg i.arg.(3)}, {emit_string comp}\n`
        | Iinttest_imm(cmp, n) ->
            let comp = name_for_comparison cmp in
            emit_cmpimm i.arg.(0) n;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}, {emit_string comp}\n`
        | Ifloattest cmp ->
            let comp = name_for_float_comparison cmp in
            `	fcmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(2)}, {emit_reg i.arg.(3)}, {emit_string comp}\n`
        | Ioddtest ->
            `	tst	{emit_reg i.arg.(0)}, #1\n`;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}, ne\n`
        | Ieventest ->
            `	tst	{emit_reg i.arg.(0)}, #1\n`;
            `	csel	{emit_reg i.res.(0)}, {emit_reg i.arg.(1)}, {emit_reg i.arg.(2)}, eq\n`
        end
    | Lreloadretaddr ->
        ()
    | Lreturn ->
        output_epilogue (fun () -> `	ret\n`)
    | Llabel { label = lbl; _ } ->
        `{emit_label lbl}:\n`
    | Lbranch lbl ->
        `	b	{emit_label lbl}\n`
    | Lcondbranch(tst, lbl) ->
        begin match tst with
        | Itruetest ->
            `	cbnz	{emit_reg i.arg.(0)}, {emit_label lbl}\n`
        | Ifalsetest ->
            `	cbz	{emit_reg i.arg.(0)}, {emit_label lbl}\n`
        | Iinttest cmp ->
            `	cmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            let comp = name_for_comparison cmp in
            `	b.{emit_string comp}	{emit_label lbl}\n`
        | Iinttest_imm(cmp, n) ->
            emit_cmpimm i.arg.(0) n;
            let comp = name_for_comparison cmp in
            `	b.{emit_string comp}	{emit_label lbl}\n`
        | Ifloattest cmp ->
            let comp = name_for_float_comparison cmp in
            `	fcmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
            `	b.{emit_string comp}	{emit_label lbl}\n`
        | Ioddtest ->
            `	tbnz	{emit_reg i.arg.(0)}, #0, {emit_label lbl}\n`
        | Ieventest ->
            `	tbz	{emit_reg i.arg.(0)}, #0, {emit_label lbl}\n`
        end
    | Lcondbranch3(lbl0, lbl1, lbl2) ->
        `	cmp	{emit_reg i.arg.(0)}, #1\n`;
        begin match lbl0 with
          None -> ()
        | Some lbl -> `	b.lt	{emit_label lbl}\n`
        end;
        begin match lbl1 with
          None -> ()
        | Some lbl -> `	b.eq	{emit_label lbl}\n`
        end;
        begin match lbl2 with
          None -> ()
        | Some lbl -> `	b.gt	{emit_label lbl}\n`
        end
    | Lswitch jumptbl ->
        let lbltbl = new_label() in
        `	adr	{emit_reg reg_tmp1}, {emit_label lbltbl}\n`;
        `	add	{emit_reg reg_tmp1}, {emit_reg reg_tmp1}, {emit_reg i.arg.(0)}, lsl #2\n`;
        `	br	{emit_reg reg_tmp1}\n`;
        `{emit_label lbltbl}:`;
        for j = 0 to Array.length jumptbl - 1 do
            `	b	{emit_label jumptbl.(j)}\n`
        done
(* Alternative:
        let lbltbl = new_label() in
        `	adr	{emit_reg reg_tmp1}, {emit_label lbltbl}\n`;
        `	ldr	{emit_wreg reg_tmp2}, [{emit_reg reg_tmp1}, {emit_reg i.arg.(0)}, lsl #2]\n`;
        `	add	{emit_reg reg_tmp1}, {emit_wreg reg_tmp2}, sxtb\n`;
        `	br	{emit_reg reg_tmp1}\n`;
        `{emit_label lbltbl}:\n`;
        for j = 0 to Array.length jumptbl - 1 do
            `	.word	{emit_label jumptbl.(j)} - {emit_label lbltbl}\n`
        done
*)
    | Lentertrap ->
        ()
    | Ladjust_stack_offset { delta_bytes } ->
        cfi_adjust_cfa_offset delta_bytes;
        stack_offset := !stack_offset + delta_bytes
    | Lpushtrap { lbl_handler; } ->
        `	adr	{emit_reg reg_tmp1}, {emit_label lbl_handler}\n`;
        stack_offset := !stack_offset + 16;
        `	str	{emit_reg reg_trap_ptr}, [sp, -16]!\n`;
        `	str	{emit_reg reg_tmp1}, [sp, #8]\n`;
        cfi_adjust_cfa_offset 16;
        `	mov	{emit_reg reg_trap_ptr}, sp\n`
    | Lpoptrap ->
        `	ldr	{emit_reg reg_trap_ptr}, [sp], 16\n`;
        cfi_adjust_cfa_offset (-16);
        stack_offset := !stack_offset - 16
    | Lraise k ->
        begin match k with
        | Lambda.Raise_regular ->
          `	bl	{emit_symbol "caml_raise_exn"}\n`;
          `{record_frame Reg.Set.empty (Dbg_raise i.dbg)}\n`
        | Lambda.Raise_reraise ->
          if Config.runtime5 then
            `	bl	{emit_symbol "caml_reraise_exn"}\n`
          else
            `	bl	{emit_symbol "caml_raise_exn"}\n`;
          `{record_frame Reg.Set.empty (Dbg_raise i.dbg)}\n`
        | Lambda.Raise_notrace ->
          `	mov	sp, {emit_reg reg_trap_ptr}\n`;
          `	ldr	{emit_reg reg_tmp1}, [sp, #8]\n`;
          `	ldr	{emit_reg reg_trap_ptr}, [sp], 16\n`;
          `	br	{emit_reg reg_tmp1}\n`
      end
    | Lstackcheck _ -> assert false (* not supported *)

(* Emission of an instruction sequence *)

let rec emit_all i =
  if i.desc = Lend then () else (emit_instr i; emit_all i.next)

(* Emission of a function declaration *)

let fundecl fundecl =
  let fun_end_label, fundecl =
    match Emitaux.Dwarf_helpers.record_dwarf_for_fundecl fundecl with
    | None -> None, fundecl
    | Some { fun_end_label; fundecl } -> Some fun_end_label, fundecl
  in
  function_name := fundecl.fun_name;
  fastcode_flag := fundecl.fun_fast;
  tailrec_entry_point := fundecl.fun_tailrec_entry_point_label;
  float_literals := [];
  stack_offset := 0;
  call_gc_sites := [];
  local_realloc_sites := [];
  for i = 0 to Proc.num_stack_slot_classes - 1 do
    num_stack_slots.(i) <- fundecl.fun_num_stack_slots.(i);
  done;
  prologue_required := fundecl.fun_prologue_required;
  contains_calls := fundecl.fun_contains_calls;
  emit_named_text_section !function_name;
  `	.align	3\n`;
  `	.globl	{emit_symbol fundecl.fun_name}\n`;
  emit_symbol_type emit_symbol fundecl.fun_name "function";
  (* Dynamic stack checking *)
  (* BACKPORT BEGIN *)
  (*let stack_threshold_size = Config.stack_threshold * 8 in (* bytes *)
  let { max_frame_size; contains_nontail_calls} =
    preproc_stack_check
      ~fun_body:fundecl.fun_body ~frame_size:(frame_size env) ~trap_size:16
  in
  let handle_overflow, stack_check_size =
    if contains_nontail_calls || max_frame_size >= stack_threshold_size then begin
      let overflow = new_label () in
      `{emit_label overflow}:\n`;
      (* Pass the desired frame size on the stack, since all of the
        argument-passing registers may be in use. *)
      let s = (Config.stack_threshold + max_frame_size / 8) in
      `    mov {emit_reg reg_tmp1}, #{emit_int s}\n`;
      `    stp {emit_reg reg_tmp1}, x30, [sp, #-16]!\n`;
      `    bl {emit_symbol "caml_call_realloc_stack"}\n`;
      `    ldp {emit_reg reg_tmp1}, x30, [sp], #16\n`;
      (* fall through function entry point *)
      Some overflow, 5
    end else
      None, 0 in*)
  `{emit_symbol fundecl.fun_name}:\n`;
  emit_debug_info fundecl.fun_dbg;
  cfi_startproc();
  (* BACKPORT BEGIN *)
  (*begin match handle_overflow with
    | None -> ()
    | Some overflow ->
      let threshold_offset = Domainstate.stack_ctx_words * 8 + stack_threshold_size in
      let f = max_frame_size + threshold_offset in
      let offset = Domainstate.(idx_of_field Domain_current_stack) * 8 in
      `	ldr	{emit_reg reg_tmp1}, [{emit_reg reg_domain_state_ptr}, #{emit_int offset}]\n`;
      emit_addimm reg_tmp1 reg_tmp1 f;
      `	cmp	sp, {emit_reg reg_tmp1}\n`;
      `	bcc	{emit_label overflow}\n`
  end;*)
  (* BACKPORT END *)
  let num_call_gc = num_call_gc_points fundecl.fun_body in
  let max_out_of_line_code_offset =
    (* BACKPORT BEGIN *)
    (*max_out_of_line_code_offset ~num_call_gc
      stack_check_size +*)
    (* BACKPORT END *)
    max_out_of_line_code_offset ~num_call_gc
  in
  BR.relax fundecl.fun_body ~max_out_of_line_code_offset;

  emit_all fundecl.fun_body;
  List.iter emit_call_gc !call_gc_sites;
  List.iter emit_local_realloc !local_realloc_sites;
  assert (List.length !call_gc_sites = num_call_gc);
  (match fun_end_label with
   | None -> ()
   | Some fun_end_label -> `{emit_label fun_end_label}:\n`);

  cfi_endproc();
  emit_symbol_type emit_symbol fundecl.fun_name "function";
  emit_symbol_size fundecl.fun_name;
  emit_literals()

(* Emission of data *)

let emit_item = function
  | Cdefine_symbol s ->
    if !Clflags.dlcode || s.sym_global = Cmm.Global then begin
      (* GOT relocations against non-global symbols don't seem to work
         properly: GOT entries are not created for the symbols and the
         relocations evaluate to random other GOT entries.  For the moment
         force all symbols to be global. *)
      `	.globl	{emit_symbol s.sym_name}\n`;
    end;
    `{emit_symbol s.sym_name}:\n`
  | Cint8 n -> `	.byte	{emit_int n}\n`
  | Cint16 n -> `	.short	{emit_int n}\n`
  | Cint32 n -> `	.long	{emit_nativeint n}\n`
  | Cint n -> `	.quad	{emit_nativeint n}\n`
  | Csingle f -> emit_float32_directive ".long" (Int32.bits_of_float f)
  | Cdouble f -> emit_float64_directive ".quad" (Int64.bits_of_float f)
  | Cvec128 _ ->
    (* CR mslater: (SIMD) arm64 *)
    Misc.fatal_error "128-bit vectors not supported on this architecture"
  | Csymbol_address s -> `	.quad	{emit_symbol s.sym_name}\n`
  | Csymbol_offset (s, o) -> `	.quad	{emit_symbol s.sym_name}+{emit_int o}\n`
  | Cstring s -> emit_string_directive "	.ascii  " s
  | Cskip n -> if n > 0 then `	.space	{emit_int n}\n`
  | Calign n -> `	.align	{emit_int(Misc.log2 n)}\n`

let data l =
  `	.data\n`;
  `	.align  3\n`;
  List.iter emit_item l

(* Beginning / end of an assembly file *)

let begin_assembly _unix =
  reset_debug_info();
  `	.file	\"\"\n`;  (* PR#7037 *)
  let lbl_begin = Cmm_helpers.make_symbol "data_begin" in
  `	.data\n`;
  `	.globl	{emit_symbol lbl_begin}\n`;
  `{emit_symbol lbl_begin}:\n`;
  let lbl_begin = Cmm_helpers.make_symbol "code_begin" in
  emit_named_text_section lbl_begin;
  `	.globl	{emit_symbol lbl_begin}\n`;
  `{emit_symbol lbl_begin}:\n`;
  (* we need to pad here to avoid collision for the unwind test between
     the code_begin symbol and the first function. (See also #4690)
     Alignment is needed to avoid linker warnings for
     shared_startup__code_{begin,end} (e.g. tests/lib-dynlink-pr4839).
   *)
  if macosx then begin
    `	nop\n`;
    `	.align	3\n`
  end;
  ()

let end_assembly _dwarf =
  let lbl_end = Cmm_helpers.make_symbol "code_end" in
  emit_named_text_section lbl_end;
  `	.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  let lbl_end = Cmm_helpers.make_symbol "data_end" in
  `	.data\n`;
  `	.quad	0\n`;  (* PR#6329 *)
  `	.globl	{emit_symbol lbl_end}\n`;
  `{emit_symbol lbl_end}:\n`;
  `	.quad	0\n`;
  `	.align	3\n`;  (* #7887 *)
  let lbl = Cmm_helpers.make_symbol "frametable" in
  `	.globl	{emit_symbol lbl}\n`;
  `{emit_symbol lbl}:\n`;
  emit_frames
    { efa_code_label = (fun lbl ->
                       emit_symbol_type emit_label lbl "function";
                       `	.quad	{emit_label lbl}\n`);
      efa_data_label = (fun lbl ->
                       emit_symbol_type emit_label lbl "object";
                       `	.quad	{emit_label lbl}\n`);
      efa_8 = (fun n -> `	.byte	{emit_int n}\n`);
      efa_16 = (fun n -> `	.short	{emit_int n}\n`);
      efa_32 = (fun n -> `	.long	{emit_int32 n}\n`);
      efa_word = (fun n -> `	.quad	{emit_int n}\n`);
      efa_align = (fun n -> `	.align	{emit_int(Misc.log2 n)}\n`);
      efa_label_rel = (fun lbl ofs ->
                           `	.long	{emit_label lbl} - . + {emit_int32 ofs}\n`);
      efa_def_label = (fun lbl -> `{emit_label lbl}:\n`);
      efa_string = (fun s -> emit_string_directive "	.asciz	" s) };
  emit_symbol_type emit_symbol lbl "object";
  emit_symbol_size lbl;
  begin match Config.system with
  | "linux" ->
      (* Mark stack as non-executable *)
      `	.section	.note.GNU-stack,\"\",%progbits\n`
  | _ -> ()
  end
