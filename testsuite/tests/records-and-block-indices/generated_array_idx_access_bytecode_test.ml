(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 flags = "-extension layouts_alpha";
 bytecode;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
external globalize : local_ 'a -> 'a = "%obj_dup";;
let int64x2_u_equal (_ : int64x2#) (_ : int64x2#) = failwith "should not be called from bytecode"

open Stdlib_upstream_compatible
open Stdlib_stable

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] get_idx_imm :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_imm -> ('b [@local_opt]) =
  "%unsafe_get_idx_imm"

external[@layout_poly] get_idx_mut :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) =
  "%unsafe_get_idx"

external[@layout_poly] set_idx_mut :
  'a ('b : any).
    ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) -> unit =
  "%unsafe_set_idx"

module Idx_repr : sig
  type t
  val of_idx_imm : 'a ('b : any). ('a, 'b) idx_imm -> t
  val of_idx_mut : 'a ('b : any). ('a, 'b) idx_mut -> t
  val equal : t -> t -> bool
  val debug_string : t -> string
end = struct
  (* See Note [Representation of block indices] in [lambda/translcore.ml] *)
  type t =
    | Bytecode of { path : int list }
    | Native of { offset : int; gap : int }

  external magic_box_bits64 : ('a : bits64) 'b . 'a -> 'b =
    "%box_int64"
  external lessthan_if_bytecode : int -> int -> bool =
    "caml_lessthan" "caml_greaterthan"

  let of_idx idx =
    let is_bytecode = lessthan_if_bytecode 0 1 in
    if is_bytecode then
      let r = Obj.repr (magic_box_bits64 idx) in
      let nth_idx n : int = Obj.magic (Obj.field r n) in
      let path = List.init (Obj.size r) nth_idx in
      Bytecode { path }
    else
      let i : int64 = magic_box_bits64 idx in
      let offset =
        Int64.(logand (sub (shift_left one 48) one)) i
        |> Int64.to_int
      in
      let gap =
        Int64.shift_right i 48
        |> Int64.to_int
      in
      Native { offset; gap }

  let of_idx_imm = of_idx
  let of_idx_mut = of_idx

  let equal t1 t2 =
    match t1, t2 with
    | Bytecode { path = path1 }, Bytecode { path = path2 } ->
      List.equal Int.equal path1 path2
    | Native { gap = gap1; offset = offset1 },
      Native { gap = gap2; offset = offset2 } ->
      Int.equal gap1 gap2 && Int.equal offset1 offset2
    | Bytecode _, Native _ | Native _, Bytecode _ -> assert false

  let debug_string = function
    | Bytecode { path } ->
      Printf.sprintf "{ %s }"
        (String.concat "; " (List.map Int.to_string path))
    | Native { offset; gap } ->
      Printf.sprintf "offset %d; gap %d" offset gap
end

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]


type t0 = #{ a0 : int }
type t1 = #{ a1 : int; b1 : int }
type t2 = #{ a2 : int; b2 : int; c2 : int }
type t3 = #{ a3 : int; b3 : int; c3 : int32# }
type t4 = #{ a4 : int; b4 : int; c4 : float }
type t5 = #{ a5 : int; b5 : int64 }
type t6 = #{ a6 : int; b6 : int64# }
type t7 = #{ a7 : int; b7 : int32# }
type t8 = #{ a8 : int; b8 : int32#; c8 : int32# }
type t9 = #{ a9 : int; b9 : nativeint# }
type t10 = #{ a10 : int; b10 : float }
type t11 = #{ a11 : int; b11 : float; c11 : int }
type t12 = #{ a12 : int; b12 : float; c12 : float }
type t13 = #{ a13 : int; b13 : t0 }
type t14 = #{ a14 : int; b14 : t1 }
type t15 = #{ a15 : int; b15 : t7 }
type t16 = #{ a16 : int; b16 : t10 }
type t17 = #{ a17 : int32# }
type t18 = #{ a18 : int; b18 : t17 }
type t19 = #{ a19 : int32#; b19 : int32# }
type t20 = #{ a20 : int; b20 : t19 }
type t21 = #{ a21 : float }
type t22 = #{ a22 : int; b22 : t21 }
type t23 = #{ a23 : float; b23 : int }
type t24 = #{ a24 : int; b24 : t23 }
type t25 = #{ a25 : float; b25 : float }
type t26 = #{ a26 : int; b26 : t25 }
type t27 = #{ a27 : int64 }
type t28 = #{ a28 : int64; b28 : int }
type t29 = #{ a29 : int64; b29 : int64 }
type t30 = #{ a30 : int64; b30 : float }
type t31 = #{ a31 : int64# }
type t32 = #{ a32 : int64#; b32 : int64# }
type t33 = #{ a33 : int64#; b33 : int32# }
type t34 = #{ a34 : int64#; b34 : nativeint# }
type t35 = #{ a35 : int32#; b35 : int64# }
type t36 = #{ a36 : int32#; b36 : int32#; c36 : int32# }
type t37 = #{ a37 : int32#; b37 : nativeint# }
type t38 = #{ a38 : int32#; b38 : t17 }
type t39 = #{ a39 : int32#; b39 : t19 }
type t40 = #{ a40 : nativeint# }
type t41 = #{ a41 : nativeint#; b41 : int64# }
type t42 = #{ a42 : nativeint#; b42 : int32# }
type t43 = #{ a43 : nativeint#; b43 : nativeint# }
type t44 = #{ a44 : float; b44 : int; c44 : int }
type t45 = #{ a45 : float; b45 : int; c45 : float }
type t46 = #{ a46 : float; b46 : int64 }
type t47 = #{ a47 : float; b47 : float; c47 : int }
type t48 = #{ a48 : float; b48 : float; c48 : float }
type t49 = #{ a49 : float; b49 : t0 }
type t50 = #{ a50 : float; b50 : t1 }
type t51 = #{ a51 : float; b51 : t10 }
type t52 = #{ a52 : float; b52 : t21 }
type t53 = #{ a53 : float; b53 : t23 }
type t54 = #{ a54 : float; b54 : t25 }
type t55 = #{ a55 : t0 }
type t56 = #{ a56 : t0; b56 : int }
type t57 = #{ a57 : t0; b57 : int32# }
type t58 = #{ a58 : t0; b58 : float }
type t59 = #{ a59 : t1 }
type t60 = #{ a60 : t1; b60 : int }
type t61 = #{ a61 : t1; b61 : int32# }
type t62 = #{ a62 : t1; b62 : float }
type t63 = #{ a63 : t7 }
type t64 = #{ a64 : t7; b64 : int32# }
type t65 = #{ a65 : t10 }
type t66 = #{ a66 : t10; b66 : int }
type t67 = #{ a67 : t10; b67 : float }
type t68 = #{ a68 : t17 }
type t69 = #{ a69 : t17; b69 : int32# }
type t70 = #{ a70 : t19 }
type t71 = #{ a71 : t19; b71 : int32# }
type t72 = #{ a72 : t21; b72 : int }
type t73 = #{ a73 : t21; b73 : float }
type t74 = #{ a74 : t23 }
type t75 = #{ a75 : t23; b75 : int }
type t76 = #{ a76 : t23; b76 : float }
type t77 = #{ a77 : t25 }
type t78 = #{ a78 : t25; b78 : int }
type t79 = #{ a79 : t25; b79 : float }

let test size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 1;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 1 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 2;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 2 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 3;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 3 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 4;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 4 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 5;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 5 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 6;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 6 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 7;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 7 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 8;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 8 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 9;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 9 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 10;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 10 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  let eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let mk_value i = (#{ a0 = (i + 0) } : t0) in
  (* Create an array of size [size] *)
  let a : t0 array = makearray_dynamic size (#{ a0 = 0 } : t0) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 11;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 11 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 12;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 12 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a0] *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 13;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 13 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  let eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let mk_value i = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) in
  (* Create an array of size [size] *)
  let a : t1 array = makearray_dynamic size (#{ a1 = 0; b1 = 1 } : t1) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 14;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 14 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 15;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 15 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a1] *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 16;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 16 failed %d %d" size i;
    (* Path: [.#b1] *)
    let el = #{ el with b1 = next_el.#b1 } in
    set_idx_mut a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 17;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 17 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  let eq = (fun (#{ a2 = a21; b2 = b21; c2 = c21 } : t2) (#{ a2 = a22; b2 = b22; c2 = c22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = (i + 1); c2 = (i + 2) } : t2) in
  (* Create an array of size [size] *)
  let a : t2 array = makearray_dynamic size (#{ a2 = 0; b2 = 1; c2 = 2 } : t2) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 18;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 18 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 19;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 19 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a2] *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 20;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 20 failed %d %d" size i;
    (* Path: [.#b2] *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 21;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 21 failed %d %d" size i;
    (* Path: [.#c2] *)
    let el = #{ el with c2 = next_el.#c2 } in
    set_idx_mut a ((.(i).#c2) : (t2 array, _) idx_mut) next_el.#c2;
    mark_test_run 22;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 22 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  let eq = (fun (#{ a3 = a31; b3 = b31; c3 = c31 } : t3) (#{ a3 = a32; b3 = b32; c3 = c32 } : t3) -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let mk_value i = (#{ a3 = (i + 0); b3 = (i + 1); c3 = Int32_u.of_int (i + 2) } : t3) in
  (* Create an array of size [size] *)
  let a : t3 array = makearray_dynamic size (#{ a3 = 0; b3 = 1; c3 = #2l } : t3) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 23;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 23 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 24;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 24 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a3] *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 25;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 25 failed %d %d" size i;
    (* Path: [.#b3] *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 26;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 26 failed %d %d" size i;
    (* Path: [.#c3] *)
    let el = #{ el with c3 = next_el.#c3 } in
    set_idx_mut a ((.(i).#c3) : (t3 array, _) idx_mut) next_el.#c3;
    mark_test_run 27;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 27 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  let eq = (fun (#{ a4 = a41; b4 = b41; c4 = c41 } : t4) (#{ a4 = a42; b4 = b42; c4 = c42 } : t4) -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let mk_value i = (#{ a4 = (i + 0); b4 = (i + 1); c4 = Float.of_int (i + 2) } : t4) in
  (* Create an array of size [size] *)
  let a : t4 array = makearray_dynamic size (#{ a4 = 0; b4 = 1; c4 = 2. } : t4) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 28;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 28 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 29;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 29 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a4] *)
    let el = #{ el with a4 = next_el.#a4 } in
    set_idx_mut a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 30;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 30 failed %d %d" size i;
    (* Path: [.#b4] *)
    let el = #{ el with b4 = next_el.#b4 } in
    set_idx_mut a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 31;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 31 failed %d %d" size i;
    (* Path: [.#c4] *)
    let el = #{ el with c4 = next_el.#c4 } in
    set_idx_mut a ((.(i).#c4) : (t4 array, _) idx_mut) next_el.#c4;
    mark_test_run 32;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 32 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t5 = #{ int; int64 }   *)
  (****************************)
  let eq = (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int64.equal (globalize a) (globalize b)) b51 b52) in
  let mk_value i = (#{ a5 = (i + 0); b5 = Int64.of_int (i + 1) } : t5) in
  (* Create an array of size [size] *)
  let a : t5 array = makearray_dynamic size (#{ a5 = 0; b5 = 1L } : t5) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 33;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 33 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 34;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 34 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a5] *)
    let el = #{ el with a5 = next_el.#a5 } in
    set_idx_mut a ((.(i).#a5) : (t5 array, _) idx_mut) next_el.#a5;
    mark_test_run 35;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 35 failed %d %d" size i;
    (* Path: [.#b5] *)
    let el = #{ el with b5 = next_el.#b5 } in
    set_idx_mut a ((.(i).#b5) : (t5 array, _) idx_mut) next_el.#b5;
    mark_test_run 36;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 36 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t6 = #{ int; int64# }   *)
  (*****************************)
  let eq = (fun (#{ a6 = a61; b6 = b61 } : t6) (#{ a6 = a62; b6 = b62 } : t6) -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b61 b62) in
  let mk_value i = (#{ a6 = (i + 0); b6 = Int64_u.of_int (i + 1) } : t6) in
  (* Create an array of size [size] *)
  let a : t6 array = makearray_dynamic size (#{ a6 = 0; b6 = #1L } : t6) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 37;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 37 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 38;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 38 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a6] *)
    let el = #{ el with a6 = next_el.#a6 } in
    set_idx_mut a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 39;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 39 failed %d %d" size i;
    (* Path: [.#b6] *)
    let el = #{ el with b6 = next_el.#b6 } in
    set_idx_mut a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 40;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 40 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t7 = #{ int; int32# }   *)
  (*****************************)
  let eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let mk_value i = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7) in
  (* Create an array of size [size] *)
  let a : t7 array = makearray_dynamic size (#{ a7 = 0; b7 = #1l } : t7) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 41;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 41 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 42;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 42 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a7] *)
    let el = #{ el with a7 = next_el.#a7 } in
    set_idx_mut a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 43;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 43 failed %d %d" size i;
    (* Path: [.#b7] *)
    let el = #{ el with b7 = next_el.#b7 } in
    set_idx_mut a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 44;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 44 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t8 = #{ int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a8 = a81; b8 = b81; c8 = c81 } : t8) (#{ a8 = a82; b8 = b82; c8 = c82 } : t8) -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b81 b82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c81 c82) in
  let mk_value i = (#{ a8 = (i + 0); b8 = Int32_u.of_int (i + 1); c8 = Int32_u.of_int (i + 2) } : t8) in
  (* Create an array of size [size] *)
  let a : t8 array = makearray_dynamic size (#{ a8 = 0; b8 = #1l; c8 = #2l } : t8) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 45;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 45 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 46;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 46 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a8] *)
    let el = #{ el with a8 = next_el.#a8 } in
    set_idx_mut a ((.(i).#a8) : (t8 array, _) idx_mut) next_el.#a8;
    mark_test_run 47;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 47 failed %d %d" size i;
    (* Path: [.#b8] *)
    let el = #{ el with b8 = next_el.#b8 } in
    set_idx_mut a ((.(i).#b8) : (t8 array, _) idx_mut) next_el.#b8;
    mark_test_run 48;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 48 failed %d %d" size i;
    (* Path: [.#c8] *)
    let el = #{ el with c8 = next_el.#c8 } in
    set_idx_mut a ((.(i).#c8) : (t8 array, _) idx_mut) next_el.#c8;
    mark_test_run 49;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 49 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t9 = #{ int; nativeint# }   *)
  (*********************************)
  let eq = (fun (#{ a9 = a91; b9 = b91 } : t9) (#{ a9 = a92; b9 = b92 } : t9) -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b91 b92) in
  let mk_value i = (#{ a9 = (i + 0); b9 = Nativeint_u.of_int (i + 1) } : t9) in
  (* Create an array of size [size] *)
  let a : t9 array = makearray_dynamic size (#{ a9 = 0; b9 = #1n } : t9) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 50;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 50 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 51;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 51 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a9] *)
    let el = #{ el with a9 = next_el.#a9 } in
    set_idx_mut a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 52;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 52 failed %d %d" size i;
    (* Path: [.#b9] *)
    let el = #{ el with b9 = next_el.#b9 } in
    set_idx_mut a ((.(i).#b9) : (t9 array, _) idx_mut) next_el.#b9;
    mark_test_run 53;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 53 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t10 = #{ int; float }   *)
  (*****************************)
  let eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let mk_value i = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10) in
  (* Create an array of size [size] *)
  let a : t10 array = makearray_dynamic size (#{ a10 = 0; b10 = 1. } : t10) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 54;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 54 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 55;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 55 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a10] *)
    let el = #{ el with a10 = next_el.#a10 } in
    set_idx_mut a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 56;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 56 failed %d %d" size i;
    (* Path: [.#b10] *)
    let el = #{ el with b10 = next_el.#b10 } in
    set_idx_mut a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 57;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 57 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t11 = #{ int; float; int }   *)
  (**********************************)
  let eq = (fun (#{ a11 = a111; b11 = b111; c11 = c111 } : t11) (#{ a11 = a112; b11 = b112; c11 = c112 } : t11) -> (fun a b -> Int.equal a b) a111 a112 && (fun a b -> Float.equal (globalize a) (globalize b)) b111 b112 && (fun a b -> Int.equal a b) c111 c112) in
  let mk_value i = (#{ a11 = (i + 0); b11 = Float.of_int (i + 1); c11 = (i + 2) } : t11) in
  (* Create an array of size [size] *)
  let a : t11 array = makearray_dynamic size (#{ a11 = 0; b11 = 1.; c11 = 2 } : t11) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 58;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 58 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 59;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 59 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a11] *)
    let el = #{ el with a11 = next_el.#a11 } in
    set_idx_mut a ((.(i).#a11) : (t11 array, _) idx_mut) next_el.#a11;
    mark_test_run 60;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 60 failed %d %d" size i;
    (* Path: [.#b11] *)
    let el = #{ el with b11 = next_el.#b11 } in
    set_idx_mut a ((.(i).#b11) : (t11 array, _) idx_mut) next_el.#b11;
    mark_test_run 61;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 61 failed %d %d" size i;
    (* Path: [.#c11] *)
    let el = #{ el with c11 = next_el.#c11 } in
    set_idx_mut a ((.(i).#c11) : (t11 array, _) idx_mut) next_el.#c11;
    mark_test_run 62;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 62 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t12 = #{ int; float; float }   *)
  (************************************)
  let eq = (fun (#{ a12 = a121; b12 = b121; c12 = c121 } : t12) (#{ a12 = a122; b12 = b122; c12 = c122 } : t12) -> (fun a b -> Int.equal a b) a121 a122 && (fun a b -> Float.equal (globalize a) (globalize b)) b121 b122 && (fun a b -> Float.equal (globalize a) (globalize b)) c121 c122) in
  let mk_value i = (#{ a12 = (i + 0); b12 = Float.of_int (i + 1); c12 = Float.of_int (i + 2) } : t12) in
  (* Create an array of size [size] *)
  let a : t12 array = makearray_dynamic size (#{ a12 = 0; b12 = 1.; c12 = 2. } : t12) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 63;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 63 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 64;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 64 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a12] *)
    let el = #{ el with a12 = next_el.#a12 } in
    set_idx_mut a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 65;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 65 failed %d %d" size i;
    (* Path: [.#b12] *)
    let el = #{ el with b12 = next_el.#b12 } in
    set_idx_mut a ((.(i).#b12) : (t12 array, _) idx_mut) next_el.#b12;
    mark_test_run 66;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 66 failed %d %d" size i;
    (* Path: [.#c12] *)
    let el = #{ el with c12 = next_el.#c12 } in
    set_idx_mut a ((.(i).#c12) : (t12 array, _) idx_mut) next_el.#c12;
    mark_test_run 67;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 67 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t13 = #{ int; #{ int } }   *)
  (********************************)
  let eq = (fun (#{ a13 = a131; b13 = b131 } : t13) (#{ a13 = a132; b13 = b132 } : t13) -> (fun a b -> Int.equal a b) a131 a132 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b131 b132) in
  let mk_value i = (#{ a13 = (i + 0); b13 = (#{ a0 = (i + 1) } : t0) } : t13) in
  (* Create an array of size [size] *)
  let a : t13 array = makearray_dynamic size (#{ a13 = 0; b13 = (#{ a0 = 1 } : t0) } : t13) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 68;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 68 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 69;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 69 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a13] *)
    let el = #{ el with a13 = next_el.#a13 } in
    set_idx_mut a ((.(i).#a13) : (t13 array, _) idx_mut) next_el.#a13;
    mark_test_run 70;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 70 failed %d %d" size i;
    (* Path: [.#b13] *)
    let el = #{ el with b13 = next_el.#b13 } in
    set_idx_mut a ((.(i).#b13) : (t13 array, _) idx_mut) next_el.#b13;
    mark_test_run 71;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 71 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b13.#a0] *)
    let el = #{ el with b13 = #{ el.#b13 with a0 = next_el.#b13.#a0 } } in
    set_idx_mut a ((.(i).#b13.#a0) : (t13 array, _) idx_mut) next_el.#b13.#a0;
    mark_test_run 72;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 72 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t14 = #{ int; #{ int; int } }   *)
  (*************************************)
  let eq = (fun (#{ a14 = a141; b14 = b141 } : t14) (#{ a14 = a142; b14 = b142 } : t14) -> (fun a b -> Int.equal a b) a141 a142 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b141 b142) in
  let mk_value i = (#{ a14 = (i + 0); b14 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t14) in
  (* Create an array of size [size] *)
  let a : t14 array = makearray_dynamic size (#{ a14 = 0; b14 = (#{ a1 = 1; b1 = 2 } : t1) } : t14) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 73;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 73 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 74;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 74 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a14] *)
    let el = #{ el with a14 = next_el.#a14 } in
    set_idx_mut a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 75;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 75 failed %d %d" size i;
    (* Path: [.#b14] *)
    let el = #{ el with b14 = next_el.#b14 } in
    set_idx_mut a ((.(i).#b14) : (t14 array, _) idx_mut) next_el.#b14;
    mark_test_run 76;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 76 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b14.#a1] *)
    let el = #{ el with b14 = #{ el.#b14 with a1 = next_el.#b14.#a1 } } in
    set_idx_mut a ((.(i).#b14.#a1) : (t14 array, _) idx_mut) next_el.#b14.#a1;
    mark_test_run 77;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 77 failed %d %d" size i;
    (* Path: [.#b14.#b1] *)
    let el = #{ el with b14 = #{ el.#b14 with b1 = next_el.#b14.#b1 } } in
    set_idx_mut a ((.(i).#b14.#b1) : (t14 array, _) idx_mut) next_el.#b14.#b1;
    mark_test_run 78;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 78 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t15 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  let eq = (fun (#{ a15 = a151; b15 = b151 } : t15) (#{ a15 = a152; b15 = b152 } : t15) -> (fun a b -> Int.equal a b) a151 a152 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b151 b152) in
  let mk_value i = (#{ a15 = (i + 0); b15 = (#{ a7 = (i + 1); b7 = Int32_u.of_int (i + 2) } : t7) } : t15) in
  (* Create an array of size [size] *)
  let a : t15 array = makearray_dynamic size (#{ a15 = 0; b15 = (#{ a7 = 1; b7 = #2l } : t7) } : t15) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 79;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 79 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 80;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 80 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a15] *)
    let el = #{ el with a15 = next_el.#a15 } in
    set_idx_mut a ((.(i).#a15) : (t15 array, _) idx_mut) next_el.#a15;
    mark_test_run 81;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 81 failed %d %d" size i;
    (* Path: [.#b15] *)
    let el = #{ el with b15 = next_el.#b15 } in
    set_idx_mut a ((.(i).#b15) : (t15 array, _) idx_mut) next_el.#b15;
    mark_test_run 82;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 82 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b15.#a7] *)
    let el = #{ el with b15 = #{ el.#b15 with a7 = next_el.#b15.#a7 } } in
    set_idx_mut a ((.(i).#b15.#a7) : (t15 array, _) idx_mut) next_el.#b15.#a7;
    mark_test_run 83;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 83 failed %d %d" size i;
    (* Path: [.#b15.#b7] *)
    let el = #{ el with b15 = #{ el.#b15 with b7 = next_el.#b15.#b7 } } in
    set_idx_mut a ((.(i).#b15.#b7) : (t15 array, _) idx_mut) next_el.#b15.#b7;
    mark_test_run 84;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 84 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t16 = #{ int; #{ int; float } }   *)
  (***************************************)
  let eq = (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int.equal a b) a161 a162 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b161 b162) in
  let mk_value i = (#{ a16 = (i + 0); b16 = (#{ a10 = (i + 1); b10 = Float.of_int (i + 2) } : t10) } : t16) in
  (* Create an array of size [size] *)
  let a : t16 array = makearray_dynamic size (#{ a16 = 0; b16 = (#{ a10 = 1; b10 = 2. } : t10) } : t16) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 85;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 85 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 86;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 86 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a16] *)
    let el = #{ el with a16 = next_el.#a16 } in
    set_idx_mut a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 87;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 87 failed %d %d" size i;
    (* Path: [.#b16] *)
    let el = #{ el with b16 = next_el.#b16 } in
    set_idx_mut a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 88;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 88 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b16.#a10] *)
    let el = #{ el with b16 = #{ el.#b16 with a10 = next_el.#b16.#a10 } } in
    set_idx_mut a ((.(i).#b16.#a10) : (t16 array, _) idx_mut) next_el.#b16.#a10;
    mark_test_run 89;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 89 failed %d %d" size i;
    (* Path: [.#b16.#b10] *)
    let el = #{ el with b16 = #{ el.#b16 with b10 = next_el.#b16.#b10 } } in
    set_idx_mut a ((.(i).#b16.#b10) : (t16 array, _) idx_mut) next_el.#b16.#b10;
    mark_test_run 90;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 90 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t18 = #{ int; #{ int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a18 = a181; b18 = b181 } : t18) (#{ a18 = a182; b18 = b182 } : t18) -> (fun a b -> Int.equal a b) a181 a182 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b181 b182) in
  let mk_value i = (#{ a18 = (i + 0); b18 = (#{ a17 = Int32_u.of_int (i + 1) } : t17) } : t18) in
  (* Create an array of size [size] *)
  let a : t18 array = makearray_dynamic size (#{ a18 = 0; b18 = (#{ a17 = #1l } : t17) } : t18) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 91 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 92;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 92 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a18] *)
    let el = #{ el with a18 = next_el.#a18 } in
    set_idx_mut a ((.(i).#a18) : (t18 array, _) idx_mut) next_el.#a18;
    mark_test_run 93;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 93 failed %d %d" size i;
    (* Path: [.#b18] *)
    let el = #{ el with b18 = next_el.#b18 } in
    set_idx_mut a ((.(i).#b18) : (t18 array, _) idx_mut) next_el.#b18;
    mark_test_run 94;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 94 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b18.#a17] *)
    let el = #{ el with b18 = #{ el.#b18 with a17 = next_el.#b18.#a17 } } in
    set_idx_mut a ((.(i).#b18.#a17) : (t18 array, _) idx_mut) next_el.#b18.#a17;
    mark_test_run 95;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 95 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t20 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Int.equal a b) a201 a202 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b201 b202) in
  let mk_value i = (#{ a20 = (i + 0); b20 = (#{ a19 = Int32_u.of_int (i + 1); b19 = Int32_u.of_int (i + 2) } : t19) } : t20) in
  (* Create an array of size [size] *)
  let a : t20 array = makearray_dynamic size (#{ a20 = 0; b20 = (#{ a19 = #1l; b19 = #2l } : t19) } : t20) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 96 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 97;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 97 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a20] *)
    let el = #{ el with a20 = next_el.#a20 } in
    set_idx_mut a ((.(i).#a20) : (t20 array, _) idx_mut) next_el.#a20;
    mark_test_run 98;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 98 failed %d %d" size i;
    (* Path: [.#b20] *)
    let el = #{ el with b20 = next_el.#b20 } in
    set_idx_mut a ((.(i).#b20) : (t20 array, _) idx_mut) next_el.#b20;
    mark_test_run 99;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 99 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b20.#a19] *)
    let el = #{ el with b20 = #{ el.#b20 with a19 = next_el.#b20.#a19 } } in
    set_idx_mut a ((.(i).#b20.#a19) : (t20 array, _) idx_mut) next_el.#b20.#a19;
    mark_test_run 100;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 100 failed %d %d" size i;
    (* Path: [.#b20.#b19] *)
    let el = #{ el with b20 = #{ el.#b20 with b19 = next_el.#b20.#b19 } } in
    set_idx_mut a ((.(i).#b20.#b19) : (t20 array, _) idx_mut) next_el.#b20.#b19;
    mark_test_run 101;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 101 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t22 = #{ int; #{ float } }   *)
  (**********************************)
  let eq = (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Int.equal a b) a221 a222 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b221 b222) in
  let mk_value i = (#{ a22 = (i + 0); b22 = (#{ a21 = Float.of_int (i + 1) } : t21) } : t22) in
  (* Create an array of size [size] *)
  let a : t22 array = makearray_dynamic size (#{ a22 = 0; b22 = (#{ a21 = 1. } : t21) } : t22) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 102;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 102 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 103;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 103 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a22] *)
    let el = #{ el with a22 = next_el.#a22 } in
    set_idx_mut a ((.(i).#a22) : (t22 array, _) idx_mut) next_el.#a22;
    mark_test_run 104;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 104 failed %d %d" size i;
    (* Path: [.#b22] *)
    let el = #{ el with b22 = next_el.#b22 } in
    set_idx_mut a ((.(i).#b22) : (t22 array, _) idx_mut) next_el.#b22;
    mark_test_run 105;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b22.#a21] *)
    let el = #{ el with b22 = #{ el.#b22 with a21 = next_el.#b22.#a21 } } in
    set_idx_mut a ((.(i).#b22.#a21) : (t22 array, _) idx_mut) next_el.#b22.#a21;
    mark_test_run 106;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 106 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t24 = #{ int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun (#{ a24 = a241; b24 = b241 } : t24) (#{ a24 = a242; b24 = b242 } : t24) -> (fun a b -> Int.equal a b) a241 a242 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b241 b242) in
  let mk_value i = (#{ a24 = (i + 0); b24 = (#{ a23 = Float.of_int (i + 1); b23 = (i + 2) } : t23) } : t24) in
  (* Create an array of size [size] *)
  let a : t24 array = makearray_dynamic size (#{ a24 = 0; b24 = (#{ a23 = 1.; b23 = 2 } : t23) } : t24) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 108;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 108 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a24] *)
    let el = #{ el with a24 = next_el.#a24 } in
    set_idx_mut a ((.(i).#a24) : (t24 array, _) idx_mut) next_el.#a24;
    mark_test_run 109;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 109 failed %d %d" size i;
    (* Path: [.#b24] *)
    let el = #{ el with b24 = next_el.#b24 } in
    set_idx_mut a ((.(i).#b24) : (t24 array, _) idx_mut) next_el.#b24;
    mark_test_run 110;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 110 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b24.#a23] *)
    let el = #{ el with b24 = #{ el.#b24 with a23 = next_el.#b24.#a23 } } in
    set_idx_mut a ((.(i).#b24.#a23) : (t24 array, _) idx_mut) next_el.#b24.#a23;
    mark_test_run 111;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 111 failed %d %d" size i;
    (* Path: [.#b24.#b23] *)
    let el = #{ el with b24 = #{ el.#b24 with b23 = next_el.#b24.#b23 } } in
    set_idx_mut a ((.(i).#b24.#b23) : (t24 array, _) idx_mut) next_el.#b24.#b23;
    mark_test_run 112;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 112 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t26 = #{ int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a26 = a261; b26 = b261 } : t26) (#{ a26 = a262; b26 = b262 } : t26) -> (fun a b -> Int.equal a b) a261 a262 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b261 b262) in
  let mk_value i = (#{ a26 = (i + 0); b26 = (#{ a25 = Float.of_int (i + 1); b25 = Float.of_int (i + 2) } : t25) } : t26) in
  (* Create an array of size [size] *)
  let a : t26 array = makearray_dynamic size (#{ a26 = 0; b26 = (#{ a25 = 1.; b25 = 2. } : t25) } : t26) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 113;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 113 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 114;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 114 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a26] *)
    let el = #{ el with a26 = next_el.#a26 } in
    set_idx_mut a ((.(i).#a26) : (t26 array, _) idx_mut) next_el.#a26;
    mark_test_run 115;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 115 failed %d %d" size i;
    (* Path: [.#b26] *)
    let el = #{ el with b26 = next_el.#b26 } in
    set_idx_mut a ((.(i).#b26) : (t26 array, _) idx_mut) next_el.#b26;
    mark_test_run 116;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 116 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b26.#a25] *)
    let el = #{ el with b26 = #{ el.#b26 with a25 = next_el.#b26.#a25 } } in
    set_idx_mut a ((.(i).#b26.#a25) : (t26 array, _) idx_mut) next_el.#b26.#a25;
    mark_test_run 117;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 117 failed %d %d" size i;
    (* Path: [.#b26.#b25] *)
    let el = #{ el with b26 = #{ el.#b26 with b25 = next_el.#b26.#b25 } } in
    set_idx_mut a ((.(i).#b26.#b25) : (t26 array, _) idx_mut) next_el.#b26.#b25;
    mark_test_run 118;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 118 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************)
  (*   t27 = #{ int64 }   *)
  (************************)
  let eq = (fun (#{ a27 = a271 } : t27) (#{ a27 = a272 } : t27) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a271 a272) in
  let mk_value i = (#{ a27 = Int64.of_int (i + 0) } : t27) in
  (* Create an array of size [size] *)
  let a : t27 array = makearray_dynamic size (#{ a27 = 0L } : t27) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 119;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 119 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a27] *)
    let el = #{ el with a27 = next_el.#a27 } in
    set_idx_mut a ((.(i).#a27) : (t27 array, _) idx_mut) next_el.#a27;
    mark_test_run 121;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 121 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t28 = #{ int64; int }   *)
  (*****************************)
  let eq = (fun (#{ a28 = a281; b28 = b281 } : t28) (#{ a28 = a282; b28 = b282 } : t28) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) in
  let mk_value i = (#{ a28 = Int64.of_int (i + 0); b28 = (i + 1) } : t28) in
  (* Create an array of size [size] *)
  let a : t28 array = makearray_dynamic size (#{ a28 = 0L; b28 = 1 } : t28) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 122;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 122 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 123;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 123 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a28] *)
    let el = #{ el with a28 = next_el.#a28 } in
    set_idx_mut a ((.(i).#a28) : (t28 array, _) idx_mut) next_el.#a28;
    mark_test_run 124;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 124 failed %d %d" size i;
    (* Path: [.#b28] *)
    let el = #{ el with b28 = next_el.#b28 } in
    set_idx_mut a ((.(i).#b28) : (t28 array, _) idx_mut) next_el.#b28;
    mark_test_run 125;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 125 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t29 = #{ int64; int64 }   *)
  (*******************************)
  let eq = (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) in
  let mk_value i = (#{ a29 = Int64.of_int (i + 0); b29 = Int64.of_int (i + 1) } : t29) in
  (* Create an array of size [size] *)
  let a : t29 array = makearray_dynamic size (#{ a29 = 0L; b29 = 1L } : t29) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 126;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 126 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 127;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 127 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a29] *)
    let el = #{ el with a29 = next_el.#a29 } in
    set_idx_mut a ((.(i).#a29) : (t29 array, _) idx_mut) next_el.#a29;
    mark_test_run 128;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 128 failed %d %d" size i;
    (* Path: [.#b29] *)
    let el = #{ el with b29 = next_el.#b29 } in
    set_idx_mut a ((.(i).#b29) : (t29 array, _) idx_mut) next_el.#b29;
    mark_test_run 129;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 129 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t30 = #{ int64; float }   *)
  (*******************************)
  let eq = (fun (#{ a30 = a301; b30 = b301 } : t30) (#{ a30 = a302; b30 = b302 } : t30) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) in
  let mk_value i = (#{ a30 = Int64.of_int (i + 0); b30 = Float.of_int (i + 1) } : t30) in
  (* Create an array of size [size] *)
  let a : t30 array = makearray_dynamic size (#{ a30 = 0L; b30 = 1. } : t30) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 130;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 130 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 131 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a30] *)
    let el = #{ el with a30 = next_el.#a30 } in
    set_idx_mut a ((.(i).#a30) : (t30 array, _) idx_mut) next_el.#a30;
    mark_test_run 132;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 132 failed %d %d" size i;
    (* Path: [.#b30] *)
    let el = #{ el with b30 = next_el.#b30 } in
    set_idx_mut a ((.(i).#b30) : (t30 array, _) idx_mut) next_el.#b30;
    mark_test_run 133;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 133 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t31 = #{ int64# }   *)
  (*************************)
  let eq = (fun (#{ a31 = a311 } : t31) (#{ a31 = a312 } : t31) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a311 a312) in
  let mk_value i = (#{ a31 = Int64_u.of_int (i + 0) } : t31) in
  (* Create an array of size [size] *)
  let a : t31 array = makearray_dynamic size (#{ a31 = #0L } : t31) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 134;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 134 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 135;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 135 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a31] *)
    let el = #{ el with a31 = next_el.#a31 } in
    set_idx_mut a ((.(i).#a31) : (t31 array, _) idx_mut) next_el.#a31;
    mark_test_run 136;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 136 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t32 = #{ int64#; int64# }   *)
  (*********************************)
  let eq = (fun (#{ a32 = a321; b32 = b321 } : t32) (#{ a32 = a322; b32 = b322 } : t32) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a321 a322 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b321 b322) in
  let mk_value i = (#{ a32 = Int64_u.of_int (i + 0); b32 = Int64_u.of_int (i + 1) } : t32) in
  (* Create an array of size [size] *)
  let a : t32 array = makearray_dynamic size (#{ a32 = #0L; b32 = #1L } : t32) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 137;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 137 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 138;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 138 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a32] *)
    let el = #{ el with a32 = next_el.#a32 } in
    set_idx_mut a ((.(i).#a32) : (t32 array, _) idx_mut) next_el.#a32;
    mark_test_run 139;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 139 failed %d %d" size i;
    (* Path: [.#b32] *)
    let el = #{ el with b32 = next_el.#b32 } in
    set_idx_mut a ((.(i).#b32) : (t32 array, _) idx_mut) next_el.#b32;
    mark_test_run 140;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 140 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t33 = #{ int64#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a33 = a331; b33 = b331 } : t33) (#{ a33 = a332; b33 = b332 } : t33) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a331 a332 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b331 b332) in
  let mk_value i = (#{ a33 = Int64_u.of_int (i + 0); b33 = Int32_u.of_int (i + 1) } : t33) in
  (* Create an array of size [size] *)
  let a : t33 array = makearray_dynamic size (#{ a33 = #0L; b33 = #1l } : t33) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 141;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 141 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 142;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 142 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a33] *)
    let el = #{ el with a33 = next_el.#a33 } in
    set_idx_mut a ((.(i).#a33) : (t33 array, _) idx_mut) next_el.#a33;
    mark_test_run 143;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 143 failed %d %d" size i;
    (* Path: [.#b33] *)
    let el = #{ el with b33 = next_el.#b33 } in
    set_idx_mut a ((.(i).#b33) : (t33 array, _) idx_mut) next_el.#b33;
    mark_test_run 144;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 144 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t34 = #{ int64#; nativeint# }   *)
  (*************************************)
  let eq = (fun (#{ a34 = a341; b34 = b341 } : t34) (#{ a34 = a342; b34 = b342 } : t34) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a341 a342 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b341 b342) in
  let mk_value i = (#{ a34 = Int64_u.of_int (i + 0); b34 = Nativeint_u.of_int (i + 1) } : t34) in
  (* Create an array of size [size] *)
  let a : t34 array = makearray_dynamic size (#{ a34 = #0L; b34 = #1n } : t34) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 145;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 145 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 146;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 146 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a34] *)
    let el = #{ el with a34 = next_el.#a34 } in
    set_idx_mut a ((.(i).#a34) : (t34 array, _) idx_mut) next_el.#a34;
    mark_test_run 147;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 147 failed %d %d" size i;
    (* Path: [.#b34] *)
    let el = #{ el with b34 = next_el.#b34 } in
    set_idx_mut a ((.(i).#b34) : (t34 array, _) idx_mut) next_el.#b34;
    mark_test_run 148;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 148 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t17 = #{ int32# }   *)
  (*************************)
  let eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let mk_value i = (#{ a17 = Int32_u.of_int (i + 0) } : t17) in
  (* Create an array of size [size] *)
  let a : t17 array = makearray_dynamic size (#{ a17 = #0l } : t17) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 149;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 149 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 150;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 150 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a17] *)
    let el = #{ el with a17 = next_el.#a17 } in
    set_idx_mut a ((.(i).#a17) : (t17 array, _) idx_mut) next_el.#a17;
    mark_test_run 151;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 151 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t35 = #{ int32#; int64# }   *)
  (*********************************)
  let eq = (fun (#{ a35 = a351; b35 = b351 } : t35) (#{ a35 = a352; b35 = b352 } : t35) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a351 a352 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b351 b352) in
  let mk_value i = (#{ a35 = Int32_u.of_int (i + 0); b35 = Int64_u.of_int (i + 1) } : t35) in
  (* Create an array of size [size] *)
  let a : t35 array = makearray_dynamic size (#{ a35 = #0l; b35 = #1L } : t35) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 152;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 152 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 153;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 153 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a35] *)
    let el = #{ el with a35 = next_el.#a35 } in
    set_idx_mut a ((.(i).#a35) : (t35 array, _) idx_mut) next_el.#a35;
    mark_test_run 154;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 154 failed %d %d" size i;
    (* Path: [.#b35] *)
    let el = #{ el with b35 = next_el.#b35 } in
    set_idx_mut a ((.(i).#b35) : (t35 array, _) idx_mut) next_el.#b35;
    mark_test_run 155;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 155 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t19 = #{ int32#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let mk_value i = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19) in
  (* Create an array of size [size] *)
  let a : t19 array = makearray_dynamic size (#{ a19 = #0l; b19 = #1l } : t19) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 156;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 156 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 157;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 157 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a19] *)
    let el = #{ el with a19 = next_el.#a19 } in
    set_idx_mut a ((.(i).#a19) : (t19 array, _) idx_mut) next_el.#a19;
    mark_test_run 158;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 158 failed %d %d" size i;
    (* Path: [.#b19] *)
    let el = #{ el with b19 = next_el.#b19 } in
    set_idx_mut a ((.(i).#b19) : (t19 array, _) idx_mut) next_el.#b19;
    mark_test_run 159;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 159 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t36 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun (#{ a36 = a361; b36 = b361; c36 = c361 } : t36) (#{ a36 = a362; b36 = b362; c36 = c362 } : t36) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a361 a362 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b361 b362 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c361 c362) in
  let mk_value i = (#{ a36 = Int32_u.of_int (i + 0); b36 = Int32_u.of_int (i + 1); c36 = Int32_u.of_int (i + 2) } : t36) in
  (* Create an array of size [size] *)
  let a : t36 array = makearray_dynamic size (#{ a36 = #0l; b36 = #1l; c36 = #2l } : t36) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 160;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 160 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 161;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 161 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a36] *)
    let el = #{ el with a36 = next_el.#a36 } in
    set_idx_mut a ((.(i).#a36) : (t36 array, _) idx_mut) next_el.#a36;
    mark_test_run 162;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 162 failed %d %d" size i;
    (* Path: [.#b36] *)
    let el = #{ el with b36 = next_el.#b36 } in
    set_idx_mut a ((.(i).#b36) : (t36 array, _) idx_mut) next_el.#b36;
    mark_test_run 163;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 163 failed %d %d" size i;
    (* Path: [.#c36] *)
    let el = #{ el with c36 = next_el.#c36 } in
    set_idx_mut a ((.(i).#c36) : (t36 array, _) idx_mut) next_el.#c36;
    mark_test_run 164;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 164 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t37 = #{ int32#; nativeint# }   *)
  (*************************************)
  let eq = (fun (#{ a37 = a371; b37 = b371 } : t37) (#{ a37 = a372; b37 = b372 } : t37) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a371 a372 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b371 b372) in
  let mk_value i = (#{ a37 = Int32_u.of_int (i + 0); b37 = Nativeint_u.of_int (i + 1) } : t37) in
  (* Create an array of size [size] *)
  let a : t37 array = makearray_dynamic size (#{ a37 = #0l; b37 = #1n } : t37) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 165;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 165 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 166;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 166 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a37] *)
    let el = #{ el with a37 = next_el.#a37 } in
    set_idx_mut a ((.(i).#a37) : (t37 array, _) idx_mut) next_el.#a37;
    mark_test_run 167;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 167 failed %d %d" size i;
    (* Path: [.#b37] *)
    let el = #{ el with b37 = next_el.#b37 } in
    set_idx_mut a ((.(i).#b37) : (t37 array, _) idx_mut) next_el.#b37;
    mark_test_run 168;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 168 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t38 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a38 = a381; b38 = b381 } : t38) (#{ a38 = a382; b38 = b382 } : t38) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a381 a382 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b381 b382) in
  let mk_value i = (#{ a38 = Int32_u.of_int (i + 0); b38 = (#{ a17 = Int32_u.of_int (i + 1) } : t17) } : t38) in
  (* Create an array of size [size] *)
  let a : t38 array = makearray_dynamic size (#{ a38 = #0l; b38 = (#{ a17 = #1l } : t17) } : t38) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 169;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 169 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 170;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 170 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a38] *)
    let el = #{ el with a38 = next_el.#a38 } in
    set_idx_mut a ((.(i).#a38) : (t38 array, _) idx_mut) next_el.#a38;
    mark_test_run 171;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 171 failed %d %d" size i;
    (* Path: [.#b38] *)
    let el = #{ el with b38 = next_el.#b38 } in
    set_idx_mut a ((.(i).#b38) : (t38 array, _) idx_mut) next_el.#b38;
    mark_test_run 172;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 172 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b38.#a17] *)
    let el = #{ el with b38 = #{ el.#b38 with a17 = next_el.#b38.#a17 } } in
    set_idx_mut a ((.(i).#b38.#a17) : (t38 array, _) idx_mut) next_el.#b38.#a17;
    mark_test_run 173;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 173 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t39 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun (#{ a39 = a391; b39 = b391 } : t39) (#{ a39 = a392; b39 = b392 } : t39) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b391 b392) in
  let mk_value i = (#{ a39 = Int32_u.of_int (i + 0); b39 = (#{ a19 = Int32_u.of_int (i + 1); b19 = Int32_u.of_int (i + 2) } : t19) } : t39) in
  (* Create an array of size [size] *)
  let a : t39 array = makearray_dynamic size (#{ a39 = #0l; b39 = (#{ a19 = #1l; b19 = #2l } : t19) } : t39) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 174;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 174 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 175;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 175 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a39] *)
    let el = #{ el with a39 = next_el.#a39 } in
    set_idx_mut a ((.(i).#a39) : (t39 array, _) idx_mut) next_el.#a39;
    mark_test_run 176;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 176 failed %d %d" size i;
    (* Path: [.#b39] *)
    let el = #{ el with b39 = next_el.#b39 } in
    set_idx_mut a ((.(i).#b39) : (t39 array, _) idx_mut) next_el.#b39;
    mark_test_run 177;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 177 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b39.#a19] *)
    let el = #{ el with b39 = #{ el.#b39 with a19 = next_el.#b39.#a19 } } in
    set_idx_mut a ((.(i).#b39.#a19) : (t39 array, _) idx_mut) next_el.#b39.#a19;
    mark_test_run 178;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 178 failed %d %d" size i;
    (* Path: [.#b39.#b19] *)
    let el = #{ el with b39 = #{ el.#b39 with b19 = next_el.#b39.#b19 } } in
    set_idx_mut a ((.(i).#b39.#b19) : (t39 array, _) idx_mut) next_el.#b39.#b19;
    mark_test_run 179;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 179 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t40 = #{ nativeint# }   *)
  (*****************************)
  let eq = (fun (#{ a40 = a401 } : t40) (#{ a40 = a402 } : t40) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a401 a402) in
  let mk_value i = (#{ a40 = Nativeint_u.of_int (i + 0) } : t40) in
  (* Create an array of size [size] *)
  let a : t40 array = makearray_dynamic size (#{ a40 = #0n } : t40) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 180;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 180 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 181;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 181 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a40] *)
    let el = #{ el with a40 = next_el.#a40 } in
    set_idx_mut a ((.(i).#a40) : (t40 array, _) idx_mut) next_el.#a40;
    mark_test_run 182;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 182 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t41 = #{ nativeint#; int64# }   *)
  (*************************************)
  let eq = (fun (#{ a41 = a411; b41 = b411 } : t41) (#{ a41 = a412; b41 = b412 } : t41) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a411 a412 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b411 b412) in
  let mk_value i = (#{ a41 = Nativeint_u.of_int (i + 0); b41 = Int64_u.of_int (i + 1) } : t41) in
  (* Create an array of size [size] *)
  let a : t41 array = makearray_dynamic size (#{ a41 = #0n; b41 = #1L } : t41) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 183;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 183 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 184;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 184 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a41] *)
    let el = #{ el with a41 = next_el.#a41 } in
    set_idx_mut a ((.(i).#a41) : (t41 array, _) idx_mut) next_el.#a41;
    mark_test_run 185;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 185 failed %d %d" size i;
    (* Path: [.#b41] *)
    let el = #{ el with b41 = next_el.#b41 } in
    set_idx_mut a ((.(i).#b41) : (t41 array, _) idx_mut) next_el.#b41;
    mark_test_run 186;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 186 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t42 = #{ nativeint#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a42 = a421; b42 = b421 } : t42) (#{ a42 = a422; b42 = b422 } : t42) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a421 a422 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b421 b422) in
  let mk_value i = (#{ a42 = Nativeint_u.of_int (i + 0); b42 = Int32_u.of_int (i + 1) } : t42) in
  (* Create an array of size [size] *)
  let a : t42 array = makearray_dynamic size (#{ a42 = #0n; b42 = #1l } : t42) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 187;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 187 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 188;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 188 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a42] *)
    let el = #{ el with a42 = next_el.#a42 } in
    set_idx_mut a ((.(i).#a42) : (t42 array, _) idx_mut) next_el.#a42;
    mark_test_run 189;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 189 failed %d %d" size i;
    (* Path: [.#b42] *)
    let el = #{ el with b42 = next_el.#b42 } in
    set_idx_mut a ((.(i).#b42) : (t42 array, _) idx_mut) next_el.#b42;
    mark_test_run 190;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 190 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t43 = #{ nativeint#; nativeint# }   *)
  (*****************************************)
  let eq = (fun (#{ a43 = a431; b43 = b431 } : t43) (#{ a43 = a432; b43 = b432 } : t43) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a431 a432 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b431 b432) in
  let mk_value i = (#{ a43 = Nativeint_u.of_int (i + 0); b43 = Nativeint_u.of_int (i + 1) } : t43) in
  (* Create an array of size [size] *)
  let a : t43 array = makearray_dynamic size (#{ a43 = #0n; b43 = #1n } : t43) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 191;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 191 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 192;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 192 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a43] *)
    let el = #{ el with a43 = next_el.#a43 } in
    set_idx_mut a ((.(i).#a43) : (t43 array, _) idx_mut) next_el.#a43;
    mark_test_run 193;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 193 failed %d %d" size i;
    (* Path: [.#b43] *)
    let el = #{ el with b43 = next_el.#b43 } in
    set_idx_mut a ((.(i).#b43) : (t43 array, _) idx_mut) next_el.#b43;
    mark_test_run 194;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 194 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t23 = #{ float; int }   *)
  (*****************************)
  let eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let mk_value i = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23) in
  (* Create an array of size [size] *)
  let a : t23 array = makearray_dynamic size (#{ a23 = 0.; b23 = 1 } : t23) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 195;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 195 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 196;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 196 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a23] *)
    let el = #{ el with a23 = next_el.#a23 } in
    set_idx_mut a ((.(i).#a23) : (t23 array, _) idx_mut) next_el.#a23;
    mark_test_run 197;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 197 failed %d %d" size i;
    (* Path: [.#b23] *)
    let el = #{ el with b23 = next_el.#b23 } in
    set_idx_mut a ((.(i).#b23) : (t23 array, _) idx_mut) next_el.#b23;
    mark_test_run 198;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 198 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t44 = #{ float; int; int }   *)
  (**********************************)
  let eq = (fun (#{ a44 = a441; b44 = b441; c44 = c441 } : t44) (#{ a44 = a442; b44 = b442; c44 = c442 } : t44) -> (fun a b -> Float.equal (globalize a) (globalize b)) a441 a442 && (fun a b -> Int.equal a b) b441 b442 && (fun a b -> Int.equal a b) c441 c442) in
  let mk_value i = (#{ a44 = Float.of_int (i + 0); b44 = (i + 1); c44 = (i + 2) } : t44) in
  (* Create an array of size [size] *)
  let a : t44 array = makearray_dynamic size (#{ a44 = 0.; b44 = 1; c44 = 2 } : t44) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 199;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 199 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 200;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 200 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a44] *)
    let el = #{ el with a44 = next_el.#a44 } in
    set_idx_mut a ((.(i).#a44) : (t44 array, _) idx_mut) next_el.#a44;
    mark_test_run 201;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 201 failed %d %d" size i;
    (* Path: [.#b44] *)
    let el = #{ el with b44 = next_el.#b44 } in
    set_idx_mut a ((.(i).#b44) : (t44 array, _) idx_mut) next_el.#b44;
    mark_test_run 202;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 202 failed %d %d" size i;
    (* Path: [.#c44] *)
    let el = #{ el with c44 = next_el.#c44 } in
    set_idx_mut a ((.(i).#c44) : (t44 array, _) idx_mut) next_el.#c44;
    mark_test_run 203;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 203 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t45 = #{ float; int; float }   *)
  (************************************)
  let eq = (fun (#{ a45 = a451; b45 = b451; c45 = c451 } : t45) (#{ a45 = a452; b45 = b452; c45 = c452 } : t45) -> (fun a b -> Float.equal (globalize a) (globalize b)) a451 a452 && (fun a b -> Int.equal a b) b451 b452 && (fun a b -> Float.equal (globalize a) (globalize b)) c451 c452) in
  let mk_value i = (#{ a45 = Float.of_int (i + 0); b45 = (i + 1); c45 = Float.of_int (i + 2) } : t45) in
  (* Create an array of size [size] *)
  let a : t45 array = makearray_dynamic size (#{ a45 = 0.; b45 = 1; c45 = 2. } : t45) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 204;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 204 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 205;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 205 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a45] *)
    let el = #{ el with a45 = next_el.#a45 } in
    set_idx_mut a ((.(i).#a45) : (t45 array, _) idx_mut) next_el.#a45;
    mark_test_run 206;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 206 failed %d %d" size i;
    (* Path: [.#b45] *)
    let el = #{ el with b45 = next_el.#b45 } in
    set_idx_mut a ((.(i).#b45) : (t45 array, _) idx_mut) next_el.#b45;
    mark_test_run 207;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 207 failed %d %d" size i;
    (* Path: [.#c45] *)
    let el = #{ el with c45 = next_el.#c45 } in
    set_idx_mut a ((.(i).#c45) : (t45 array, _) idx_mut) next_el.#c45;
    mark_test_run 208;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 208 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t46 = #{ float; int64 }   *)
  (*******************************)
  let eq = (fun (#{ a46 = a461; b46 = b461 } : t46) (#{ a46 = a462; b46 = b462 } : t46) -> (fun a b -> Float.equal (globalize a) (globalize b)) a461 a462 && (fun a b -> Int64.equal (globalize a) (globalize b)) b461 b462) in
  let mk_value i = (#{ a46 = Float.of_int (i + 0); b46 = Int64.of_int (i + 1) } : t46) in
  (* Create an array of size [size] *)
  let a : t46 array = makearray_dynamic size (#{ a46 = 0.; b46 = 1L } : t46) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 209;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 209 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 210;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 210 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a46] *)
    let el = #{ el with a46 = next_el.#a46 } in
    set_idx_mut a ((.(i).#a46) : (t46 array, _) idx_mut) next_el.#a46;
    mark_test_run 211;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 211 failed %d %d" size i;
    (* Path: [.#b46] *)
    let el = #{ el with b46 = next_el.#b46 } in
    set_idx_mut a ((.(i).#b46) : (t46 array, _) idx_mut) next_el.#b46;
    mark_test_run 212;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 212 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t25 = #{ float; float }   *)
  (*******************************)
  let eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let mk_value i = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25) in
  (* Create an array of size [size] *)
  let a : t25 array = makearray_dynamic size (#{ a25 = 0.; b25 = 1. } : t25) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 213;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 213 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 214;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 214 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a25] *)
    let el = #{ el with a25 = next_el.#a25 } in
    set_idx_mut a ((.(i).#a25) : (t25 array, _) idx_mut) next_el.#a25;
    mark_test_run 215;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 215 failed %d %d" size i;
    (* Path: [.#b25] *)
    let el = #{ el with b25 = next_el.#b25 } in
    set_idx_mut a ((.(i).#b25) : (t25 array, _) idx_mut) next_el.#b25;
    mark_test_run 216;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 216 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t47 = #{ float; float; int }   *)
  (************************************)
  let eq = (fun (#{ a47 = a471; b47 = b471; c47 = c471 } : t47) (#{ a47 = a472; b47 = b472; c47 = c472 } : t47) -> (fun a b -> Float.equal (globalize a) (globalize b)) a471 a472 && (fun a b -> Float.equal (globalize a) (globalize b)) b471 b472 && (fun a b -> Int.equal a b) c471 c472) in
  let mk_value i = (#{ a47 = Float.of_int (i + 0); b47 = Float.of_int (i + 1); c47 = (i + 2) } : t47) in
  (* Create an array of size [size] *)
  let a : t47 array = makearray_dynamic size (#{ a47 = 0.; b47 = 1.; c47 = 2 } : t47) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 217;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 217 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 218;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 218 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a47] *)
    let el = #{ el with a47 = next_el.#a47 } in
    set_idx_mut a ((.(i).#a47) : (t47 array, _) idx_mut) next_el.#a47;
    mark_test_run 219;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 219 failed %d %d" size i;
    (* Path: [.#b47] *)
    let el = #{ el with b47 = next_el.#b47 } in
    set_idx_mut a ((.(i).#b47) : (t47 array, _) idx_mut) next_el.#b47;
    mark_test_run 220;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 220 failed %d %d" size i;
    (* Path: [.#c47] *)
    let el = #{ el with c47 = next_el.#c47 } in
    set_idx_mut a ((.(i).#c47) : (t47 array, _) idx_mut) next_el.#c47;
    mark_test_run 221;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 221 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t48 = #{ float; float; float }   *)
  (**************************************)
  let eq = (fun (#{ a48 = a481; b48 = b481; c48 = c481 } : t48) (#{ a48 = a482; b48 = b482; c48 = c482 } : t48) -> (fun a b -> Float.equal (globalize a) (globalize b)) a481 a482 && (fun a b -> Float.equal (globalize a) (globalize b)) b481 b482 && (fun a b -> Float.equal (globalize a) (globalize b)) c481 c482) in
  let mk_value i = (#{ a48 = Float.of_int (i + 0); b48 = Float.of_int (i + 1); c48 = Float.of_int (i + 2) } : t48) in
  (* Create an array of size [size] *)
  let a : t48 array = makearray_dynamic size (#{ a48 = 0.; b48 = 1.; c48 = 2. } : t48) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 222;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 222 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 223;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 223 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a48] *)
    let el = #{ el with a48 = next_el.#a48 } in
    set_idx_mut a ((.(i).#a48) : (t48 array, _) idx_mut) next_el.#a48;
    mark_test_run 224;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 224 failed %d %d" size i;
    (* Path: [.#b48] *)
    let el = #{ el with b48 = next_el.#b48 } in
    set_idx_mut a ((.(i).#b48) : (t48 array, _) idx_mut) next_el.#b48;
    mark_test_run 225;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 225 failed %d %d" size i;
    (* Path: [.#c48] *)
    let el = #{ el with c48 = next_el.#c48 } in
    set_idx_mut a ((.(i).#c48) : (t48 array, _) idx_mut) next_el.#c48;
    mark_test_run 226;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 226 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t49 = #{ float; #{ int } }   *)
  (**********************************)
  let eq = (fun (#{ a49 = a491; b49 = b491 } : t49) (#{ a49 = a492; b49 = b492 } : t49) -> (fun a b -> Float.equal (globalize a) (globalize b)) a491 a492 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b491 b492) in
  let mk_value i = (#{ a49 = Float.of_int (i + 0); b49 = (#{ a0 = (i + 1) } : t0) } : t49) in
  (* Create an array of size [size] *)
  let a : t49 array = makearray_dynamic size (#{ a49 = 0.; b49 = (#{ a0 = 1 } : t0) } : t49) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 227;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 227 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 228;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 228 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a49] *)
    let el = #{ el with a49 = next_el.#a49 } in
    set_idx_mut a ((.(i).#a49) : (t49 array, _) idx_mut) next_el.#a49;
    mark_test_run 229;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 229 failed %d %d" size i;
    (* Path: [.#b49] *)
    let el = #{ el with b49 = next_el.#b49 } in
    set_idx_mut a ((.(i).#b49) : (t49 array, _) idx_mut) next_el.#b49;
    mark_test_run 230;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 230 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b49.#a0] *)
    let el = #{ el with b49 = #{ el.#b49 with a0 = next_el.#b49.#a0 } } in
    set_idx_mut a ((.(i).#b49.#a0) : (t49 array, _) idx_mut) next_el.#b49.#a0;
    mark_test_run 231;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 231 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t50 = #{ float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun (#{ a50 = a501; b50 = b501 } : t50) (#{ a50 = a502; b50 = b502 } : t50) -> (fun a b -> Float.equal (globalize a) (globalize b)) a501 a502 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b501 b502) in
  let mk_value i = (#{ a50 = Float.of_int (i + 0); b50 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t50) in
  (* Create an array of size [size] *)
  let a : t50 array = makearray_dynamic size (#{ a50 = 0.; b50 = (#{ a1 = 1; b1 = 2 } : t1) } : t50) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 232;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 232 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 233;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 233 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a50] *)
    let el = #{ el with a50 = next_el.#a50 } in
    set_idx_mut a ((.(i).#a50) : (t50 array, _) idx_mut) next_el.#a50;
    mark_test_run 234;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 234 failed %d %d" size i;
    (* Path: [.#b50] *)
    let el = #{ el with b50 = next_el.#b50 } in
    set_idx_mut a ((.(i).#b50) : (t50 array, _) idx_mut) next_el.#b50;
    mark_test_run 235;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 235 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b50.#a1] *)
    let el = #{ el with b50 = #{ el.#b50 with a1 = next_el.#b50.#a1 } } in
    set_idx_mut a ((.(i).#b50.#a1) : (t50 array, _) idx_mut) next_el.#b50.#a1;
    mark_test_run 236;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 236 failed %d %d" size i;
    (* Path: [.#b50.#b1] *)
    let el = #{ el with b50 = #{ el.#b50 with b1 = next_el.#b50.#b1 } } in
    set_idx_mut a ((.(i).#b50.#b1) : (t50 array, _) idx_mut) next_el.#b50.#b1;
    mark_test_run 237;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 237 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t51 = #{ float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a51 = a511; b51 = b511 } : t51) (#{ a51 = a512; b51 = b512 } : t51) -> (fun a b -> Float.equal (globalize a) (globalize b)) a511 a512 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b511 b512) in
  let mk_value i = (#{ a51 = Float.of_int (i + 0); b51 = (#{ a10 = (i + 1); b10 = Float.of_int (i + 2) } : t10) } : t51) in
  (* Create an array of size [size] *)
  let a : t51 array = makearray_dynamic size (#{ a51 = 0.; b51 = (#{ a10 = 1; b10 = 2. } : t10) } : t51) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 238;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 238 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 239;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 239 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a51] *)
    let el = #{ el with a51 = next_el.#a51 } in
    set_idx_mut a ((.(i).#a51) : (t51 array, _) idx_mut) next_el.#a51;
    mark_test_run 240;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 240 failed %d %d" size i;
    (* Path: [.#b51] *)
    let el = #{ el with b51 = next_el.#b51 } in
    set_idx_mut a ((.(i).#b51) : (t51 array, _) idx_mut) next_el.#b51;
    mark_test_run 241;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 241 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b51.#a10] *)
    let el = #{ el with b51 = #{ el.#b51 with a10 = next_el.#b51.#a10 } } in
    set_idx_mut a ((.(i).#b51.#a10) : (t51 array, _) idx_mut) next_el.#b51.#a10;
    mark_test_run 242;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 242 failed %d %d" size i;
    (* Path: [.#b51.#b10] *)
    let el = #{ el with b51 = #{ el.#b51 with b10 = next_el.#b51.#b10 } } in
    set_idx_mut a ((.(i).#b51.#b10) : (t51 array, _) idx_mut) next_el.#b51.#b10;
    mark_test_run 243;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 243 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t52 = #{ float; #{ float } }   *)
  (************************************)
  let eq = (fun (#{ a52 = a521; b52 = b521 } : t52) (#{ a52 = a522; b52 = b522 } : t52) -> (fun a b -> Float.equal (globalize a) (globalize b)) a521 a522 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b521 b522) in
  let mk_value i = (#{ a52 = Float.of_int (i + 0); b52 = (#{ a21 = Float.of_int (i + 1) } : t21) } : t52) in
  (* Create an array of size [size] *)
  let a : t52 array = makearray_dynamic size (#{ a52 = 0.; b52 = (#{ a21 = 1. } : t21) } : t52) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 244;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 244 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 245;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 245 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a52] *)
    let el = #{ el with a52 = next_el.#a52 } in
    set_idx_mut a ((.(i).#a52) : (t52 array, _) idx_mut) next_el.#a52;
    mark_test_run 246;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 246 failed %d %d" size i;
    (* Path: [.#b52] *)
    let el = #{ el with b52 = next_el.#b52 } in
    set_idx_mut a ((.(i).#b52) : (t52 array, _) idx_mut) next_el.#b52;
    mark_test_run 247;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 247 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b52.#a21] *)
    let el = #{ el with b52 = #{ el.#b52 with a21 = next_el.#b52.#a21 } } in
    set_idx_mut a ((.(i).#b52.#a21) : (t52 array, _) idx_mut) next_el.#b52.#a21;
    mark_test_run 248;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 248 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t53 = #{ float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun (#{ a53 = a531; b53 = b531 } : t53) (#{ a53 = a532; b53 = b532 } : t53) -> (fun a b -> Float.equal (globalize a) (globalize b)) a531 a532 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b531 b532) in
  let mk_value i = (#{ a53 = Float.of_int (i + 0); b53 = (#{ a23 = Float.of_int (i + 1); b23 = (i + 2) } : t23) } : t53) in
  (* Create an array of size [size] *)
  let a : t53 array = makearray_dynamic size (#{ a53 = 0.; b53 = (#{ a23 = 1.; b23 = 2 } : t23) } : t53) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 249;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 249 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 250;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 250 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a53] *)
    let el = #{ el with a53 = next_el.#a53 } in
    set_idx_mut a ((.(i).#a53) : (t53 array, _) idx_mut) next_el.#a53;
    mark_test_run 251;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 251 failed %d %d" size i;
    (* Path: [.#b53] *)
    let el = #{ el with b53 = next_el.#b53 } in
    set_idx_mut a ((.(i).#b53) : (t53 array, _) idx_mut) next_el.#b53;
    mark_test_run 252;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 252 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b53.#a23] *)
    let el = #{ el with b53 = #{ el.#b53 with a23 = next_el.#b53.#a23 } } in
    set_idx_mut a ((.(i).#b53.#a23) : (t53 array, _) idx_mut) next_el.#b53.#a23;
    mark_test_run 253;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 253 failed %d %d" size i;
    (* Path: [.#b53.#b23] *)
    let el = #{ el with b53 = #{ el.#b53 with b23 = next_el.#b53.#b23 } } in
    set_idx_mut a ((.(i).#b53.#b23) : (t53 array, _) idx_mut) next_el.#b53.#b23;
    mark_test_run 254;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 254 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t54 = #{ float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun (#{ a54 = a541; b54 = b541 } : t54) (#{ a54 = a542; b54 = b542 } : t54) -> (fun a b -> Float.equal (globalize a) (globalize b)) a541 a542 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b541 b542) in
  let mk_value i = (#{ a54 = Float.of_int (i + 0); b54 = (#{ a25 = Float.of_int (i + 1); b25 = Float.of_int (i + 2) } : t25) } : t54) in
  (* Create an array of size [size] *)
  let a : t54 array = makearray_dynamic size (#{ a54 = 0.; b54 = (#{ a25 = 1.; b25 = 2. } : t25) } : t54) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 255;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 255 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 256;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 256 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a54] *)
    let el = #{ el with a54 = next_el.#a54 } in
    set_idx_mut a ((.(i).#a54) : (t54 array, _) idx_mut) next_el.#a54;
    mark_test_run 257;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 257 failed %d %d" size i;
    (* Path: [.#b54] *)
    let el = #{ el with b54 = next_el.#b54 } in
    set_idx_mut a ((.(i).#b54) : (t54 array, _) idx_mut) next_el.#b54;
    mark_test_run 258;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 258 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#b54.#a25] *)
    let el = #{ el with b54 = #{ el.#b54 with a25 = next_el.#b54.#a25 } } in
    set_idx_mut a ((.(i).#b54.#a25) : (t54 array, _) idx_mut) next_el.#b54.#a25;
    mark_test_run 259;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 259 failed %d %d" size i;
    (* Path: [.#b54.#b25] *)
    let el = #{ el with b54 = #{ el.#b54 with b25 = next_el.#b54.#b25 } } in
    set_idx_mut a ((.(i).#b54.#b25) : (t54 array, _) idx_mut) next_el.#b54.#b25;
    mark_test_run 260;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 260 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************)
  (*   t55 = #{ #{ int } }   *)
  (***************************)
  let eq = (fun (#{ a55 = a551 } : t55) (#{ a55 = a552 } : t55) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a551 a552) in
  let mk_value i = (#{ a55 = (#{ a0 = (i + 0) } : t0) } : t55) in
  (* Create an array of size [size] *)
  let a : t55 array = makearray_dynamic size (#{ a55 = (#{ a0 = 0 } : t0) } : t55) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 261;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 261 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 262;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 262 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a55] *)
    let el = #{ el with a55 = next_el.#a55 } in
    set_idx_mut a ((.(i).#a55) : (t55 array, _) idx_mut) next_el.#a55;
    mark_test_run 263;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 263 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a55.#a0] *)
    let el = #{ el with a55 = #{ el.#a55 with a0 = next_el.#a55.#a0 } } in
    set_idx_mut a ((.(i).#a55.#a0) : (t55 array, _) idx_mut) next_el.#a55.#a0;
    mark_test_run 264;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 264 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t56 = #{ #{ int }; int }   *)
  (********************************)
  let eq = (fun (#{ a56 = a561; b56 = b561 } : t56) (#{ a56 = a562; b56 = b562 } : t56) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a561 a562 && (fun a b -> Int.equal a b) b561 b562) in
  let mk_value i = (#{ a56 = (#{ a0 = (i + 0) } : t0); b56 = (i + 1) } : t56) in
  (* Create an array of size [size] *)
  let a : t56 array = makearray_dynamic size (#{ a56 = (#{ a0 = 0 } : t0); b56 = 1 } : t56) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 265;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 265 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 266;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 266 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a56] *)
    let el = #{ el with a56 = next_el.#a56 } in
    set_idx_mut a ((.(i).#a56) : (t56 array, _) idx_mut) next_el.#a56;
    mark_test_run 267;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 267 failed %d %d" size i;
    (* Path: [.#b56] *)
    let el = #{ el with b56 = next_el.#b56 } in
    set_idx_mut a ((.(i).#b56) : (t56 array, _) idx_mut) next_el.#b56;
    mark_test_run 268;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 268 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a56.#a0] *)
    let el = #{ el with a56 = #{ el.#a56 with a0 = next_el.#a56.#a0 } } in
    set_idx_mut a ((.(i).#a56.#a0) : (t56 array, _) idx_mut) next_el.#a56.#a0;
    mark_test_run 269;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 269 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t57 = #{ #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun (#{ a57 = a571; b57 = b571 } : t57) (#{ a57 = a572; b57 = b572 } : t57) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a571 a572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b571 b572) in
  let mk_value i = (#{ a57 = (#{ a0 = (i + 0) } : t0); b57 = Int32_u.of_int (i + 1) } : t57) in
  (* Create an array of size [size] *)
  let a : t57 array = makearray_dynamic size (#{ a57 = (#{ a0 = 0 } : t0); b57 = #1l } : t57) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 270;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 270 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 271;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 271 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a57] *)
    let el = #{ el with a57 = next_el.#a57 } in
    set_idx_mut a ((.(i).#a57) : (t57 array, _) idx_mut) next_el.#a57;
    mark_test_run 272;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 272 failed %d %d" size i;
    (* Path: [.#b57] *)
    let el = #{ el with b57 = next_el.#b57 } in
    set_idx_mut a ((.(i).#b57) : (t57 array, _) idx_mut) next_el.#b57;
    mark_test_run 273;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 273 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a57.#a0] *)
    let el = #{ el with a57 = #{ el.#a57 with a0 = next_el.#a57.#a0 } } in
    set_idx_mut a ((.(i).#a57.#a0) : (t57 array, _) idx_mut) next_el.#a57.#a0;
    mark_test_run 274;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 274 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t58 = #{ #{ int }; float }   *)
  (**********************************)
  let eq = (fun (#{ a58 = a581; b58 = b581 } : t58) (#{ a58 = a582; b58 = b582 } : t58) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a581 a582 && (fun a b -> Float.equal (globalize a) (globalize b)) b581 b582) in
  let mk_value i = (#{ a58 = (#{ a0 = (i + 0) } : t0); b58 = Float.of_int (i + 1) } : t58) in
  (* Create an array of size [size] *)
  let a : t58 array = makearray_dynamic size (#{ a58 = (#{ a0 = 0 } : t0); b58 = 1. } : t58) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 275;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 275 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 276;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 276 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a58] *)
    let el = #{ el with a58 = next_el.#a58 } in
    set_idx_mut a ((.(i).#a58) : (t58 array, _) idx_mut) next_el.#a58;
    mark_test_run 277;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 277 failed %d %d" size i;
    (* Path: [.#b58] *)
    let el = #{ el with b58 = next_el.#b58 } in
    set_idx_mut a ((.(i).#b58) : (t58 array, _) idx_mut) next_el.#b58;
    mark_test_run 278;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 278 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a58.#a0] *)
    let el = #{ el with a58 = #{ el.#a58 with a0 = next_el.#a58.#a0 } } in
    set_idx_mut a ((.(i).#a58.#a0) : (t58 array, _) idx_mut) next_el.#a58.#a0;
    mark_test_run 279;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 279 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t59 = #{ #{ int; int } }   *)
  (********************************)
  let eq = (fun (#{ a59 = a591 } : t59) (#{ a59 = a592 } : t59) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a591 a592) in
  let mk_value i = (#{ a59 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) } : t59) in
  (* Create an array of size [size] *)
  let a : t59 array = makearray_dynamic size (#{ a59 = (#{ a1 = 0; b1 = 1 } : t1) } : t59) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 280;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 280 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 281;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 281 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a59] *)
    let el = #{ el with a59 = next_el.#a59 } in
    set_idx_mut a ((.(i).#a59) : (t59 array, _) idx_mut) next_el.#a59;
    mark_test_run 282;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 282 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a59.#a1] *)
    let el = #{ el with a59 = #{ el.#a59 with a1 = next_el.#a59.#a1 } } in
    set_idx_mut a ((.(i).#a59.#a1) : (t59 array, _) idx_mut) next_el.#a59.#a1;
    mark_test_run 283;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 283 failed %d %d" size i;
    (* Path: [.#a59.#b1] *)
    let el = #{ el with a59 = #{ el.#a59 with b1 = next_el.#a59.#b1 } } in
    set_idx_mut a ((.(i).#a59.#b1) : (t59 array, _) idx_mut) next_el.#a59.#b1;
    mark_test_run 284;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 284 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t60 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun (#{ a60 = a601; b60 = b601 } : t60) (#{ a60 = a602; b60 = b602 } : t60) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a601 a602 && (fun a b -> Int.equal a b) b601 b602) in
  let mk_value i = (#{ a60 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b60 = (i + 2) } : t60) in
  (* Create an array of size [size] *)
  let a : t60 array = makearray_dynamic size (#{ a60 = (#{ a1 = 0; b1 = 1 } : t1); b60 = 2 } : t60) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 285;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 285 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 286;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 286 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a60] *)
    let el = #{ el with a60 = next_el.#a60 } in
    set_idx_mut a ((.(i).#a60) : (t60 array, _) idx_mut) next_el.#a60;
    mark_test_run 287;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 287 failed %d %d" size i;
    (* Path: [.#b60] *)
    let el = #{ el with b60 = next_el.#b60 } in
    set_idx_mut a ((.(i).#b60) : (t60 array, _) idx_mut) next_el.#b60;
    mark_test_run 288;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 288 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a60.#a1] *)
    let el = #{ el with a60 = #{ el.#a60 with a1 = next_el.#a60.#a1 } } in
    set_idx_mut a ((.(i).#a60.#a1) : (t60 array, _) idx_mut) next_el.#a60.#a1;
    mark_test_run 289;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 289 failed %d %d" size i;
    (* Path: [.#a60.#b1] *)
    let el = #{ el with a60 = #{ el.#a60 with b1 = next_el.#a60.#b1 } } in
    set_idx_mut a ((.(i).#a60.#b1) : (t60 array, _) idx_mut) next_el.#a60.#b1;
    mark_test_run 290;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 290 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t61 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun (#{ a61 = a611; b61 = b611 } : t61) (#{ a61 = a612; b61 = b612 } : t61) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a611 a612 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b611 b612) in
  let mk_value i = (#{ a61 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b61 = Int32_u.of_int (i + 2) } : t61) in
  (* Create an array of size [size] *)
  let a : t61 array = makearray_dynamic size (#{ a61 = (#{ a1 = 0; b1 = 1 } : t1); b61 = #2l } : t61) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 291;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 291 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 292;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 292 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a61] *)
    let el = #{ el with a61 = next_el.#a61 } in
    set_idx_mut a ((.(i).#a61) : (t61 array, _) idx_mut) next_el.#a61;
    mark_test_run 293;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 293 failed %d %d" size i;
    (* Path: [.#b61] *)
    let el = #{ el with b61 = next_el.#b61 } in
    set_idx_mut a ((.(i).#b61) : (t61 array, _) idx_mut) next_el.#b61;
    mark_test_run 294;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 294 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a61.#a1] *)
    let el = #{ el with a61 = #{ el.#a61 with a1 = next_el.#a61.#a1 } } in
    set_idx_mut a ((.(i).#a61.#a1) : (t61 array, _) idx_mut) next_el.#a61.#a1;
    mark_test_run 295;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 295 failed %d %d" size i;
    (* Path: [.#a61.#b1] *)
    let el = #{ el with a61 = #{ el.#a61 with b1 = next_el.#a61.#b1 } } in
    set_idx_mut a ((.(i).#a61.#b1) : (t61 array, _) idx_mut) next_el.#a61.#b1;
    mark_test_run 296;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 296 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t62 = #{ #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun (#{ a62 = a621; b62 = b621 } : t62) (#{ a62 = a622; b62 = b622 } : t62) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a621 a622 && (fun a b -> Float.equal (globalize a) (globalize b)) b621 b622) in
  let mk_value i = (#{ a62 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b62 = Float.of_int (i + 2) } : t62) in
  (* Create an array of size [size] *)
  let a : t62 array = makearray_dynamic size (#{ a62 = (#{ a1 = 0; b1 = 1 } : t1); b62 = 2. } : t62) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 297;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 297 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 298;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 298 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a62] *)
    let el = #{ el with a62 = next_el.#a62 } in
    set_idx_mut a ((.(i).#a62) : (t62 array, _) idx_mut) next_el.#a62;
    mark_test_run 299;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 299 failed %d %d" size i;
    (* Path: [.#b62] *)
    let el = #{ el with b62 = next_el.#b62 } in
    set_idx_mut a ((.(i).#b62) : (t62 array, _) idx_mut) next_el.#b62;
    mark_test_run 300;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 300 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a62.#a1] *)
    let el = #{ el with a62 = #{ el.#a62 with a1 = next_el.#a62.#a1 } } in
    set_idx_mut a ((.(i).#a62.#a1) : (t62 array, _) idx_mut) next_el.#a62.#a1;
    mark_test_run 301;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 301 failed %d %d" size i;
    (* Path: [.#a62.#b1] *)
    let el = #{ el with a62 = #{ el.#a62 with b1 = next_el.#a62.#b1 } } in
    set_idx_mut a ((.(i).#a62.#b1) : (t62 array, _) idx_mut) next_el.#a62.#b1;
    mark_test_run 302;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 302 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t63 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a63 = a631 } : t63) (#{ a63 = a632 } : t63) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a631 a632) in
  let mk_value i = (#{ a63 = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7) } : t63) in
  (* Create an array of size [size] *)
  let a : t63 array = makearray_dynamic size (#{ a63 = (#{ a7 = 0; b7 = #1l } : t7) } : t63) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 303;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 303 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 304;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 304 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a63] *)
    let el = #{ el with a63 = next_el.#a63 } in
    set_idx_mut a ((.(i).#a63) : (t63 array, _) idx_mut) next_el.#a63;
    mark_test_run 305;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 305 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a63.#a7] *)
    let el = #{ el with a63 = #{ el.#a63 with a7 = next_el.#a63.#a7 } } in
    set_idx_mut a ((.(i).#a63.#a7) : (t63 array, _) idx_mut) next_el.#a63.#a7;
    mark_test_run 306;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 306 failed %d %d" size i;
    (* Path: [.#a63.#b7] *)
    let el = #{ el with a63 = #{ el.#a63 with b7 = next_el.#a63.#b7 } } in
    set_idx_mut a ((.(i).#a63.#b7) : (t63 array, _) idx_mut) next_el.#a63.#b7;
    mark_test_run 307;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 307 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t64 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun (#{ a64 = a641; b64 = b641 } : t64) (#{ a64 = a642; b64 = b642 } : t64) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a641 a642 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b641 b642) in
  let mk_value i = (#{ a64 = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7); b64 = Int32_u.of_int (i + 2) } : t64) in
  (* Create an array of size [size] *)
  let a : t64 array = makearray_dynamic size (#{ a64 = (#{ a7 = 0; b7 = #1l } : t7); b64 = #2l } : t64) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 308;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 308 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 309;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 309 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a64] *)
    let el = #{ el with a64 = next_el.#a64 } in
    set_idx_mut a ((.(i).#a64) : (t64 array, _) idx_mut) next_el.#a64;
    mark_test_run 310;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 310 failed %d %d" size i;
    (* Path: [.#b64] *)
    let el = #{ el with b64 = next_el.#b64 } in
    set_idx_mut a ((.(i).#b64) : (t64 array, _) idx_mut) next_el.#b64;
    mark_test_run 311;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 311 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a64.#a7] *)
    let el = #{ el with a64 = #{ el.#a64 with a7 = next_el.#a64.#a7 } } in
    set_idx_mut a ((.(i).#a64.#a7) : (t64 array, _) idx_mut) next_el.#a64.#a7;
    mark_test_run 312;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 312 failed %d %d" size i;
    (* Path: [.#a64.#b7] *)
    let el = #{ el with a64 = #{ el.#a64 with b7 = next_el.#a64.#b7 } } in
    set_idx_mut a ((.(i).#a64.#b7) : (t64 array, _) idx_mut) next_el.#a64.#b7;
    mark_test_run 313;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 313 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t65 = #{ #{ int; float } }   *)
  (**********************************)
  let eq = (fun (#{ a65 = a651 } : t65) (#{ a65 = a652 } : t65) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a651 a652) in
  let mk_value i = (#{ a65 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10) } : t65) in
  (* Create an array of size [size] *)
  let a : t65 array = makearray_dynamic size (#{ a65 = (#{ a10 = 0; b10 = 1. } : t10) } : t65) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 314;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 314 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 315;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 315 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a65] *)
    let el = #{ el with a65 = next_el.#a65 } in
    set_idx_mut a ((.(i).#a65) : (t65 array, _) idx_mut) next_el.#a65;
    mark_test_run 316;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 316 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a65.#a10] *)
    let el = #{ el with a65 = #{ el.#a65 with a10 = next_el.#a65.#a10 } } in
    set_idx_mut a ((.(i).#a65.#a10) : (t65 array, _) idx_mut) next_el.#a65.#a10;
    mark_test_run 317;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 317 failed %d %d" size i;
    (* Path: [.#a65.#b10] *)
    let el = #{ el with a65 = #{ el.#a65 with b10 = next_el.#a65.#b10 } } in
    set_idx_mut a ((.(i).#a65.#b10) : (t65 array, _) idx_mut) next_el.#a65.#b10;
    mark_test_run 318;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 318 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t66 = #{ #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun (#{ a66 = a661; b66 = b661 } : t66) (#{ a66 = a662; b66 = b662 } : t66) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a661 a662 && (fun a b -> Int.equal a b) b661 b662) in
  let mk_value i = (#{ a66 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10); b66 = (i + 2) } : t66) in
  (* Create an array of size [size] *)
  let a : t66 array = makearray_dynamic size (#{ a66 = (#{ a10 = 0; b10 = 1. } : t10); b66 = 2 } : t66) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 319;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 319 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 320;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 320 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a66] *)
    let el = #{ el with a66 = next_el.#a66 } in
    set_idx_mut a ((.(i).#a66) : (t66 array, _) idx_mut) next_el.#a66;
    mark_test_run 321;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 321 failed %d %d" size i;
    (* Path: [.#b66] *)
    let el = #{ el with b66 = next_el.#b66 } in
    set_idx_mut a ((.(i).#b66) : (t66 array, _) idx_mut) next_el.#b66;
    mark_test_run 322;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 322 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a66.#a10] *)
    let el = #{ el with a66 = #{ el.#a66 with a10 = next_el.#a66.#a10 } } in
    set_idx_mut a ((.(i).#a66.#a10) : (t66 array, _) idx_mut) next_el.#a66.#a10;
    mark_test_run 323;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 323 failed %d %d" size i;
    (* Path: [.#a66.#b10] *)
    let el = #{ el with a66 = #{ el.#a66 with b10 = next_el.#a66.#b10 } } in
    set_idx_mut a ((.(i).#a66.#b10) : (t66 array, _) idx_mut) next_el.#a66.#b10;
    mark_test_run 324;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 324 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t67 = #{ #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a67 = a671; b67 = b671 } : t67) (#{ a67 = a672; b67 = b672 } : t67) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a671 a672 && (fun a b -> Float.equal (globalize a) (globalize b)) b671 b672) in
  let mk_value i = (#{ a67 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10); b67 = Float.of_int (i + 2) } : t67) in
  (* Create an array of size [size] *)
  let a : t67 array = makearray_dynamic size (#{ a67 = (#{ a10 = 0; b10 = 1. } : t10); b67 = 2. } : t67) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 325;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 325 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 326;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 326 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a67] *)
    let el = #{ el with a67 = next_el.#a67 } in
    set_idx_mut a ((.(i).#a67) : (t67 array, _) idx_mut) next_el.#a67;
    mark_test_run 327;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 327 failed %d %d" size i;
    (* Path: [.#b67] *)
    let el = #{ el with b67 = next_el.#b67 } in
    set_idx_mut a ((.(i).#b67) : (t67 array, _) idx_mut) next_el.#b67;
    mark_test_run 328;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 328 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a67.#a10] *)
    let el = #{ el with a67 = #{ el.#a67 with a10 = next_el.#a67.#a10 } } in
    set_idx_mut a ((.(i).#a67.#a10) : (t67 array, _) idx_mut) next_el.#a67.#a10;
    mark_test_run 329;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 329 failed %d %d" size i;
    (* Path: [.#a67.#b10] *)
    let el = #{ el with a67 = #{ el.#a67 with b10 = next_el.#a67.#b10 } } in
    set_idx_mut a ((.(i).#a67.#b10) : (t67 array, _) idx_mut) next_el.#a67.#b10;
    mark_test_run 330;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 330 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************)
  (*   t68 = #{ #{ int32# } }   *)
  (******************************)
  let eq = (fun (#{ a68 = a681 } : t68) (#{ a68 = a682 } : t68) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a681 a682) in
  let mk_value i = (#{ a68 = (#{ a17 = Int32_u.of_int (i + 0) } : t17) } : t68) in
  (* Create an array of size [size] *)
  let a : t68 array = makearray_dynamic size (#{ a68 = (#{ a17 = #0l } : t17) } : t68) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 331;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 331 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 332;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 332 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a68] *)
    let el = #{ el with a68 = next_el.#a68 } in
    set_idx_mut a ((.(i).#a68) : (t68 array, _) idx_mut) next_el.#a68;
    mark_test_run 333;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 333 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a68.#a17] *)
    let el = #{ el with a68 = #{ el.#a68 with a17 = next_el.#a68.#a17 } } in
    set_idx_mut a ((.(i).#a68.#a17) : (t68 array, _) idx_mut) next_el.#a68.#a17;
    mark_test_run 334;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 334 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t69 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun (#{ a69 = a691; b69 = b691 } : t69) (#{ a69 = a692; b69 = b692 } : t69) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a691 a692 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b691 b692) in
  let mk_value i = (#{ a69 = (#{ a17 = Int32_u.of_int (i + 0) } : t17); b69 = Int32_u.of_int (i + 1) } : t69) in
  (* Create an array of size [size] *)
  let a : t69 array = makearray_dynamic size (#{ a69 = (#{ a17 = #0l } : t17); b69 = #1l } : t69) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 335;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 335 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 336;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 336 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a69] *)
    let el = #{ el with a69 = next_el.#a69 } in
    set_idx_mut a ((.(i).#a69) : (t69 array, _) idx_mut) next_el.#a69;
    mark_test_run 337;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 337 failed %d %d" size i;
    (* Path: [.#b69] *)
    let el = #{ el with b69 = next_el.#b69 } in
    set_idx_mut a ((.(i).#b69) : (t69 array, _) idx_mut) next_el.#b69;
    mark_test_run 338;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 338 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a69.#a17] *)
    let el = #{ el with a69 = #{ el.#a69 with a17 = next_el.#a69.#a17 } } in
    set_idx_mut a ((.(i).#a69.#a17) : (t69 array, _) idx_mut) next_el.#a69.#a17;
    mark_test_run 339;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 339 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t70 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a70 = a701 } : t70) (#{ a70 = a702 } : t70) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a701 a702) in
  let mk_value i = (#{ a70 = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19) } : t70) in
  (* Create an array of size [size] *)
  let a : t70 array = makearray_dynamic size (#{ a70 = (#{ a19 = #0l; b19 = #1l } : t19) } : t70) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 340;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 340 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 341;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 341 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a70] *)
    let el = #{ el with a70 = next_el.#a70 } in
    set_idx_mut a ((.(i).#a70) : (t70 array, _) idx_mut) next_el.#a70;
    mark_test_run 342;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 342 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a70.#a19] *)
    let el = #{ el with a70 = #{ el.#a70 with a19 = next_el.#a70.#a19 } } in
    set_idx_mut a ((.(i).#a70.#a19) : (t70 array, _) idx_mut) next_el.#a70.#a19;
    mark_test_run 343;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 343 failed %d %d" size i;
    (* Path: [.#a70.#b19] *)
    let el = #{ el with a70 = #{ el.#a70 with b19 = next_el.#a70.#b19 } } in
    set_idx_mut a ((.(i).#a70.#b19) : (t70 array, _) idx_mut) next_el.#a70.#b19;
    mark_test_run 344;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 344 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t71 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun (#{ a71 = a711; b71 = b711 } : t71) (#{ a71 = a712; b71 = b712 } : t71) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a711 a712 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b711 b712) in
  let mk_value i = (#{ a71 = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19); b71 = Int32_u.of_int (i + 2) } : t71) in
  (* Create an array of size [size] *)
  let a : t71 array = makearray_dynamic size (#{ a71 = (#{ a19 = #0l; b19 = #1l } : t19); b71 = #2l } : t71) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 345;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 345 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 346;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 346 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a71] *)
    let el = #{ el with a71 = next_el.#a71 } in
    set_idx_mut a ((.(i).#a71) : (t71 array, _) idx_mut) next_el.#a71;
    mark_test_run 347;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 347 failed %d %d" size i;
    (* Path: [.#b71] *)
    let el = #{ el with b71 = next_el.#b71 } in
    set_idx_mut a ((.(i).#b71) : (t71 array, _) idx_mut) next_el.#b71;
    mark_test_run 348;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 348 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a71.#a19] *)
    let el = #{ el with a71 = #{ el.#a71 with a19 = next_el.#a71.#a19 } } in
    set_idx_mut a ((.(i).#a71.#a19) : (t71 array, _) idx_mut) next_el.#a71.#a19;
    mark_test_run 349;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 349 failed %d %d" size i;
    (* Path: [.#a71.#b19] *)
    let el = #{ el with a71 = #{ el.#a71 with b19 = next_el.#a71.#b19 } } in
    set_idx_mut a ((.(i).#a71.#b19) : (t71 array, _) idx_mut) next_el.#a71.#b19;
    mark_test_run 350;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 350 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t72 = #{ #{ float }; int }   *)
  (**********************************)
  let eq = (fun (#{ a72 = a721; b72 = b721 } : t72) (#{ a72 = a722; b72 = b722 } : t72) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a721 a722 && (fun a b -> Int.equal a b) b721 b722) in
  let mk_value i = (#{ a72 = (#{ a21 = Float.of_int (i + 0) } : t21); b72 = (i + 1) } : t72) in
  (* Create an array of size [size] *)
  let a : t72 array = makearray_dynamic size (#{ a72 = (#{ a21 = 0. } : t21); b72 = 1 } : t72) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 351;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 351 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 352;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 352 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a72] *)
    let el = #{ el with a72 = next_el.#a72 } in
    set_idx_mut a ((.(i).#a72) : (t72 array, _) idx_mut) next_el.#a72;
    mark_test_run 353;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 353 failed %d %d" size i;
    (* Path: [.#b72] *)
    let el = #{ el with b72 = next_el.#b72 } in
    set_idx_mut a ((.(i).#b72) : (t72 array, _) idx_mut) next_el.#b72;
    mark_test_run 354;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 354 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a72.#a21] *)
    let el = #{ el with a72 = #{ el.#a72 with a21 = next_el.#a72.#a21 } } in
    set_idx_mut a ((.(i).#a72.#a21) : (t72 array, _) idx_mut) next_el.#a72.#a21;
    mark_test_run 355;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 355 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t73 = #{ #{ float }; float }   *)
  (************************************)
  let eq = (fun (#{ a73 = a731; b73 = b731 } : t73) (#{ a73 = a732; b73 = b732 } : t73) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a731 a732 && (fun a b -> Float.equal (globalize a) (globalize b)) b731 b732) in
  let mk_value i = (#{ a73 = (#{ a21 = Float.of_int (i + 0) } : t21); b73 = Float.of_int (i + 1) } : t73) in
  (* Create an array of size [size] *)
  let a : t73 array = makearray_dynamic size (#{ a73 = (#{ a21 = 0. } : t21); b73 = 1. } : t73) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 356;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 356 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 357;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 357 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a73] *)
    let el = #{ el with a73 = next_el.#a73 } in
    set_idx_mut a ((.(i).#a73) : (t73 array, _) idx_mut) next_el.#a73;
    mark_test_run 358;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 358 failed %d %d" size i;
    (* Path: [.#b73] *)
    let el = #{ el with b73 = next_el.#b73 } in
    set_idx_mut a ((.(i).#b73) : (t73 array, _) idx_mut) next_el.#b73;
    mark_test_run 359;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 359 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a73.#a21] *)
    let el = #{ el with a73 = #{ el.#a73 with a21 = next_el.#a73.#a21 } } in
    set_idx_mut a ((.(i).#a73.#a21) : (t73 array, _) idx_mut) next_el.#a73.#a21;
    mark_test_run 360;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 360 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t74 = #{ #{ float; int } }   *)
  (**********************************)
  let eq = (fun (#{ a74 = a741 } : t74) (#{ a74 = a742 } : t74) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a741 a742) in
  let mk_value i = (#{ a74 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23) } : t74) in
  (* Create an array of size [size] *)
  let a : t74 array = makearray_dynamic size (#{ a74 = (#{ a23 = 0.; b23 = 1 } : t23) } : t74) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 361;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 361 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 362;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 362 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a74] *)
    let el = #{ el with a74 = next_el.#a74 } in
    set_idx_mut a ((.(i).#a74) : (t74 array, _) idx_mut) next_el.#a74;
    mark_test_run 363;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 363 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a74.#a23] *)
    let el = #{ el with a74 = #{ el.#a74 with a23 = next_el.#a74.#a23 } } in
    set_idx_mut a ((.(i).#a74.#a23) : (t74 array, _) idx_mut) next_el.#a74.#a23;
    mark_test_run 364;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 364 failed %d %d" size i;
    (* Path: [.#a74.#b23] *)
    let el = #{ el with a74 = #{ el.#a74 with b23 = next_el.#a74.#b23 } } in
    set_idx_mut a ((.(i).#a74.#b23) : (t74 array, _) idx_mut) next_el.#a74.#b23;
    mark_test_run 365;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 365 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t75 = #{ #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun (#{ a75 = a751; b75 = b751 } : t75) (#{ a75 = a752; b75 = b752 } : t75) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a751 a752 && (fun a b -> Int.equal a b) b751 b752) in
  let mk_value i = (#{ a75 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23); b75 = (i + 2) } : t75) in
  (* Create an array of size [size] *)
  let a : t75 array = makearray_dynamic size (#{ a75 = (#{ a23 = 0.; b23 = 1 } : t23); b75 = 2 } : t75) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 366;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 366 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 367;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 367 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a75] *)
    let el = #{ el with a75 = next_el.#a75 } in
    set_idx_mut a ((.(i).#a75) : (t75 array, _) idx_mut) next_el.#a75;
    mark_test_run 368;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 368 failed %d %d" size i;
    (* Path: [.#b75] *)
    let el = #{ el with b75 = next_el.#b75 } in
    set_idx_mut a ((.(i).#b75) : (t75 array, _) idx_mut) next_el.#b75;
    mark_test_run 369;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 369 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a75.#a23] *)
    let el = #{ el with a75 = #{ el.#a75 with a23 = next_el.#a75.#a23 } } in
    set_idx_mut a ((.(i).#a75.#a23) : (t75 array, _) idx_mut) next_el.#a75.#a23;
    mark_test_run 370;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 370 failed %d %d" size i;
    (* Path: [.#a75.#b23] *)
    let el = #{ el with a75 = #{ el.#a75 with b23 = next_el.#a75.#b23 } } in
    set_idx_mut a ((.(i).#a75.#b23) : (t75 array, _) idx_mut) next_el.#a75.#b23;
    mark_test_run 371;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 371 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t76 = #{ #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a76 = a761; b76 = b761 } : t76) (#{ a76 = a762; b76 = b762 } : t76) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a761 a762 && (fun a b -> Float.equal (globalize a) (globalize b)) b761 b762) in
  let mk_value i = (#{ a76 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23); b76 = Float.of_int (i + 2) } : t76) in
  (* Create an array of size [size] *)
  let a : t76 array = makearray_dynamic size (#{ a76 = (#{ a23 = 0.; b23 = 1 } : t23); b76 = 2. } : t76) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 372;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 372 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 373;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 373 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a76] *)
    let el = #{ el with a76 = next_el.#a76 } in
    set_idx_mut a ((.(i).#a76) : (t76 array, _) idx_mut) next_el.#a76;
    mark_test_run 374;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 374 failed %d %d" size i;
    (* Path: [.#b76] *)
    let el = #{ el with b76 = next_el.#b76 } in
    set_idx_mut a ((.(i).#b76) : (t76 array, _) idx_mut) next_el.#b76;
    mark_test_run 375;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 375 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a76.#a23] *)
    let el = #{ el with a76 = #{ el.#a76 with a23 = next_el.#a76.#a23 } } in
    set_idx_mut a ((.(i).#a76.#a23) : (t76 array, _) idx_mut) next_el.#a76.#a23;
    mark_test_run 376;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 376 failed %d %d" size i;
    (* Path: [.#a76.#b23] *)
    let el = #{ el with a76 = #{ el.#a76 with b23 = next_el.#a76.#b23 } } in
    set_idx_mut a ((.(i).#a76.#b23) : (t76 array, _) idx_mut) next_el.#a76.#b23;
    mark_test_run 377;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 377 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t77 = #{ #{ float; float } }   *)
  (************************************)
  let eq = (fun (#{ a77 = a771 } : t77) (#{ a77 = a772 } : t77) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a771 a772) in
  let mk_value i = (#{ a77 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25) } : t77) in
  (* Create an array of size [size] *)
  let a : t77 array = makearray_dynamic size (#{ a77 = (#{ a25 = 0.; b25 = 1. } : t25) } : t77) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 378;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 378 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 379;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 379 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a77] *)
    let el = #{ el with a77 = next_el.#a77 } in
    set_idx_mut a ((.(i).#a77) : (t77 array, _) idx_mut) next_el.#a77;
    mark_test_run 380;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 380 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a77.#a25] *)
    let el = #{ el with a77 = #{ el.#a77 with a25 = next_el.#a77.#a25 } } in
    set_idx_mut a ((.(i).#a77.#a25) : (t77 array, _) idx_mut) next_el.#a77.#a25;
    mark_test_run 381;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 381 failed %d %d" size i;
    (* Path: [.#a77.#b25] *)
    let el = #{ el with a77 = #{ el.#a77 with b25 = next_el.#a77.#b25 } } in
    set_idx_mut a ((.(i).#a77.#b25) : (t77 array, _) idx_mut) next_el.#a77.#b25;
    mark_test_run 382;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 382 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t78 = #{ #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun (#{ a78 = a781; b78 = b781 } : t78) (#{ a78 = a782; b78 = b782 } : t78) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a781 a782 && (fun a b -> Int.equal a b) b781 b782) in
  let mk_value i = (#{ a78 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25); b78 = (i + 2) } : t78) in
  (* Create an array of size [size] *)
  let a : t78 array = makearray_dynamic size (#{ a78 = (#{ a25 = 0.; b25 = 1. } : t25); b78 = 2 } : t78) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 383;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 383 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 384;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 384 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a78] *)
    let el = #{ el with a78 = next_el.#a78 } in
    set_idx_mut a ((.(i).#a78) : (t78 array, _) idx_mut) next_el.#a78;
    mark_test_run 385;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 385 failed %d %d" size i;
    (* Path: [.#b78] *)
    let el = #{ el with b78 = next_el.#b78 } in
    set_idx_mut a ((.(i).#b78) : (t78 array, _) idx_mut) next_el.#b78;
    mark_test_run 386;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 386 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a78.#a25] *)
    let el = #{ el with a78 = #{ el.#a78 with a25 = next_el.#a78.#a25 } } in
    set_idx_mut a ((.(i).#a78.#a25) : (t78 array, _) idx_mut) next_el.#a78.#a25;
    mark_test_run 387;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 387 failed %d %d" size i;
    (* Path: [.#a78.#b25] *)
    let el = #{ el with a78 = #{ el.#a78 with b25 = next_el.#a78.#b25 } } in
    set_idx_mut a ((.(i).#a78.#b25) : (t78 array, _) idx_mut) next_el.#a78.#b25;
    mark_test_run 388;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 388 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t79 = #{ #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun (#{ a79 = a791; b79 = b791 } : t79) (#{ a79 = a792; b79 = b792 } : t79) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a791 a792 && (fun a b -> Float.equal (globalize a) (globalize b)) b791 b792) in
  let mk_value i = (#{ a79 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25); b79 = Float.of_int (i + 2) } : t79) in
  (* Create an array of size [size] *)
  let a : t79 array = makearray_dynamic size (#{ a79 = (#{ a25 = 0.; b25 = 1. } : t25); b79 = 2. } : t79) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 389;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 389 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 390;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 390 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* Path: [.#a79] *)
    let el = #{ el with a79 = next_el.#a79 } in
    set_idx_mut a ((.(i).#a79) : (t79 array, _) idx_mut) next_el.#a79;
    mark_test_run 391;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 391 failed %d %d" size i;
    (* Path: [.#b79] *)
    let el = #{ el with b79 = next_el.#b79 } in
    set_idx_mut a ((.(i).#b79) : (t79 array, _) idx_mut) next_el.#b79;
    mark_test_run 392;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 392 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* Path: [.#a79.#a25] *)
    let el = #{ el with a79 = #{ el.#a79 with a25 = next_el.#a79.#a25 } } in
    set_idx_mut a ((.(i).#a79.#a25) : (t79 array, _) idx_mut) next_el.#a79.#a25;
    mark_test_run 393;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 393 failed %d %d" size i;
    (* Path: [.#a79.#b25] *)
    let el = #{ el with a79 = #{ el.#a79 with b25 = next_el.#a79.#b25 } } in
    set_idx_mut a ((.(i).#a79.#b25) : (t79 array, _) idx_mut) next_el.#a79.#b25;
    mark_test_run 394;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 394 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()
;;

let () =
  iter sizes ~f:test;
  ()
;;

for i = 1 to 394 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
