(* TEST
 include stdlib_stable;
 include stdlib_beta;
 include stdlib_upstream_compatible;
 flags = "-extension layouts_alpha";
 bytecode;
*)
(** This is code generated by [test_generation.ml]. *)

[@@@warning "-23"]
external globalize : local_ 'a -> 'a = "%obj_dup";;
let int64x2_u_equal (_ : int64x2#) (_ : int64x2#) = failwith "should not be called from bytecode"

open Stdlib_upstream_compatible
open Stdlib_stable
open Stdlib_beta

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

module Idx_repr : sig
  type t
  val of_idx_imm : 'a ('b : any). ('a, 'b) idx_imm -> t
  val of_idx_mut : 'a ('b : any). ('a, 'b) idx_mut -> t
  val equal : t -> t -> bool
  val debug_string : t -> string
end = struct
  (* See [jane/doc/extensions/_02-unboxed-types/block-indices.md] *)
  type t =
    | Bytecode of { path : int list }
    | Native of { offset : int; gap : int }

  external magic_box_bits64 : ('a : bits64) 'b . 'a -> 'b =
    "%box_int64"
  external lessthan_if_bytecode : int -> int -> bool =
    "caml_lessthan" "caml_greaterthan"

  let of_idx idx =
    let is_bytecode = lessthan_if_bytecode 0 1 in
    if is_bytecode then
      let r = Obj.repr (magic_box_bits64 idx) in
      let nth_idx n : int = Obj.magic (Obj.field r n) in
      let path = List.init (Obj.size r) nth_idx in
      Bytecode { path }
    else
      let i : int64 = magic_box_bits64 idx in
      let offset =
        Int64.(logand (sub (shift_left one 48) one)) i
        |> Int64.to_int
      in
      let gap =
        Int64.shift_right i 48
        |> Int64.to_int
      in
      Native { offset; gap }

  let of_idx_imm = of_idx
  let of_idx_mut = of_idx

  let equal t1 t2 =
    match t1, t2 with
    | Bytecode { path = path1 }, Bytecode { path = path2 } ->
      List.equal Int.equal path1 path2
    | Native { gap = gap1; offset = offset1 },
      Native { gap = gap2; offset = offset2 } ->
      Int.equal gap1 gap2 && Int.equal offset1 offset2
    | Bytecode _, Native _ | Native _, Bytecode _ -> assert false

  let debug_string = function
    | Bytecode { path } ->
      Printf.sprintf "{ %s }"
        (String.concat "; " (List.map Int.to_string path))
    | Native { offset; gap } ->
      Printf.sprintf "offset %d; gap %d" offset gap
end

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]

type packed = P : 'a -> packed
let ref_to_force_heap_allocation : packed ref = ref (P 0)

type t0 = #{ a0 : int } (* #{ int } *)
type t1 = #{ a1 : int; b1 : int } (* #{ int; int } *)
type t2 = #{ a2 : int; b2 : int; c2 : int } (* #{ int; int; int } *)
type t3 = #{ a3 : int; b3 : int; c3 : int32# } (* #{ int; int; int32# } *)
type t4 = #{ a4 : int; b4 : int; c4 : float } (* #{ int; int; float } *)
type t5 = #{ a5 : int; b5 : int64 } (* #{ int; int64 } *)
type t6 = #{ a6 : int; b6 : int64# } (* #{ int; int64# } *)
type t7 = #{ a7 : int; b7 : int32# } (* #{ int; int32# } *)
type t8 = #{ a8 : int; b8 : int32#; c8 : int32# } (* #{ int; int32#; int32# } *)
type t9 = #{ a9 : int; b9 : nativeint# } (* #{ int; nativeint# } *)
type t10 = #{ a10 : int; b10 : float } (* #{ int; float } *)
type t11 = #{ a11 : int; b11 : float; c11 : int } (* #{ int; float; int } *)
type t12 = #{ a12 : int; b12 : float; c12 : float } (* #{ int; float; float } *)
type t13 = #{ a13 : int; b13 : t0 } (* #{ int; #{ int } } *)
type t14 = #{ a14 : int; b14 : t1 } (* #{ int; #{ int; int } } *)
type t15 = #{ a15 : int; b15 : t7 } (* #{ int; #{ int; int32# } } *)
type t16 = #{ a16 : int; b16 : t10 } (* #{ int; #{ int; float } } *)
type t17 = #{ a17 : int; b17 : t13 } (* #{ int; #{ int; #{ int } } } *)
type t18 = #{ a18 : int32# } (* #{ int32# } *)
type t19 = #{ a19 : int; b19 : t18 } (* #{ int; #{ int32# } } *)
type t20 = #{ a20 : int; b20 : t19 } (* #{ int; #{ int; #{ int32# } } } *)
type t21 = #{ a21 : float } (* #{ float } *)
type t22 = #{ a22 : int; b22 : t21 } (* #{ int; #{ float } } *)
type t23 = #{ a23 : int; b23 : t22 } (* #{ int; #{ int; #{ float } } } *)
type t24 = #{ a24 : int32#; b24 : int32# } (* #{ int32#; int32# } *)
type t25 = #{ a25 : int; b25 : t24 } (* #{ int; #{ int32#; int32# } } *)
type t26 = #{ a26 : int32#; b26 : t18 } (* #{ int32#; #{ int32# } } *)
type t27 = #{ a27 : int; b27 : t26 } (* #{ int; #{ int32#; #{ int32# } } } *)
type t28 = #{ a28 : float; b28 : int } (* #{ float; int } *)
type t29 = #{ a29 : int; b29 : t28 } (* #{ int; #{ float; int } } *)
type t30 = #{ a30 : float; b30 : float } (* #{ float; float } *)
type t31 = #{ a31 : int; b31 : t30 } (* #{ int; #{ float; float } } *)
type t32 = #{ a32 : float; b32 : t0 } (* #{ float; #{ int } } *)
type t33 = #{ a33 : int; b33 : t32 } (* #{ int; #{ float; #{ int } } } *)
type t34 = #{ a34 : float; b34 : t21 } (* #{ float; #{ float } } *)
type t35 = #{ a35 : int; b35 : t34 } (* #{ int; #{ float; #{ float } } } *)
type t36 = #{ a36 : t1 } (* #{ #{ int; int } } *)
type t37 = #{ a37 : int; b37 : t36 } (* #{ int; #{ #{ int; int } } } *)
type t38 = #{ a38 : t7 } (* #{ #{ int; int32# } } *)
type t39 = #{ a39 : int; b39 : t38 } (* #{ int; #{ #{ int; int32# } } } *)
type t40 = #{ a40 : t10 } (* #{ #{ int; float } } *)
type t41 = #{ a41 : int; b41 : t40 } (* #{ int; #{ #{ int; float } } } *)
type t42 = #{ a42 : t24 } (* #{ #{ int32#; int32# } } *)
type t43 = #{ a43 : int; b43 : t42 } (* #{ int; #{ #{ int32#; int32# } } } *)
type t44 = #{ a44 : t28 } (* #{ #{ float; int } } *)
type t45 = #{ a45 : int; b45 : t44 } (* #{ int; #{ #{ float; int } } } *)
type t46 = #{ a46 : t30 } (* #{ #{ float; float } } *)
type t47 = #{ a47 : int; b47 : t46 } (* #{ int; #{ #{ float; float } } } *)
type t48 = #{ a48 : int64 } (* #{ int64 } *)
type t49 = #{ a49 : int64; b49 : int } (* #{ int64; int } *)
type t50 = #{ a50 : int64; b50 : int64 } (* #{ int64; int64 } *)
type t51 = #{ a51 : int64; b51 : float } (* #{ int64; float } *)
type t52 = #{ a52 : int64# } (* #{ int64# } *)
type t53 = #{ a53 : int64#; b53 : int64# } (* #{ int64#; int64# } *)
type t54 = #{ a54 : int64#; b54 : int32# } (* #{ int64#; int32# } *)
type t55 = #{ a55 : int64#; b55 : nativeint# } (* #{ int64#; nativeint# } *)
type t56 = #{ a56 : int32#; b56 : int64# } (* #{ int32#; int64# } *)
type t57 = #{ a57 : int32#; b57 : int32#; c57 : int32# } (* #{ int32#; int32#; int32# } *)
type t58 = #{ a58 : int32#; b58 : nativeint# } (* #{ int32#; nativeint# } *)
type t59 = #{ a59 : int32#; b59 : t24 } (* #{ int32#; #{ int32#; int32# } } *)
type t60 = #{ a60 : int32#; b60 : t26 } (* #{ int32#; #{ int32#; #{ int32# } } } *)
type t61 = #{ a61 : int32#; b61 : t42 } (* #{ int32#; #{ #{ int32#; int32# } } } *)
type t62 = #{ a62 : nativeint# } (* #{ nativeint# } *)
type t63 = #{ a63 : nativeint#; b63 : int64# } (* #{ nativeint#; int64# } *)
type t64 = #{ a64 : nativeint#; b64 : int32# } (* #{ nativeint#; int32# } *)
type t65 = #{ a65 : nativeint#; b65 : nativeint# } (* #{ nativeint#; nativeint# } *)
type t66 = #{ a66 : float; b66 : int; c66 : int } (* #{ float; int; int } *)
type t67 = #{ a67 : float; b67 : int; c67 : float } (* #{ float; int; float } *)
type t68 = #{ a68 : float; b68 : int64 } (* #{ float; int64 } *)
type t69 = #{ a69 : float; b69 : float; c69 : int } (* #{ float; float; int } *)
type t70 = #{ a70 : float; b70 : float; c70 : float } (* #{ float; float; float } *)
type t71 = #{ a71 : float; b71 : t1 } (* #{ float; #{ int; int } } *)
type t72 = #{ a72 : float; b72 : t10 } (* #{ float; #{ int; float } } *)
type t73 = #{ a73 : float; b73 : t13 } (* #{ float; #{ int; #{ int } } } *)
type t74 = #{ a74 : float; b74 : t22 } (* #{ float; #{ int; #{ float } } } *)
type t75 = #{ a75 : float; b75 : t28 } (* #{ float; #{ float; int } } *)
type t76 = #{ a76 : float; b76 : t30 } (* #{ float; #{ float; float } } *)
type t77 = #{ a77 : float; b77 : t32 } (* #{ float; #{ float; #{ int } } } *)
type t78 = #{ a78 : float; b78 : t34 } (* #{ float; #{ float; #{ float } } } *)
type t79 = #{ a79 : float; b79 : t36 } (* #{ float; #{ #{ int; int } } } *)
type t80 = #{ a80 : float; b80 : t40 } (* #{ float; #{ #{ int; float } } } *)
type t81 = #{ a81 : float; b81 : t44 } (* #{ float; #{ #{ float; int } } } *)
type t82 = #{ a82 : float; b82 : t46 } (* #{ float; #{ #{ float; float } } } *)
type t83 = #{ a83 : float# } (* #{ float# } *)
type t84 = #{ a84 : float#; b84 : float# } (* #{ float#; float# } *)
type t85 = #{ a85 : float#; b85 : float#; c85 : float# } (* #{ float#; float#; float# } *)
type t86 = #{ a86 : float#; b86 : t83 } (* #{ float#; #{ float# } } *)
type t87 = #{ a87 : float#; b87 : t84 } (* #{ float#; #{ float#; float# } } *)
type t88 = #{ a88 : float#; b88 : t86 } (* #{ float#; #{ float#; #{ float# } } } *)
type t89 = #{ a89 : t84 } (* #{ #{ float#; float# } } *)
type t90 = #{ a90 : float#; b90 : t89 } (* #{ float#; #{ #{ float#; float# } } } *)
type t91 = #{ a91 : t0 } (* #{ #{ int } } *)
type t92 = #{ a92 : t0; b92 : int } (* #{ #{ int }; int } *)
type t93 = #{ a93 : t0; b93 : int32# } (* #{ #{ int }; int32# } *)
type t94 = #{ a94 : t0; b94 : float } (* #{ #{ int }; float } *)
type t95 = #{ a95 : t1; b95 : int } (* #{ #{ int; int }; int } *)
type t96 = #{ a96 : t1; b96 : int32# } (* #{ #{ int; int }; int32# } *)
type t97 = #{ a97 : t1; b97 : float } (* #{ #{ int; int }; float } *)
type t98 = #{ a98 : t7; b98 : int32# } (* #{ #{ int; int32# }; int32# } *)
type t99 = #{ a99 : t10; b99 : int } (* #{ #{ int; float }; int } *)
type t100 = #{ a100 : t10; b100 : float } (* #{ #{ int; float }; float } *)
type t101 = #{ a101 : t14 } (* #{ #{ int; #{ int; int } } } *)
type t102 = #{ a102 : t15 } (* #{ #{ int; #{ int; int32# } } } *)
type t103 = #{ a103 : t16 } (* #{ #{ int; #{ int; float } } } *)
type t104 = #{ a104 : t25 } (* #{ #{ int; #{ int32#; int32# } } } *)
type t105 = #{ a105 : t29 } (* #{ #{ int; #{ float; int } } } *)
type t106 = #{ a106 : t31 } (* #{ #{ int; #{ float; float } } } *)
type t107 = #{ a107 : t18 } (* #{ #{ int32# } } *)
type t108 = #{ a108 : t18; b108 : int32# } (* #{ #{ int32# }; int32# } *)
type t109 = #{ a109 : t24; b109 : int32# } (* #{ #{ int32#; int32# }; int32# } *)
type t110 = #{ a110 : t59 } (* #{ #{ int32#; #{ int32#; int32# } } } *)
type t111 = #{ a111 : t21; b111 : int } (* #{ #{ float }; int } *)
type t112 = #{ a112 : t21; b112 : float } (* #{ #{ float }; float } *)
type t113 = #{ a113 : t28; b113 : int } (* #{ #{ float; int }; int } *)
type t114 = #{ a114 : t28; b114 : float } (* #{ #{ float; int }; float } *)
type t115 = #{ a115 : t30; b115 : int } (* #{ #{ float; float }; int } *)
type t116 = #{ a116 : t30; b116 : float } (* #{ #{ float; float }; float } *)
type t117 = #{ a117 : t71 } (* #{ #{ float; #{ int; int } } } *)
type t118 = #{ a118 : t72 } (* #{ #{ float; #{ int; float } } } *)
type t119 = #{ a119 : t75 } (* #{ #{ float; #{ float; int } } } *)
type t120 = #{ a120 : t76 } (* #{ #{ float; #{ float; float } } } *)
type t121 = #{ a121 : t83 } (* #{ #{ float# } } *)
type t122 = #{ a122 : t83; b122 : float# } (* #{ #{ float# }; float# } *)
type t123 = #{ a123 : t84; b123 : float# } (* #{ #{ float#; float# }; float# } *)
type t124 = #{ a124 : t87 } (* #{ #{ float#; #{ float#; float# } } } *)
type t125 = #{ a125 : t95 } (* #{ #{ #{ int; int }; int } } *)
type t126 = #{ a126 : t96 } (* #{ #{ #{ int; int }; int32# } } *)
type t127 = #{ a127 : t97 } (* #{ #{ #{ int; int }; float } } *)
type t128 = #{ a128 : t98 } (* #{ #{ #{ int; int32# }; int32# } } *)
type t129 = #{ a129 : t99 } (* #{ #{ #{ int; float }; int } } *)
type t130 = #{ a130 : t100 } (* #{ #{ #{ int; float }; float } } *)
type t131 = #{ a131 : t109 } (* #{ #{ #{ int32#; int32# }; int32# } } *)
type t132 = #{ a132 : t113 } (* #{ #{ #{ float; int }; int } } *)
type t133 = #{ a133 : t114 } (* #{ #{ #{ float; int }; float } } *)
type t134 = #{ a134 : t115 } (* #{ #{ #{ float; float }; int } } *)
type t135 = #{ a135 : t116 } (* #{ #{ #{ float; float }; float } } *)
type t136 = #{ a136 : t123 } (* #{ #{ #{ float#; float# }; float# } } *)

let test size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 1;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 1 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 2;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 2 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 3;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 3 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 4;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 4 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 5;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 5 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 6;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 6 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 7;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 7 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 8;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 8 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 9;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 9 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 10;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 10 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : float# array = makearray_dynamic_local size #0. in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 11;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 11 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 12;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 12 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  let eq = (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) in
  let mk_value i = #{ a0 = (i + 0) } in
  (* Create an array of size [size] *)
  let a : t0 array = makearray_dynamic_local size #{ a0 = 0 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 13;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 13 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 14;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 14 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a0] *)
    let el = #{ el with a0 = next_el.#a0 } in
    Idx_mut.unsafe_set a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 15;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 15 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  let eq = (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let mk_value i = #{ a1 = (i + 0); b1 = (i + 1) } in
  (* Create an array of size [size] *)
  let a : t1 array = makearray_dynamic_local size #{ a1 = 0; b1 = 1 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 16;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 16 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 17;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 17 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a1] *)
    let el = #{ el with a1 = next_el.#a1 } in
    Idx_mut.unsafe_set a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 18;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 18 failed %d %d" size i;
    (* Path: [.#b1] *)
    let el = #{ el with b1 = next_el.#b1 } in
    Idx_mut.unsafe_set a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 19;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 19 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  let eq = (fun #{ a2 = a21; b2 = b21; c2 = c21 } #{ a2 = a22; b2 = b22; c2 = c22 } -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let mk_value i = #{ a2 = (i + 0); b2 = (i + 1); c2 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t2 array = makearray_dynamic_local size #{ a2 = 0; b2 = 1; c2 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 20;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 20 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 21;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 21 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a2] *)
    let el = #{ el with a2 = next_el.#a2 } in
    Idx_mut.unsafe_set a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 22;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 22 failed %d %d" size i;
    (* Path: [.#b2] *)
    let el = #{ el with b2 = next_el.#b2 } in
    Idx_mut.unsafe_set a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 23;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 23 failed %d %d" size i;
    (* Path: [.#c2] *)
    let el = #{ el with c2 = next_el.#c2 } in
    Idx_mut.unsafe_set a ((.(i).#c2) : (t2 array, _) idx_mut) next_el.#c2;
    mark_test_run 24;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 24 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  let eq = (fun #{ a3 = a31; b3 = b31; c3 = c31 } #{ a3 = a32; b3 = b32; c3 = c32 } -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let mk_value i = #{ a3 = (i + 0); b3 = (i + 1); c3 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t3 array = makearray_dynamic_local size #{ a3 = 0; b3 = 1; c3 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 25;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 25 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 26;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 26 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a3] *)
    let el = #{ el with a3 = next_el.#a3 } in
    Idx_mut.unsafe_set a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 27;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 27 failed %d %d" size i;
    (* Path: [.#b3] *)
    let el = #{ el with b3 = next_el.#b3 } in
    Idx_mut.unsafe_set a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 28;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 28 failed %d %d" size i;
    (* Path: [.#c3] *)
    let el = #{ el with c3 = next_el.#c3 } in
    Idx_mut.unsafe_set a ((.(i).#c3) : (t3 array, _) idx_mut) next_el.#c3;
    mark_test_run 29;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 29 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  let eq = (fun #{ a4 = a41; b4 = b41; c4 = c41 } #{ a4 = a42; b4 = b42; c4 = c42 } -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let mk_value i = #{ a4 = (i + 0); b4 = (i + 1); c4 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t4 array = makearray_dynamic_local size #{ a4 = 0; b4 = 1; c4 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 30;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 30 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 31;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 31 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a4] *)
    let el = #{ el with a4 = next_el.#a4 } in
    Idx_mut.unsafe_set a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 32;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 32 failed %d %d" size i;
    (* Path: [.#b4] *)
    let el = #{ el with b4 = next_el.#b4 } in
    Idx_mut.unsafe_set a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 33;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 33 failed %d %d" size i;
    (* Path: [.#c4] *)
    let el = #{ el with c4 = next_el.#c4 } in
    Idx_mut.unsafe_set a ((.(i).#c4) : (t4 array, _) idx_mut) next_el.#c4;
    mark_test_run 34;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 34 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t5 = #{ int; int64 }   *)
  (****************************)
  let eq = (fun #{ a5 = a51; b5 = b51 } #{ a5 = a52; b5 = b52 } -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int64.equal (globalize a) (globalize b)) b51 b52) in
  let mk_value i = #{ a5 = (i + 0); b5 = Int64.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t5 array = makearray_dynamic_local size #{ a5 = 0; b5 = 1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 35;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 35 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 36;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 36 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a5] *)
    let el = #{ el with a5 = next_el.#a5 } in
    Idx_mut.unsafe_set a ((.(i).#a5) : (t5 array, _) idx_mut) next_el.#a5;
    mark_test_run 37;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 37 failed %d %d" size i;
    (* Path: [.#b5] *)
    let el = #{ el with b5 = next_el.#b5 } in
    Idx_mut.unsafe_set a ((.(i).#b5) : (t5 array, _) idx_mut) next_el.#b5;
    mark_test_run 38;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 38 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t6 = #{ int; int64# }   *)
  (*****************************)
  let eq = (fun #{ a6 = a61; b6 = b61 } #{ a6 = a62; b6 = b62 } -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b61 b62) in
  let mk_value i = #{ a6 = (i + 0); b6 = Int64_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t6 array = makearray_dynamic_local size #{ a6 = 0; b6 = #1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 39;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 39 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 40;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 40 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a6] *)
    let el = #{ el with a6 = next_el.#a6 } in
    Idx_mut.unsafe_set a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 41;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 41 failed %d %d" size i;
    (* Path: [.#b6] *)
    let el = #{ el with b6 = next_el.#b6 } in
    Idx_mut.unsafe_set a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 42;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 42 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t7 = #{ int; int32# }   *)
  (*****************************)
  let eq = (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let mk_value i = #{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t7 array = makearray_dynamic_local size #{ a7 = 0; b7 = #1l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 43;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 43 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 44;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 44 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a7] *)
    let el = #{ el with a7 = next_el.#a7 } in
    Idx_mut.unsafe_set a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 45;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 45 failed %d %d" size i;
    (* Path: [.#b7] *)
    let el = #{ el with b7 = next_el.#b7 } in
    Idx_mut.unsafe_set a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 46;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 46 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t8 = #{ int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun #{ a8 = a81; b8 = b81; c8 = c81 } #{ a8 = a82; b8 = b82; c8 = c82 } -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b81 b82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c81 c82) in
  let mk_value i = #{ a8 = (i + 0); b8 = Int32_u.of_int (i + 1); c8 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t8 array = makearray_dynamic_local size #{ a8 = 0; b8 = #1l; c8 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 47;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 47 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 48;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 48 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a8] *)
    let el = #{ el with a8 = next_el.#a8 } in
    Idx_mut.unsafe_set a ((.(i).#a8) : (t8 array, _) idx_mut) next_el.#a8;
    mark_test_run 49;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 49 failed %d %d" size i;
    (* Path: [.#b8] *)
    let el = #{ el with b8 = next_el.#b8 } in
    Idx_mut.unsafe_set a ((.(i).#b8) : (t8 array, _) idx_mut) next_el.#b8;
    mark_test_run 50;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 50 failed %d %d" size i;
    (* Path: [.#c8] *)
    let el = #{ el with c8 = next_el.#c8 } in
    Idx_mut.unsafe_set a ((.(i).#c8) : (t8 array, _) idx_mut) next_el.#c8;
    mark_test_run 51;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 51 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t9 = #{ int; nativeint# }   *)
  (*********************************)
  let eq = (fun #{ a9 = a91; b9 = b91 } #{ a9 = a92; b9 = b92 } -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b91 b92) in
  let mk_value i = #{ a9 = (i + 0); b9 = Nativeint_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t9 array = makearray_dynamic_local size #{ a9 = 0; b9 = #1n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 52;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 52 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 53;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 53 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a9] *)
    let el = #{ el with a9 = next_el.#a9 } in
    Idx_mut.unsafe_set a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 54;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 54 failed %d %d" size i;
    (* Path: [.#b9] *)
    let el = #{ el with b9 = next_el.#b9 } in
    Idx_mut.unsafe_set a ((.(i).#b9) : (t9 array, _) idx_mut) next_el.#b9;
    mark_test_run 55;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 55 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t10 = #{ int; float }   *)
  (*****************************)
  let eq = (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let mk_value i = #{ a10 = (i + 0); b10 = Float.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t10 array = makearray_dynamic_local size #{ a10 = 0; b10 = 1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 56;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 56 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 57;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 57 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a10] *)
    let el = #{ el with a10 = next_el.#a10 } in
    Idx_mut.unsafe_set a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 58;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 58 failed %d %d" size i;
    (* Path: [.#b10] *)
    let el = #{ el with b10 = next_el.#b10 } in
    Idx_mut.unsafe_set a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 59;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 59 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t11 = #{ int; float; int }   *)
  (**********************************)
  let eq = (fun #{ a11 = a111; b11 = b111; c11 = c111 } #{ a11 = a112; b11 = b112; c11 = c112 } -> (fun a b -> Int.equal a b) a111 a112 && (fun a b -> Float.equal (globalize a) (globalize b)) b111 b112 && (fun a b -> Int.equal a b) c111 c112) in
  let mk_value i = #{ a11 = (i + 0); b11 = Float.of_int (i + 1); c11 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t11 array = makearray_dynamic_local size #{ a11 = 0; b11 = 1.; c11 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 60;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 60 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 61;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 61 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a11] *)
    let el = #{ el with a11 = next_el.#a11 } in
    Idx_mut.unsafe_set a ((.(i).#a11) : (t11 array, _) idx_mut) next_el.#a11;
    mark_test_run 62;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 62 failed %d %d" size i;
    (* Path: [.#b11] *)
    let el = #{ el with b11 = next_el.#b11 } in
    Idx_mut.unsafe_set a ((.(i).#b11) : (t11 array, _) idx_mut) next_el.#b11;
    mark_test_run 63;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 63 failed %d %d" size i;
    (* Path: [.#c11] *)
    let el = #{ el with c11 = next_el.#c11 } in
    Idx_mut.unsafe_set a ((.(i).#c11) : (t11 array, _) idx_mut) next_el.#c11;
    mark_test_run 64;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 64 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t12 = #{ int; float; float }   *)
  (************************************)
  let eq = (fun #{ a12 = a121; b12 = b121; c12 = c121 } #{ a12 = a122; b12 = b122; c12 = c122 } -> (fun a b -> Int.equal a b) a121 a122 && (fun a b -> Float.equal (globalize a) (globalize b)) b121 b122 && (fun a b -> Float.equal (globalize a) (globalize b)) c121 c122) in
  let mk_value i = #{ a12 = (i + 0); b12 = Float.of_int (i + 1); c12 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t12 array = makearray_dynamic_local size #{ a12 = 0; b12 = 1.; c12 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 65;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 65 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 66;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 66 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a12] *)
    let el = #{ el with a12 = next_el.#a12 } in
    Idx_mut.unsafe_set a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 67;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 67 failed %d %d" size i;
    (* Path: [.#b12] *)
    let el = #{ el with b12 = next_el.#b12 } in
    Idx_mut.unsafe_set a ((.(i).#b12) : (t12 array, _) idx_mut) next_el.#b12;
    mark_test_run 68;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 68 failed %d %d" size i;
    (* Path: [.#c12] *)
    let el = #{ el with c12 = next_el.#c12 } in
    Idx_mut.unsafe_set a ((.(i).#c12) : (t12 array, _) idx_mut) next_el.#c12;
    mark_test_run 69;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 69 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t13 = #{ int; #{ int } }   *)
  (********************************)
  let eq = (fun #{ a13 = a131; b13 = b131 } #{ a13 = a132; b13 = b132 } -> (fun a b -> Int.equal a b) a131 a132 && (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) b131 b132) in
  let mk_value i = #{ a13 = (i + 0); b13 = #{ a0 = (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t13 array = makearray_dynamic_local size #{ a13 = 0; b13 = #{ a0 = 1 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 70;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 70 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 71;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 71 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a13] *)
    let el = #{ el with a13 = next_el.#a13 } in
    Idx_mut.unsafe_set a ((.(i).#a13) : (t13 array, _) idx_mut) next_el.#a13;
    mark_test_run 72;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 72 failed %d %d" size i;
    (* Path: [.#b13] *)
    let el = #{ el with b13 = next_el.#b13 } in
    Idx_mut.unsafe_set a ((.(i).#b13) : (t13 array, _) idx_mut) next_el.#b13;
    mark_test_run 73;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 73 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b13.#a0] *)
    let el = #{ el with b13 = #{ el.#b13 with a0 = next_el.#b13.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#b13.#a0) : (t13 array, _) idx_mut) next_el.#b13.#a0;
    mark_test_run 74;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 74 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t14 = #{ int; #{ int; int } }   *)
  (*************************************)
  let eq = (fun #{ a14 = a141; b14 = b141 } #{ a14 = a142; b14 = b142 } -> (fun a b -> Int.equal a b) a141 a142 && (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b141 b142) in
  let mk_value i = #{ a14 = (i + 0); b14 = #{ a1 = (i + 1); b1 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t14 array = makearray_dynamic_local size #{ a14 = 0; b14 = #{ a1 = 1; b1 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 75;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 75 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 76;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 76 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a14] *)
    let el = #{ el with a14 = next_el.#a14 } in
    Idx_mut.unsafe_set a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 77;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 77 failed %d %d" size i;
    (* Path: [.#b14] *)
    let el = #{ el with b14 = next_el.#b14 } in
    Idx_mut.unsafe_set a ((.(i).#b14) : (t14 array, _) idx_mut) next_el.#b14;
    mark_test_run 78;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 78 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b14.#a1] *)
    let el = #{ el with b14 = #{ el.#b14 with a1 = next_el.#b14.#a1 } } in
    Idx_mut.unsafe_set a ((.(i).#b14.#a1) : (t14 array, _) idx_mut) next_el.#b14.#a1;
    mark_test_run 79;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 79 failed %d %d" size i;
    (* Path: [.#b14.#b1] *)
    let el = #{ el with b14 = #{ el.#b14 with b1 = next_el.#b14.#b1 } } in
    Idx_mut.unsafe_set a ((.(i).#b14.#b1) : (t14 array, _) idx_mut) next_el.#b14.#b1;
    mark_test_run 80;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 80 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t15 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  let eq = (fun #{ a15 = a151; b15 = b151 } #{ a15 = a152; b15 = b152 } -> (fun a b -> Int.equal a b) a151 a152 && (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b151 b152) in
  let mk_value i = #{ a15 = (i + 0); b15 = #{ a7 = (i + 1); b7 = Int32_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t15 array = makearray_dynamic_local size #{ a15 = 0; b15 = #{ a7 = 1; b7 = #2l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 81;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 81 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 82;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 82 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a15] *)
    let el = #{ el with a15 = next_el.#a15 } in
    Idx_mut.unsafe_set a ((.(i).#a15) : (t15 array, _) idx_mut) next_el.#a15;
    mark_test_run 83;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 83 failed %d %d" size i;
    (* Path: [.#b15] *)
    let el = #{ el with b15 = next_el.#b15 } in
    Idx_mut.unsafe_set a ((.(i).#b15) : (t15 array, _) idx_mut) next_el.#b15;
    mark_test_run 84;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 84 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b15.#a7] *)
    let el = #{ el with b15 = #{ el.#b15 with a7 = next_el.#b15.#a7 } } in
    Idx_mut.unsafe_set a ((.(i).#b15.#a7) : (t15 array, _) idx_mut) next_el.#b15.#a7;
    mark_test_run 85;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 85 failed %d %d" size i;
    (* Path: [.#b15.#b7] *)
    let el = #{ el with b15 = #{ el.#b15 with b7 = next_el.#b15.#b7 } } in
    Idx_mut.unsafe_set a ((.(i).#b15.#b7) : (t15 array, _) idx_mut) next_el.#b15.#b7;
    mark_test_run 86;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 86 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t16 = #{ int; #{ int; float } }   *)
  (***************************************)
  let eq = (fun #{ a16 = a161; b16 = b161 } #{ a16 = a162; b16 = b162 } -> (fun a b -> Int.equal a b) a161 a162 && (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b161 b162) in
  let mk_value i = #{ a16 = (i + 0); b16 = #{ a10 = (i + 1); b10 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t16 array = makearray_dynamic_local size #{ a16 = 0; b16 = #{ a10 = 1; b10 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 87;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 87 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 88;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 88 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a16] *)
    let el = #{ el with a16 = next_el.#a16 } in
    Idx_mut.unsafe_set a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 89;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 89 failed %d %d" size i;
    (* Path: [.#b16] *)
    let el = #{ el with b16 = next_el.#b16 } in
    Idx_mut.unsafe_set a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 90;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 90 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b16.#a10] *)
    let el = #{ el with b16 = #{ el.#b16 with a10 = next_el.#b16.#a10 } } in
    Idx_mut.unsafe_set a ((.(i).#b16.#a10) : (t16 array, _) idx_mut) next_el.#b16.#a10;
    mark_test_run 91;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 91 failed %d %d" size i;
    (* Path: [.#b16.#b10] *)
    let el = #{ el with b16 = #{ el.#b16 with b10 = next_el.#b16.#b10 } } in
    Idx_mut.unsafe_set a ((.(i).#b16.#b10) : (t16 array, _) idx_mut) next_el.#b16.#b10;
    mark_test_run 92;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 92 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************************)
  (*   t17 = #{ int; #{ int; #{ int } } }   *)
  (******************************************)
  let eq = (fun #{ a17 = a171; b17 = b171 } #{ a17 = a172; b17 = b172 } -> (fun a b -> Int.equal a b) a171 a172 && (fun #{ a13 = a131; b13 = b131 } #{ a13 = a132; b13 = b132 } -> (fun a b -> Int.equal a b) a131 a132 && (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) b131 b132) b171 b172) in
  let mk_value i = #{ a17 = (i + 0); b17 = #{ a13 = (i + 1); b13 = #{ a0 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t17 array = makearray_dynamic_local size #{ a17 = 0; b17 = #{ a13 = 1; b13 = #{ a0 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 93;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 93 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 94;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 94 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a17] *)
    let el = #{ el with a17 = next_el.#a17 } in
    Idx_mut.unsafe_set a ((.(i).#a17) : (t17 array, _) idx_mut) next_el.#a17;
    mark_test_run 95;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 95 failed %d %d" size i;
    (* Path: [.#b17] *)
    let el = #{ el with b17 = next_el.#b17 } in
    Idx_mut.unsafe_set a ((.(i).#b17) : (t17 array, _) idx_mut) next_el.#b17;
    mark_test_run 96;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 96 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b17.#a13] *)
    let el = #{ el with b17 = #{ el.#b17 with a13 = next_el.#b17.#a13 } } in
    Idx_mut.unsafe_set a ((.(i).#b17.#a13) : (t17 array, _) idx_mut) next_el.#b17.#a13;
    mark_test_run 97;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 97 failed %d %d" size i;
    (* Path: [.#b17.#b13] *)
    let el = #{ el with b17 = #{ el.#b17 with b13 = next_el.#b17.#b13 } } in
    Idx_mut.unsafe_set a ((.(i).#b17.#b13) : (t17 array, _) idx_mut) next_el.#b17.#b13;
    mark_test_run 98;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 98 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b17.#b13.#a0] *)
    let el = #{ el with b17 = #{ el.#b17 with b13 = #{ el.#b17.#b13 with a0 = next_el.#b17.#b13.#a0 } } } in
    Idx_mut.unsafe_set a ((.(i).#b17.#b13.#a0) : (t17 array, _) idx_mut) next_el.#b17.#b13.#a0;
    mark_test_run 99;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 99 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t20 = #{ int; #{ int; #{ int32# } } }   *)
  (*********************************************)
  let eq = (fun #{ a20 = a201; b20 = b201 } #{ a20 = a202; b20 = b202 } -> (fun a b -> Int.equal a b) a201 a202 && (fun #{ a19 = a191; b19 = b191 } #{ a19 = a192; b19 = b192 } -> (fun a b -> Int.equal a b) a191 a192 && (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) b191 b192) b201 b202) in
  let mk_value i = #{ a20 = (i + 0); b20 = #{ a19 = (i + 1); b19 = #{ a18 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t20 array = makearray_dynamic_local size #{ a20 = 0; b20 = #{ a19 = 1; b19 = #{ a18 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 100;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 100 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 101;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 101 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a20] *)
    let el = #{ el with a20 = next_el.#a20 } in
    Idx_mut.unsafe_set a ((.(i).#a20) : (t20 array, _) idx_mut) next_el.#a20;
    mark_test_run 102;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 102 failed %d %d" size i;
    (* Path: [.#b20] *)
    let el = #{ el with b20 = next_el.#b20 } in
    Idx_mut.unsafe_set a ((.(i).#b20) : (t20 array, _) idx_mut) next_el.#b20;
    mark_test_run 103;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 103 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b20.#a19] *)
    let el = #{ el with b20 = #{ el.#b20 with a19 = next_el.#b20.#a19 } } in
    Idx_mut.unsafe_set a ((.(i).#b20.#a19) : (t20 array, _) idx_mut) next_el.#b20.#a19;
    mark_test_run 104;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 104 failed %d %d" size i;
    (* Path: [.#b20.#b19] *)
    let el = #{ el with b20 = #{ el.#b20 with b19 = next_el.#b20.#b19 } } in
    Idx_mut.unsafe_set a ((.(i).#b20.#b19) : (t20 array, _) idx_mut) next_el.#b20.#b19;
    mark_test_run 105;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b20.#b19.#a18] *)
    let el = #{ el with b20 = #{ el.#b20 with b19 = #{ el.#b20.#b19 with a18 = next_el.#b20.#b19.#a18 } } } in
    Idx_mut.unsafe_set a ((.(i).#b20.#b19.#a18) : (t20 array, _) idx_mut) next_el.#b20.#b19.#a18;
    mark_test_run 106;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 106 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t23 = #{ int; #{ int; #{ float } } }   *)
  (********************************************)
  let eq = (fun #{ a23 = a231; b23 = b231 } #{ a23 = a232; b23 = b232 } -> (fun a b -> Int.equal a b) a231 a232 && (fun #{ a22 = a221; b22 = b221 } #{ a22 = a222; b22 = b222 } -> (fun a b -> Int.equal a b) a221 a222 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b221 b222) b231 b232) in
  let mk_value i = #{ a23 = (i + 0); b23 = #{ a22 = (i + 1); b22 = #{ a21 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t23 array = makearray_dynamic_local size #{ a23 = 0; b23 = #{ a22 = 1; b22 = #{ a21 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 108;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 108 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a23] *)
    let el = #{ el with a23 = next_el.#a23 } in
    Idx_mut.unsafe_set a ((.(i).#a23) : (t23 array, _) idx_mut) next_el.#a23;
    mark_test_run 109;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 109 failed %d %d" size i;
    (* Path: [.#b23] *)
    let el = #{ el with b23 = next_el.#b23 } in
    Idx_mut.unsafe_set a ((.(i).#b23) : (t23 array, _) idx_mut) next_el.#b23;
    mark_test_run 110;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 110 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b23.#a22] *)
    let el = #{ el with b23 = #{ el.#b23 with a22 = next_el.#b23.#a22 } } in
    Idx_mut.unsafe_set a ((.(i).#b23.#a22) : (t23 array, _) idx_mut) next_el.#b23.#a22;
    mark_test_run 111;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 111 failed %d %d" size i;
    (* Path: [.#b23.#b22] *)
    let el = #{ el with b23 = #{ el.#b23 with b22 = next_el.#b23.#b22 } } in
    Idx_mut.unsafe_set a ((.(i).#b23.#b22) : (t23 array, _) idx_mut) next_el.#b23.#b22;
    mark_test_run 112;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 112 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b23.#b22.#a21] *)
    let el = #{ el with b23 = #{ el.#b23 with b22 = #{ el.#b23.#b22 with a21 = next_el.#b23.#b22.#a21 } } } in
    Idx_mut.unsafe_set a ((.(i).#b23.#b22.#a21) : (t23 array, _) idx_mut) next_el.#b23.#b22.#a21;
    mark_test_run 113;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 113 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t19 = #{ int; #{ int32# } }   *)
  (***********************************)
  let eq = (fun #{ a19 = a191; b19 = b191 } #{ a19 = a192; b19 = b192 } -> (fun a b -> Int.equal a b) a191 a192 && (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) b191 b192) in
  let mk_value i = #{ a19 = (i + 0); b19 = #{ a18 = Int32_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t19 array = makearray_dynamic_local size #{ a19 = 0; b19 = #{ a18 = #1l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 114;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 114 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 115;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 115 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a19] *)
    let el = #{ el with a19 = next_el.#a19 } in
    Idx_mut.unsafe_set a ((.(i).#a19) : (t19 array, _) idx_mut) next_el.#a19;
    mark_test_run 116;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 116 failed %d %d" size i;
    (* Path: [.#b19] *)
    let el = #{ el with b19 = next_el.#b19 } in
    Idx_mut.unsafe_set a ((.(i).#b19) : (t19 array, _) idx_mut) next_el.#b19;
    mark_test_run 117;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 117 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b19.#a18] *)
    let el = #{ el with b19 = #{ el.#b19 with a18 = next_el.#b19.#a18 } } in
    Idx_mut.unsafe_set a ((.(i).#b19.#a18) : (t19 array, _) idx_mut) next_el.#b19.#a18;
    mark_test_run 118;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 118 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t25 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun #{ a25 = a251; b25 = b251 } #{ a25 = a252; b25 = b252 } -> (fun a b -> Int.equal a b) a251 a252 && (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) b251 b252) in
  let mk_value i = #{ a25 = (i + 0); b25 = #{ a24 = Int32_u.of_int (i + 1); b24 = Int32_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t25 array = makearray_dynamic_local size #{ a25 = 0; b25 = #{ a24 = #1l; b24 = #2l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 119;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 119 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a25] *)
    let el = #{ el with a25 = next_el.#a25 } in
    Idx_mut.unsafe_set a ((.(i).#a25) : (t25 array, _) idx_mut) next_el.#a25;
    mark_test_run 121;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 121 failed %d %d" size i;
    (* Path: [.#b25] *)
    let el = #{ el with b25 = next_el.#b25 } in
    Idx_mut.unsafe_set a ((.(i).#b25) : (t25 array, _) idx_mut) next_el.#b25;
    mark_test_run 122;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 122 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b25.#a24] *)
    let el = #{ el with b25 = #{ el.#b25 with a24 = next_el.#b25.#a24 } } in
    Idx_mut.unsafe_set a ((.(i).#b25.#a24) : (t25 array, _) idx_mut) next_el.#b25.#a24;
    mark_test_run 123;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 123 failed %d %d" size i;
    (* Path: [.#b25.#b24] *)
    let el = #{ el with b25 = #{ el.#b25 with b24 = next_el.#b25.#b24 } } in
    Idx_mut.unsafe_set a ((.(i).#b25.#b24) : (t25 array, _) idx_mut) next_el.#b25.#b24;
    mark_test_run 124;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 124 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************************)
  (*   t27 = #{ int; #{ int32#; #{ int32# } } }   *)
  (************************************************)
  let eq = (fun #{ a27 = a271; b27 = b271 } #{ a27 = a272; b27 = b272 } -> (fun a b -> Int.equal a b) a271 a272 && (fun #{ a26 = a261; b26 = b261 } #{ a26 = a262; b26 = b262 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a261 a262 && (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) b261 b262) b271 b272) in
  let mk_value i = #{ a27 = (i + 0); b27 = #{ a26 = Int32_u.of_int (i + 1); b26 = #{ a18 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t27 array = makearray_dynamic_local size #{ a27 = 0; b27 = #{ a26 = #1l; b26 = #{ a18 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 125;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 125 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 126;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 126 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a27] *)
    let el = #{ el with a27 = next_el.#a27 } in
    Idx_mut.unsafe_set a ((.(i).#a27) : (t27 array, _) idx_mut) next_el.#a27;
    mark_test_run 127;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 127 failed %d %d" size i;
    (* Path: [.#b27] *)
    let el = #{ el with b27 = next_el.#b27 } in
    Idx_mut.unsafe_set a ((.(i).#b27) : (t27 array, _) idx_mut) next_el.#b27;
    mark_test_run 128;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 128 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b27.#a26] *)
    let el = #{ el with b27 = #{ el.#b27 with a26 = next_el.#b27.#a26 } } in
    Idx_mut.unsafe_set a ((.(i).#b27.#a26) : (t27 array, _) idx_mut) next_el.#b27.#a26;
    mark_test_run 129;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 129 failed %d %d" size i;
    (* Path: [.#b27.#b26] *)
    let el = #{ el with b27 = #{ el.#b27 with b26 = next_el.#b27.#b26 } } in
    Idx_mut.unsafe_set a ((.(i).#b27.#b26) : (t27 array, _) idx_mut) next_el.#b27.#b26;
    mark_test_run 130;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 130 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b27.#b26.#a18] *)
    let el = #{ el with b27 = #{ el.#b27 with b26 = #{ el.#b27.#b26 with a18 = next_el.#b27.#b26.#a18 } } } in
    Idx_mut.unsafe_set a ((.(i).#b27.#b26.#a18) : (t27 array, _) idx_mut) next_el.#b27.#b26.#a18;
    mark_test_run 131;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 131 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t22 = #{ int; #{ float } }   *)
  (**********************************)
  let eq = (fun #{ a22 = a221; b22 = b221 } #{ a22 = a222; b22 = b222 } -> (fun a b -> Int.equal a b) a221 a222 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b221 b222) in
  let mk_value i = #{ a22 = (i + 0); b22 = #{ a21 = Float.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t22 array = makearray_dynamic_local size #{ a22 = 0; b22 = #{ a21 = 1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 132;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 132 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 133;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 133 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a22] *)
    let el = #{ el with a22 = next_el.#a22 } in
    Idx_mut.unsafe_set a ((.(i).#a22) : (t22 array, _) idx_mut) next_el.#a22;
    mark_test_run 134;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 134 failed %d %d" size i;
    (* Path: [.#b22] *)
    let el = #{ el with b22 = next_el.#b22 } in
    Idx_mut.unsafe_set a ((.(i).#b22) : (t22 array, _) idx_mut) next_el.#b22;
    mark_test_run 135;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 135 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b22.#a21] *)
    let el = #{ el with b22 = #{ el.#b22 with a21 = next_el.#b22.#a21 } } in
    Idx_mut.unsafe_set a ((.(i).#b22.#a21) : (t22 array, _) idx_mut) next_el.#b22.#a21;
    mark_test_run 136;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 136 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t29 = #{ int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) b291 b292) in
  let mk_value i = #{ a29 = (i + 0); b29 = #{ a28 = Float.of_int (i + 1); b28 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t29 array = makearray_dynamic_local size #{ a29 = 0; b29 = #{ a28 = 1.; b28 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 137;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 137 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 138;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 138 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a29] *)
    let el = #{ el with a29 = next_el.#a29 } in
    Idx_mut.unsafe_set a ((.(i).#a29) : (t29 array, _) idx_mut) next_el.#a29;
    mark_test_run 139;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 139 failed %d %d" size i;
    (* Path: [.#b29] *)
    let el = #{ el with b29 = next_el.#b29 } in
    Idx_mut.unsafe_set a ((.(i).#b29) : (t29 array, _) idx_mut) next_el.#b29;
    mark_test_run 140;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 140 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b29.#a28] *)
    let el = #{ el with b29 = #{ el.#b29 with a28 = next_el.#b29.#a28 } } in
    Idx_mut.unsafe_set a ((.(i).#b29.#a28) : (t29 array, _) idx_mut) next_el.#b29.#a28;
    mark_test_run 141;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 141 failed %d %d" size i;
    (* Path: [.#b29.#b28] *)
    let el = #{ el with b29 = #{ el.#b29 with b28 = next_el.#b29.#b28 } } in
    Idx_mut.unsafe_set a ((.(i).#b29.#b28) : (t29 array, _) idx_mut) next_el.#b29.#b28;
    mark_test_run 142;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 142 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t31 = #{ int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) b311 b312) in
  let mk_value i = #{ a31 = (i + 0); b31 = #{ a30 = Float.of_int (i + 1); b30 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t31 array = makearray_dynamic_local size #{ a31 = 0; b31 = #{ a30 = 1.; b30 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 143;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 143 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 144;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 144 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a31] *)
    let el = #{ el with a31 = next_el.#a31 } in
    Idx_mut.unsafe_set a ((.(i).#a31) : (t31 array, _) idx_mut) next_el.#a31;
    mark_test_run 145;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 145 failed %d %d" size i;
    (* Path: [.#b31] *)
    let el = #{ el with b31 = next_el.#b31 } in
    Idx_mut.unsafe_set a ((.(i).#b31) : (t31 array, _) idx_mut) next_el.#b31;
    mark_test_run 146;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 146 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b31.#a30] *)
    let el = #{ el with b31 = #{ el.#b31 with a30 = next_el.#b31.#a30 } } in
    Idx_mut.unsafe_set a ((.(i).#b31.#a30) : (t31 array, _) idx_mut) next_el.#b31.#a30;
    mark_test_run 147;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 147 failed %d %d" size i;
    (* Path: [.#b31.#b30] *)
    let el = #{ el with b31 = #{ el.#b31 with b30 = next_el.#b31.#b30 } } in
    Idx_mut.unsafe_set a ((.(i).#b31.#b30) : (t31 array, _) idx_mut) next_el.#b31.#b30;
    mark_test_run 148;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 148 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t33 = #{ int; #{ float; #{ int } } }   *)
  (********************************************)
  let eq = (fun #{ a33 = a331; b33 = b331 } #{ a33 = a332; b33 = b332 } -> (fun a b -> Int.equal a b) a331 a332 && (fun #{ a32 = a321; b32 = b321 } #{ a32 = a322; b32 = b322 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a321 a322 && (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) b321 b322) b331 b332) in
  let mk_value i = #{ a33 = (i + 0); b33 = #{ a32 = Float.of_int (i + 1); b32 = #{ a0 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t33 array = makearray_dynamic_local size #{ a33 = 0; b33 = #{ a32 = 1.; b32 = #{ a0 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 149;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 149 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 150;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 150 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a33] *)
    let el = #{ el with a33 = next_el.#a33 } in
    Idx_mut.unsafe_set a ((.(i).#a33) : (t33 array, _) idx_mut) next_el.#a33;
    mark_test_run 151;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 151 failed %d %d" size i;
    (* Path: [.#b33] *)
    let el = #{ el with b33 = next_el.#b33 } in
    Idx_mut.unsafe_set a ((.(i).#b33) : (t33 array, _) idx_mut) next_el.#b33;
    mark_test_run 152;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 152 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b33.#a32] *)
    let el = #{ el with b33 = #{ el.#b33 with a32 = next_el.#b33.#a32 } } in
    Idx_mut.unsafe_set a ((.(i).#b33.#a32) : (t33 array, _) idx_mut) next_el.#b33.#a32;
    mark_test_run 153;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 153 failed %d %d" size i;
    (* Path: [.#b33.#b32] *)
    let el = #{ el with b33 = #{ el.#b33 with b32 = next_el.#b33.#b32 } } in
    Idx_mut.unsafe_set a ((.(i).#b33.#b32) : (t33 array, _) idx_mut) next_el.#b33.#b32;
    mark_test_run 154;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 154 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b33.#b32.#a0] *)
    let el = #{ el with b33 = #{ el.#b33 with b32 = #{ el.#b33.#b32 with a0 = next_el.#b33.#b32.#a0 } } } in
    Idx_mut.unsafe_set a ((.(i).#b33.#b32.#a0) : (t33 array, _) idx_mut) next_el.#b33.#b32.#a0;
    mark_test_run 155;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 155 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t35 = #{ int; #{ float; #{ float } } }   *)
  (**********************************************)
  let eq = (fun #{ a35 = a351; b35 = b351 } #{ a35 = a352; b35 = b352 } -> (fun a b -> Int.equal a b) a351 a352 && (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b341 b342) b351 b352) in
  let mk_value i = #{ a35 = (i + 0); b35 = #{ a34 = Float.of_int (i + 1); b34 = #{ a21 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t35 array = makearray_dynamic_local size #{ a35 = 0; b35 = #{ a34 = 1.; b34 = #{ a21 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 156;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 156 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 157;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 157 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a35] *)
    let el = #{ el with a35 = next_el.#a35 } in
    Idx_mut.unsafe_set a ((.(i).#a35) : (t35 array, _) idx_mut) next_el.#a35;
    mark_test_run 158;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 158 failed %d %d" size i;
    (* Path: [.#b35] *)
    let el = #{ el with b35 = next_el.#b35 } in
    Idx_mut.unsafe_set a ((.(i).#b35) : (t35 array, _) idx_mut) next_el.#b35;
    mark_test_run 159;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 159 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b35.#a34] *)
    let el = #{ el with b35 = #{ el.#b35 with a34 = next_el.#b35.#a34 } } in
    Idx_mut.unsafe_set a ((.(i).#b35.#a34) : (t35 array, _) idx_mut) next_el.#b35.#a34;
    mark_test_run 160;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 160 failed %d %d" size i;
    (* Path: [.#b35.#b34] *)
    let el = #{ el with b35 = #{ el.#b35 with b34 = next_el.#b35.#b34 } } in
    Idx_mut.unsafe_set a ((.(i).#b35.#b34) : (t35 array, _) idx_mut) next_el.#b35.#b34;
    mark_test_run 161;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 161 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b35.#b34.#a21] *)
    let el = #{ el with b35 = #{ el.#b35 with b34 = #{ el.#b35.#b34 with a21 = next_el.#b35.#b34.#a21 } } } in
    Idx_mut.unsafe_set a ((.(i).#b35.#b34.#a21) : (t35 array, _) idx_mut) next_el.#b35.#b34.#a21;
    mark_test_run 162;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 162 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************************)
  (*   t37 = #{ int; #{ #{ int; int } } }   *)
  (******************************************)
  let eq = (fun #{ a37 = a371; b37 = b371 } #{ a37 = a372; b37 = b372 } -> (fun a b -> Int.equal a b) a371 a372 && (fun #{ a36 = a361 } #{ a36 = a362 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a361 a362) b371 b372) in
  let mk_value i = #{ a37 = (i + 0); b37 = #{ a36 = #{ a1 = (i + 1); b1 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t37 array = makearray_dynamic_local size #{ a37 = 0; b37 = #{ a36 = #{ a1 = 1; b1 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 163;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 163 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 164;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 164 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a37] *)
    let el = #{ el with a37 = next_el.#a37 } in
    Idx_mut.unsafe_set a ((.(i).#a37) : (t37 array, _) idx_mut) next_el.#a37;
    mark_test_run 165;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 165 failed %d %d" size i;
    (* Path: [.#b37] *)
    let el = #{ el with b37 = next_el.#b37 } in
    Idx_mut.unsafe_set a ((.(i).#b37) : (t37 array, _) idx_mut) next_el.#b37;
    mark_test_run 166;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 166 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b37.#a36] *)
    let el = #{ el with b37 = #{ el.#b37 with a36 = next_el.#b37.#a36 } } in
    Idx_mut.unsafe_set a ((.(i).#b37.#a36) : (t37 array, _) idx_mut) next_el.#b37.#a36;
    mark_test_run 167;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 167 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b37.#a36.#a1] *)
    let el = #{ el with b37 = #{ el.#b37 with a36 = #{ el.#b37.#a36 with a1 = next_el.#b37.#a36.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#b37.#a36.#a1) : (t37 array, _) idx_mut) next_el.#b37.#a36.#a1;
    mark_test_run 168;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 168 failed %d %d" size i;
    (* Path: [.#b37.#a36.#b1] *)
    let el = #{ el with b37 = #{ el.#b37 with a36 = #{ el.#b37.#a36 with b1 = next_el.#b37.#a36.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#b37.#a36.#b1) : (t37 array, _) idx_mut) next_el.#b37.#a36.#b1;
    mark_test_run 169;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 169 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t39 = #{ int; #{ #{ int; int32# } } }   *)
  (*********************************************)
  let eq = (fun #{ a39 = a391; b39 = b391 } #{ a39 = a392; b39 = b392 } -> (fun a b -> Int.equal a b) a391 a392 && (fun #{ a38 = a381 } #{ a38 = a382 } -> (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a381 a382) b391 b392) in
  let mk_value i = #{ a39 = (i + 0); b39 = #{ a38 = #{ a7 = (i + 1); b7 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t39 array = makearray_dynamic_local size #{ a39 = 0; b39 = #{ a38 = #{ a7 = 1; b7 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 170;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 170 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 171;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 171 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a39] *)
    let el = #{ el with a39 = next_el.#a39 } in
    Idx_mut.unsafe_set a ((.(i).#a39) : (t39 array, _) idx_mut) next_el.#a39;
    mark_test_run 172;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 172 failed %d %d" size i;
    (* Path: [.#b39] *)
    let el = #{ el with b39 = next_el.#b39 } in
    Idx_mut.unsafe_set a ((.(i).#b39) : (t39 array, _) idx_mut) next_el.#b39;
    mark_test_run 173;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 173 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b39.#a38] *)
    let el = #{ el with b39 = #{ el.#b39 with a38 = next_el.#b39.#a38 } } in
    Idx_mut.unsafe_set a ((.(i).#b39.#a38) : (t39 array, _) idx_mut) next_el.#b39.#a38;
    mark_test_run 174;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 174 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b39.#a38.#a7] *)
    let el = #{ el with b39 = #{ el.#b39 with a38 = #{ el.#b39.#a38 with a7 = next_el.#b39.#a38.#a7 } } } in
    Idx_mut.unsafe_set a ((.(i).#b39.#a38.#a7) : (t39 array, _) idx_mut) next_el.#b39.#a38.#a7;
    mark_test_run 175;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 175 failed %d %d" size i;
    (* Path: [.#b39.#a38.#b7] *)
    let el = #{ el with b39 = #{ el.#b39 with a38 = #{ el.#b39.#a38 with b7 = next_el.#b39.#a38.#b7 } } } in
    Idx_mut.unsafe_set a ((.(i).#b39.#a38.#b7) : (t39 array, _) idx_mut) next_el.#b39.#a38.#b7;
    mark_test_run 176;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 176 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t41 = #{ int; #{ #{ int; float } } }   *)
  (********************************************)
  let eq = (fun #{ a41 = a411; b41 = b411 } #{ a41 = a412; b41 = b412 } -> (fun a b -> Int.equal a b) a411 a412 && (fun #{ a40 = a401 } #{ a40 = a402 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a401 a402) b411 b412) in
  let mk_value i = #{ a41 = (i + 0); b41 = #{ a40 = #{ a10 = (i + 1); b10 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t41 array = makearray_dynamic_local size #{ a41 = 0; b41 = #{ a40 = #{ a10 = 1; b10 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 177;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 177 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 178;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 178 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a41] *)
    let el = #{ el with a41 = next_el.#a41 } in
    Idx_mut.unsafe_set a ((.(i).#a41) : (t41 array, _) idx_mut) next_el.#a41;
    mark_test_run 179;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 179 failed %d %d" size i;
    (* Path: [.#b41] *)
    let el = #{ el with b41 = next_el.#b41 } in
    Idx_mut.unsafe_set a ((.(i).#b41) : (t41 array, _) idx_mut) next_el.#b41;
    mark_test_run 180;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 180 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b41.#a40] *)
    let el = #{ el with b41 = #{ el.#b41 with a40 = next_el.#b41.#a40 } } in
    Idx_mut.unsafe_set a ((.(i).#b41.#a40) : (t41 array, _) idx_mut) next_el.#b41.#a40;
    mark_test_run 181;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 181 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b41.#a40.#a10] *)
    let el = #{ el with b41 = #{ el.#b41 with a40 = #{ el.#b41.#a40 with a10 = next_el.#b41.#a40.#a10 } } } in
    Idx_mut.unsafe_set a ((.(i).#b41.#a40.#a10) : (t41 array, _) idx_mut) next_el.#b41.#a40.#a10;
    mark_test_run 182;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 182 failed %d %d" size i;
    (* Path: [.#b41.#a40.#b10] *)
    let el = #{ el with b41 = #{ el.#b41 with a40 = #{ el.#b41.#a40 with b10 = next_el.#b41.#a40.#b10 } } } in
    Idx_mut.unsafe_set a ((.(i).#b41.#a40.#b10) : (t41 array, _) idx_mut) next_el.#b41.#a40.#b10;
    mark_test_run 183;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 183 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************************)
  (*   t43 = #{ int; #{ #{ int32#; int32# } } }   *)
  (************************************************)
  let eq = (fun #{ a43 = a431; b43 = b431 } #{ a43 = a432; b43 = b432 } -> (fun a b -> Int.equal a b) a431 a432 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) a421 a422) b431 b432) in
  let mk_value i = #{ a43 = (i + 0); b43 = #{ a42 = #{ a24 = Int32_u.of_int (i + 1); b24 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t43 array = makearray_dynamic_local size #{ a43 = 0; b43 = #{ a42 = #{ a24 = #1l; b24 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 184;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 184 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 185;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 185 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a43] *)
    let el = #{ el with a43 = next_el.#a43 } in
    Idx_mut.unsafe_set a ((.(i).#a43) : (t43 array, _) idx_mut) next_el.#a43;
    mark_test_run 186;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 186 failed %d %d" size i;
    (* Path: [.#b43] *)
    let el = #{ el with b43 = next_el.#b43 } in
    Idx_mut.unsafe_set a ((.(i).#b43) : (t43 array, _) idx_mut) next_el.#b43;
    mark_test_run 187;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 187 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b43.#a42] *)
    let el = #{ el with b43 = #{ el.#b43 with a42 = next_el.#b43.#a42 } } in
    Idx_mut.unsafe_set a ((.(i).#b43.#a42) : (t43 array, _) idx_mut) next_el.#b43.#a42;
    mark_test_run 188;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 188 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b43.#a42.#a24] *)
    let el = #{ el with b43 = #{ el.#b43 with a42 = #{ el.#b43.#a42 with a24 = next_el.#b43.#a42.#a24 } } } in
    Idx_mut.unsafe_set a ((.(i).#b43.#a42.#a24) : (t43 array, _) idx_mut) next_el.#b43.#a42.#a24;
    mark_test_run 189;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 189 failed %d %d" size i;
    (* Path: [.#b43.#a42.#b24] *)
    let el = #{ el with b43 = #{ el.#b43 with a42 = #{ el.#b43.#a42 with b24 = next_el.#b43.#a42.#b24 } } } in
    Idx_mut.unsafe_set a ((.(i).#b43.#a42.#b24) : (t43 array, _) idx_mut) next_el.#b43.#a42.#b24;
    mark_test_run 190;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 190 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t45 = #{ int; #{ #{ float; int } } }   *)
  (********************************************)
  let eq = (fun #{ a45 = a451; b45 = b451 } #{ a45 = a452; b45 = b452 } -> (fun a b -> Int.equal a b) a451 a452 && (fun #{ a44 = a441 } #{ a44 = a442 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a441 a442) b451 b452) in
  let mk_value i = #{ a45 = (i + 0); b45 = #{ a44 = #{ a28 = Float.of_int (i + 1); b28 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t45 array = makearray_dynamic_local size #{ a45 = 0; b45 = #{ a44 = #{ a28 = 1.; b28 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 191;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 191 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 192;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 192 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a45] *)
    let el = #{ el with a45 = next_el.#a45 } in
    Idx_mut.unsafe_set a ((.(i).#a45) : (t45 array, _) idx_mut) next_el.#a45;
    mark_test_run 193;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 193 failed %d %d" size i;
    (* Path: [.#b45] *)
    let el = #{ el with b45 = next_el.#b45 } in
    Idx_mut.unsafe_set a ((.(i).#b45) : (t45 array, _) idx_mut) next_el.#b45;
    mark_test_run 194;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 194 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b45.#a44] *)
    let el = #{ el with b45 = #{ el.#b45 with a44 = next_el.#b45.#a44 } } in
    Idx_mut.unsafe_set a ((.(i).#b45.#a44) : (t45 array, _) idx_mut) next_el.#b45.#a44;
    mark_test_run 195;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 195 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b45.#a44.#a28] *)
    let el = #{ el with b45 = #{ el.#b45 with a44 = #{ el.#b45.#a44 with a28 = next_el.#b45.#a44.#a28 } } } in
    Idx_mut.unsafe_set a ((.(i).#b45.#a44.#a28) : (t45 array, _) idx_mut) next_el.#b45.#a44.#a28;
    mark_test_run 196;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 196 failed %d %d" size i;
    (* Path: [.#b45.#a44.#b28] *)
    let el = #{ el with b45 = #{ el.#b45 with a44 = #{ el.#b45.#a44 with b28 = next_el.#b45.#a44.#b28 } } } in
    Idx_mut.unsafe_set a ((.(i).#b45.#a44.#b28) : (t45 array, _) idx_mut) next_el.#b45.#a44.#b28;
    mark_test_run 197;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 197 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t47 = #{ int; #{ #{ float; float } } }   *)
  (**********************************************)
  let eq = (fun #{ a47 = a471; b47 = b471 } #{ a47 = a472; b47 = b472 } -> (fun a b -> Int.equal a b) a471 a472 && (fun #{ a46 = a461 } #{ a46 = a462 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a461 a462) b471 b472) in
  let mk_value i = #{ a47 = (i + 0); b47 = #{ a46 = #{ a30 = Float.of_int (i + 1); b30 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t47 array = makearray_dynamic_local size #{ a47 = 0; b47 = #{ a46 = #{ a30 = 1.; b30 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 198;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 198 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 199;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 199 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a47] *)
    let el = #{ el with a47 = next_el.#a47 } in
    Idx_mut.unsafe_set a ((.(i).#a47) : (t47 array, _) idx_mut) next_el.#a47;
    mark_test_run 200;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 200 failed %d %d" size i;
    (* Path: [.#b47] *)
    let el = #{ el with b47 = next_el.#b47 } in
    Idx_mut.unsafe_set a ((.(i).#b47) : (t47 array, _) idx_mut) next_el.#b47;
    mark_test_run 201;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 201 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b47.#a46] *)
    let el = #{ el with b47 = #{ el.#b47 with a46 = next_el.#b47.#a46 } } in
    Idx_mut.unsafe_set a ((.(i).#b47.#a46) : (t47 array, _) idx_mut) next_el.#b47.#a46;
    mark_test_run 202;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 202 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b47.#a46.#a30] *)
    let el = #{ el with b47 = #{ el.#b47 with a46 = #{ el.#b47.#a46 with a30 = next_el.#b47.#a46.#a30 } } } in
    Idx_mut.unsafe_set a ((.(i).#b47.#a46.#a30) : (t47 array, _) idx_mut) next_el.#b47.#a46.#a30;
    mark_test_run 203;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 203 failed %d %d" size i;
    (* Path: [.#b47.#a46.#b30] *)
    let el = #{ el with b47 = #{ el.#b47 with a46 = #{ el.#b47.#a46 with b30 = next_el.#b47.#a46.#b30 } } } in
    Idx_mut.unsafe_set a ((.(i).#b47.#a46.#b30) : (t47 array, _) idx_mut) next_el.#b47.#a46.#b30;
    mark_test_run 204;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 204 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************)
  (*   t48 = #{ int64 }   *)
  (************************)
  let eq = (fun #{ a48 = a481 } #{ a48 = a482 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a481 a482) in
  let mk_value i = #{ a48 = Int64.of_int (i + 0) } in
  (* Create an array of size [size] *)
  let a : t48 array = makearray_dynamic_local size #{ a48 = 0L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 205;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 205 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 206;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 206 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a48] *)
    let el = #{ el with a48 = next_el.#a48 } in
    Idx_mut.unsafe_set a ((.(i).#a48) : (t48 array, _) idx_mut) next_el.#a48;
    mark_test_run 207;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 207 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t49 = #{ int64; int }   *)
  (*****************************)
  let eq = (fun #{ a49 = a491; b49 = b491 } #{ a49 = a492; b49 = b492 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a491 a492 && (fun a b -> Int.equal a b) b491 b492) in
  let mk_value i = #{ a49 = Int64.of_int (i + 0); b49 = (i + 1) } in
  (* Create an array of size [size] *)
  let a : t49 array = makearray_dynamic_local size #{ a49 = 0L; b49 = 1 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 208;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 208 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 209;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 209 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a49] *)
    let el = #{ el with a49 = next_el.#a49 } in
    Idx_mut.unsafe_set a ((.(i).#a49) : (t49 array, _) idx_mut) next_el.#a49;
    mark_test_run 210;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 210 failed %d %d" size i;
    (* Path: [.#b49] *)
    let el = #{ el with b49 = next_el.#b49 } in
    Idx_mut.unsafe_set a ((.(i).#b49) : (t49 array, _) idx_mut) next_el.#b49;
    mark_test_run 211;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 211 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t50 = #{ int64; int64 }   *)
  (*******************************)
  let eq = (fun #{ a50 = a501; b50 = b501 } #{ a50 = a502; b50 = b502 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a501 a502 && (fun a b -> Int64.equal (globalize a) (globalize b)) b501 b502) in
  let mk_value i = #{ a50 = Int64.of_int (i + 0); b50 = Int64.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t50 array = makearray_dynamic_local size #{ a50 = 0L; b50 = 1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 212;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 212 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 213;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 213 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a50] *)
    let el = #{ el with a50 = next_el.#a50 } in
    Idx_mut.unsafe_set a ((.(i).#a50) : (t50 array, _) idx_mut) next_el.#a50;
    mark_test_run 214;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 214 failed %d %d" size i;
    (* Path: [.#b50] *)
    let el = #{ el with b50 = next_el.#b50 } in
    Idx_mut.unsafe_set a ((.(i).#b50) : (t50 array, _) idx_mut) next_el.#b50;
    mark_test_run 215;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 215 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t51 = #{ int64; float }   *)
  (*******************************)
  let eq = (fun #{ a51 = a511; b51 = b511 } #{ a51 = a512; b51 = b512 } -> (fun a b -> Int64.equal (globalize a) (globalize b)) a511 a512 && (fun a b -> Float.equal (globalize a) (globalize b)) b511 b512) in
  let mk_value i = #{ a51 = Int64.of_int (i + 0); b51 = Float.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t51 array = makearray_dynamic_local size #{ a51 = 0L; b51 = 1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 216;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 216 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 217;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 217 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a51] *)
    let el = #{ el with a51 = next_el.#a51 } in
    Idx_mut.unsafe_set a ((.(i).#a51) : (t51 array, _) idx_mut) next_el.#a51;
    mark_test_run 218;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 218 failed %d %d" size i;
    (* Path: [.#b51] *)
    let el = #{ el with b51 = next_el.#b51 } in
    Idx_mut.unsafe_set a ((.(i).#b51) : (t51 array, _) idx_mut) next_el.#b51;
    mark_test_run 219;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 219 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t52 = #{ int64# }   *)
  (*************************)
  let eq = (fun #{ a52 = a521 } #{ a52 = a522 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a521 a522) in
  let mk_value i = #{ a52 = Int64_u.of_int (i + 0) } in
  (* Create an array of size [size] *)
  let a : t52 array = makearray_dynamic_local size #{ a52 = #0L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 220;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 220 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 221;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 221 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a52] *)
    let el = #{ el with a52 = next_el.#a52 } in
    Idx_mut.unsafe_set a ((.(i).#a52) : (t52 array, _) idx_mut) next_el.#a52;
    mark_test_run 222;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 222 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t53 = #{ int64#; int64# }   *)
  (*********************************)
  let eq = (fun #{ a53 = a531; b53 = b531 } #{ a53 = a532; b53 = b532 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a531 a532 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b531 b532) in
  let mk_value i = #{ a53 = Int64_u.of_int (i + 0); b53 = Int64_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t53 array = makearray_dynamic_local size #{ a53 = #0L; b53 = #1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 223;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 223 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 224;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 224 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a53] *)
    let el = #{ el with a53 = next_el.#a53 } in
    Idx_mut.unsafe_set a ((.(i).#a53) : (t53 array, _) idx_mut) next_el.#a53;
    mark_test_run 225;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 225 failed %d %d" size i;
    (* Path: [.#b53] *)
    let el = #{ el with b53 = next_el.#b53 } in
    Idx_mut.unsafe_set a ((.(i).#b53) : (t53 array, _) idx_mut) next_el.#b53;
    mark_test_run 226;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 226 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t54 = #{ int64#; int32# }   *)
  (*********************************)
  let eq = (fun #{ a54 = a541; b54 = b541 } #{ a54 = a542; b54 = b542 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a541 a542 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b541 b542) in
  let mk_value i = #{ a54 = Int64_u.of_int (i + 0); b54 = Int32_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t54 array = makearray_dynamic_local size #{ a54 = #0L; b54 = #1l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 227;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 227 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 228;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 228 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a54] *)
    let el = #{ el with a54 = next_el.#a54 } in
    Idx_mut.unsafe_set a ((.(i).#a54) : (t54 array, _) idx_mut) next_el.#a54;
    mark_test_run 229;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 229 failed %d %d" size i;
    (* Path: [.#b54] *)
    let el = #{ el with b54 = next_el.#b54 } in
    Idx_mut.unsafe_set a ((.(i).#b54) : (t54 array, _) idx_mut) next_el.#b54;
    mark_test_run 230;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 230 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t55 = #{ int64#; nativeint# }   *)
  (*************************************)
  let eq = (fun #{ a55 = a551; b55 = b551 } #{ a55 = a552; b55 = b552 } -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a551 a552 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b551 b552) in
  let mk_value i = #{ a55 = Int64_u.of_int (i + 0); b55 = Nativeint_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t55 array = makearray_dynamic_local size #{ a55 = #0L; b55 = #1n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 231;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 231 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 232;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 232 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a55] *)
    let el = #{ el with a55 = next_el.#a55 } in
    Idx_mut.unsafe_set a ((.(i).#a55) : (t55 array, _) idx_mut) next_el.#a55;
    mark_test_run 233;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 233 failed %d %d" size i;
    (* Path: [.#b55] *)
    let el = #{ el with b55 = next_el.#b55 } in
    Idx_mut.unsafe_set a ((.(i).#b55) : (t55 array, _) idx_mut) next_el.#b55;
    mark_test_run 234;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 234 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t18 = #{ int32# }   *)
  (*************************)
  let eq = (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) in
  let mk_value i = #{ a18 = Int32_u.of_int (i + 0) } in
  (* Create an array of size [size] *)
  let a : t18 array = makearray_dynamic_local size #{ a18 = #0l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 235;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 235 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 236;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 236 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a18] *)
    let el = #{ el with a18 = next_el.#a18 } in
    Idx_mut.unsafe_set a ((.(i).#a18) : (t18 array, _) idx_mut) next_el.#a18;
    mark_test_run 237;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 237 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t56 = #{ int32#; int64# }   *)
  (*********************************)
  let eq = (fun #{ a56 = a561; b56 = b561 } #{ a56 = a562; b56 = b562 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a561 a562 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b561 b562) in
  let mk_value i = #{ a56 = Int32_u.of_int (i + 0); b56 = Int64_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t56 array = makearray_dynamic_local size #{ a56 = #0l; b56 = #1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 238;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 238 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 239;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 239 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a56] *)
    let el = #{ el with a56 = next_el.#a56 } in
    Idx_mut.unsafe_set a ((.(i).#a56) : (t56 array, _) idx_mut) next_el.#a56;
    mark_test_run 240;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 240 failed %d %d" size i;
    (* Path: [.#b56] *)
    let el = #{ el with b56 = next_el.#b56 } in
    Idx_mut.unsafe_set a ((.(i).#b56) : (t56 array, _) idx_mut) next_el.#b56;
    mark_test_run 241;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 241 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t24 = #{ int32#; int32# }   *)
  (*********************************)
  let eq = (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) in
  let mk_value i = #{ a24 = Int32_u.of_int (i + 0); b24 = Int32_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t24 array = makearray_dynamic_local size #{ a24 = #0l; b24 = #1l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 242;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 242 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 243;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 243 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a24] *)
    let el = #{ el with a24 = next_el.#a24 } in
    Idx_mut.unsafe_set a ((.(i).#a24) : (t24 array, _) idx_mut) next_el.#a24;
    mark_test_run 244;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 244 failed %d %d" size i;
    (* Path: [.#b24] *)
    let el = #{ el with b24 = next_el.#b24 } in
    Idx_mut.unsafe_set a ((.(i).#b24) : (t24 array, _) idx_mut) next_el.#b24;
    mark_test_run 245;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 245 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t57 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun #{ a57 = a571; b57 = b571; c57 = c571 } #{ a57 = a572; b57 = b572; c57 = c572 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a571 a572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b571 b572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c571 c572) in
  let mk_value i = #{ a57 = Int32_u.of_int (i + 0); b57 = Int32_u.of_int (i + 1); c57 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t57 array = makearray_dynamic_local size #{ a57 = #0l; b57 = #1l; c57 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 246;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 246 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 247;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 247 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a57] *)
    let el = #{ el with a57 = next_el.#a57 } in
    Idx_mut.unsafe_set a ((.(i).#a57) : (t57 array, _) idx_mut) next_el.#a57;
    mark_test_run 248;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 248 failed %d %d" size i;
    (* Path: [.#b57] *)
    let el = #{ el with b57 = next_el.#b57 } in
    Idx_mut.unsafe_set a ((.(i).#b57) : (t57 array, _) idx_mut) next_el.#b57;
    mark_test_run 249;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 249 failed %d %d" size i;
    (* Path: [.#c57] *)
    let el = #{ el with c57 = next_el.#c57 } in
    Idx_mut.unsafe_set a ((.(i).#c57) : (t57 array, _) idx_mut) next_el.#c57;
    mark_test_run 250;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 250 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t58 = #{ int32#; nativeint# }   *)
  (*************************************)
  let eq = (fun #{ a58 = a581; b58 = b581 } #{ a58 = a582; b58 = b582 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a581 a582 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b581 b582) in
  let mk_value i = #{ a58 = Int32_u.of_int (i + 0); b58 = Nativeint_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t58 array = makearray_dynamic_local size #{ a58 = #0l; b58 = #1n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 251;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 251 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 252;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 252 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a58] *)
    let el = #{ el with a58 = next_el.#a58 } in
    Idx_mut.unsafe_set a ((.(i).#a58) : (t58 array, _) idx_mut) next_el.#a58;
    mark_test_run 253;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 253 failed %d %d" size i;
    (* Path: [.#b58] *)
    let el = #{ el with b58 = next_el.#b58 } in
    Idx_mut.unsafe_set a ((.(i).#b58) : (t58 array, _) idx_mut) next_el.#b58;
    mark_test_run 254;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 254 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t26 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun #{ a26 = a261; b26 = b261 } #{ a26 = a262; b26 = b262 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a261 a262 && (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) b261 b262) in
  let mk_value i = #{ a26 = Int32_u.of_int (i + 0); b26 = #{ a18 = Int32_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t26 array = makearray_dynamic_local size #{ a26 = #0l; b26 = #{ a18 = #1l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 255;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 255 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 256;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 256 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a26] *)
    let el = #{ el with a26 = next_el.#a26 } in
    Idx_mut.unsafe_set a ((.(i).#a26) : (t26 array, _) idx_mut) next_el.#a26;
    mark_test_run 257;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 257 failed %d %d" size i;
    (* Path: [.#b26] *)
    let el = #{ el with b26 = next_el.#b26 } in
    Idx_mut.unsafe_set a ((.(i).#b26) : (t26 array, _) idx_mut) next_el.#b26;
    mark_test_run 258;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 258 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b26.#a18] *)
    let el = #{ el with b26 = #{ el.#b26 with a18 = next_el.#b26.#a18 } } in
    Idx_mut.unsafe_set a ((.(i).#b26.#a18) : (t26 array, _) idx_mut) next_el.#b26.#a18;
    mark_test_run 259;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 259 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t59 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun #{ a59 = a591; b59 = b591 } #{ a59 = a592; b59 = b592 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a591 a592 && (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) b591 b592) in
  let mk_value i = #{ a59 = Int32_u.of_int (i + 0); b59 = #{ a24 = Int32_u.of_int (i + 1); b24 = Int32_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t59 array = makearray_dynamic_local size #{ a59 = #0l; b59 = #{ a24 = #1l; b24 = #2l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 260;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 260 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 261;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 261 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a59] *)
    let el = #{ el with a59 = next_el.#a59 } in
    Idx_mut.unsafe_set a ((.(i).#a59) : (t59 array, _) idx_mut) next_el.#a59;
    mark_test_run 262;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 262 failed %d %d" size i;
    (* Path: [.#b59] *)
    let el = #{ el with b59 = next_el.#b59 } in
    Idx_mut.unsafe_set a ((.(i).#b59) : (t59 array, _) idx_mut) next_el.#b59;
    mark_test_run 263;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 263 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b59.#a24] *)
    let el = #{ el with b59 = #{ el.#b59 with a24 = next_el.#b59.#a24 } } in
    Idx_mut.unsafe_set a ((.(i).#b59.#a24) : (t59 array, _) idx_mut) next_el.#b59.#a24;
    mark_test_run 264;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 264 failed %d %d" size i;
    (* Path: [.#b59.#b24] *)
    let el = #{ el with b59 = #{ el.#b59 with b24 = next_el.#b59.#b24 } } in
    Idx_mut.unsafe_set a ((.(i).#b59.#b24) : (t59 array, _) idx_mut) next_el.#b59.#b24;
    mark_test_run 265;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 265 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************************)
  (*   t60 = #{ int32#; #{ int32#; #{ int32# } } }   *)
  (***************************************************)
  let eq = (fun #{ a60 = a601; b60 = b601 } #{ a60 = a602; b60 = b602 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a601 a602 && (fun #{ a26 = a261; b26 = b261 } #{ a26 = a262; b26 = b262 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a261 a262 && (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) b261 b262) b601 b602) in
  let mk_value i = #{ a60 = Int32_u.of_int (i + 0); b60 = #{ a26 = Int32_u.of_int (i + 1); b26 = #{ a18 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t60 array = makearray_dynamic_local size #{ a60 = #0l; b60 = #{ a26 = #1l; b26 = #{ a18 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 266;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 266 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 267;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 267 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a60] *)
    let el = #{ el with a60 = next_el.#a60 } in
    Idx_mut.unsafe_set a ((.(i).#a60) : (t60 array, _) idx_mut) next_el.#a60;
    mark_test_run 268;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 268 failed %d %d" size i;
    (* Path: [.#b60] *)
    let el = #{ el with b60 = next_el.#b60 } in
    Idx_mut.unsafe_set a ((.(i).#b60) : (t60 array, _) idx_mut) next_el.#b60;
    mark_test_run 269;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 269 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b60.#a26] *)
    let el = #{ el with b60 = #{ el.#b60 with a26 = next_el.#b60.#a26 } } in
    Idx_mut.unsafe_set a ((.(i).#b60.#a26) : (t60 array, _) idx_mut) next_el.#b60.#a26;
    mark_test_run 270;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 270 failed %d %d" size i;
    (* Path: [.#b60.#b26] *)
    let el = #{ el with b60 = #{ el.#b60 with b26 = next_el.#b60.#b26 } } in
    Idx_mut.unsafe_set a ((.(i).#b60.#b26) : (t60 array, _) idx_mut) next_el.#b60.#b26;
    mark_test_run 271;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 271 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b60.#b26.#a18] *)
    let el = #{ el with b60 = #{ el.#b60 with b26 = #{ el.#b60.#b26 with a18 = next_el.#b60.#b26.#a18 } } } in
    Idx_mut.unsafe_set a ((.(i).#b60.#b26.#a18) : (t60 array, _) idx_mut) next_el.#b60.#b26.#a18;
    mark_test_run 272;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 272 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************************)
  (*   t61 = #{ int32#; #{ #{ int32#; int32# } } }   *)
  (***************************************************)
  let eq = (fun #{ a61 = a611; b61 = b611 } #{ a61 = a612; b61 = b612 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a611 a612 && (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) a421 a422) b611 b612) in
  let mk_value i = #{ a61 = Int32_u.of_int (i + 0); b61 = #{ a42 = #{ a24 = Int32_u.of_int (i + 1); b24 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t61 array = makearray_dynamic_local size #{ a61 = #0l; b61 = #{ a42 = #{ a24 = #1l; b24 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 273;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 273 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 274;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 274 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a61] *)
    let el = #{ el with a61 = next_el.#a61 } in
    Idx_mut.unsafe_set a ((.(i).#a61) : (t61 array, _) idx_mut) next_el.#a61;
    mark_test_run 275;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 275 failed %d %d" size i;
    (* Path: [.#b61] *)
    let el = #{ el with b61 = next_el.#b61 } in
    Idx_mut.unsafe_set a ((.(i).#b61) : (t61 array, _) idx_mut) next_el.#b61;
    mark_test_run 276;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 276 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b61.#a42] *)
    let el = #{ el with b61 = #{ el.#b61 with a42 = next_el.#b61.#a42 } } in
    Idx_mut.unsafe_set a ((.(i).#b61.#a42) : (t61 array, _) idx_mut) next_el.#b61.#a42;
    mark_test_run 277;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 277 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b61.#a42.#a24] *)
    let el = #{ el with b61 = #{ el.#b61 with a42 = #{ el.#b61.#a42 with a24 = next_el.#b61.#a42.#a24 } } } in
    Idx_mut.unsafe_set a ((.(i).#b61.#a42.#a24) : (t61 array, _) idx_mut) next_el.#b61.#a42.#a24;
    mark_test_run 278;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 278 failed %d %d" size i;
    (* Path: [.#b61.#a42.#b24] *)
    let el = #{ el with b61 = #{ el.#b61 with a42 = #{ el.#b61.#a42 with b24 = next_el.#b61.#a42.#b24 } } } in
    Idx_mut.unsafe_set a ((.(i).#b61.#a42.#b24) : (t61 array, _) idx_mut) next_el.#b61.#a42.#b24;
    mark_test_run 279;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 279 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t62 = #{ nativeint# }   *)
  (*****************************)
  let eq = (fun #{ a62 = a621 } #{ a62 = a622 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a621 a622) in
  let mk_value i = #{ a62 = Nativeint_u.of_int (i + 0) } in
  (* Create an array of size [size] *)
  let a : t62 array = makearray_dynamic_local size #{ a62 = #0n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 280;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 280 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 281;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 281 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a62] *)
    let el = #{ el with a62 = next_el.#a62 } in
    Idx_mut.unsafe_set a ((.(i).#a62) : (t62 array, _) idx_mut) next_el.#a62;
    mark_test_run 282;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 282 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t63 = #{ nativeint#; int64# }   *)
  (*************************************)
  let eq = (fun #{ a63 = a631; b63 = b631 } #{ a63 = a632; b63 = b632 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a631 a632 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b631 b632) in
  let mk_value i = #{ a63 = Nativeint_u.of_int (i + 0); b63 = Int64_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t63 array = makearray_dynamic_local size #{ a63 = #0n; b63 = #1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 283;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 283 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 284;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 284 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a63] *)
    let el = #{ el with a63 = next_el.#a63 } in
    Idx_mut.unsafe_set a ((.(i).#a63) : (t63 array, _) idx_mut) next_el.#a63;
    mark_test_run 285;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 285 failed %d %d" size i;
    (* Path: [.#b63] *)
    let el = #{ el with b63 = next_el.#b63 } in
    Idx_mut.unsafe_set a ((.(i).#b63) : (t63 array, _) idx_mut) next_el.#b63;
    mark_test_run 286;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 286 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t64 = #{ nativeint#; int32# }   *)
  (*************************************)
  let eq = (fun #{ a64 = a641; b64 = b641 } #{ a64 = a642; b64 = b642 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a641 a642 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b641 b642) in
  let mk_value i = #{ a64 = Nativeint_u.of_int (i + 0); b64 = Int32_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t64 array = makearray_dynamic_local size #{ a64 = #0n; b64 = #1l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 287;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 287 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 288;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 288 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a64] *)
    let el = #{ el with a64 = next_el.#a64 } in
    Idx_mut.unsafe_set a ((.(i).#a64) : (t64 array, _) idx_mut) next_el.#a64;
    mark_test_run 289;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 289 failed %d %d" size i;
    (* Path: [.#b64] *)
    let el = #{ el with b64 = next_el.#b64 } in
    Idx_mut.unsafe_set a ((.(i).#b64) : (t64 array, _) idx_mut) next_el.#b64;
    mark_test_run 290;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 290 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t65 = #{ nativeint#; nativeint# }   *)
  (*****************************************)
  let eq = (fun #{ a65 = a651; b65 = b651 } #{ a65 = a652; b65 = b652 } -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a651 a652 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b651 b652) in
  let mk_value i = #{ a65 = Nativeint_u.of_int (i + 0); b65 = Nativeint_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t65 array = makearray_dynamic_local size #{ a65 = #0n; b65 = #1n } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 291;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 291 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 292;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 292 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a65] *)
    let el = #{ el with a65 = next_el.#a65 } in
    Idx_mut.unsafe_set a ((.(i).#a65) : (t65 array, _) idx_mut) next_el.#a65;
    mark_test_run 293;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 293 failed %d %d" size i;
    (* Path: [.#b65] *)
    let el = #{ el with b65 = next_el.#b65 } in
    Idx_mut.unsafe_set a ((.(i).#b65) : (t65 array, _) idx_mut) next_el.#b65;
    mark_test_run 294;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 294 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t28 = #{ float; int }   *)
  (*****************************)
  let eq = (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) in
  let mk_value i = #{ a28 = Float.of_int (i + 0); b28 = (i + 1) } in
  (* Create an array of size [size] *)
  let a : t28 array = makearray_dynamic_local size #{ a28 = 0.; b28 = 1 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 295;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 295 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 296;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 296 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a28] *)
    let el = #{ el with a28 = next_el.#a28 } in
    Idx_mut.unsafe_set a ((.(i).#a28) : (t28 array, _) idx_mut) next_el.#a28;
    mark_test_run 297;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 297 failed %d %d" size i;
    (* Path: [.#b28] *)
    let el = #{ el with b28 = next_el.#b28 } in
    Idx_mut.unsafe_set a ((.(i).#b28) : (t28 array, _) idx_mut) next_el.#b28;
    mark_test_run 298;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 298 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t66 = #{ float; int; int }   *)
  (**********************************)
  let eq = (fun #{ a66 = a661; b66 = b661; c66 = c661 } #{ a66 = a662; b66 = b662; c66 = c662 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a661 a662 && (fun a b -> Int.equal a b) b661 b662 && (fun a b -> Int.equal a b) c661 c662) in
  let mk_value i = #{ a66 = Float.of_int (i + 0); b66 = (i + 1); c66 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t66 array = makearray_dynamic_local size #{ a66 = 0.; b66 = 1; c66 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 299;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 299 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 300;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 300 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a66] *)
    let el = #{ el with a66 = next_el.#a66 } in
    Idx_mut.unsafe_set a ((.(i).#a66) : (t66 array, _) idx_mut) next_el.#a66;
    mark_test_run 301;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 301 failed %d %d" size i;
    (* Path: [.#b66] *)
    let el = #{ el with b66 = next_el.#b66 } in
    Idx_mut.unsafe_set a ((.(i).#b66) : (t66 array, _) idx_mut) next_el.#b66;
    mark_test_run 302;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 302 failed %d %d" size i;
    (* Path: [.#c66] *)
    let el = #{ el with c66 = next_el.#c66 } in
    Idx_mut.unsafe_set a ((.(i).#c66) : (t66 array, _) idx_mut) next_el.#c66;
    mark_test_run 303;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 303 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t67 = #{ float; int; float }   *)
  (************************************)
  let eq = (fun #{ a67 = a671; b67 = b671; c67 = c671 } #{ a67 = a672; b67 = b672; c67 = c672 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a671 a672 && (fun a b -> Int.equal a b) b671 b672 && (fun a b -> Float.equal (globalize a) (globalize b)) c671 c672) in
  let mk_value i = #{ a67 = Float.of_int (i + 0); b67 = (i + 1); c67 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t67 array = makearray_dynamic_local size #{ a67 = 0.; b67 = 1; c67 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 304;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 304 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 305;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 305 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a67] *)
    let el = #{ el with a67 = next_el.#a67 } in
    Idx_mut.unsafe_set a ((.(i).#a67) : (t67 array, _) idx_mut) next_el.#a67;
    mark_test_run 306;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 306 failed %d %d" size i;
    (* Path: [.#b67] *)
    let el = #{ el with b67 = next_el.#b67 } in
    Idx_mut.unsafe_set a ((.(i).#b67) : (t67 array, _) idx_mut) next_el.#b67;
    mark_test_run 307;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 307 failed %d %d" size i;
    (* Path: [.#c67] *)
    let el = #{ el with c67 = next_el.#c67 } in
    Idx_mut.unsafe_set a ((.(i).#c67) : (t67 array, _) idx_mut) next_el.#c67;
    mark_test_run 308;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 308 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t68 = #{ float; int64 }   *)
  (*******************************)
  let eq = (fun #{ a68 = a681; b68 = b681 } #{ a68 = a682; b68 = b682 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a681 a682 && (fun a b -> Int64.equal (globalize a) (globalize b)) b681 b682) in
  let mk_value i = #{ a68 = Float.of_int (i + 0); b68 = Int64.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t68 array = makearray_dynamic_local size #{ a68 = 0.; b68 = 1L } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 309;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 309 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 310;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 310 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a68] *)
    let el = #{ el with a68 = next_el.#a68 } in
    Idx_mut.unsafe_set a ((.(i).#a68) : (t68 array, _) idx_mut) next_el.#a68;
    mark_test_run 311;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 311 failed %d %d" size i;
    (* Path: [.#b68] *)
    let el = #{ el with b68 = next_el.#b68 } in
    Idx_mut.unsafe_set a ((.(i).#b68) : (t68 array, _) idx_mut) next_el.#b68;
    mark_test_run 312;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 312 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t30 = #{ float; float }   *)
  (*******************************)
  let eq = (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) in
  let mk_value i = #{ a30 = Float.of_int (i + 0); b30 = Float.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t30 array = makearray_dynamic_local size #{ a30 = 0.; b30 = 1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 313;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 313 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 314;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 314 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a30] *)
    let el = #{ el with a30 = next_el.#a30 } in
    Idx_mut.unsafe_set a ((.(i).#a30) : (t30 array, _) idx_mut) next_el.#a30;
    mark_test_run 315;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 315 failed %d %d" size i;
    (* Path: [.#b30] *)
    let el = #{ el with b30 = next_el.#b30 } in
    Idx_mut.unsafe_set a ((.(i).#b30) : (t30 array, _) idx_mut) next_el.#b30;
    mark_test_run 316;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 316 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t69 = #{ float; float; int }   *)
  (************************************)
  let eq = (fun #{ a69 = a691; b69 = b691; c69 = c691 } #{ a69 = a692; b69 = b692; c69 = c692 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a691 a692 && (fun a b -> Float.equal (globalize a) (globalize b)) b691 b692 && (fun a b -> Int.equal a b) c691 c692) in
  let mk_value i = #{ a69 = Float.of_int (i + 0); b69 = Float.of_int (i + 1); c69 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t69 array = makearray_dynamic_local size #{ a69 = 0.; b69 = 1.; c69 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 317;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 317 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 318;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 318 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a69] *)
    let el = #{ el with a69 = next_el.#a69 } in
    Idx_mut.unsafe_set a ((.(i).#a69) : (t69 array, _) idx_mut) next_el.#a69;
    mark_test_run 319;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 319 failed %d %d" size i;
    (* Path: [.#b69] *)
    let el = #{ el with b69 = next_el.#b69 } in
    Idx_mut.unsafe_set a ((.(i).#b69) : (t69 array, _) idx_mut) next_el.#b69;
    mark_test_run 320;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 320 failed %d %d" size i;
    (* Path: [.#c69] *)
    let el = #{ el with c69 = next_el.#c69 } in
    Idx_mut.unsafe_set a ((.(i).#c69) : (t69 array, _) idx_mut) next_el.#c69;
    mark_test_run 321;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 321 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t70 = #{ float; float; float }   *)
  (**************************************)
  let eq = (fun #{ a70 = a701; b70 = b701; c70 = c701 } #{ a70 = a702; b70 = b702; c70 = c702 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a701 a702 && (fun a b -> Float.equal (globalize a) (globalize b)) b701 b702 && (fun a b -> Float.equal (globalize a) (globalize b)) c701 c702) in
  let mk_value i = #{ a70 = Float.of_int (i + 0); b70 = Float.of_int (i + 1); c70 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t70 array = makearray_dynamic_local size #{ a70 = 0.; b70 = 1.; c70 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 322;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 322 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 323;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 323 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a70] *)
    let el = #{ el with a70 = next_el.#a70 } in
    Idx_mut.unsafe_set a ((.(i).#a70) : (t70 array, _) idx_mut) next_el.#a70;
    mark_test_run 324;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 324 failed %d %d" size i;
    (* Path: [.#b70] *)
    let el = #{ el with b70 = next_el.#b70 } in
    Idx_mut.unsafe_set a ((.(i).#b70) : (t70 array, _) idx_mut) next_el.#b70;
    mark_test_run 325;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 325 failed %d %d" size i;
    (* Path: [.#c70] *)
    let el = #{ el with c70 = next_el.#c70 } in
    Idx_mut.unsafe_set a ((.(i).#c70) : (t70 array, _) idx_mut) next_el.#c70;
    mark_test_run 326;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 326 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t32 = #{ float; #{ int } }   *)
  (**********************************)
  let eq = (fun #{ a32 = a321; b32 = b321 } #{ a32 = a322; b32 = b322 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a321 a322 && (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) b321 b322) in
  let mk_value i = #{ a32 = Float.of_int (i + 0); b32 = #{ a0 = (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t32 array = makearray_dynamic_local size #{ a32 = 0.; b32 = #{ a0 = 1 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 327;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 327 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 328;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 328 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a32] *)
    let el = #{ el with a32 = next_el.#a32 } in
    Idx_mut.unsafe_set a ((.(i).#a32) : (t32 array, _) idx_mut) next_el.#a32;
    mark_test_run 329;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 329 failed %d %d" size i;
    (* Path: [.#b32] *)
    let el = #{ el with b32 = next_el.#b32 } in
    Idx_mut.unsafe_set a ((.(i).#b32) : (t32 array, _) idx_mut) next_el.#b32;
    mark_test_run 330;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 330 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b32.#a0] *)
    let el = #{ el with b32 = #{ el.#b32 with a0 = next_el.#b32.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#b32.#a0) : (t32 array, _) idx_mut) next_el.#b32.#a0;
    mark_test_run 331;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 331 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t71 = #{ float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a711 a712 && (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b711 b712) in
  let mk_value i = #{ a71 = Float.of_int (i + 0); b71 = #{ a1 = (i + 1); b1 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t71 array = makearray_dynamic_local size #{ a71 = 0.; b71 = #{ a1 = 1; b1 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 332;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 332 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 333;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 333 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a71] *)
    let el = #{ el with a71 = next_el.#a71 } in
    Idx_mut.unsafe_set a ((.(i).#a71) : (t71 array, _) idx_mut) next_el.#a71;
    mark_test_run 334;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 334 failed %d %d" size i;
    (* Path: [.#b71] *)
    let el = #{ el with b71 = next_el.#b71 } in
    Idx_mut.unsafe_set a ((.(i).#b71) : (t71 array, _) idx_mut) next_el.#b71;
    mark_test_run 335;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 335 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b71.#a1] *)
    let el = #{ el with b71 = #{ el.#b71 with a1 = next_el.#b71.#a1 } } in
    Idx_mut.unsafe_set a ((.(i).#b71.#a1) : (t71 array, _) idx_mut) next_el.#b71.#a1;
    mark_test_run 336;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 336 failed %d %d" size i;
    (* Path: [.#b71.#b1] *)
    let el = #{ el with b71 = #{ el.#b71 with b1 = next_el.#b71.#b1 } } in
    Idx_mut.unsafe_set a ((.(i).#b71.#b1) : (t71 array, _) idx_mut) next_el.#b71.#b1;
    mark_test_run 337;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 337 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t72 = #{ float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun #{ a72 = a721; b72 = b721 } #{ a72 = a722; b72 = b722 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a721 a722 && (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b721 b722) in
  let mk_value i = #{ a72 = Float.of_int (i + 0); b72 = #{ a10 = (i + 1); b10 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t72 array = makearray_dynamic_local size #{ a72 = 0.; b72 = #{ a10 = 1; b10 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 338;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 338 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 339;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 339 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a72] *)
    let el = #{ el with a72 = next_el.#a72 } in
    Idx_mut.unsafe_set a ((.(i).#a72) : (t72 array, _) idx_mut) next_el.#a72;
    mark_test_run 340;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 340 failed %d %d" size i;
    (* Path: [.#b72] *)
    let el = #{ el with b72 = next_el.#b72 } in
    Idx_mut.unsafe_set a ((.(i).#b72) : (t72 array, _) idx_mut) next_el.#b72;
    mark_test_run 341;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 341 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b72.#a10] *)
    let el = #{ el with b72 = #{ el.#b72 with a10 = next_el.#b72.#a10 } } in
    Idx_mut.unsafe_set a ((.(i).#b72.#a10) : (t72 array, _) idx_mut) next_el.#b72.#a10;
    mark_test_run 342;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 342 failed %d %d" size i;
    (* Path: [.#b72.#b10] *)
    let el = #{ el with b72 = #{ el.#b72 with b10 = next_el.#b72.#b10 } } in
    Idx_mut.unsafe_set a ((.(i).#b72.#b10) : (t72 array, _) idx_mut) next_el.#b72.#b10;
    mark_test_run 343;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 343 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t73 = #{ float; #{ int; #{ int } } }   *)
  (********************************************)
  let eq = (fun #{ a73 = a731; b73 = b731 } #{ a73 = a732; b73 = b732 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a731 a732 && (fun #{ a13 = a131; b13 = b131 } #{ a13 = a132; b13 = b132 } -> (fun a b -> Int.equal a b) a131 a132 && (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) b131 b132) b731 b732) in
  let mk_value i = #{ a73 = Float.of_int (i + 0); b73 = #{ a13 = (i + 1); b13 = #{ a0 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t73 array = makearray_dynamic_local size #{ a73 = 0.; b73 = #{ a13 = 1; b13 = #{ a0 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 344;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 344 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 345;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 345 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a73] *)
    let el = #{ el with a73 = next_el.#a73 } in
    Idx_mut.unsafe_set a ((.(i).#a73) : (t73 array, _) idx_mut) next_el.#a73;
    mark_test_run 346;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 346 failed %d %d" size i;
    (* Path: [.#b73] *)
    let el = #{ el with b73 = next_el.#b73 } in
    Idx_mut.unsafe_set a ((.(i).#b73) : (t73 array, _) idx_mut) next_el.#b73;
    mark_test_run 347;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 347 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b73.#a13] *)
    let el = #{ el with b73 = #{ el.#b73 with a13 = next_el.#b73.#a13 } } in
    Idx_mut.unsafe_set a ((.(i).#b73.#a13) : (t73 array, _) idx_mut) next_el.#b73.#a13;
    mark_test_run 348;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 348 failed %d %d" size i;
    (* Path: [.#b73.#b13] *)
    let el = #{ el with b73 = #{ el.#b73 with b13 = next_el.#b73.#b13 } } in
    Idx_mut.unsafe_set a ((.(i).#b73.#b13) : (t73 array, _) idx_mut) next_el.#b73.#b13;
    mark_test_run 349;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 349 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b73.#b13.#a0] *)
    let el = #{ el with b73 = #{ el.#b73 with b13 = #{ el.#b73.#b13 with a0 = next_el.#b73.#b13.#a0 } } } in
    Idx_mut.unsafe_set a ((.(i).#b73.#b13.#a0) : (t73 array, _) idx_mut) next_el.#b73.#b13.#a0;
    mark_test_run 350;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 350 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t74 = #{ float; #{ int; #{ float } } }   *)
  (**********************************************)
  let eq = (fun #{ a74 = a741; b74 = b741 } #{ a74 = a742; b74 = b742 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a741 a742 && (fun #{ a22 = a221; b22 = b221 } #{ a22 = a222; b22 = b222 } -> (fun a b -> Int.equal a b) a221 a222 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b221 b222) b741 b742) in
  let mk_value i = #{ a74 = Float.of_int (i + 0); b74 = #{ a22 = (i + 1); b22 = #{ a21 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t74 array = makearray_dynamic_local size #{ a74 = 0.; b74 = #{ a22 = 1; b22 = #{ a21 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 351;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 351 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 352;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 352 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a74] *)
    let el = #{ el with a74 = next_el.#a74 } in
    Idx_mut.unsafe_set a ((.(i).#a74) : (t74 array, _) idx_mut) next_el.#a74;
    mark_test_run 353;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 353 failed %d %d" size i;
    (* Path: [.#b74] *)
    let el = #{ el with b74 = next_el.#b74 } in
    Idx_mut.unsafe_set a ((.(i).#b74) : (t74 array, _) idx_mut) next_el.#b74;
    mark_test_run 354;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 354 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b74.#a22] *)
    let el = #{ el with b74 = #{ el.#b74 with a22 = next_el.#b74.#a22 } } in
    Idx_mut.unsafe_set a ((.(i).#b74.#a22) : (t74 array, _) idx_mut) next_el.#b74.#a22;
    mark_test_run 355;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 355 failed %d %d" size i;
    (* Path: [.#b74.#b22] *)
    let el = #{ el with b74 = #{ el.#b74 with b22 = next_el.#b74.#b22 } } in
    Idx_mut.unsafe_set a ((.(i).#b74.#b22) : (t74 array, _) idx_mut) next_el.#b74.#b22;
    mark_test_run 356;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 356 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b74.#b22.#a21] *)
    let el = #{ el with b74 = #{ el.#b74 with b22 = #{ el.#b74.#b22 with a21 = next_el.#b74.#b22.#a21 } } } in
    Idx_mut.unsafe_set a ((.(i).#b74.#b22.#a21) : (t74 array, _) idx_mut) next_el.#b74.#b22.#a21;
    mark_test_run 357;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 357 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t34 = #{ float; #{ float } }   *)
  (************************************)
  let eq = (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b341 b342) in
  let mk_value i = #{ a34 = Float.of_int (i + 0); b34 = #{ a21 = Float.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t34 array = makearray_dynamic_local size #{ a34 = 0.; b34 = #{ a21 = 1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 358;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 358 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 359;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 359 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a34] *)
    let el = #{ el with a34 = next_el.#a34 } in
    Idx_mut.unsafe_set a ((.(i).#a34) : (t34 array, _) idx_mut) next_el.#a34;
    mark_test_run 360;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 360 failed %d %d" size i;
    (* Path: [.#b34] *)
    let el = #{ el with b34 = next_el.#b34 } in
    Idx_mut.unsafe_set a ((.(i).#b34) : (t34 array, _) idx_mut) next_el.#b34;
    mark_test_run 361;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 361 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b34.#a21] *)
    let el = #{ el with b34 = #{ el.#b34 with a21 = next_el.#b34.#a21 } } in
    Idx_mut.unsafe_set a ((.(i).#b34.#a21) : (t34 array, _) idx_mut) next_el.#b34.#a21;
    mark_test_run 362;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 362 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t75 = #{ float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun #{ a75 = a751; b75 = b751 } #{ a75 = a752; b75 = b752 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a751 a752 && (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) b751 b752) in
  let mk_value i = #{ a75 = Float.of_int (i + 0); b75 = #{ a28 = Float.of_int (i + 1); b28 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t75 array = makearray_dynamic_local size #{ a75 = 0.; b75 = #{ a28 = 1.; b28 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 363;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 363 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 364;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 364 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a75] *)
    let el = #{ el with a75 = next_el.#a75 } in
    Idx_mut.unsafe_set a ((.(i).#a75) : (t75 array, _) idx_mut) next_el.#a75;
    mark_test_run 365;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 365 failed %d %d" size i;
    (* Path: [.#b75] *)
    let el = #{ el with b75 = next_el.#b75 } in
    Idx_mut.unsafe_set a ((.(i).#b75) : (t75 array, _) idx_mut) next_el.#b75;
    mark_test_run 366;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 366 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b75.#a28] *)
    let el = #{ el with b75 = #{ el.#b75 with a28 = next_el.#b75.#a28 } } in
    Idx_mut.unsafe_set a ((.(i).#b75.#a28) : (t75 array, _) idx_mut) next_el.#b75.#a28;
    mark_test_run 367;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 367 failed %d %d" size i;
    (* Path: [.#b75.#b28] *)
    let el = #{ el with b75 = #{ el.#b75 with b28 = next_el.#b75.#b28 } } in
    Idx_mut.unsafe_set a ((.(i).#b75.#b28) : (t75 array, _) idx_mut) next_el.#b75.#b28;
    mark_test_run 368;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 368 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t76 = #{ float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun #{ a76 = a761; b76 = b761 } #{ a76 = a762; b76 = b762 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a761 a762 && (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) b761 b762) in
  let mk_value i = #{ a76 = Float.of_int (i + 0); b76 = #{ a30 = Float.of_int (i + 1); b30 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t76 array = makearray_dynamic_local size #{ a76 = 0.; b76 = #{ a30 = 1.; b30 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 369;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 369 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 370;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 370 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a76] *)
    let el = #{ el with a76 = next_el.#a76 } in
    Idx_mut.unsafe_set a ((.(i).#a76) : (t76 array, _) idx_mut) next_el.#a76;
    mark_test_run 371;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 371 failed %d %d" size i;
    (* Path: [.#b76] *)
    let el = #{ el with b76 = next_el.#b76 } in
    Idx_mut.unsafe_set a ((.(i).#b76) : (t76 array, _) idx_mut) next_el.#b76;
    mark_test_run 372;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 372 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b76.#a30] *)
    let el = #{ el with b76 = #{ el.#b76 with a30 = next_el.#b76.#a30 } } in
    Idx_mut.unsafe_set a ((.(i).#b76.#a30) : (t76 array, _) idx_mut) next_el.#b76.#a30;
    mark_test_run 373;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 373 failed %d %d" size i;
    (* Path: [.#b76.#b30] *)
    let el = #{ el with b76 = #{ el.#b76 with b30 = next_el.#b76.#b30 } } in
    Idx_mut.unsafe_set a ((.(i).#b76.#b30) : (t76 array, _) idx_mut) next_el.#b76.#b30;
    mark_test_run 374;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 374 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t77 = #{ float; #{ float; #{ int } } }   *)
  (**********************************************)
  let eq = (fun #{ a77 = a771; b77 = b771 } #{ a77 = a772; b77 = b772 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a771 a772 && (fun #{ a32 = a321; b32 = b321 } #{ a32 = a322; b32 = b322 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a321 a322 && (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) b321 b322) b771 b772) in
  let mk_value i = #{ a77 = Float.of_int (i + 0); b77 = #{ a32 = Float.of_int (i + 1); b32 = #{ a0 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t77 array = makearray_dynamic_local size #{ a77 = 0.; b77 = #{ a32 = 1.; b32 = #{ a0 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 375;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 375 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 376;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 376 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a77] *)
    let el = #{ el with a77 = next_el.#a77 } in
    Idx_mut.unsafe_set a ((.(i).#a77) : (t77 array, _) idx_mut) next_el.#a77;
    mark_test_run 377;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 377 failed %d %d" size i;
    (* Path: [.#b77] *)
    let el = #{ el with b77 = next_el.#b77 } in
    Idx_mut.unsafe_set a ((.(i).#b77) : (t77 array, _) idx_mut) next_el.#b77;
    mark_test_run 378;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 378 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b77.#a32] *)
    let el = #{ el with b77 = #{ el.#b77 with a32 = next_el.#b77.#a32 } } in
    Idx_mut.unsafe_set a ((.(i).#b77.#a32) : (t77 array, _) idx_mut) next_el.#b77.#a32;
    mark_test_run 379;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 379 failed %d %d" size i;
    (* Path: [.#b77.#b32] *)
    let el = #{ el with b77 = #{ el.#b77 with b32 = next_el.#b77.#b32 } } in
    Idx_mut.unsafe_set a ((.(i).#b77.#b32) : (t77 array, _) idx_mut) next_el.#b77.#b32;
    mark_test_run 380;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 380 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b77.#b32.#a0] *)
    let el = #{ el with b77 = #{ el.#b77 with b32 = #{ el.#b77.#b32 with a0 = next_el.#b77.#b32.#a0 } } } in
    Idx_mut.unsafe_set a ((.(i).#b77.#b32.#a0) : (t77 array, _) idx_mut) next_el.#b77.#b32.#a0;
    mark_test_run 381;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 381 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************************)
  (*   t78 = #{ float; #{ float; #{ float } } }   *)
  (************************************************)
  let eq = (fun #{ a78 = a781; b78 = b781 } #{ a78 = a782; b78 = b782 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a781 a782 && (fun #{ a34 = a341; b34 = b341 } #{ a34 = a342; b34 = b342 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b341 b342) b781 b782) in
  let mk_value i = #{ a78 = Float.of_int (i + 0); b78 = #{ a34 = Float.of_int (i + 1); b34 = #{ a21 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t78 array = makearray_dynamic_local size #{ a78 = 0.; b78 = #{ a34 = 1.; b34 = #{ a21 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 382;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 382 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 383;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 383 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a78] *)
    let el = #{ el with a78 = next_el.#a78 } in
    Idx_mut.unsafe_set a ((.(i).#a78) : (t78 array, _) idx_mut) next_el.#a78;
    mark_test_run 384;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 384 failed %d %d" size i;
    (* Path: [.#b78] *)
    let el = #{ el with b78 = next_el.#b78 } in
    Idx_mut.unsafe_set a ((.(i).#b78) : (t78 array, _) idx_mut) next_el.#b78;
    mark_test_run 385;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 385 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b78.#a34] *)
    let el = #{ el with b78 = #{ el.#b78 with a34 = next_el.#b78.#a34 } } in
    Idx_mut.unsafe_set a ((.(i).#b78.#a34) : (t78 array, _) idx_mut) next_el.#b78.#a34;
    mark_test_run 386;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 386 failed %d %d" size i;
    (* Path: [.#b78.#b34] *)
    let el = #{ el with b78 = #{ el.#b78 with b34 = next_el.#b78.#b34 } } in
    Idx_mut.unsafe_set a ((.(i).#b78.#b34) : (t78 array, _) idx_mut) next_el.#b78.#b34;
    mark_test_run 387;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 387 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b78.#b34.#a21] *)
    let el = #{ el with b78 = #{ el.#b78 with b34 = #{ el.#b78.#b34 with a21 = next_el.#b78.#b34.#a21 } } } in
    Idx_mut.unsafe_set a ((.(i).#b78.#b34.#a21) : (t78 array, _) idx_mut) next_el.#b78.#b34.#a21;
    mark_test_run 388;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 388 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t79 = #{ float; #{ #{ int; int } } }   *)
  (********************************************)
  let eq = (fun #{ a79 = a791; b79 = b791 } #{ a79 = a792; b79 = b792 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a791 a792 && (fun #{ a36 = a361 } #{ a36 = a362 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a361 a362) b791 b792) in
  let mk_value i = #{ a79 = Float.of_int (i + 0); b79 = #{ a36 = #{ a1 = (i + 1); b1 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t79 array = makearray_dynamic_local size #{ a79 = 0.; b79 = #{ a36 = #{ a1 = 1; b1 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 389;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 389 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 390;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 390 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a79] *)
    let el = #{ el with a79 = next_el.#a79 } in
    Idx_mut.unsafe_set a ((.(i).#a79) : (t79 array, _) idx_mut) next_el.#a79;
    mark_test_run 391;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 391 failed %d %d" size i;
    (* Path: [.#b79] *)
    let el = #{ el with b79 = next_el.#b79 } in
    Idx_mut.unsafe_set a ((.(i).#b79) : (t79 array, _) idx_mut) next_el.#b79;
    mark_test_run 392;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 392 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b79.#a36] *)
    let el = #{ el with b79 = #{ el.#b79 with a36 = next_el.#b79.#a36 } } in
    Idx_mut.unsafe_set a ((.(i).#b79.#a36) : (t79 array, _) idx_mut) next_el.#b79.#a36;
    mark_test_run 393;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 393 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b79.#a36.#a1] *)
    let el = #{ el with b79 = #{ el.#b79 with a36 = #{ el.#b79.#a36 with a1 = next_el.#b79.#a36.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#b79.#a36.#a1) : (t79 array, _) idx_mut) next_el.#b79.#a36.#a1;
    mark_test_run 394;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 394 failed %d %d" size i;
    (* Path: [.#b79.#a36.#b1] *)
    let el = #{ el with b79 = #{ el.#b79 with a36 = #{ el.#b79.#a36 with b1 = next_el.#b79.#a36.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#b79.#a36.#b1) : (t79 array, _) idx_mut) next_el.#b79.#a36.#b1;
    mark_test_run 395;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 395 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t80 = #{ float; #{ #{ int; float } } }   *)
  (**********************************************)
  let eq = (fun #{ a80 = a801; b80 = b801 } #{ a80 = a802; b80 = b802 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a801 a802 && (fun #{ a40 = a401 } #{ a40 = a402 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a401 a402) b801 b802) in
  let mk_value i = #{ a80 = Float.of_int (i + 0); b80 = #{ a40 = #{ a10 = (i + 1); b10 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t80 array = makearray_dynamic_local size #{ a80 = 0.; b80 = #{ a40 = #{ a10 = 1; b10 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 396;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 396 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 397;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 397 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a80] *)
    let el = #{ el with a80 = next_el.#a80 } in
    Idx_mut.unsafe_set a ((.(i).#a80) : (t80 array, _) idx_mut) next_el.#a80;
    mark_test_run 398;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 398 failed %d %d" size i;
    (* Path: [.#b80] *)
    let el = #{ el with b80 = next_el.#b80 } in
    Idx_mut.unsafe_set a ((.(i).#b80) : (t80 array, _) idx_mut) next_el.#b80;
    mark_test_run 399;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 399 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b80.#a40] *)
    let el = #{ el with b80 = #{ el.#b80 with a40 = next_el.#b80.#a40 } } in
    Idx_mut.unsafe_set a ((.(i).#b80.#a40) : (t80 array, _) idx_mut) next_el.#b80.#a40;
    mark_test_run 400;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 400 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b80.#a40.#a10] *)
    let el = #{ el with b80 = #{ el.#b80 with a40 = #{ el.#b80.#a40 with a10 = next_el.#b80.#a40.#a10 } } } in
    Idx_mut.unsafe_set a ((.(i).#b80.#a40.#a10) : (t80 array, _) idx_mut) next_el.#b80.#a40.#a10;
    mark_test_run 401;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 401 failed %d %d" size i;
    (* Path: [.#b80.#a40.#b10] *)
    let el = #{ el with b80 = #{ el.#b80 with a40 = #{ el.#b80.#a40 with b10 = next_el.#b80.#a40.#b10 } } } in
    Idx_mut.unsafe_set a ((.(i).#b80.#a40.#b10) : (t80 array, _) idx_mut) next_el.#b80.#a40.#b10;
    mark_test_run 402;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 402 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t81 = #{ float; #{ #{ float; int } } }   *)
  (**********************************************)
  let eq = (fun #{ a81 = a811; b81 = b811 } #{ a81 = a812; b81 = b812 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a811 a812 && (fun #{ a44 = a441 } #{ a44 = a442 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a441 a442) b811 b812) in
  let mk_value i = #{ a81 = Float.of_int (i + 0); b81 = #{ a44 = #{ a28 = Float.of_int (i + 1); b28 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t81 array = makearray_dynamic_local size #{ a81 = 0.; b81 = #{ a44 = #{ a28 = 1.; b28 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 403;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 403 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 404;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 404 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a81] *)
    let el = #{ el with a81 = next_el.#a81 } in
    Idx_mut.unsafe_set a ((.(i).#a81) : (t81 array, _) idx_mut) next_el.#a81;
    mark_test_run 405;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 405 failed %d %d" size i;
    (* Path: [.#b81] *)
    let el = #{ el with b81 = next_el.#b81 } in
    Idx_mut.unsafe_set a ((.(i).#b81) : (t81 array, _) idx_mut) next_el.#b81;
    mark_test_run 406;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 406 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b81.#a44] *)
    let el = #{ el with b81 = #{ el.#b81 with a44 = next_el.#b81.#a44 } } in
    Idx_mut.unsafe_set a ((.(i).#b81.#a44) : (t81 array, _) idx_mut) next_el.#b81.#a44;
    mark_test_run 407;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 407 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b81.#a44.#a28] *)
    let el = #{ el with b81 = #{ el.#b81 with a44 = #{ el.#b81.#a44 with a28 = next_el.#b81.#a44.#a28 } } } in
    Idx_mut.unsafe_set a ((.(i).#b81.#a44.#a28) : (t81 array, _) idx_mut) next_el.#b81.#a44.#a28;
    mark_test_run 408;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 408 failed %d %d" size i;
    (* Path: [.#b81.#a44.#b28] *)
    let el = #{ el with b81 = #{ el.#b81 with a44 = #{ el.#b81.#a44 with b28 = next_el.#b81.#a44.#b28 } } } in
    Idx_mut.unsafe_set a ((.(i).#b81.#a44.#b28) : (t81 array, _) idx_mut) next_el.#b81.#a44.#b28;
    mark_test_run 409;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 409 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************************)
  (*   t82 = #{ float; #{ #{ float; float } } }   *)
  (************************************************)
  let eq = (fun #{ a82 = a821; b82 = b821 } #{ a82 = a822; b82 = b822 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a821 a822 && (fun #{ a46 = a461 } #{ a46 = a462 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a461 a462) b821 b822) in
  let mk_value i = #{ a82 = Float.of_int (i + 0); b82 = #{ a46 = #{ a30 = Float.of_int (i + 1); b30 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t82 array = makearray_dynamic_local size #{ a82 = 0.; b82 = #{ a46 = #{ a30 = 1.; b30 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 410;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 410 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 411;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 411 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a82] *)
    let el = #{ el with a82 = next_el.#a82 } in
    Idx_mut.unsafe_set a ((.(i).#a82) : (t82 array, _) idx_mut) next_el.#a82;
    mark_test_run 412;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 412 failed %d %d" size i;
    (* Path: [.#b82] *)
    let el = #{ el with b82 = next_el.#b82 } in
    Idx_mut.unsafe_set a ((.(i).#b82) : (t82 array, _) idx_mut) next_el.#b82;
    mark_test_run 413;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 413 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b82.#a46] *)
    let el = #{ el with b82 = #{ el.#b82 with a46 = next_el.#b82.#a46 } } in
    Idx_mut.unsafe_set a ((.(i).#b82.#a46) : (t82 array, _) idx_mut) next_el.#b82.#a46;
    mark_test_run 414;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 414 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b82.#a46.#a30] *)
    let el = #{ el with b82 = #{ el.#b82 with a46 = #{ el.#b82.#a46 with a30 = next_el.#b82.#a46.#a30 } } } in
    Idx_mut.unsafe_set a ((.(i).#b82.#a46.#a30) : (t82 array, _) idx_mut) next_el.#b82.#a46.#a30;
    mark_test_run 415;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 415 failed %d %d" size i;
    (* Path: [.#b82.#a46.#b30] *)
    let el = #{ el with b82 = #{ el.#b82 with a46 = #{ el.#b82.#a46 with b30 = next_el.#b82.#a46.#b30 } } } in
    Idx_mut.unsafe_set a ((.(i).#b82.#a46.#b30) : (t82 array, _) idx_mut) next_el.#b82.#a46.#b30;
    mark_test_run 416;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 416 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t83 = #{ float# }   *)
  (*************************)
  let eq = (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a831 a832) in
  let mk_value i = #{ a83 = Float_u.of_int (i + 0) } in
  (* Create an array of size [size] *)
  let a : t83 array = makearray_dynamic_local size #{ a83 = #0. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 417;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 417 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 418;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 418 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a83] *)
    let el = #{ el with a83 = next_el.#a83 } in
    Idx_mut.unsafe_set a ((.(i).#a83) : (t83 array, _) idx_mut) next_el.#a83;
    mark_test_run 419;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 419 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t84 = #{ float#; float# }   *)
  (*********************************)
  let eq = (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) in
  let mk_value i = #{ a84 = Float_u.of_int (i + 0); b84 = Float_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t84 array = makearray_dynamic_local size #{ a84 = #0.; b84 = #1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 420;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 420 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 421;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 421 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a84] *)
    let el = #{ el with a84 = next_el.#a84 } in
    Idx_mut.unsafe_set a ((.(i).#a84) : (t84 array, _) idx_mut) next_el.#a84;
    mark_test_run 422;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 422 failed %d %d" size i;
    (* Path: [.#b84] *)
    let el = #{ el with b84 = next_el.#b84 } in
    Idx_mut.unsafe_set a ((.(i).#b84) : (t84 array, _) idx_mut) next_el.#b84;
    mark_test_run 423;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 423 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t85 = #{ float#; float#; float# }   *)
  (*****************************************)
  let eq = (fun #{ a85 = a851; b85 = b851; c85 = c851 } #{ a85 = a852; b85 = b852; c85 = c852 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a851 a852 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b851 b852 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) c851 c852) in
  let mk_value i = #{ a85 = Float_u.of_int (i + 0); b85 = Float_u.of_int (i + 1); c85 = Float_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t85 array = makearray_dynamic_local size #{ a85 = #0.; b85 = #1.; c85 = #2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 424;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 424 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 425;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 425 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a85] *)
    let el = #{ el with a85 = next_el.#a85 } in
    Idx_mut.unsafe_set a ((.(i).#a85) : (t85 array, _) idx_mut) next_el.#a85;
    mark_test_run 426;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 426 failed %d %d" size i;
    (* Path: [.#b85] *)
    let el = #{ el with b85 = next_el.#b85 } in
    Idx_mut.unsafe_set a ((.(i).#b85) : (t85 array, _) idx_mut) next_el.#b85;
    mark_test_run 427;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 427 failed %d %d" size i;
    (* Path: [.#c85] *)
    let el = #{ el with c85 = next_el.#c85 } in
    Idx_mut.unsafe_set a ((.(i).#c85) : (t85 array, _) idx_mut) next_el.#c85;
    mark_test_run 428;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 428 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t86 = #{ float#; #{ float# } }   *)
  (**************************************)
  let eq = (fun #{ a86 = a861; b86 = b861 } #{ a86 = a862; b86 = b862 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a861 a862 && (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a831 a832) b861 b862) in
  let mk_value i = #{ a86 = Float_u.of_int (i + 0); b86 = #{ a83 = Float_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t86 array = makearray_dynamic_local size #{ a86 = #0.; b86 = #{ a83 = #1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 429;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 429 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 430;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 430 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a86] *)
    let el = #{ el with a86 = next_el.#a86 } in
    Idx_mut.unsafe_set a ((.(i).#a86) : (t86 array, _) idx_mut) next_el.#a86;
    mark_test_run 431;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 431 failed %d %d" size i;
    (* Path: [.#b86] *)
    let el = #{ el with b86 = next_el.#b86 } in
    Idx_mut.unsafe_set a ((.(i).#b86) : (t86 array, _) idx_mut) next_el.#b86;
    mark_test_run 432;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 432 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b86.#a83] *)
    let el = #{ el with b86 = #{ el.#b86 with a83 = next_el.#b86.#a83 } } in
    Idx_mut.unsafe_set a ((.(i).#b86.#a83) : (t86 array, _) idx_mut) next_el.#b86.#a83;
    mark_test_run 433;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 433 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t87 = #{ float#; #{ float#; float# } }   *)
  (**********************************************)
  let eq = (fun #{ a87 = a871; b87 = b871 } #{ a87 = a872; b87 = b872 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a871 a872 && (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) b871 b872) in
  let mk_value i = #{ a87 = Float_u.of_int (i + 0); b87 = #{ a84 = Float_u.of_int (i + 1); b84 = Float_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t87 array = makearray_dynamic_local size #{ a87 = #0.; b87 = #{ a84 = #1.; b84 = #2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 434;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 434 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 435;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 435 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a87] *)
    let el = #{ el with a87 = next_el.#a87 } in
    Idx_mut.unsafe_set a ((.(i).#a87) : (t87 array, _) idx_mut) next_el.#a87;
    mark_test_run 436;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 436 failed %d %d" size i;
    (* Path: [.#b87] *)
    let el = #{ el with b87 = next_el.#b87 } in
    Idx_mut.unsafe_set a ((.(i).#b87) : (t87 array, _) idx_mut) next_el.#b87;
    mark_test_run 437;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 437 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b87.#a84] *)
    let el = #{ el with b87 = #{ el.#b87 with a84 = next_el.#b87.#a84 } } in
    Idx_mut.unsafe_set a ((.(i).#b87.#a84) : (t87 array, _) idx_mut) next_el.#b87.#a84;
    mark_test_run 438;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 438 failed %d %d" size i;
    (* Path: [.#b87.#b84] *)
    let el = #{ el with b87 = #{ el.#b87 with b84 = next_el.#b87.#b84 } } in
    Idx_mut.unsafe_set a ((.(i).#b87.#b84) : (t87 array, _) idx_mut) next_el.#b87.#b84;
    mark_test_run 439;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 439 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************************)
  (*   t88 = #{ float#; #{ float#; #{ float# } } }   *)
  (***************************************************)
  let eq = (fun #{ a88 = a881; b88 = b881 } #{ a88 = a882; b88 = b882 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a881 a882 && (fun #{ a86 = a861; b86 = b861 } #{ a86 = a862; b86 = b862 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a861 a862 && (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a831 a832) b861 b862) b881 b882) in
  let mk_value i = #{ a88 = Float_u.of_int (i + 0); b88 = #{ a86 = Float_u.of_int (i + 1); b86 = #{ a83 = Float_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t88 array = makearray_dynamic_local size #{ a88 = #0.; b88 = #{ a86 = #1.; b86 = #{ a83 = #2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 440;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 440 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 441;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 441 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a88] *)
    let el = #{ el with a88 = next_el.#a88 } in
    Idx_mut.unsafe_set a ((.(i).#a88) : (t88 array, _) idx_mut) next_el.#a88;
    mark_test_run 442;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 442 failed %d %d" size i;
    (* Path: [.#b88] *)
    let el = #{ el with b88 = next_el.#b88 } in
    Idx_mut.unsafe_set a ((.(i).#b88) : (t88 array, _) idx_mut) next_el.#b88;
    mark_test_run 443;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 443 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b88.#a86] *)
    let el = #{ el with b88 = #{ el.#b88 with a86 = next_el.#b88.#a86 } } in
    Idx_mut.unsafe_set a ((.(i).#b88.#a86) : (t88 array, _) idx_mut) next_el.#b88.#a86;
    mark_test_run 444;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 444 failed %d %d" size i;
    (* Path: [.#b88.#b86] *)
    let el = #{ el with b88 = #{ el.#b88 with b86 = next_el.#b88.#b86 } } in
    Idx_mut.unsafe_set a ((.(i).#b88.#b86) : (t88 array, _) idx_mut) next_el.#b88.#b86;
    mark_test_run 445;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 445 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b88.#b86.#a83] *)
    let el = #{ el with b88 = #{ el.#b88 with b86 = #{ el.#b88.#b86 with a83 = next_el.#b88.#b86.#a83 } } } in
    Idx_mut.unsafe_set a ((.(i).#b88.#b86.#a83) : (t88 array, _) idx_mut) next_el.#b88.#b86.#a83;
    mark_test_run 446;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 446 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************************)
  (*   t90 = #{ float#; #{ #{ float#; float# } } }   *)
  (***************************************************)
  let eq = (fun #{ a90 = a901; b90 = b901 } #{ a90 = a902; b90 = b902 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a901 a902 && (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) a891 a892) b901 b902) in
  let mk_value i = #{ a90 = Float_u.of_int (i + 0); b90 = #{ a89 = #{ a84 = Float_u.of_int (i + 1); b84 = Float_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t90 array = makearray_dynamic_local size #{ a90 = #0.; b90 = #{ a89 = #{ a84 = #1.; b84 = #2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 447;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 447 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 448;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 448 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a90] *)
    let el = #{ el with a90 = next_el.#a90 } in
    Idx_mut.unsafe_set a ((.(i).#a90) : (t90 array, _) idx_mut) next_el.#a90;
    mark_test_run 449;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 449 failed %d %d" size i;
    (* Path: [.#b90] *)
    let el = #{ el with b90 = next_el.#b90 } in
    Idx_mut.unsafe_set a ((.(i).#b90) : (t90 array, _) idx_mut) next_el.#b90;
    mark_test_run 450;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 450 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b90.#a89] *)
    let el = #{ el with b90 = #{ el.#b90 with a89 = next_el.#b90.#a89 } } in
    Idx_mut.unsafe_set a ((.(i).#b90.#a89) : (t90 array, _) idx_mut) next_el.#b90.#a89;
    mark_test_run 451;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 451 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#b90.#a89.#a84] *)
    let el = #{ el with b90 = #{ el.#b90 with a89 = #{ el.#b90.#a89 with a84 = next_el.#b90.#a89.#a84 } } } in
    Idx_mut.unsafe_set a ((.(i).#b90.#a89.#a84) : (t90 array, _) idx_mut) next_el.#b90.#a89.#a84;
    mark_test_run 452;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 452 failed %d %d" size i;
    (* Path: [.#b90.#a89.#b84] *)
    let el = #{ el with b90 = #{ el.#b90 with a89 = #{ el.#b90.#a89 with b84 = next_el.#b90.#a89.#b84 } } } in
    Idx_mut.unsafe_set a ((.(i).#b90.#a89.#b84) : (t90 array, _) idx_mut) next_el.#b90.#a89.#b84;
    mark_test_run 453;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 453 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************)
  (*   t91 = #{ #{ int } }   *)
  (***************************)
  let eq = (fun #{ a91 = a911 } #{ a91 = a912 } -> (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) a911 a912) in
  let mk_value i = #{ a91 = #{ a0 = (i + 0) } } in
  (* Create an array of size [size] *)
  let a : t91 array = makearray_dynamic_local size #{ a91 = #{ a0 = 0 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 454;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 454 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 455;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 455 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a91] *)
    let el = #{ el with a91 = next_el.#a91 } in
    Idx_mut.unsafe_set a ((.(i).#a91) : (t91 array, _) idx_mut) next_el.#a91;
    mark_test_run 456;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 456 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a91.#a0] *)
    let el = #{ el with a91 = #{ el.#a91 with a0 = next_el.#a91.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#a91.#a0) : (t91 array, _) idx_mut) next_el.#a91.#a0;
    mark_test_run 457;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 457 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t92 = #{ #{ int }; int }   *)
  (********************************)
  let eq = (fun #{ a92 = a921; b92 = b921 } #{ a92 = a922; b92 = b922 } -> (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) a921 a922 && (fun a b -> Int.equal a b) b921 b922) in
  let mk_value i = #{ a92 = #{ a0 = (i + 0) }; b92 = (i + 1) } in
  (* Create an array of size [size] *)
  let a : t92 array = makearray_dynamic_local size #{ a92 = #{ a0 = 0 }; b92 = 1 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 458;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 458 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 459;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 459 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a92] *)
    let el = #{ el with a92 = next_el.#a92 } in
    Idx_mut.unsafe_set a ((.(i).#a92) : (t92 array, _) idx_mut) next_el.#a92;
    mark_test_run 460;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 460 failed %d %d" size i;
    (* Path: [.#b92] *)
    let el = #{ el with b92 = next_el.#b92 } in
    Idx_mut.unsafe_set a ((.(i).#b92) : (t92 array, _) idx_mut) next_el.#b92;
    mark_test_run 461;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 461 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a92.#a0] *)
    let el = #{ el with a92 = #{ el.#a92 with a0 = next_el.#a92.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#a92.#a0) : (t92 array, _) idx_mut) next_el.#a92.#a0;
    mark_test_run 462;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 462 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t93 = #{ #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun #{ a93 = a931; b93 = b931 } #{ a93 = a932; b93 = b932 } -> (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) a931 a932 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b931 b932) in
  let mk_value i = #{ a93 = #{ a0 = (i + 0) }; b93 = Int32_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t93 array = makearray_dynamic_local size #{ a93 = #{ a0 = 0 }; b93 = #1l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 463;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 463 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 464;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 464 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a93] *)
    let el = #{ el with a93 = next_el.#a93 } in
    Idx_mut.unsafe_set a ((.(i).#a93) : (t93 array, _) idx_mut) next_el.#a93;
    mark_test_run 465;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 465 failed %d %d" size i;
    (* Path: [.#b93] *)
    let el = #{ el with b93 = next_el.#b93 } in
    Idx_mut.unsafe_set a ((.(i).#b93) : (t93 array, _) idx_mut) next_el.#b93;
    mark_test_run 466;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 466 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a93.#a0] *)
    let el = #{ el with a93 = #{ el.#a93 with a0 = next_el.#a93.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#a93.#a0) : (t93 array, _) idx_mut) next_el.#a93.#a0;
    mark_test_run 467;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 467 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t94 = #{ #{ int }; float }   *)
  (**********************************)
  let eq = (fun #{ a94 = a941; b94 = b941 } #{ a94 = a942; b94 = b942 } -> (fun #{ a0 = a01 } #{ a0 = a02 } -> (fun a b -> Int.equal a b) a01 a02) a941 a942 && (fun a b -> Float.equal (globalize a) (globalize b)) b941 b942) in
  let mk_value i = #{ a94 = #{ a0 = (i + 0) }; b94 = Float.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t94 array = makearray_dynamic_local size #{ a94 = #{ a0 = 0 }; b94 = 1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 468;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 468 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 469;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 469 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a94] *)
    let el = #{ el with a94 = next_el.#a94 } in
    Idx_mut.unsafe_set a ((.(i).#a94) : (t94 array, _) idx_mut) next_el.#a94;
    mark_test_run 470;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 470 failed %d %d" size i;
    (* Path: [.#b94] *)
    let el = #{ el with b94 = next_el.#b94 } in
    Idx_mut.unsafe_set a ((.(i).#b94) : (t94 array, _) idx_mut) next_el.#b94;
    mark_test_run 471;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 471 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a94.#a0] *)
    let el = #{ el with a94 = #{ el.#a94 with a0 = next_el.#a94.#a0 } } in
    Idx_mut.unsafe_set a ((.(i).#a94.#a0) : (t94 array, _) idx_mut) next_el.#a94.#a0;
    mark_test_run 472;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 472 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t36 = #{ #{ int; int } }   *)
  (********************************)
  let eq = (fun #{ a36 = a361 } #{ a36 = a362 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a361 a362) in
  let mk_value i = #{ a36 = #{ a1 = (i + 0); b1 = (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t36 array = makearray_dynamic_local size #{ a36 = #{ a1 = 0; b1 = 1 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 473;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 473 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 474;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 474 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a36] *)
    let el = #{ el with a36 = next_el.#a36 } in
    Idx_mut.unsafe_set a ((.(i).#a36) : (t36 array, _) idx_mut) next_el.#a36;
    mark_test_run 475;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 475 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a36.#a1] *)
    let el = #{ el with a36 = #{ el.#a36 with a1 = next_el.#a36.#a1 } } in
    Idx_mut.unsafe_set a ((.(i).#a36.#a1) : (t36 array, _) idx_mut) next_el.#a36.#a1;
    mark_test_run 476;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 476 failed %d %d" size i;
    (* Path: [.#a36.#b1] *)
    let el = #{ el with a36 = #{ el.#a36 with b1 = next_el.#a36.#b1 } } in
    Idx_mut.unsafe_set a ((.(i).#a36.#b1) : (t36 array, _) idx_mut) next_el.#a36.#b1;
    mark_test_run 477;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 477 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t95 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun #{ a95 = a951; b95 = b951 } #{ a95 = a952; b95 = b952 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a951 a952 && (fun a b -> Int.equal a b) b951 b952) in
  let mk_value i = #{ a95 = #{ a1 = (i + 0); b1 = (i + 1) }; b95 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t95 array = makearray_dynamic_local size #{ a95 = #{ a1 = 0; b1 = 1 }; b95 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 478;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 478 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 479;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 479 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a95] *)
    let el = #{ el with a95 = next_el.#a95 } in
    Idx_mut.unsafe_set a ((.(i).#a95) : (t95 array, _) idx_mut) next_el.#a95;
    mark_test_run 480;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 480 failed %d %d" size i;
    (* Path: [.#b95] *)
    let el = #{ el with b95 = next_el.#b95 } in
    Idx_mut.unsafe_set a ((.(i).#b95) : (t95 array, _) idx_mut) next_el.#b95;
    mark_test_run 481;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 481 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a95.#a1] *)
    let el = #{ el with a95 = #{ el.#a95 with a1 = next_el.#a95.#a1 } } in
    Idx_mut.unsafe_set a ((.(i).#a95.#a1) : (t95 array, _) idx_mut) next_el.#a95.#a1;
    mark_test_run 482;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 482 failed %d %d" size i;
    (* Path: [.#a95.#b1] *)
    let el = #{ el with a95 = #{ el.#a95 with b1 = next_el.#a95.#b1 } } in
    Idx_mut.unsafe_set a ((.(i).#a95.#b1) : (t95 array, _) idx_mut) next_el.#a95.#b1;
    mark_test_run 483;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 483 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t96 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun #{ a96 = a961; b96 = b961 } #{ a96 = a962; b96 = b962 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a961 a962 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b961 b962) in
  let mk_value i = #{ a96 = #{ a1 = (i + 0); b1 = (i + 1) }; b96 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t96 array = makearray_dynamic_local size #{ a96 = #{ a1 = 0; b1 = 1 }; b96 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 484;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 484 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 485;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 485 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a96] *)
    let el = #{ el with a96 = next_el.#a96 } in
    Idx_mut.unsafe_set a ((.(i).#a96) : (t96 array, _) idx_mut) next_el.#a96;
    mark_test_run 486;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 486 failed %d %d" size i;
    (* Path: [.#b96] *)
    let el = #{ el with b96 = next_el.#b96 } in
    Idx_mut.unsafe_set a ((.(i).#b96) : (t96 array, _) idx_mut) next_el.#b96;
    mark_test_run 487;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 487 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a96.#a1] *)
    let el = #{ el with a96 = #{ el.#a96 with a1 = next_el.#a96.#a1 } } in
    Idx_mut.unsafe_set a ((.(i).#a96.#a1) : (t96 array, _) idx_mut) next_el.#a96.#a1;
    mark_test_run 488;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 488 failed %d %d" size i;
    (* Path: [.#a96.#b1] *)
    let el = #{ el with a96 = #{ el.#a96 with b1 = next_el.#a96.#b1 } } in
    Idx_mut.unsafe_set a ((.(i).#a96.#b1) : (t96 array, _) idx_mut) next_el.#a96.#b1;
    mark_test_run 489;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 489 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t97 = #{ #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun #{ a97 = a971; b97 = b971 } #{ a97 = a972; b97 = b972 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a971 a972 && (fun a b -> Float.equal (globalize a) (globalize b)) b971 b972) in
  let mk_value i = #{ a97 = #{ a1 = (i + 0); b1 = (i + 1) }; b97 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t97 array = makearray_dynamic_local size #{ a97 = #{ a1 = 0; b1 = 1 }; b97 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 490;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 490 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 491;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 491 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a97] *)
    let el = #{ el with a97 = next_el.#a97 } in
    Idx_mut.unsafe_set a ((.(i).#a97) : (t97 array, _) idx_mut) next_el.#a97;
    mark_test_run 492;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 492 failed %d %d" size i;
    (* Path: [.#b97] *)
    let el = #{ el with b97 = next_el.#b97 } in
    Idx_mut.unsafe_set a ((.(i).#b97) : (t97 array, _) idx_mut) next_el.#b97;
    mark_test_run 493;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 493 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a97.#a1] *)
    let el = #{ el with a97 = #{ el.#a97 with a1 = next_el.#a97.#a1 } } in
    Idx_mut.unsafe_set a ((.(i).#a97.#a1) : (t97 array, _) idx_mut) next_el.#a97.#a1;
    mark_test_run 494;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 494 failed %d %d" size i;
    (* Path: [.#a97.#b1] *)
    let el = #{ el with a97 = #{ el.#a97 with b1 = next_el.#a97.#b1 } } in
    Idx_mut.unsafe_set a ((.(i).#a97.#b1) : (t97 array, _) idx_mut) next_el.#a97.#b1;
    mark_test_run 495;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 495 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t38 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun #{ a38 = a381 } #{ a38 = a382 } -> (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a381 a382) in
  let mk_value i = #{ a38 = #{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t38 array = makearray_dynamic_local size #{ a38 = #{ a7 = 0; b7 = #1l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 496;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 496 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 497;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 497 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a38] *)
    let el = #{ el with a38 = next_el.#a38 } in
    Idx_mut.unsafe_set a ((.(i).#a38) : (t38 array, _) idx_mut) next_el.#a38;
    mark_test_run 498;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 498 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a38.#a7] *)
    let el = #{ el with a38 = #{ el.#a38 with a7 = next_el.#a38.#a7 } } in
    Idx_mut.unsafe_set a ((.(i).#a38.#a7) : (t38 array, _) idx_mut) next_el.#a38.#a7;
    mark_test_run 499;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 499 failed %d %d" size i;
    (* Path: [.#a38.#b7] *)
    let el = #{ el with a38 = #{ el.#a38 with b7 = next_el.#a38.#b7 } } in
    Idx_mut.unsafe_set a ((.(i).#a38.#b7) : (t38 array, _) idx_mut) next_el.#a38.#b7;
    mark_test_run 500;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 500 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t98 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun #{ a98 = a981; b98 = b981 } #{ a98 = a982; b98 = b982 } -> (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a981 a982 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b981 b982) in
  let mk_value i = #{ a98 = #{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) }; b98 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t98 array = makearray_dynamic_local size #{ a98 = #{ a7 = 0; b7 = #1l }; b98 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 501;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 501 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 502;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 502 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a98] *)
    let el = #{ el with a98 = next_el.#a98 } in
    Idx_mut.unsafe_set a ((.(i).#a98) : (t98 array, _) idx_mut) next_el.#a98;
    mark_test_run 503;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 503 failed %d %d" size i;
    (* Path: [.#b98] *)
    let el = #{ el with b98 = next_el.#b98 } in
    Idx_mut.unsafe_set a ((.(i).#b98) : (t98 array, _) idx_mut) next_el.#b98;
    mark_test_run 504;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 504 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a98.#a7] *)
    let el = #{ el with a98 = #{ el.#a98 with a7 = next_el.#a98.#a7 } } in
    Idx_mut.unsafe_set a ((.(i).#a98.#a7) : (t98 array, _) idx_mut) next_el.#a98.#a7;
    mark_test_run 505;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 505 failed %d %d" size i;
    (* Path: [.#a98.#b7] *)
    let el = #{ el with a98 = #{ el.#a98 with b7 = next_el.#a98.#b7 } } in
    Idx_mut.unsafe_set a ((.(i).#a98.#b7) : (t98 array, _) idx_mut) next_el.#a98.#b7;
    mark_test_run 506;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 506 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t40 = #{ #{ int; float } }   *)
  (**********************************)
  let eq = (fun #{ a40 = a401 } #{ a40 = a402 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a401 a402) in
  let mk_value i = #{ a40 = #{ a10 = (i + 0); b10 = Float.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t40 array = makearray_dynamic_local size #{ a40 = #{ a10 = 0; b10 = 1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 507;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 507 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 508;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 508 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a40] *)
    let el = #{ el with a40 = next_el.#a40 } in
    Idx_mut.unsafe_set a ((.(i).#a40) : (t40 array, _) idx_mut) next_el.#a40;
    mark_test_run 509;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 509 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a40.#a10] *)
    let el = #{ el with a40 = #{ el.#a40 with a10 = next_el.#a40.#a10 } } in
    Idx_mut.unsafe_set a ((.(i).#a40.#a10) : (t40 array, _) idx_mut) next_el.#a40.#a10;
    mark_test_run 510;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 510 failed %d %d" size i;
    (* Path: [.#a40.#b10] *)
    let el = #{ el with a40 = #{ el.#a40 with b10 = next_el.#a40.#b10 } } in
    Idx_mut.unsafe_set a ((.(i).#a40.#b10) : (t40 array, _) idx_mut) next_el.#a40.#b10;
    mark_test_run 511;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 511 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t99 = #{ #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun #{ a99 = a991; b99 = b991 } #{ a99 = a992; b99 = b992 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let mk_value i = #{ a99 = #{ a10 = (i + 0); b10 = Float.of_int (i + 1) }; b99 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t99 array = makearray_dynamic_local size #{ a99 = #{ a10 = 0; b10 = 1. }; b99 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 512;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 512 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 513;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 513 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a99] *)
    let el = #{ el with a99 = next_el.#a99 } in
    Idx_mut.unsafe_set a ((.(i).#a99) : (t99 array, _) idx_mut) next_el.#a99;
    mark_test_run 514;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 514 failed %d %d" size i;
    (* Path: [.#b99] *)
    let el = #{ el with b99 = next_el.#b99 } in
    Idx_mut.unsafe_set a ((.(i).#b99) : (t99 array, _) idx_mut) next_el.#b99;
    mark_test_run 515;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 515 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a99.#a10] *)
    let el = #{ el with a99 = #{ el.#a99 with a10 = next_el.#a99.#a10 } } in
    Idx_mut.unsafe_set a ((.(i).#a99.#a10) : (t99 array, _) idx_mut) next_el.#a99.#a10;
    mark_test_run 516;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 516 failed %d %d" size i;
    (* Path: [.#a99.#b10] *)
    let el = #{ el with a99 = #{ el.#a99 with b10 = next_el.#a99.#b10 } } in
    Idx_mut.unsafe_set a ((.(i).#a99.#b10) : (t99 array, _) idx_mut) next_el.#a99.#b10;
    mark_test_run 517;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 517 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************************)
  (*   t100 = #{ #{ int; float }; float }   *)
  (******************************************)
  let eq = (fun #{ a100 = a1001; b100 = b1001 } #{ a100 = a1002; b100 = b1002 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1001 a1002 && (fun a b -> Float.equal (globalize a) (globalize b)) b1001 b1002) in
  let mk_value i = #{ a100 = #{ a10 = (i + 0); b10 = Float.of_int (i + 1) }; b100 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t100 array = makearray_dynamic_local size #{ a100 = #{ a10 = 0; b10 = 1. }; b100 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 518;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 518 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 519;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 519 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a100] *)
    let el = #{ el with a100 = next_el.#a100 } in
    Idx_mut.unsafe_set a ((.(i).#a100) : (t100 array, _) idx_mut) next_el.#a100;
    mark_test_run 520;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 520 failed %d %d" size i;
    (* Path: [.#b100] *)
    let el = #{ el with b100 = next_el.#b100 } in
    Idx_mut.unsafe_set a ((.(i).#b100) : (t100 array, _) idx_mut) next_el.#b100;
    mark_test_run 521;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 521 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a100.#a10] *)
    let el = #{ el with a100 = #{ el.#a100 with a10 = next_el.#a100.#a10 } } in
    Idx_mut.unsafe_set a ((.(i).#a100.#a10) : (t100 array, _) idx_mut) next_el.#a100.#a10;
    mark_test_run 522;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 522 failed %d %d" size i;
    (* Path: [.#a100.#b10] *)
    let el = #{ el with a100 = #{ el.#a100 with b10 = next_el.#a100.#b10 } } in
    Idx_mut.unsafe_set a ((.(i).#a100.#b10) : (t100 array, _) idx_mut) next_el.#a100.#b10;
    mark_test_run 523;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 523 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t101 = #{ #{ int; #{ int; int } } }   *)
  (*******************************************)
  let eq = (fun #{ a101 = a1011 } #{ a101 = a1012 } -> (fun #{ a14 = a141; b14 = b141 } #{ a14 = a142; b14 = b142 } -> (fun a b -> Int.equal a b) a141 a142 && (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b141 b142) a1011 a1012) in
  let mk_value i = #{ a101 = #{ a14 = (i + 0); b14 = #{ a1 = (i + 1); b1 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t101 array = makearray_dynamic_local size #{ a101 = #{ a14 = 0; b14 = #{ a1 = 1; b1 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 524;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 524 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 525;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 525 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a101] *)
    let el = #{ el with a101 = next_el.#a101 } in
    Idx_mut.unsafe_set a ((.(i).#a101) : (t101 array, _) idx_mut) next_el.#a101;
    mark_test_run 526;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 526 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a101.#a14] *)
    let el = #{ el with a101 = #{ el.#a101 with a14 = next_el.#a101.#a14 } } in
    Idx_mut.unsafe_set a ((.(i).#a101.#a14) : (t101 array, _) idx_mut) next_el.#a101.#a14;
    mark_test_run 527;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 527 failed %d %d" size i;
    (* Path: [.#a101.#b14] *)
    let el = #{ el with a101 = #{ el.#a101 with b14 = next_el.#a101.#b14 } } in
    Idx_mut.unsafe_set a ((.(i).#a101.#b14) : (t101 array, _) idx_mut) next_el.#a101.#b14;
    mark_test_run 528;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 528 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a101.#b14.#a1] *)
    let el = #{ el with a101 = #{ el.#a101 with b14 = #{ el.#a101.#b14 with a1 = next_el.#a101.#b14.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a101.#b14.#a1) : (t101 array, _) idx_mut) next_el.#a101.#b14.#a1;
    mark_test_run 529;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 529 failed %d %d" size i;
    (* Path: [.#a101.#b14.#b1] *)
    let el = #{ el with a101 = #{ el.#a101 with b14 = #{ el.#a101.#b14 with b1 = next_el.#a101.#b14.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a101.#b14.#b1) : (t101 array, _) idx_mut) next_el.#a101.#b14.#b1;
    mark_test_run 530;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 530 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t102 = #{ #{ int; #{ int; int32# } } }   *)
  (**********************************************)
  let eq = (fun #{ a102 = a1021 } #{ a102 = a1022 } -> (fun #{ a15 = a151; b15 = b151 } #{ a15 = a152; b15 = b152 } -> (fun a b -> Int.equal a b) a151 a152 && (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b151 b152) a1021 a1022) in
  let mk_value i = #{ a102 = #{ a15 = (i + 0); b15 = #{ a7 = (i + 1); b7 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t102 array = makearray_dynamic_local size #{ a102 = #{ a15 = 0; b15 = #{ a7 = 1; b7 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 531;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 531 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 532;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 532 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a102] *)
    let el = #{ el with a102 = next_el.#a102 } in
    Idx_mut.unsafe_set a ((.(i).#a102) : (t102 array, _) idx_mut) next_el.#a102;
    mark_test_run 533;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 533 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a102.#a15] *)
    let el = #{ el with a102 = #{ el.#a102 with a15 = next_el.#a102.#a15 } } in
    Idx_mut.unsafe_set a ((.(i).#a102.#a15) : (t102 array, _) idx_mut) next_el.#a102.#a15;
    mark_test_run 534;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 534 failed %d %d" size i;
    (* Path: [.#a102.#b15] *)
    let el = #{ el with a102 = #{ el.#a102 with b15 = next_el.#a102.#b15 } } in
    Idx_mut.unsafe_set a ((.(i).#a102.#b15) : (t102 array, _) idx_mut) next_el.#a102.#b15;
    mark_test_run 535;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 535 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a102.#b15.#a7] *)
    let el = #{ el with a102 = #{ el.#a102 with b15 = #{ el.#a102.#b15 with a7 = next_el.#a102.#b15.#a7 } } } in
    Idx_mut.unsafe_set a ((.(i).#a102.#b15.#a7) : (t102 array, _) idx_mut) next_el.#a102.#b15.#a7;
    mark_test_run 536;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 536 failed %d %d" size i;
    (* Path: [.#a102.#b15.#b7] *)
    let el = #{ el with a102 = #{ el.#a102 with b15 = #{ el.#a102.#b15 with b7 = next_el.#a102.#b15.#b7 } } } in
    Idx_mut.unsafe_set a ((.(i).#a102.#b15.#b7) : (t102 array, _) idx_mut) next_el.#a102.#b15.#b7;
    mark_test_run 537;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 537 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t103 = #{ #{ int; #{ int; float } } }   *)
  (*********************************************)
  let eq = (fun #{ a103 = a1031 } #{ a103 = a1032 } -> (fun #{ a16 = a161; b16 = b161 } #{ a16 = a162; b16 = b162 } -> (fun a b -> Int.equal a b) a161 a162 && (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b161 b162) a1031 a1032) in
  let mk_value i = #{ a103 = #{ a16 = (i + 0); b16 = #{ a10 = (i + 1); b10 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t103 array = makearray_dynamic_local size #{ a103 = #{ a16 = 0; b16 = #{ a10 = 1; b10 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 538;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 538 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 539;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 539 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a103] *)
    let el = #{ el with a103 = next_el.#a103 } in
    Idx_mut.unsafe_set a ((.(i).#a103) : (t103 array, _) idx_mut) next_el.#a103;
    mark_test_run 540;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 540 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a103.#a16] *)
    let el = #{ el with a103 = #{ el.#a103 with a16 = next_el.#a103.#a16 } } in
    Idx_mut.unsafe_set a ((.(i).#a103.#a16) : (t103 array, _) idx_mut) next_el.#a103.#a16;
    mark_test_run 541;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 541 failed %d %d" size i;
    (* Path: [.#a103.#b16] *)
    let el = #{ el with a103 = #{ el.#a103 with b16 = next_el.#a103.#b16 } } in
    Idx_mut.unsafe_set a ((.(i).#a103.#b16) : (t103 array, _) idx_mut) next_el.#a103.#b16;
    mark_test_run 542;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 542 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a103.#b16.#a10] *)
    let el = #{ el with a103 = #{ el.#a103 with b16 = #{ el.#a103.#b16 with a10 = next_el.#a103.#b16.#a10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a103.#b16.#a10) : (t103 array, _) idx_mut) next_el.#a103.#b16.#a10;
    mark_test_run 543;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 543 failed %d %d" size i;
    (* Path: [.#a103.#b16.#b10] *)
    let el = #{ el with a103 = #{ el.#a103 with b16 = #{ el.#a103.#b16 with b10 = next_el.#a103.#b16.#b10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a103.#b16.#b10) : (t103 array, _) idx_mut) next_el.#a103.#b16.#b10;
    mark_test_run 544;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 544 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************************)
  (*   t104 = #{ #{ int; #{ int32#; int32# } } }   *)
  (*************************************************)
  let eq = (fun #{ a104 = a1041 } #{ a104 = a1042 } -> (fun #{ a25 = a251; b25 = b251 } #{ a25 = a252; b25 = b252 } -> (fun a b -> Int.equal a b) a251 a252 && (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) b251 b252) a1041 a1042) in
  let mk_value i = #{ a104 = #{ a25 = (i + 0); b25 = #{ a24 = Int32_u.of_int (i + 1); b24 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t104 array = makearray_dynamic_local size #{ a104 = #{ a25 = 0; b25 = #{ a24 = #1l; b24 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 545;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 545 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 546;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 546 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a104] *)
    let el = #{ el with a104 = next_el.#a104 } in
    Idx_mut.unsafe_set a ((.(i).#a104) : (t104 array, _) idx_mut) next_el.#a104;
    mark_test_run 547;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 547 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a104.#a25] *)
    let el = #{ el with a104 = #{ el.#a104 with a25 = next_el.#a104.#a25 } } in
    Idx_mut.unsafe_set a ((.(i).#a104.#a25) : (t104 array, _) idx_mut) next_el.#a104.#a25;
    mark_test_run 548;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 548 failed %d %d" size i;
    (* Path: [.#a104.#b25] *)
    let el = #{ el with a104 = #{ el.#a104 with b25 = next_el.#a104.#b25 } } in
    Idx_mut.unsafe_set a ((.(i).#a104.#b25) : (t104 array, _) idx_mut) next_el.#a104.#b25;
    mark_test_run 549;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 549 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a104.#b25.#a24] *)
    let el = #{ el with a104 = #{ el.#a104 with b25 = #{ el.#a104.#b25 with a24 = next_el.#a104.#b25.#a24 } } } in
    Idx_mut.unsafe_set a ((.(i).#a104.#b25.#a24) : (t104 array, _) idx_mut) next_el.#a104.#b25.#a24;
    mark_test_run 550;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 550 failed %d %d" size i;
    (* Path: [.#a104.#b25.#b24] *)
    let el = #{ el with a104 = #{ el.#a104 with b25 = #{ el.#a104.#b25 with b24 = next_el.#a104.#b25.#b24 } } } in
    Idx_mut.unsafe_set a ((.(i).#a104.#b25.#b24) : (t104 array, _) idx_mut) next_el.#a104.#b25.#b24;
    mark_test_run 551;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 551 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t105 = #{ #{ int; #{ float; int } } }   *)
  (*********************************************)
  let eq = (fun #{ a105 = a1051 } #{ a105 = a1052 } -> (fun #{ a29 = a291; b29 = b291 } #{ a29 = a292; b29 = b292 } -> (fun a b -> Int.equal a b) a291 a292 && (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) b291 b292) a1051 a1052) in
  let mk_value i = #{ a105 = #{ a29 = (i + 0); b29 = #{ a28 = Float.of_int (i + 1); b28 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t105 array = makearray_dynamic_local size #{ a105 = #{ a29 = 0; b29 = #{ a28 = 1.; b28 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 552;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 552 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 553;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 553 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a105] *)
    let el = #{ el with a105 = next_el.#a105 } in
    Idx_mut.unsafe_set a ((.(i).#a105) : (t105 array, _) idx_mut) next_el.#a105;
    mark_test_run 554;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 554 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a105.#a29] *)
    let el = #{ el with a105 = #{ el.#a105 with a29 = next_el.#a105.#a29 } } in
    Idx_mut.unsafe_set a ((.(i).#a105.#a29) : (t105 array, _) idx_mut) next_el.#a105.#a29;
    mark_test_run 555;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 555 failed %d %d" size i;
    (* Path: [.#a105.#b29] *)
    let el = #{ el with a105 = #{ el.#a105 with b29 = next_el.#a105.#b29 } } in
    Idx_mut.unsafe_set a ((.(i).#a105.#b29) : (t105 array, _) idx_mut) next_el.#a105.#b29;
    mark_test_run 556;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 556 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a105.#b29.#a28] *)
    let el = #{ el with a105 = #{ el.#a105 with b29 = #{ el.#a105.#b29 with a28 = next_el.#a105.#b29.#a28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a105.#b29.#a28) : (t105 array, _) idx_mut) next_el.#a105.#b29.#a28;
    mark_test_run 557;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 557 failed %d %d" size i;
    (* Path: [.#a105.#b29.#b28] *)
    let el = #{ el with a105 = #{ el.#a105 with b29 = #{ el.#a105.#b29 with b28 = next_el.#a105.#b29.#b28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a105.#b29.#b28) : (t105 array, _) idx_mut) next_el.#a105.#b29.#b28;
    mark_test_run 558;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 558 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t106 = #{ #{ int; #{ float; float } } }   *)
  (***********************************************)
  let eq = (fun #{ a106 = a1061 } #{ a106 = a1062 } -> (fun #{ a31 = a311; b31 = b311 } #{ a31 = a312; b31 = b312 } -> (fun a b -> Int.equal a b) a311 a312 && (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) b311 b312) a1061 a1062) in
  let mk_value i = #{ a106 = #{ a31 = (i + 0); b31 = #{ a30 = Float.of_int (i + 1); b30 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t106 array = makearray_dynamic_local size #{ a106 = #{ a31 = 0; b31 = #{ a30 = 1.; b30 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 559;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 559 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 560;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 560 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a106] *)
    let el = #{ el with a106 = next_el.#a106 } in
    Idx_mut.unsafe_set a ((.(i).#a106) : (t106 array, _) idx_mut) next_el.#a106;
    mark_test_run 561;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 561 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a106.#a31] *)
    let el = #{ el with a106 = #{ el.#a106 with a31 = next_el.#a106.#a31 } } in
    Idx_mut.unsafe_set a ((.(i).#a106.#a31) : (t106 array, _) idx_mut) next_el.#a106.#a31;
    mark_test_run 562;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 562 failed %d %d" size i;
    (* Path: [.#a106.#b31] *)
    let el = #{ el with a106 = #{ el.#a106 with b31 = next_el.#a106.#b31 } } in
    Idx_mut.unsafe_set a ((.(i).#a106.#b31) : (t106 array, _) idx_mut) next_el.#a106.#b31;
    mark_test_run 563;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 563 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a106.#b31.#a30] *)
    let el = #{ el with a106 = #{ el.#a106 with b31 = #{ el.#a106.#b31 with a30 = next_el.#a106.#b31.#a30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a106.#b31.#a30) : (t106 array, _) idx_mut) next_el.#a106.#b31.#a30;
    mark_test_run 564;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 564 failed %d %d" size i;
    (* Path: [.#a106.#b31.#b30] *)
    let el = #{ el with a106 = #{ el.#a106 with b31 = #{ el.#a106.#b31 with b30 = next_el.#a106.#b31.#b30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a106.#b31.#b30) : (t106 array, _) idx_mut) next_el.#a106.#b31.#b30;
    mark_test_run 565;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 565 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t107 = #{ #{ int32# } }   *)
  (*******************************)
  let eq = (fun #{ a107 = a1071 } #{ a107 = a1072 } -> (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) a1071 a1072) in
  let mk_value i = #{ a107 = #{ a18 = Int32_u.of_int (i + 0) } } in
  (* Create an array of size [size] *)
  let a : t107 array = makearray_dynamic_local size #{ a107 = #{ a18 = #0l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 566;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 566 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 567;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 567 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a107] *)
    let el = #{ el with a107 = next_el.#a107 } in
    Idx_mut.unsafe_set a ((.(i).#a107) : (t107 array, _) idx_mut) next_el.#a107;
    mark_test_run 568;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 568 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a107.#a18] *)
    let el = #{ el with a107 = #{ el.#a107 with a18 = next_el.#a107.#a18 } } in
    Idx_mut.unsafe_set a ((.(i).#a107.#a18) : (t107 array, _) idx_mut) next_el.#a107.#a18;
    mark_test_run 569;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 569 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t108 = #{ #{ int32# }; int32# }   *)
  (***************************************)
  let eq = (fun #{ a108 = a1081; b108 = b1081 } #{ a108 = a1082; b108 = b1082 } -> (fun #{ a18 = a181 } #{ a18 = a182 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a181 a182) a1081 a1082 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1081 b1082) in
  let mk_value i = #{ a108 = #{ a18 = Int32_u.of_int (i + 0) }; b108 = Int32_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t108 array = makearray_dynamic_local size #{ a108 = #{ a18 = #0l }; b108 = #1l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 570;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 570 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 571;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 571 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a108] *)
    let el = #{ el with a108 = next_el.#a108 } in
    Idx_mut.unsafe_set a ((.(i).#a108) : (t108 array, _) idx_mut) next_el.#a108;
    mark_test_run 572;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 572 failed %d %d" size i;
    (* Path: [.#b108] *)
    let el = #{ el with b108 = next_el.#b108 } in
    Idx_mut.unsafe_set a ((.(i).#b108) : (t108 array, _) idx_mut) next_el.#b108;
    mark_test_run 573;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 573 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a108.#a18] *)
    let el = #{ el with a108 = #{ el.#a108 with a18 = next_el.#a108.#a18 } } in
    Idx_mut.unsafe_set a ((.(i).#a108.#a18) : (t108 array, _) idx_mut) next_el.#a108.#a18;
    mark_test_run 574;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 574 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t42 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun #{ a42 = a421 } #{ a42 = a422 } -> (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) a421 a422) in
  let mk_value i = #{ a42 = #{ a24 = Int32_u.of_int (i + 0); b24 = Int32_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t42 array = makearray_dynamic_local size #{ a42 = #{ a24 = #0l; b24 = #1l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 575;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 575 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 576;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 576 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a42] *)
    let el = #{ el with a42 = next_el.#a42 } in
    Idx_mut.unsafe_set a ((.(i).#a42) : (t42 array, _) idx_mut) next_el.#a42;
    mark_test_run 577;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 577 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a42.#a24] *)
    let el = #{ el with a42 = #{ el.#a42 with a24 = next_el.#a42.#a24 } } in
    Idx_mut.unsafe_set a ((.(i).#a42.#a24) : (t42 array, _) idx_mut) next_el.#a42.#a24;
    mark_test_run 578;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 578 failed %d %d" size i;
    (* Path: [.#a42.#b24] *)
    let el = #{ el with a42 = #{ el.#a42 with b24 = next_el.#a42.#b24 } } in
    Idx_mut.unsafe_set a ((.(i).#a42.#b24) : (t42 array, _) idx_mut) next_el.#a42.#b24;
    mark_test_run 579;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 579 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t109 = #{ #{ int32#; int32# }; int32# }   *)
  (***********************************************)
  let eq = (fun #{ a109 = a1091; b109 = b1091 } #{ a109 = a1092; b109 = b1092 } -> (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) a1091 a1092 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1091 b1092) in
  let mk_value i = #{ a109 = #{ a24 = Int32_u.of_int (i + 0); b24 = Int32_u.of_int (i + 1) }; b109 = Int32_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t109 array = makearray_dynamic_local size #{ a109 = #{ a24 = #0l; b24 = #1l }; b109 = #2l } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 580;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 580 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 581;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 581 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a109] *)
    let el = #{ el with a109 = next_el.#a109 } in
    Idx_mut.unsafe_set a ((.(i).#a109) : (t109 array, _) idx_mut) next_el.#a109;
    mark_test_run 582;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 582 failed %d %d" size i;
    (* Path: [.#b109] *)
    let el = #{ el with b109 = next_el.#b109 } in
    Idx_mut.unsafe_set a ((.(i).#b109) : (t109 array, _) idx_mut) next_el.#b109;
    mark_test_run 583;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 583 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a109.#a24] *)
    let el = #{ el with a109 = #{ el.#a109 with a24 = next_el.#a109.#a24 } } in
    Idx_mut.unsafe_set a ((.(i).#a109.#a24) : (t109 array, _) idx_mut) next_el.#a109.#a24;
    mark_test_run 584;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 584 failed %d %d" size i;
    (* Path: [.#a109.#b24] *)
    let el = #{ el with a109 = #{ el.#a109 with b24 = next_el.#a109.#b24 } } in
    Idx_mut.unsafe_set a ((.(i).#a109.#b24) : (t109 array, _) idx_mut) next_el.#a109.#b24;
    mark_test_run 585;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 585 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************************)
  (*   t110 = #{ #{ int32#; #{ int32#; int32# } } }   *)
  (****************************************************)
  let eq = (fun #{ a110 = a1101 } #{ a110 = a1102 } -> (fun #{ a59 = a591; b59 = b591 } #{ a59 = a592; b59 = b592 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a591 a592 && (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) b591 b592) a1101 a1102) in
  let mk_value i = #{ a110 = #{ a59 = Int32_u.of_int (i + 0); b59 = #{ a24 = Int32_u.of_int (i + 1); b24 = Int32_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t110 array = makearray_dynamic_local size #{ a110 = #{ a59 = #0l; b59 = #{ a24 = #1l; b24 = #2l } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 586;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 586 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 587;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 587 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a110] *)
    let el = #{ el with a110 = next_el.#a110 } in
    Idx_mut.unsafe_set a ((.(i).#a110) : (t110 array, _) idx_mut) next_el.#a110;
    mark_test_run 588;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 588 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a110.#a59] *)
    let el = #{ el with a110 = #{ el.#a110 with a59 = next_el.#a110.#a59 } } in
    Idx_mut.unsafe_set a ((.(i).#a110.#a59) : (t110 array, _) idx_mut) next_el.#a110.#a59;
    mark_test_run 589;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 589 failed %d %d" size i;
    (* Path: [.#a110.#b59] *)
    let el = #{ el with a110 = #{ el.#a110 with b59 = next_el.#a110.#b59 } } in
    Idx_mut.unsafe_set a ((.(i).#a110.#b59) : (t110 array, _) idx_mut) next_el.#a110.#b59;
    mark_test_run 590;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 590 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a110.#b59.#a24] *)
    let el = #{ el with a110 = #{ el.#a110 with b59 = #{ el.#a110.#b59 with a24 = next_el.#a110.#b59.#a24 } } } in
    Idx_mut.unsafe_set a ((.(i).#a110.#b59.#a24) : (t110 array, _) idx_mut) next_el.#a110.#b59.#a24;
    mark_test_run 591;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 591 failed %d %d" size i;
    (* Path: [.#a110.#b59.#b24] *)
    let el = #{ el with a110 = #{ el.#a110 with b59 = #{ el.#a110.#b59 with b24 = next_el.#a110.#b59.#b24 } } } in
    Idx_mut.unsafe_set a ((.(i).#a110.#b59.#b24) : (t110 array, _) idx_mut) next_el.#a110.#b59.#b24;
    mark_test_run 592;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 592 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t111 = #{ #{ float }; int }   *)
  (***********************************)
  let eq = (fun #{ a111 = a1111; b111 = b1111 } #{ a111 = a1112; b111 = b1112 } -> (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1111 a1112 && (fun a b -> Int.equal a b) b1111 b1112) in
  let mk_value i = #{ a111 = #{ a21 = Float.of_int (i + 0) }; b111 = (i + 1) } in
  (* Create an array of size [size] *)
  let a : t111 array = makearray_dynamic_local size #{ a111 = #{ a21 = 0. }; b111 = 1 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 593;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 593 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 594;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 594 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a111] *)
    let el = #{ el with a111 = next_el.#a111 } in
    Idx_mut.unsafe_set a ((.(i).#a111) : (t111 array, _) idx_mut) next_el.#a111;
    mark_test_run 595;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 595 failed %d %d" size i;
    (* Path: [.#b111] *)
    let el = #{ el with b111 = next_el.#b111 } in
    Idx_mut.unsafe_set a ((.(i).#b111) : (t111 array, _) idx_mut) next_el.#b111;
    mark_test_run 596;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 596 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a111.#a21] *)
    let el = #{ el with a111 = #{ el.#a111 with a21 = next_el.#a111.#a21 } } in
    Idx_mut.unsafe_set a ((.(i).#a111.#a21) : (t111 array, _) idx_mut) next_el.#a111.#a21;
    mark_test_run 597;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 597 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t112 = #{ #{ float }; float }   *)
  (*************************************)
  let eq = (fun #{ a112 = a1121; b112 = b1121 } #{ a112 = a1122; b112 = b1122 } -> (fun #{ a21 = a211 } #{ a21 = a212 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1121 a1122 && (fun a b -> Float.equal (globalize a) (globalize b)) b1121 b1122) in
  let mk_value i = #{ a112 = #{ a21 = Float.of_int (i + 0) }; b112 = Float.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t112 array = makearray_dynamic_local size #{ a112 = #{ a21 = 0. }; b112 = 1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 598;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 598 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 599;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 599 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a112] *)
    let el = #{ el with a112 = next_el.#a112 } in
    Idx_mut.unsafe_set a ((.(i).#a112) : (t112 array, _) idx_mut) next_el.#a112;
    mark_test_run 600;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 600 failed %d %d" size i;
    (* Path: [.#b112] *)
    let el = #{ el with b112 = next_el.#b112 } in
    Idx_mut.unsafe_set a ((.(i).#b112) : (t112 array, _) idx_mut) next_el.#b112;
    mark_test_run 601;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 601 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a112.#a21] *)
    let el = #{ el with a112 = #{ el.#a112 with a21 = next_el.#a112.#a21 } } in
    Idx_mut.unsafe_set a ((.(i).#a112.#a21) : (t112 array, _) idx_mut) next_el.#a112.#a21;
    mark_test_run 602;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 602 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t44 = #{ #{ float; int } }   *)
  (**********************************)
  let eq = (fun #{ a44 = a441 } #{ a44 = a442 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a441 a442) in
  let mk_value i = #{ a44 = #{ a28 = Float.of_int (i + 0); b28 = (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t44 array = makearray_dynamic_local size #{ a44 = #{ a28 = 0.; b28 = 1 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 603;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 603 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 604;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 604 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a44] *)
    let el = #{ el with a44 = next_el.#a44 } in
    Idx_mut.unsafe_set a ((.(i).#a44) : (t44 array, _) idx_mut) next_el.#a44;
    mark_test_run 605;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 605 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a44.#a28] *)
    let el = #{ el with a44 = #{ el.#a44 with a28 = next_el.#a44.#a28 } } in
    Idx_mut.unsafe_set a ((.(i).#a44.#a28) : (t44 array, _) idx_mut) next_el.#a44.#a28;
    mark_test_run 606;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 606 failed %d %d" size i;
    (* Path: [.#a44.#b28] *)
    let el = #{ el with a44 = #{ el.#a44 with b28 = next_el.#a44.#b28 } } in
    Idx_mut.unsafe_set a ((.(i).#a44.#b28) : (t44 array, _) idx_mut) next_el.#a44.#b28;
    mark_test_run 607;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 607 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t113 = #{ #{ float; int }; int }   *)
  (****************************************)
  let eq = (fun #{ a113 = a1131; b113 = b1131 } #{ a113 = a1132; b113 = b1132 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a1131 a1132 && (fun a b -> Int.equal a b) b1131 b1132) in
  let mk_value i = #{ a113 = #{ a28 = Float.of_int (i + 0); b28 = (i + 1) }; b113 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t113 array = makearray_dynamic_local size #{ a113 = #{ a28 = 0.; b28 = 1 }; b113 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 608;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 608 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 609;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 609 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a113] *)
    let el = #{ el with a113 = next_el.#a113 } in
    Idx_mut.unsafe_set a ((.(i).#a113) : (t113 array, _) idx_mut) next_el.#a113;
    mark_test_run 610;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 610 failed %d %d" size i;
    (* Path: [.#b113] *)
    let el = #{ el with b113 = next_el.#b113 } in
    Idx_mut.unsafe_set a ((.(i).#b113) : (t113 array, _) idx_mut) next_el.#b113;
    mark_test_run 611;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 611 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a113.#a28] *)
    let el = #{ el with a113 = #{ el.#a113 with a28 = next_el.#a113.#a28 } } in
    Idx_mut.unsafe_set a ((.(i).#a113.#a28) : (t113 array, _) idx_mut) next_el.#a113.#a28;
    mark_test_run 612;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 612 failed %d %d" size i;
    (* Path: [.#a113.#b28] *)
    let el = #{ el with a113 = #{ el.#a113 with b28 = next_el.#a113.#b28 } } in
    Idx_mut.unsafe_set a ((.(i).#a113.#b28) : (t113 array, _) idx_mut) next_el.#a113.#b28;
    mark_test_run 613;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 613 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************************)
  (*   t114 = #{ #{ float; int }; float }   *)
  (******************************************)
  let eq = (fun #{ a114 = a1141; b114 = b1141 } #{ a114 = a1142; b114 = b1142 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a1141 a1142 && (fun a b -> Float.equal (globalize a) (globalize b)) b1141 b1142) in
  let mk_value i = #{ a114 = #{ a28 = Float.of_int (i + 0); b28 = (i + 1) }; b114 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t114 array = makearray_dynamic_local size #{ a114 = #{ a28 = 0.; b28 = 1 }; b114 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 614;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 614 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 615;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 615 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a114] *)
    let el = #{ el with a114 = next_el.#a114 } in
    Idx_mut.unsafe_set a ((.(i).#a114) : (t114 array, _) idx_mut) next_el.#a114;
    mark_test_run 616;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 616 failed %d %d" size i;
    (* Path: [.#b114] *)
    let el = #{ el with b114 = next_el.#b114 } in
    Idx_mut.unsafe_set a ((.(i).#b114) : (t114 array, _) idx_mut) next_el.#b114;
    mark_test_run 617;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 617 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a114.#a28] *)
    let el = #{ el with a114 = #{ el.#a114 with a28 = next_el.#a114.#a28 } } in
    Idx_mut.unsafe_set a ((.(i).#a114.#a28) : (t114 array, _) idx_mut) next_el.#a114.#a28;
    mark_test_run 618;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 618 failed %d %d" size i;
    (* Path: [.#a114.#b28] *)
    let el = #{ el with a114 = #{ el.#a114 with b28 = next_el.#a114.#b28 } } in
    Idx_mut.unsafe_set a ((.(i).#a114.#b28) : (t114 array, _) idx_mut) next_el.#a114.#b28;
    mark_test_run 619;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 619 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t46 = #{ #{ float; float } }   *)
  (************************************)
  let eq = (fun #{ a46 = a461 } #{ a46 = a462 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a461 a462) in
  let mk_value i = #{ a46 = #{ a30 = Float.of_int (i + 0); b30 = Float.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t46 array = makearray_dynamic_local size #{ a46 = #{ a30 = 0.; b30 = 1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 620;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 620 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 621;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 621 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a46] *)
    let el = #{ el with a46 = next_el.#a46 } in
    Idx_mut.unsafe_set a ((.(i).#a46) : (t46 array, _) idx_mut) next_el.#a46;
    mark_test_run 622;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 622 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a46.#a30] *)
    let el = #{ el with a46 = #{ el.#a46 with a30 = next_el.#a46.#a30 } } in
    Idx_mut.unsafe_set a ((.(i).#a46.#a30) : (t46 array, _) idx_mut) next_el.#a46.#a30;
    mark_test_run 623;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 623 failed %d %d" size i;
    (* Path: [.#a46.#b30] *)
    let el = #{ el with a46 = #{ el.#a46 with b30 = next_el.#a46.#b30 } } in
    Idx_mut.unsafe_set a ((.(i).#a46.#b30) : (t46 array, _) idx_mut) next_el.#a46.#b30;
    mark_test_run 624;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 624 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************************)
  (*   t115 = #{ #{ float; float }; int }   *)
  (******************************************)
  let eq = (fun #{ a115 = a1151; b115 = b1151 } #{ a115 = a1152; b115 = b1152 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a1151 a1152 && (fun a b -> Int.equal a b) b1151 b1152) in
  let mk_value i = #{ a115 = #{ a30 = Float.of_int (i + 0); b30 = Float.of_int (i + 1) }; b115 = (i + 2) } in
  (* Create an array of size [size] *)
  let a : t115 array = makearray_dynamic_local size #{ a115 = #{ a30 = 0.; b30 = 1. }; b115 = 2 } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 625;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 625 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 626;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 626 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a115] *)
    let el = #{ el with a115 = next_el.#a115 } in
    Idx_mut.unsafe_set a ((.(i).#a115) : (t115 array, _) idx_mut) next_el.#a115;
    mark_test_run 627;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 627 failed %d %d" size i;
    (* Path: [.#b115] *)
    let el = #{ el with b115 = next_el.#b115 } in
    Idx_mut.unsafe_set a ((.(i).#b115) : (t115 array, _) idx_mut) next_el.#b115;
    mark_test_run 628;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 628 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a115.#a30] *)
    let el = #{ el with a115 = #{ el.#a115 with a30 = next_el.#a115.#a30 } } in
    Idx_mut.unsafe_set a ((.(i).#a115.#a30) : (t115 array, _) idx_mut) next_el.#a115.#a30;
    mark_test_run 629;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 629 failed %d %d" size i;
    (* Path: [.#a115.#b30] *)
    let el = #{ el with a115 = #{ el.#a115 with b30 = next_el.#a115.#b30 } } in
    Idx_mut.unsafe_set a ((.(i).#a115.#b30) : (t115 array, _) idx_mut) next_el.#a115.#b30;
    mark_test_run 630;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 630 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************)
  (*   t116 = #{ #{ float; float }; float }   *)
  (********************************************)
  let eq = (fun #{ a116 = a1161; b116 = b1161 } #{ a116 = a1162; b116 = b1162 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a1161 a1162 && (fun a b -> Float.equal (globalize a) (globalize b)) b1161 b1162) in
  let mk_value i = #{ a116 = #{ a30 = Float.of_int (i + 0); b30 = Float.of_int (i + 1) }; b116 = Float.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t116 array = makearray_dynamic_local size #{ a116 = #{ a30 = 0.; b30 = 1. }; b116 = 2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 631;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 631 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 632;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 632 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a116] *)
    let el = #{ el with a116 = next_el.#a116 } in
    Idx_mut.unsafe_set a ((.(i).#a116) : (t116 array, _) idx_mut) next_el.#a116;
    mark_test_run 633;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 633 failed %d %d" size i;
    (* Path: [.#b116] *)
    let el = #{ el with b116 = next_el.#b116 } in
    Idx_mut.unsafe_set a ((.(i).#b116) : (t116 array, _) idx_mut) next_el.#b116;
    mark_test_run 634;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 634 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a116.#a30] *)
    let el = #{ el with a116 = #{ el.#a116 with a30 = next_el.#a116.#a30 } } in
    Idx_mut.unsafe_set a ((.(i).#a116.#a30) : (t116 array, _) idx_mut) next_el.#a116.#a30;
    mark_test_run 635;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 635 failed %d %d" size i;
    (* Path: [.#a116.#b30] *)
    let el = #{ el with a116 = #{ el.#a116 with b30 = next_el.#a116.#b30 } } in
    Idx_mut.unsafe_set a ((.(i).#a116.#b30) : (t116 array, _) idx_mut) next_el.#a116.#b30;
    mark_test_run 636;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 636 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t117 = #{ #{ float; #{ int; int } } }   *)
  (*********************************************)
  let eq = (fun #{ a117 = a1171 } #{ a117 = a1172 } -> (fun #{ a71 = a711; b71 = b711 } #{ a71 = a712; b71 = b712 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a711 a712 && (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b711 b712) a1171 a1172) in
  let mk_value i = #{ a117 = #{ a71 = Float.of_int (i + 0); b71 = #{ a1 = (i + 1); b1 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t117 array = makearray_dynamic_local size #{ a117 = #{ a71 = 0.; b71 = #{ a1 = 1; b1 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 637;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 637 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 638;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 638 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a117] *)
    let el = #{ el with a117 = next_el.#a117 } in
    Idx_mut.unsafe_set a ((.(i).#a117) : (t117 array, _) idx_mut) next_el.#a117;
    mark_test_run 639;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 639 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a117.#a71] *)
    let el = #{ el with a117 = #{ el.#a117 with a71 = next_el.#a117.#a71 } } in
    Idx_mut.unsafe_set a ((.(i).#a117.#a71) : (t117 array, _) idx_mut) next_el.#a117.#a71;
    mark_test_run 640;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 640 failed %d %d" size i;
    (* Path: [.#a117.#b71] *)
    let el = #{ el with a117 = #{ el.#a117 with b71 = next_el.#a117.#b71 } } in
    Idx_mut.unsafe_set a ((.(i).#a117.#b71) : (t117 array, _) idx_mut) next_el.#a117.#b71;
    mark_test_run 641;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 641 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a117.#b71.#a1] *)
    let el = #{ el with a117 = #{ el.#a117 with b71 = #{ el.#a117.#b71 with a1 = next_el.#a117.#b71.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a117.#b71.#a1) : (t117 array, _) idx_mut) next_el.#a117.#b71.#a1;
    mark_test_run 642;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 642 failed %d %d" size i;
    (* Path: [.#a117.#b71.#b1] *)
    let el = #{ el with a117 = #{ el.#a117 with b71 = #{ el.#a117.#b71 with b1 = next_el.#a117.#b71.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a117.#b71.#b1) : (t117 array, _) idx_mut) next_el.#a117.#b71.#b1;
    mark_test_run 643;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 643 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t118 = #{ #{ float; #{ int; float } } }   *)
  (***********************************************)
  let eq = (fun #{ a118 = a1181 } #{ a118 = a1182 } -> (fun #{ a72 = a721; b72 = b721 } #{ a72 = a722; b72 = b722 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a721 a722 && (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b721 b722) a1181 a1182) in
  let mk_value i = #{ a118 = #{ a72 = Float.of_int (i + 0); b72 = #{ a10 = (i + 1); b10 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t118 array = makearray_dynamic_local size #{ a118 = #{ a72 = 0.; b72 = #{ a10 = 1; b10 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 644;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 644 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 645;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 645 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a118] *)
    let el = #{ el with a118 = next_el.#a118 } in
    Idx_mut.unsafe_set a ((.(i).#a118) : (t118 array, _) idx_mut) next_el.#a118;
    mark_test_run 646;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 646 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a118.#a72] *)
    let el = #{ el with a118 = #{ el.#a118 with a72 = next_el.#a118.#a72 } } in
    Idx_mut.unsafe_set a ((.(i).#a118.#a72) : (t118 array, _) idx_mut) next_el.#a118.#a72;
    mark_test_run 647;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 647 failed %d %d" size i;
    (* Path: [.#a118.#b72] *)
    let el = #{ el with a118 = #{ el.#a118 with b72 = next_el.#a118.#b72 } } in
    Idx_mut.unsafe_set a ((.(i).#a118.#b72) : (t118 array, _) idx_mut) next_el.#a118.#b72;
    mark_test_run 648;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 648 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a118.#b72.#a10] *)
    let el = #{ el with a118 = #{ el.#a118 with b72 = #{ el.#a118.#b72 with a10 = next_el.#a118.#b72.#a10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a118.#b72.#a10) : (t118 array, _) idx_mut) next_el.#a118.#b72.#a10;
    mark_test_run 649;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 649 failed %d %d" size i;
    (* Path: [.#a118.#b72.#b10] *)
    let el = #{ el with a118 = #{ el.#a118 with b72 = #{ el.#a118.#b72 with b10 = next_el.#a118.#b72.#b10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a118.#b72.#b10) : (t118 array, _) idx_mut) next_el.#a118.#b72.#b10;
    mark_test_run 650;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 650 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t119 = #{ #{ float; #{ float; int } } }   *)
  (***********************************************)
  let eq = (fun #{ a119 = a1191 } #{ a119 = a1192 } -> (fun #{ a75 = a751; b75 = b751 } #{ a75 = a752; b75 = b752 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a751 a752 && (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) b751 b752) a1191 a1192) in
  let mk_value i = #{ a119 = #{ a75 = Float.of_int (i + 0); b75 = #{ a28 = Float.of_int (i + 1); b28 = (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t119 array = makearray_dynamic_local size #{ a119 = #{ a75 = 0.; b75 = #{ a28 = 1.; b28 = 2 } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 651;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 651 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 652;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 652 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a119] *)
    let el = #{ el with a119 = next_el.#a119 } in
    Idx_mut.unsafe_set a ((.(i).#a119) : (t119 array, _) idx_mut) next_el.#a119;
    mark_test_run 653;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 653 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a119.#a75] *)
    let el = #{ el with a119 = #{ el.#a119 with a75 = next_el.#a119.#a75 } } in
    Idx_mut.unsafe_set a ((.(i).#a119.#a75) : (t119 array, _) idx_mut) next_el.#a119.#a75;
    mark_test_run 654;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 654 failed %d %d" size i;
    (* Path: [.#a119.#b75] *)
    let el = #{ el with a119 = #{ el.#a119 with b75 = next_el.#a119.#b75 } } in
    Idx_mut.unsafe_set a ((.(i).#a119.#b75) : (t119 array, _) idx_mut) next_el.#a119.#b75;
    mark_test_run 655;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 655 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a119.#b75.#a28] *)
    let el = #{ el with a119 = #{ el.#a119 with b75 = #{ el.#a119.#b75 with a28 = next_el.#a119.#b75.#a28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a119.#b75.#a28) : (t119 array, _) idx_mut) next_el.#a119.#b75.#a28;
    mark_test_run 656;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 656 failed %d %d" size i;
    (* Path: [.#a119.#b75.#b28] *)
    let el = #{ el with a119 = #{ el.#a119 with b75 = #{ el.#a119.#b75 with b28 = next_el.#a119.#b75.#b28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a119.#b75.#b28) : (t119 array, _) idx_mut) next_el.#a119.#b75.#b28;
    mark_test_run 657;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 657 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************************)
  (*   t120 = #{ #{ float; #{ float; float } } }   *)
  (*************************************************)
  let eq = (fun #{ a120 = a1201 } #{ a120 = a1202 } -> (fun #{ a76 = a761; b76 = b761 } #{ a76 = a762; b76 = b762 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a761 a762 && (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) b761 b762) a1201 a1202) in
  let mk_value i = #{ a120 = #{ a76 = Float.of_int (i + 0); b76 = #{ a30 = Float.of_int (i + 1); b30 = Float.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t120 array = makearray_dynamic_local size #{ a120 = #{ a76 = 0.; b76 = #{ a30 = 1.; b30 = 2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 658;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 658 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 659;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 659 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a120] *)
    let el = #{ el with a120 = next_el.#a120 } in
    Idx_mut.unsafe_set a ((.(i).#a120) : (t120 array, _) idx_mut) next_el.#a120;
    mark_test_run 660;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 660 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a120.#a76] *)
    let el = #{ el with a120 = #{ el.#a120 with a76 = next_el.#a120.#a76 } } in
    Idx_mut.unsafe_set a ((.(i).#a120.#a76) : (t120 array, _) idx_mut) next_el.#a120.#a76;
    mark_test_run 661;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 661 failed %d %d" size i;
    (* Path: [.#a120.#b76] *)
    let el = #{ el with a120 = #{ el.#a120 with b76 = next_el.#a120.#b76 } } in
    Idx_mut.unsafe_set a ((.(i).#a120.#b76) : (t120 array, _) idx_mut) next_el.#a120.#b76;
    mark_test_run 662;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 662 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a120.#b76.#a30] *)
    let el = #{ el with a120 = #{ el.#a120 with b76 = #{ el.#a120.#b76 with a30 = next_el.#a120.#b76.#a30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a120.#b76.#a30) : (t120 array, _) idx_mut) next_el.#a120.#b76.#a30;
    mark_test_run 663;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 663 failed %d %d" size i;
    (* Path: [.#a120.#b76.#b30] *)
    let el = #{ el with a120 = #{ el.#a120 with b76 = #{ el.#a120.#b76 with b30 = next_el.#a120.#b76.#b30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a120.#b76.#b30) : (t120 array, _) idx_mut) next_el.#a120.#b76.#b30;
    mark_test_run 664;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 664 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t121 = #{ #{ float# } }   *)
  (*******************************)
  let eq = (fun #{ a121 = a1211 } #{ a121 = a1212 } -> (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a831 a832) a1211 a1212) in
  let mk_value i = #{ a121 = #{ a83 = Float_u.of_int (i + 0) } } in
  (* Create an array of size [size] *)
  let a : t121 array = makearray_dynamic_local size #{ a121 = #{ a83 = #0. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 665;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 665 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 666;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 666 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a121] *)
    let el = #{ el with a121 = next_el.#a121 } in
    Idx_mut.unsafe_set a ((.(i).#a121) : (t121 array, _) idx_mut) next_el.#a121;
    mark_test_run 667;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 667 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a121.#a83] *)
    let el = #{ el with a121 = #{ el.#a121 with a83 = next_el.#a121.#a83 } } in
    Idx_mut.unsafe_set a ((.(i).#a121.#a83) : (t121 array, _) idx_mut) next_el.#a121.#a83;
    mark_test_run 668;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 668 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t122 = #{ #{ float# }; float# }   *)
  (***************************************)
  let eq = (fun #{ a122 = a1221; b122 = b1221 } #{ a122 = a1222; b122 = b1222 } -> (fun #{ a83 = a831 } #{ a83 = a832 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a831 a832) a1221 a1222 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1221 b1222) in
  let mk_value i = #{ a122 = #{ a83 = Float_u.of_int (i + 0) }; b122 = Float_u.of_int (i + 1) } in
  (* Create an array of size [size] *)
  let a : t122 array = makearray_dynamic_local size #{ a122 = #{ a83 = #0. }; b122 = #1. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 669;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 669 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 670;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 670 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a122] *)
    let el = #{ el with a122 = next_el.#a122 } in
    Idx_mut.unsafe_set a ((.(i).#a122) : (t122 array, _) idx_mut) next_el.#a122;
    mark_test_run 671;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 671 failed %d %d" size i;
    (* Path: [.#b122] *)
    let el = #{ el with b122 = next_el.#b122 } in
    Idx_mut.unsafe_set a ((.(i).#b122) : (t122 array, _) idx_mut) next_el.#b122;
    mark_test_run 672;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 672 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a122.#a83] *)
    let el = #{ el with a122 = #{ el.#a122 with a83 = next_el.#a122.#a83 } } in
    Idx_mut.unsafe_set a ((.(i).#a122.#a83) : (t122 array, _) idx_mut) next_el.#a122.#a83;
    mark_test_run 673;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 673 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t89 = #{ #{ float#; float# } }   *)
  (**************************************)
  let eq = (fun #{ a89 = a891 } #{ a89 = a892 } -> (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) a891 a892) in
  let mk_value i = #{ a89 = #{ a84 = Float_u.of_int (i + 0); b84 = Float_u.of_int (i + 1) } } in
  (* Create an array of size [size] *)
  let a : t89 array = makearray_dynamic_local size #{ a89 = #{ a84 = #0.; b84 = #1. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 674;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 674 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 675;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 675 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a89] *)
    let el = #{ el with a89 = next_el.#a89 } in
    Idx_mut.unsafe_set a ((.(i).#a89) : (t89 array, _) idx_mut) next_el.#a89;
    mark_test_run 676;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 676 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a89.#a84] *)
    let el = #{ el with a89 = #{ el.#a89 with a84 = next_el.#a89.#a84 } } in
    Idx_mut.unsafe_set a ((.(i).#a89.#a84) : (t89 array, _) idx_mut) next_el.#a89.#a84;
    mark_test_run 677;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 677 failed %d %d" size i;
    (* Path: [.#a89.#b84] *)
    let el = #{ el with a89 = #{ el.#a89 with b84 = next_el.#a89.#b84 } } in
    Idx_mut.unsafe_set a ((.(i).#a89.#b84) : (t89 array, _) idx_mut) next_el.#a89.#b84;
    mark_test_run 678;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 678 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t123 = #{ #{ float#; float# }; float# }   *)
  (***********************************************)
  let eq = (fun #{ a123 = a1231; b123 = b1231 } #{ a123 = a1232; b123 = b1232 } -> (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) a1231 a1232 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1231 b1232) in
  let mk_value i = #{ a123 = #{ a84 = Float_u.of_int (i + 0); b84 = Float_u.of_int (i + 1) }; b123 = Float_u.of_int (i + 2) } in
  (* Create an array of size [size] *)
  let a : t123 array = makearray_dynamic_local size #{ a123 = #{ a84 = #0.; b84 = #1. }; b123 = #2. } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 679;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 679 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 680;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 680 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a123] *)
    let el = #{ el with a123 = next_el.#a123 } in
    Idx_mut.unsafe_set a ((.(i).#a123) : (t123 array, _) idx_mut) next_el.#a123;
    mark_test_run 681;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 681 failed %d %d" size i;
    (* Path: [.#b123] *)
    let el = #{ el with b123 = next_el.#b123 } in
    Idx_mut.unsafe_set a ((.(i).#b123) : (t123 array, _) idx_mut) next_el.#b123;
    mark_test_run 682;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 682 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a123.#a84] *)
    let el = #{ el with a123 = #{ el.#a123 with a84 = next_el.#a123.#a84 } } in
    Idx_mut.unsafe_set a ((.(i).#a123.#a84) : (t123 array, _) idx_mut) next_el.#a123.#a84;
    mark_test_run 683;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 683 failed %d %d" size i;
    (* Path: [.#a123.#b84] *)
    let el = #{ el with a123 = #{ el.#a123 with b84 = next_el.#a123.#b84 } } in
    Idx_mut.unsafe_set a ((.(i).#a123.#b84) : (t123 array, _) idx_mut) next_el.#a123.#b84;
    mark_test_run 684;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 684 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************************)
  (*   t124 = #{ #{ float#; #{ float#; float# } } }   *)
  (****************************************************)
  let eq = (fun #{ a124 = a1241 } #{ a124 = a1242 } -> (fun #{ a87 = a871; b87 = b871 } #{ a87 = a872; b87 = b872 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a871 a872 && (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) b871 b872) a1241 a1242) in
  let mk_value i = #{ a124 = #{ a87 = Float_u.of_int (i + 0); b87 = #{ a84 = Float_u.of_int (i + 1); b84 = Float_u.of_int (i + 2) } } } in
  (* Create an array of size [size] *)
  let a : t124 array = makearray_dynamic_local size #{ a124 = #{ a87 = #0.; b87 = #{ a84 = #1.; b84 = #2. } } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 685;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 685 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 686;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 686 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a124] *)
    let el = #{ el with a124 = next_el.#a124 } in
    Idx_mut.unsafe_set a ((.(i).#a124) : (t124 array, _) idx_mut) next_el.#a124;
    mark_test_run 687;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 687 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a124.#a87] *)
    let el = #{ el with a124 = #{ el.#a124 with a87 = next_el.#a124.#a87 } } in
    Idx_mut.unsafe_set a ((.(i).#a124.#a87) : (t124 array, _) idx_mut) next_el.#a124.#a87;
    mark_test_run 688;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 688 failed %d %d" size i;
    (* Path: [.#a124.#b87] *)
    let el = #{ el with a124 = #{ el.#a124 with b87 = next_el.#a124.#b87 } } in
    Idx_mut.unsafe_set a ((.(i).#a124.#b87) : (t124 array, _) idx_mut) next_el.#a124.#b87;
    mark_test_run 689;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 689 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a124.#b87.#a84] *)
    let el = #{ el with a124 = #{ el.#a124 with b87 = #{ el.#a124.#b87 with a84 = next_el.#a124.#b87.#a84 } } } in
    Idx_mut.unsafe_set a ((.(i).#a124.#b87.#a84) : (t124 array, _) idx_mut) next_el.#a124.#b87.#a84;
    mark_test_run 690;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 690 failed %d %d" size i;
    (* Path: [.#a124.#b87.#b84] *)
    let el = #{ el with a124 = #{ el.#a124 with b87 = #{ el.#a124.#b87 with b84 = next_el.#a124.#b87.#b84 } } } in
    Idx_mut.unsafe_set a ((.(i).#a124.#b87.#b84) : (t124 array, _) idx_mut) next_el.#a124.#b87.#b84;
    mark_test_run 691;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 691 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t125 = #{ #{ #{ int; int }; int } }   *)
  (*******************************************)
  let eq = (fun #{ a125 = a1251 } #{ a125 = a1252 } -> (fun #{ a95 = a951; b95 = b951 } #{ a95 = a952; b95 = b952 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a951 a952 && (fun a b -> Int.equal a b) b951 b952) a1251 a1252) in
  let mk_value i = #{ a125 = #{ a95 = #{ a1 = (i + 0); b1 = (i + 1) }; b95 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t125 array = makearray_dynamic_local size #{ a125 = #{ a95 = #{ a1 = 0; b1 = 1 }; b95 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 692;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 692 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 693;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 693 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a125] *)
    let el = #{ el with a125 = next_el.#a125 } in
    Idx_mut.unsafe_set a ((.(i).#a125) : (t125 array, _) idx_mut) next_el.#a125;
    mark_test_run 694;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 694 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a125.#a95] *)
    let el = #{ el with a125 = #{ el.#a125 with a95 = next_el.#a125.#a95 } } in
    Idx_mut.unsafe_set a ((.(i).#a125.#a95) : (t125 array, _) idx_mut) next_el.#a125.#a95;
    mark_test_run 695;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 695 failed %d %d" size i;
    (* Path: [.#a125.#b95] *)
    let el = #{ el with a125 = #{ el.#a125 with b95 = next_el.#a125.#b95 } } in
    Idx_mut.unsafe_set a ((.(i).#a125.#b95) : (t125 array, _) idx_mut) next_el.#a125.#b95;
    mark_test_run 696;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 696 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a125.#a95.#a1] *)
    let el = #{ el with a125 = #{ el.#a125 with a95 = #{ el.#a125.#a95 with a1 = next_el.#a125.#a95.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a125.#a95.#a1) : (t125 array, _) idx_mut) next_el.#a125.#a95.#a1;
    mark_test_run 697;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 697 failed %d %d" size i;
    (* Path: [.#a125.#a95.#b1] *)
    let el = #{ el with a125 = #{ el.#a125 with a95 = #{ el.#a125.#a95 with b1 = next_el.#a125.#a95.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a125.#a95.#b1) : (t125 array, _) idx_mut) next_el.#a125.#a95.#b1;
    mark_test_run 698;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 698 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t126 = #{ #{ #{ int; int }; int32# } }   *)
  (**********************************************)
  let eq = (fun #{ a126 = a1261 } #{ a126 = a1262 } -> (fun #{ a96 = a961; b96 = b961 } #{ a96 = a962; b96 = b962 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a961 a962 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b961 b962) a1261 a1262) in
  let mk_value i = #{ a126 = #{ a96 = #{ a1 = (i + 0); b1 = (i + 1) }; b96 = Int32_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t126 array = makearray_dynamic_local size #{ a126 = #{ a96 = #{ a1 = 0; b1 = 1 }; b96 = #2l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 699;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 699 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 700;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 700 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a126] *)
    let el = #{ el with a126 = next_el.#a126 } in
    Idx_mut.unsafe_set a ((.(i).#a126) : (t126 array, _) idx_mut) next_el.#a126;
    mark_test_run 701;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 701 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a126.#a96] *)
    let el = #{ el with a126 = #{ el.#a126 with a96 = next_el.#a126.#a96 } } in
    Idx_mut.unsafe_set a ((.(i).#a126.#a96) : (t126 array, _) idx_mut) next_el.#a126.#a96;
    mark_test_run 702;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 702 failed %d %d" size i;
    (* Path: [.#a126.#b96] *)
    let el = #{ el with a126 = #{ el.#a126 with b96 = next_el.#a126.#b96 } } in
    Idx_mut.unsafe_set a ((.(i).#a126.#b96) : (t126 array, _) idx_mut) next_el.#a126.#b96;
    mark_test_run 703;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 703 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a126.#a96.#a1] *)
    let el = #{ el with a126 = #{ el.#a126 with a96 = #{ el.#a126.#a96 with a1 = next_el.#a126.#a96.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a126.#a96.#a1) : (t126 array, _) idx_mut) next_el.#a126.#a96.#a1;
    mark_test_run 704;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 704 failed %d %d" size i;
    (* Path: [.#a126.#a96.#b1] *)
    let el = #{ el with a126 = #{ el.#a126 with a96 = #{ el.#a126.#a96 with b1 = next_el.#a126.#a96.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a126.#a96.#b1) : (t126 array, _) idx_mut) next_el.#a126.#a96.#b1;
    mark_test_run 705;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 705 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t127 = #{ #{ #{ int; int }; float } }   *)
  (*********************************************)
  let eq = (fun #{ a127 = a1271 } #{ a127 = a1272 } -> (fun #{ a97 = a971; b97 = b971 } #{ a97 = a972; b97 = b972 } -> (fun #{ a1 = a11; b1 = b11 } #{ a1 = a12; b1 = b12 } -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a971 a972 && (fun a b -> Float.equal (globalize a) (globalize b)) b971 b972) a1271 a1272) in
  let mk_value i = #{ a127 = #{ a97 = #{ a1 = (i + 0); b1 = (i + 1) }; b97 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t127 array = makearray_dynamic_local size #{ a127 = #{ a97 = #{ a1 = 0; b1 = 1 }; b97 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 706;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 706 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 707;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 707 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a127] *)
    let el = #{ el with a127 = next_el.#a127 } in
    Idx_mut.unsafe_set a ((.(i).#a127) : (t127 array, _) idx_mut) next_el.#a127;
    mark_test_run 708;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 708 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a127.#a97] *)
    let el = #{ el with a127 = #{ el.#a127 with a97 = next_el.#a127.#a97 } } in
    Idx_mut.unsafe_set a ((.(i).#a127.#a97) : (t127 array, _) idx_mut) next_el.#a127.#a97;
    mark_test_run 709;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 709 failed %d %d" size i;
    (* Path: [.#a127.#b97] *)
    let el = #{ el with a127 = #{ el.#a127 with b97 = next_el.#a127.#b97 } } in
    Idx_mut.unsafe_set a ((.(i).#a127.#b97) : (t127 array, _) idx_mut) next_el.#a127.#b97;
    mark_test_run 710;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 710 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a127.#a97.#a1] *)
    let el = #{ el with a127 = #{ el.#a127 with a97 = #{ el.#a127.#a97 with a1 = next_el.#a127.#a97.#a1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a127.#a97.#a1) : (t127 array, _) idx_mut) next_el.#a127.#a97.#a1;
    mark_test_run 711;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 711 failed %d %d" size i;
    (* Path: [.#a127.#a97.#b1] *)
    let el = #{ el with a127 = #{ el.#a127 with a97 = #{ el.#a127.#a97 with b1 = next_el.#a127.#a97.#b1 } } } in
    Idx_mut.unsafe_set a ((.(i).#a127.#a97.#b1) : (t127 array, _) idx_mut) next_el.#a127.#a97.#b1;
    mark_test_run 712;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 712 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************************)
  (*   t128 = #{ #{ #{ int; int32# }; int32# } }   *)
  (*************************************************)
  let eq = (fun #{ a128 = a1281 } #{ a128 = a1282 } -> (fun #{ a98 = a981; b98 = b981 } #{ a98 = a982; b98 = b982 } -> (fun #{ a7 = a71; b7 = b71 } #{ a7 = a72; b7 = b72 } -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a981 a982 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b981 b982) a1281 a1282) in
  let mk_value i = #{ a128 = #{ a98 = #{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) }; b98 = Int32_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t128 array = makearray_dynamic_local size #{ a128 = #{ a98 = #{ a7 = 0; b7 = #1l }; b98 = #2l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 713;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 713 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 714;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 714 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a128] *)
    let el = #{ el with a128 = next_el.#a128 } in
    Idx_mut.unsafe_set a ((.(i).#a128) : (t128 array, _) idx_mut) next_el.#a128;
    mark_test_run 715;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 715 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a128.#a98] *)
    let el = #{ el with a128 = #{ el.#a128 with a98 = next_el.#a128.#a98 } } in
    Idx_mut.unsafe_set a ((.(i).#a128.#a98) : (t128 array, _) idx_mut) next_el.#a128.#a98;
    mark_test_run 716;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 716 failed %d %d" size i;
    (* Path: [.#a128.#b98] *)
    let el = #{ el with a128 = #{ el.#a128 with b98 = next_el.#a128.#b98 } } in
    Idx_mut.unsafe_set a ((.(i).#a128.#b98) : (t128 array, _) idx_mut) next_el.#a128.#b98;
    mark_test_run 717;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 717 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a128.#a98.#a7] *)
    let el = #{ el with a128 = #{ el.#a128 with a98 = #{ el.#a128.#a98 with a7 = next_el.#a128.#a98.#a7 } } } in
    Idx_mut.unsafe_set a ((.(i).#a128.#a98.#a7) : (t128 array, _) idx_mut) next_el.#a128.#a98.#a7;
    mark_test_run 718;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 718 failed %d %d" size i;
    (* Path: [.#a128.#a98.#b7] *)
    let el = #{ el with a128 = #{ el.#a128 with a98 = #{ el.#a128.#a98 with b7 = next_el.#a128.#a98.#b7 } } } in
    Idx_mut.unsafe_set a ((.(i).#a128.#a98.#b7) : (t128 array, _) idx_mut) next_el.#a128.#a98.#b7;
    mark_test_run 719;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 719 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t129 = #{ #{ #{ int; float }; int } }   *)
  (*********************************************)
  let eq = (fun #{ a129 = a1291 } #{ a129 = a1292 } -> (fun #{ a99 = a991; b99 = b991 } #{ a99 = a992; b99 = b992 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1291 a1292) in
  let mk_value i = #{ a129 = #{ a99 = #{ a10 = (i + 0); b10 = Float.of_int (i + 1) }; b99 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t129 array = makearray_dynamic_local size #{ a129 = #{ a99 = #{ a10 = 0; b10 = 1. }; b99 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 720;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 720 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 721;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 721 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a129] *)
    let el = #{ el with a129 = next_el.#a129 } in
    Idx_mut.unsafe_set a ((.(i).#a129) : (t129 array, _) idx_mut) next_el.#a129;
    mark_test_run 722;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 722 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a129.#a99] *)
    let el = #{ el with a129 = #{ el.#a129 with a99 = next_el.#a129.#a99 } } in
    Idx_mut.unsafe_set a ((.(i).#a129.#a99) : (t129 array, _) idx_mut) next_el.#a129.#a99;
    mark_test_run 723;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 723 failed %d %d" size i;
    (* Path: [.#a129.#b99] *)
    let el = #{ el with a129 = #{ el.#a129 with b99 = next_el.#a129.#b99 } } in
    Idx_mut.unsafe_set a ((.(i).#a129.#b99) : (t129 array, _) idx_mut) next_el.#a129.#b99;
    mark_test_run 724;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 724 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a129.#a99.#a10] *)
    let el = #{ el with a129 = #{ el.#a129 with a99 = #{ el.#a129.#a99 with a10 = next_el.#a129.#a99.#a10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a129.#a99.#a10) : (t129 array, _) idx_mut) next_el.#a129.#a99.#a10;
    mark_test_run 725;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 725 failed %d %d" size i;
    (* Path: [.#a129.#a99.#b10] *)
    let el = #{ el with a129 = #{ el.#a129 with a99 = #{ el.#a129.#a99 with b10 = next_el.#a129.#a99.#b10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a129.#a99.#b10) : (t129 array, _) idx_mut) next_el.#a129.#a99.#b10;
    mark_test_run 726;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 726 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t130 = #{ #{ #{ int; float }; float } }   *)
  (***********************************************)
  let eq = (fun #{ a130 = a1301 } #{ a130 = a1302 } -> (fun #{ a100 = a1001; b100 = b1001 } #{ a100 = a1002; b100 = b1002 } -> (fun #{ a10 = a101; b10 = b101 } #{ a10 = a102; b10 = b102 } -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1001 a1002 && (fun a b -> Float.equal (globalize a) (globalize b)) b1001 b1002) a1301 a1302) in
  let mk_value i = #{ a130 = #{ a100 = #{ a10 = (i + 0); b10 = Float.of_int (i + 1) }; b100 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t130 array = makearray_dynamic_local size #{ a130 = #{ a100 = #{ a10 = 0; b10 = 1. }; b100 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 727;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 727 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 728;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 728 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a130] *)
    let el = #{ el with a130 = next_el.#a130 } in
    Idx_mut.unsafe_set a ((.(i).#a130) : (t130 array, _) idx_mut) next_el.#a130;
    mark_test_run 729;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 729 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a130.#a100] *)
    let el = #{ el with a130 = #{ el.#a130 with a100 = next_el.#a130.#a100 } } in
    Idx_mut.unsafe_set a ((.(i).#a130.#a100) : (t130 array, _) idx_mut) next_el.#a130.#a100;
    mark_test_run 730;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 730 failed %d %d" size i;
    (* Path: [.#a130.#b100] *)
    let el = #{ el with a130 = #{ el.#a130 with b100 = next_el.#a130.#b100 } } in
    Idx_mut.unsafe_set a ((.(i).#a130.#b100) : (t130 array, _) idx_mut) next_el.#a130.#b100;
    mark_test_run 731;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 731 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a130.#a100.#a10] *)
    let el = #{ el with a130 = #{ el.#a130 with a100 = #{ el.#a130.#a100 with a10 = next_el.#a130.#a100.#a10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a130.#a100.#a10) : (t130 array, _) idx_mut) next_el.#a130.#a100.#a10;
    mark_test_run 732;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 732 failed %d %d" size i;
    (* Path: [.#a130.#a100.#b10] *)
    let el = #{ el with a130 = #{ el.#a130 with a100 = #{ el.#a130.#a100 with b10 = next_el.#a130.#a100.#b10 } } } in
    Idx_mut.unsafe_set a ((.(i).#a130.#a100.#b10) : (t130 array, _) idx_mut) next_el.#a130.#a100.#b10;
    mark_test_run 733;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 733 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************************)
  (*   t131 = #{ #{ #{ int32#; int32# }; int32# } }   *)
  (****************************************************)
  let eq = (fun #{ a131 = a1311 } #{ a131 = a1312 } -> (fun #{ a109 = a1091; b109 = b1091 } #{ a109 = a1092; b109 = b1092 } -> (fun #{ a24 = a241; b24 = b241 } #{ a24 = a242; b24 = b242 } -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a241 a242 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b241 b242) a1091 a1092 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1091 b1092) a1311 a1312) in
  let mk_value i = #{ a131 = #{ a109 = #{ a24 = Int32_u.of_int (i + 0); b24 = Int32_u.of_int (i + 1) }; b109 = Int32_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t131 array = makearray_dynamic_local size #{ a131 = #{ a109 = #{ a24 = #0l; b24 = #1l }; b109 = #2l } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 734;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 734 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 735;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 735 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a131] *)
    let el = #{ el with a131 = next_el.#a131 } in
    Idx_mut.unsafe_set a ((.(i).#a131) : (t131 array, _) idx_mut) next_el.#a131;
    mark_test_run 736;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 736 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a131.#a109] *)
    let el = #{ el with a131 = #{ el.#a131 with a109 = next_el.#a131.#a109 } } in
    Idx_mut.unsafe_set a ((.(i).#a131.#a109) : (t131 array, _) idx_mut) next_el.#a131.#a109;
    mark_test_run 737;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 737 failed %d %d" size i;
    (* Path: [.#a131.#b109] *)
    let el = #{ el with a131 = #{ el.#a131 with b109 = next_el.#a131.#b109 } } in
    Idx_mut.unsafe_set a ((.(i).#a131.#b109) : (t131 array, _) idx_mut) next_el.#a131.#b109;
    mark_test_run 738;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 738 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a131.#a109.#a24] *)
    let el = #{ el with a131 = #{ el.#a131 with a109 = #{ el.#a131.#a109 with a24 = next_el.#a131.#a109.#a24 } } } in
    Idx_mut.unsafe_set a ((.(i).#a131.#a109.#a24) : (t131 array, _) idx_mut) next_el.#a131.#a109.#a24;
    mark_test_run 739;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 739 failed %d %d" size i;
    (* Path: [.#a131.#a109.#b24] *)
    let el = #{ el with a131 = #{ el.#a131 with a109 = #{ el.#a131.#a109 with b24 = next_el.#a131.#a109.#b24 } } } in
    Idx_mut.unsafe_set a ((.(i).#a131.#a109.#b24) : (t131 array, _) idx_mut) next_el.#a131.#a109.#b24;
    mark_test_run 740;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 740 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************************)
  (*   t132 = #{ #{ #{ float; int }; int } }   *)
  (*********************************************)
  let eq = (fun #{ a132 = a1321 } #{ a132 = a1322 } -> (fun #{ a113 = a1131; b113 = b1131 } #{ a113 = a1132; b113 = b1132 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a1131 a1132 && (fun a b -> Int.equal a b) b1131 b1132) a1321 a1322) in
  let mk_value i = #{ a132 = #{ a113 = #{ a28 = Float.of_int (i + 0); b28 = (i + 1) }; b113 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t132 array = makearray_dynamic_local size #{ a132 = #{ a113 = #{ a28 = 0.; b28 = 1 }; b113 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 741;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 741 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 742;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 742 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a132] *)
    let el = #{ el with a132 = next_el.#a132 } in
    Idx_mut.unsafe_set a ((.(i).#a132) : (t132 array, _) idx_mut) next_el.#a132;
    mark_test_run 743;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 743 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a132.#a113] *)
    let el = #{ el with a132 = #{ el.#a132 with a113 = next_el.#a132.#a113 } } in
    Idx_mut.unsafe_set a ((.(i).#a132.#a113) : (t132 array, _) idx_mut) next_el.#a132.#a113;
    mark_test_run 744;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 744 failed %d %d" size i;
    (* Path: [.#a132.#b113] *)
    let el = #{ el with a132 = #{ el.#a132 with b113 = next_el.#a132.#b113 } } in
    Idx_mut.unsafe_set a ((.(i).#a132.#b113) : (t132 array, _) idx_mut) next_el.#a132.#b113;
    mark_test_run 745;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 745 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a132.#a113.#a28] *)
    let el = #{ el with a132 = #{ el.#a132 with a113 = #{ el.#a132.#a113 with a28 = next_el.#a132.#a113.#a28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a132.#a113.#a28) : (t132 array, _) idx_mut) next_el.#a132.#a113.#a28;
    mark_test_run 746;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 746 failed %d %d" size i;
    (* Path: [.#a132.#a113.#b28] *)
    let el = #{ el with a132 = #{ el.#a132 with a113 = #{ el.#a132.#a113 with b28 = next_el.#a132.#a113.#b28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a132.#a113.#b28) : (t132 array, _) idx_mut) next_el.#a132.#a113.#b28;
    mark_test_run 747;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 747 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t133 = #{ #{ #{ float; int }; float } }   *)
  (***********************************************)
  let eq = (fun #{ a133 = a1331 } #{ a133 = a1332 } -> (fun #{ a114 = a1141; b114 = b1141 } #{ a114 = a1142; b114 = b1142 } -> (fun #{ a28 = a281; b28 = b281 } #{ a28 = a282; b28 = b282 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) a1141 a1142 && (fun a b -> Float.equal (globalize a) (globalize b)) b1141 b1142) a1331 a1332) in
  let mk_value i = #{ a133 = #{ a114 = #{ a28 = Float.of_int (i + 0); b28 = (i + 1) }; b114 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t133 array = makearray_dynamic_local size #{ a133 = #{ a114 = #{ a28 = 0.; b28 = 1 }; b114 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 748;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 748 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 749;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 749 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a133] *)
    let el = #{ el with a133 = next_el.#a133 } in
    Idx_mut.unsafe_set a ((.(i).#a133) : (t133 array, _) idx_mut) next_el.#a133;
    mark_test_run 750;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 750 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a133.#a114] *)
    let el = #{ el with a133 = #{ el.#a133 with a114 = next_el.#a133.#a114 } } in
    Idx_mut.unsafe_set a ((.(i).#a133.#a114) : (t133 array, _) idx_mut) next_el.#a133.#a114;
    mark_test_run 751;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 751 failed %d %d" size i;
    (* Path: [.#a133.#b114] *)
    let el = #{ el with a133 = #{ el.#a133 with b114 = next_el.#a133.#b114 } } in
    Idx_mut.unsafe_set a ((.(i).#a133.#b114) : (t133 array, _) idx_mut) next_el.#a133.#b114;
    mark_test_run 752;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 752 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a133.#a114.#a28] *)
    let el = #{ el with a133 = #{ el.#a133 with a114 = #{ el.#a133.#a114 with a28 = next_el.#a133.#a114.#a28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a133.#a114.#a28) : (t133 array, _) idx_mut) next_el.#a133.#a114.#a28;
    mark_test_run 753;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 753 failed %d %d" size i;
    (* Path: [.#a133.#a114.#b28] *)
    let el = #{ el with a133 = #{ el.#a133 with a114 = #{ el.#a133.#a114 with b28 = next_el.#a133.#a114.#b28 } } } in
    Idx_mut.unsafe_set a ((.(i).#a133.#a114.#b28) : (t133 array, _) idx_mut) next_el.#a133.#a114.#b28;
    mark_test_run 754;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 754 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************************)
  (*   t134 = #{ #{ #{ float; float }; int } }   *)
  (***********************************************)
  let eq = (fun #{ a134 = a1341 } #{ a134 = a1342 } -> (fun #{ a115 = a1151; b115 = b1151 } #{ a115 = a1152; b115 = b1152 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a1151 a1152 && (fun a b -> Int.equal a b) b1151 b1152) a1341 a1342) in
  let mk_value i = #{ a134 = #{ a115 = #{ a30 = Float.of_int (i + 0); b30 = Float.of_int (i + 1) }; b115 = (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t134 array = makearray_dynamic_local size #{ a134 = #{ a115 = #{ a30 = 0.; b30 = 1. }; b115 = 2 } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 755;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 755 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 756;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 756 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a134] *)
    let el = #{ el with a134 = next_el.#a134 } in
    Idx_mut.unsafe_set a ((.(i).#a134) : (t134 array, _) idx_mut) next_el.#a134;
    mark_test_run 757;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 757 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a134.#a115] *)
    let el = #{ el with a134 = #{ el.#a134 with a115 = next_el.#a134.#a115 } } in
    Idx_mut.unsafe_set a ((.(i).#a134.#a115) : (t134 array, _) idx_mut) next_el.#a134.#a115;
    mark_test_run 758;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 758 failed %d %d" size i;
    (* Path: [.#a134.#b115] *)
    let el = #{ el with a134 = #{ el.#a134 with b115 = next_el.#a134.#b115 } } in
    Idx_mut.unsafe_set a ((.(i).#a134.#b115) : (t134 array, _) idx_mut) next_el.#a134.#b115;
    mark_test_run 759;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 759 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a134.#a115.#a30] *)
    let el = #{ el with a134 = #{ el.#a134 with a115 = #{ el.#a134.#a115 with a30 = next_el.#a134.#a115.#a30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a134.#a115.#a30) : (t134 array, _) idx_mut) next_el.#a134.#a115.#a30;
    mark_test_run 760;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 760 failed %d %d" size i;
    (* Path: [.#a134.#a115.#b30] *)
    let el = #{ el with a134 = #{ el.#a134 with a115 = #{ el.#a134.#a115 with b30 = next_el.#a134.#a115.#b30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a134.#a115.#b30) : (t134 array, _) idx_mut) next_el.#a134.#a115.#b30;
    mark_test_run 761;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 761 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************************)
  (*   t135 = #{ #{ #{ float; float }; float } }   *)
  (*************************************************)
  let eq = (fun #{ a135 = a1351 } #{ a135 = a1352 } -> (fun #{ a116 = a1161; b116 = b1161 } #{ a116 = a1162; b116 = b1162 } -> (fun #{ a30 = a301; b30 = b301 } #{ a30 = a302; b30 = b302 } -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) a1161 a1162 && (fun a b -> Float.equal (globalize a) (globalize b)) b1161 b1162) a1351 a1352) in
  let mk_value i = #{ a135 = #{ a116 = #{ a30 = Float.of_int (i + 0); b30 = Float.of_int (i + 1) }; b116 = Float.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t135 array = makearray_dynamic_local size #{ a135 = #{ a116 = #{ a30 = 0.; b30 = 1. }; b116 = 2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 762;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 762 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 763;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 763 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a135] *)
    let el = #{ el with a135 = next_el.#a135 } in
    Idx_mut.unsafe_set a ((.(i).#a135) : (t135 array, _) idx_mut) next_el.#a135;
    mark_test_run 764;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 764 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a135.#a116] *)
    let el = #{ el with a135 = #{ el.#a135 with a116 = next_el.#a135.#a116 } } in
    Idx_mut.unsafe_set a ((.(i).#a135.#a116) : (t135 array, _) idx_mut) next_el.#a135.#a116;
    mark_test_run 765;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 765 failed %d %d" size i;
    (* Path: [.#a135.#b116] *)
    let el = #{ el with a135 = #{ el.#a135 with b116 = next_el.#a135.#b116 } } in
    Idx_mut.unsafe_set a ((.(i).#a135.#b116) : (t135 array, _) idx_mut) next_el.#a135.#b116;
    mark_test_run 766;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 766 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a135.#a116.#a30] *)
    let el = #{ el with a135 = #{ el.#a135 with a116 = #{ el.#a135.#a116 with a30 = next_el.#a135.#a116.#a30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a135.#a116.#a30) : (t135 array, _) idx_mut) next_el.#a135.#a116.#a30;
    mark_test_run 767;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 767 failed %d %d" size i;
    (* Path: [.#a135.#a116.#b30] *)
    let el = #{ el with a135 = #{ el.#a135 with a116 = #{ el.#a135.#a116 with b30 = next_el.#a135.#a116.#b30 } } } in
    Idx_mut.unsafe_set a ((.(i).#a135.#a116.#b30) : (t135 array, _) idx_mut) next_el.#a135.#a116.#b30;
    mark_test_run 768;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 768 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************************)
  (*   t136 = #{ #{ #{ float#; float# }; float# } }   *)
  (****************************************************)
  let eq = (fun #{ a136 = a1361 } #{ a136 = a1362 } -> (fun #{ a123 = a1231; b123 = b1231 } #{ a123 = a1232; b123 = b1232 } -> (fun #{ a84 = a841; b84 = b841 } #{ a84 = a842; b84 = b842 } -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a841 a842 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b841 b842) a1231 a1232 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1231 b1232) a1361 a1362) in
  let mk_value i = #{ a136 = #{ a123 = #{ a84 = Float_u.of_int (i + 0); b84 = Float_u.of_int (i + 1) }; b123 = Float_u.of_int (i + 2) } } in
  (* Create an array of size [size] *)
  let a : t136 array = makearray_dynamic_local size #{ a136 = #{ a123 = #{ a84 = #0.; b84 = #1. }; b123 = #2. } } in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    Idx_mut.unsafe_set a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 769;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 769 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 770;
    let test = eq (Idx_mut.unsafe_get a (.(i))) (mk_value i) in
    if not test then failwithf "test 770 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let next_el = mk_value (i + 100 * 1) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 1 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a136] *)
    let el = #{ el with a136 = next_el.#a136 } in
    Idx_mut.unsafe_set a ((.(i).#a136) : (t136 array, _) idx_mut) next_el.#a136;
    mark_test_run 771;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 771 failed %d %d" size i;
    (* Paths of depth 2 *)
    let next_el = mk_value (i + 100 * 2) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 2 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a136.#a123] *)
    let el = #{ el with a136 = #{ el.#a136 with a123 = next_el.#a136.#a123 } } in
    Idx_mut.unsafe_set a ((.(i).#a136.#a123) : (t136 array, _) idx_mut) next_el.#a136.#a123;
    mark_test_run 772;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 772 failed %d %d" size i;
    (* Path: [.#a136.#b123] *)
    let el = #{ el with a136 = #{ el.#a136 with b123 = next_el.#a136.#b123 } } in
    Idx_mut.unsafe_set a ((.(i).#a136.#b123) : (t136 array, _) idx_mut) next_el.#a136.#b123;
    mark_test_run 773;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 773 failed %d %d" size i;
    (* Paths of depth 3 *)
    let next_el = mk_value (i + 100 * 3) in
    (* We update [a.(i)] to become [next_el] by setting all paths of depth 3 *)
    (* [el] is the reference value, updated with [with] *)
    let el = get a i in
    (* Path: [.#a136.#a123.#a84] *)
    let el = #{ el with a136 = #{ el.#a136 with a123 = #{ el.#a136.#a123 with a84 = next_el.#a136.#a123.#a84 } } } in
    Idx_mut.unsafe_set a ((.(i).#a136.#a123.#a84) : (t136 array, _) idx_mut) next_el.#a136.#a123.#a84;
    mark_test_run 774;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 774 failed %d %d" size i;
    (* Path: [.#a136.#a123.#b84] *)
    let el = #{ el with a136 = #{ el.#a136 with a123 = #{ el.#a136.#a123 with b84 = next_el.#a136.#a123.#b84 } } } in
    Idx_mut.unsafe_set a ((.(i).#a136.#a123.#b84) : (t136 array, _) idx_mut) next_el.#a136.#a123.#b84;
    mark_test_run 775;
    let test = eq (Idx_mut.unsafe_get a (.(i))) el in
    if not test then failwithf "test 775 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()
;;

let () =
  iter sizes ~f:test;
  ()
;;

for i = 1 to 775 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
