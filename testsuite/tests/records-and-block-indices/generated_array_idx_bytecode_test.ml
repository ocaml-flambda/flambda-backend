(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 flags = "-extension layouts_alpha";
 bytecode;
*)
(** This is code generated by [generate_array_idx_tests.ml]. *)

[@@@warning "-23"]
external globalize : local_ 'a -> 'a = "%obj_dup";;
let int64x2_u_equal (_ : int64x2#) (_ : int64x2#) = failwith "should not be called from bytecode"

open Stdlib_upstream_compatible
open Stdlib_stable

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] get_idx_imm :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_imm -> ('b [@local_opt]) =
  "%unsafe_get_idx_imm"

external[@layout_poly] get_idx_mut :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) =
  "%unsafe_get_idx"

external[@layout_poly] set_idx_mut :
  'a ('b : any).
    ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) -> unit =
  "%unsafe_set_idx"

module Idx_repr : sig
  type t
  val of_idx_imm : 'a ('b : any). ('a, 'b) idx_imm -> t
  val of_idx_mut : 'a ('b : any). ('a, 'b) idx_mut -> t
  val equal : t -> t -> bool
  val debug_string : t -> string
end = struct
  (* See Note [Representation of block indices] in [lambda/translcore.ml] *)
  type t =
    | Bytecode of { path : int list }
    | Native of { offset : int; gap : int }

  external magic_box_bits64 : ('a : bits64) 'b . 'a -> 'b =
    "%box_int64"
  external lessthan_if_bytecode : int -> int -> bool =
    "caml_lessthan" "caml_greaterthan"

  let of_idx idx =
    let is_bytecode = lessthan_if_bytecode 0 1 in
    if is_bytecode then
      let r = Obj.repr (magic_box_bits64 idx) in
      let nth_idx n : int = Obj.magic (Obj.field r n) in
      let path = List.init (Obj.size r) nth_idx in
      Bytecode { path }
    else
      let i : int64 = magic_box_bits64 idx in
      let offset =
        Int64.(logand (sub (shift_left one 48) one)) i
        |> Int64.to_int
      in
      let gap =
        Int64.shift_right i 48
        |> Int64.to_int
      in
      Native { offset; gap }

  let of_idx_imm = of_idx
  let of_idx_mut = of_idx

  let equal t1 t2 =
    match t1, t2 with
    | Bytecode { path = path1 }, Bytecode { path = path2 } ->
      List.equal Int.equal path1 path2
    | Native { gap = gap1; offset = offset1 },
      Native { gap = gap2; offset = offset2 } ->
      Int.equal gap1 gap2 && Int.equal offset1 offset2
    | Bytecode _, Native _ | Native _, Bytecode _ -> assert false

  let debug_string = function
    | Bytecode { path } ->
      Printf.sprintf "{ %s }"
        (String.concat "; " (List.map Int.to_string path))
    | Native { offset; gap } ->
      Printf.sprintf "offset %d; gap %d" offset gap
end

let failwithf fmt = Printf.ksprintf failwith fmt

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]


type t0 = #{ a0 : int }
type t1 = #{ a1 : int; b1 : int }
type t2 = #{ a2 : int; b2 : int; c2 : int }
type t3 = #{ a3 : int; b3 : int; c3 : int32# }
type t4 = #{ a4 : int; b4 : int; c4 : float }
type t5 = #{ a5 : int; b5 : int64 }
type t6 = #{ a6 : int; b6 : int64# }
type t7 = #{ a7 : int; b7 : int32# }
type t8 = #{ a8 : int; b8 : int32#; c8 : int32# }
type t9 = #{ a9 : int; b9 : nativeint# }
type t10 = #{ a10 : int; b10 : float }
type t11 = #{ a11 : int; b11 : float; c11 : int }
type t12 = #{ a12 : int; b12 : float; c12 : float }
type t13 = #{ a13 : int; b13 : t0 }
type t14 = #{ a14 : int; b14 : t1 }
type t15 = #{ a15 : int; b15 : t7 }
type t16 = #{ a16 : int; b16 : t10 }
type t17 = #{ a17 : int32# }
type t18 = #{ a18 : int; b18 : t17 }
type t19 = #{ a19 : int32#; b19 : int32# }
type t20 = #{ a20 : int; b20 : t19 }
type t21 = #{ a21 : float }
type t22 = #{ a22 : int; b22 : t21 }
type t23 = #{ a23 : float; b23 : int }
type t24 = #{ a24 : int; b24 : t23 }
type t25 = #{ a25 : float; b25 : float }
type t26 = #{ a26 : int; b26 : t25 }
type t27 = #{ a27 : int64 }
type t28 = #{ a28 : int64; b28 : int }
type t29 = #{ a29 : int64; b29 : int64 }
type t30 = #{ a30 : int64; b30 : float }
type t31 = #{ a31 : int64# }
type t32 = #{ a32 : int64#; b32 : int64# }
type t33 = #{ a33 : int64#; b33 : int32# }
type t34 = #{ a34 : int64#; b34 : nativeint# }
type t35 = #{ a35 : int32#; b35 : int64# }
type t36 = #{ a36 : int32#; b36 : int32#; c36 : int32# }
type t37 = #{ a37 : int32#; b37 : nativeint# }
type t38 = #{ a38 : int32#; b38 : t17 }
type t39 = #{ a39 : int32#; b39 : t19 }
type t40 = #{ a40 : nativeint# }
type t41 = #{ a41 : nativeint#; b41 : int64# }
type t42 = #{ a42 : nativeint#; b42 : int32# }
type t43 = #{ a43 : nativeint#; b43 : nativeint# }
type t44 = #{ a44 : float; b44 : int; c44 : int }
type t45 = #{ a45 : float; b45 : int; c45 : float }
type t46 = #{ a46 : float; b46 : int64 }
type t47 = #{ a47 : float; b47 : float; c47 : int }
type t48 = #{ a48 : float; b48 : float; c48 : float }
type t49 = #{ a49 : float; b49 : t0 }
type t50 = #{ a50 : float; b50 : t1 }
type t51 = #{ a51 : float; b51 : t10 }
type t52 = #{ a52 : float; b52 : t21 }
type t53 = #{ a53 : float; b53 : t23 }
type t54 = #{ a54 : float; b54 : t25 }
type t55 = #{ a55 : t0 }
type t56 = #{ a56 : t0; b56 : int }
type t57 = #{ a57 : t0; b57 : int32# }
type t58 = #{ a58 : t0; b58 : float }
type t59 = #{ a59 : t1 }
type t60 = #{ a60 : t1; b60 : int }
type t61 = #{ a61 : t1; b61 : int32# }
type t62 = #{ a62 : t1; b62 : float }
type t63 = #{ a63 : t7 }
type t64 = #{ a64 : t7; b64 : int32# }
type t65 = #{ a65 : t10 }
type t66 = #{ a66 : t10; b66 : int }
type t67 = #{ a67 : t10; b67 : float }
type t68 = #{ a68 : t17 }
type t69 = #{ a69 : t17; b69 : int32# }
type t70 = #{ a70 : t19 }
type t71 = #{ a71 : t19; b71 : int32# }
type t72 = #{ a72 : t21; b72 : int }
type t73 = #{ a73 : t21; b73 : float }
type t74 = #{ a74 : t23 }
type t75 = #{ a75 : t23; b75 : int }
type t76 = #{ a76 : t23; b76 : float }
type t77 = #{ a77 : t25 }
type t78 = #{ a78 : t25; b78 : int }
type t79 = #{ a79 : t25; b79 : float }
type t80 = { mutable a80 : int }
type t81 = { mutable a81 : int; mutable b81 : int }
type t82 = { mutable a82 : int; mutable b82 : int; mutable c82 : int }
type t83 = { mutable a83 : int; mutable b83 : int; mutable c83 : int32# }
type t84 = { mutable a84 : int; mutable b84 : int; mutable c84 : float }
type t85 = { mutable a85 : int; mutable b85 : int64 }
type t86 = { mutable a86 : int; mutable b86 : int64# }
type t87 = { mutable a87 : int; mutable b87 : int32# }
type t88 = { mutable a88 : int; mutable b88 : int32#; mutable c88 : int }
type t89 = { mutable a89 : int; mutable b89 : int32#; mutable c89 : int32# }
type t90 = { mutable a90 : int; mutable b90 : nativeint# }
type t91 = { mutable a91 : int; mutable b91 : float }
type t92 = { mutable a92 : int; mutable b92 : float; mutable c92 : int }
type t93 = { mutable a93 : int; mutable b93 : float; mutable c93 : float }
type t94 = { mutable a94 : int; mutable b94 : t0 }
type t95 = { mutable a95 : int; mutable b95 : t1 }
type t96 = { mutable a96 : int; mutable b96 : t7 }
type t97 = { mutable a97 : int; mutable b97 : t10 }
type t98 = { mutable a98 : int; mutable b98 : t17 }
type t99 = #{ a99 : int32#; b99 : int }
type t100 = { mutable a100 : int; mutable b100 : t99 }
type t101 = { mutable a101 : int; mutable b101 : t19 }
type t102 = { mutable a102 : int; mutable b102 : t21 }
type t103 = { mutable a103 : int; mutable b103 : t23 }
type t104 = { mutable a104 : int; mutable b104 : t25 }
type t105 = { mutable a105 : int64 }
type t106 = { mutable a106 : int64; mutable b106 : int }
type t107 = { mutable a107 : int64; mutable b107 : int64 }
type t108 = { mutable a108 : int64; mutable b108 : int64# }
type t109 = { mutable a109 : int64; mutable b109 : int32# }
type t110 = { mutable a110 : int64; mutable b110 : nativeint# }
type t111 = { mutable a111 : int64; mutable b111 : float }
type t112 = { mutable a112 : int64# }
type t113 = { mutable a113 : int64#; mutable b113 : int }
type t114 = { mutable a114 : int64#; mutable b114 : int64 }
type t115 = { mutable a115 : int64#; mutable b115 : int64# }
type t116 = { mutable a116 : int64#; mutable b116 : int32# }
type t117 = { mutable a117 : int64#; mutable b117 : nativeint# }
type t118 = { mutable a118 : int64#; mutable b118 : float }
type t119 = { mutable a119 : int32# }
type t120 = { mutable a120 : int32#; mutable b120 : int }
type t121 = { mutable a121 : int32#; mutable b121 : int; mutable c121 : int }
type t122 = { mutable a122 : int32#; mutable b122 : int; mutable c122 : int32# }
type t123 = { mutable a123 : int32#; mutable b123 : int64 }
type t124 = { mutable a124 : int32#; mutable b124 : int64# }
type t125 = { mutable a125 : int32#; mutable b125 : int32# }
type t126 = { mutable a126 : int32#; mutable b126 : int32#; mutable c126 : int }
type t127 = { mutable a127 : int32#; mutable b127 : int32#; mutable c127 : int32# }
type t128 = { mutable a128 : int32#; mutable b128 : nativeint# }
type t129 = { mutable a129 : int32#; mutable b129 : float }
type t130 = { mutable a130 : int32#; mutable b130 : t0 }
type t131 = { mutable a131 : int32#; mutable b131 : t1 }
type t132 = { mutable a132 : int32#; mutable b132 : t7 }
type t133 = { mutable a133 : int32#; mutable b133 : t17 }
type t134 = { mutable a134 : int32#; mutable b134 : t99 }
type t135 = { mutable a135 : int32#; mutable b135 : t19 }
type t136 = { mutable a136 : nativeint# }
type t137 = { mutable a137 : nativeint#; mutable b137 : int }
type t138 = { mutable a138 : nativeint#; mutable b138 : int64 }
type t139 = { mutable a139 : nativeint#; mutable b139 : int64# }
type t140 = { mutable a140 : nativeint#; mutable b140 : int32# }
type t141 = { mutable a141 : nativeint#; mutable b141 : nativeint# }
type t142 = { mutable a142 : nativeint#; mutable b142 : float }
type t143 = { mutable a143 : float }
type t144 = { mutable a144 : float; mutable b144 : int }
type t145 = { mutable a145 : float; mutable b145 : int; mutable c145 : int }
type t146 = { mutable a146 : float; mutable b146 : int; mutable c146 : float }
type t147 = { mutable a147 : float; mutable b147 : int64 }
type t148 = { mutable a148 : float; mutable b148 : int64# }
type t149 = { mutable a149 : float; mutable b149 : int32# }
type t150 = { mutable a150 : float; mutable b150 : nativeint# }
type t151 = { mutable a151 : float; mutable b151 : float }
type t152 = { mutable a152 : float; mutable b152 : float; mutable c152 : int }
type t153 = { mutable a153 : float; mutable b153 : float; mutable c153 : float }
type t154 = { mutable a154 : float; mutable b154 : t0 }
type t155 = { mutable a155 : float; mutable b155 : t1 }
type t156 = { mutable a156 : float; mutable b156 : t10 }
type t157 = { mutable a157 : float; mutable b157 : t21 }
type t158 = { mutable a158 : float; mutable b158 : t23 }
type t159 = { mutable a159 : float; mutable b159 : t25 }
type t160 = { mutable a160 : t0 }
type t161 = { mutable a161 : t0; mutable b161 : int }
type t162 = { mutable a162 : t0; mutable b162 : int32# }
type t163 = { mutable a163 : t0; mutable b163 : float }
type t164 = { mutable a164 : t1 }
type t165 = { mutable a165 : t1; mutable b165 : int }
type t166 = { mutable a166 : t1; mutable b166 : int32# }
type t167 = { mutable a167 : t1; mutable b167 : float }
type t168 = { mutable a168 : t7 }
type t169 = { mutable a169 : t7; mutable b169 : int }
type t170 = { mutable a170 : t7; mutable b170 : int32# }
type t171 = { mutable a171 : t10 }
type t172 = { mutable a172 : t10; mutable b172 : int }
type t173 = { mutable a173 : t10; mutable b173 : float }
type t174 = #{ a174 : int64; b174 : int64# }
type t175 = #{ a175 : int64#; b175 : float# }
type t176 = { mutable a176 : t174; mutable b176 : t175 }
type t177 = #{ a177 : int64; b177 : string }
type t178 = #{ a178 : int64#; b178 : string }
type t179 = { mutable a179 : t177; mutable b179 : t178 }
type t180 = #{ a180 : int64#; b180 : int64 }
type t181 = { mutable a181 : t180; mutable b181 : t29 }
type t182 = #{ a182 : float32#; b182 : float }
type t183 = { mutable a183 : t180; mutable b183 : t182 }
type t184 = { mutable a184 : t17 }
type t185 = { mutable a185 : t17; mutable b185 : int }
type t186 = { mutable a186 : t17; mutable b186 : int32# }
type t187 = { mutable a187 : t99 }
type t188 = { mutable a188 : t99; mutable b188 : int }
type t189 = { mutable a189 : t99; mutable b189 : int32# }
type t190 = { mutable a190 : t19 }
type t191 = { mutable a191 : t19; mutable b191 : int }
type t192 = { mutable a192 : t19; mutable b192 : int32# }
type t193 = { mutable a193 : t21 }
type t194 = { mutable a194 : t21; mutable b194 : int }
type t195 = { mutable a195 : t21; mutable b195 : float }
type t196 = { mutable a196 : t23 }
type t197 = { mutable a197 : t23; mutable b197 : int }
type t198 = { mutable a198 : t23; mutable b198 : float }
type t199 = { mutable a199 : t25 }
type t200 = { mutable a200 : t25; mutable b200 : int }
type t201 = { mutable a201 : t25; mutable b201 : float }
type t202 = #{ a202 : float32#; b202 : int64# }
type t203 = #{ a203 : string; b203 : int64# }
type t204 = { mutable a204 : t202; mutable b204 : t203 }

let test_array_idx_with_makearray_dynamic size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 1;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 1 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 2;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 2 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 3;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 3 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 4;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 4 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 5;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 5 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 6;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 6 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 7;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 7 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 8;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 8 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 9;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 9 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 10;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 10 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  let eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let mk_value i = (#{ a0 = (i + 0) } : t0) in
  (* Create an array of size [size] *)
  let a : t0 array = makearray_dynamic size (#{ a0 = 0 } : t0) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 11;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 11 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 12;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 12 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a0 *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 13;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 13 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  let eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let mk_value i = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) in
  (* Create an array of size [size] *)
  let a : t1 array = makearray_dynamic size (#{ a1 = 0; b1 = 1 } : t1) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 14;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 14 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 15;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 15 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a1 *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 16;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 16 failed %d %d" size i;
    (* .#b1 *)
    let el = #{ el with b1 = next_el.#b1 } in
    set_idx_mut a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 17;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 17 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  let eq = (fun (#{ a2 = a21; b2 = b21; c2 = c21 } : t2) (#{ a2 = a22; b2 = b22; c2 = c22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = (i + 1); c2 = (i + 2) } : t2) in
  (* Create an array of size [size] *)
  let a : t2 array = makearray_dynamic size (#{ a2 = 0; b2 = 1; c2 = 2 } : t2) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 18;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 18 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 19;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 19 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a2 *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 20;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 20 failed %d %d" size i;
    (* .#b2 *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 21;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 21 failed %d %d" size i;
    (* .#c2 *)
    let el = #{ el with c2 = next_el.#c2 } in
    set_idx_mut a ((.(i).#c2) : (t2 array, _) idx_mut) next_el.#c2;
    mark_test_run 22;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 22 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  let eq = (fun (#{ a3 = a31; b3 = b31; c3 = c31 } : t3) (#{ a3 = a32; b3 = b32; c3 = c32 } : t3) -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let mk_value i = (#{ a3 = (i + 0); b3 = (i + 1); c3 = Int32_u.of_int (i + 2) } : t3) in
  (* Create an array of size [size] *)
  let a : t3 array = makearray_dynamic size (#{ a3 = 0; b3 = 1; c3 = #2l } : t3) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 23;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 23 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 24;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 24 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a3 *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 25;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 25 failed %d %d" size i;
    (* .#b3 *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 26;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 26 failed %d %d" size i;
    (* .#c3 *)
    let el = #{ el with c3 = next_el.#c3 } in
    set_idx_mut a ((.(i).#c3) : (t3 array, _) idx_mut) next_el.#c3;
    mark_test_run 27;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 27 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  let eq = (fun (#{ a4 = a41; b4 = b41; c4 = c41 } : t4) (#{ a4 = a42; b4 = b42; c4 = c42 } : t4) -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let mk_value i = (#{ a4 = (i + 0); b4 = (i + 1); c4 = Float.of_int (i + 2) } : t4) in
  (* Create an array of size [size] *)
  let a : t4 array = makearray_dynamic size (#{ a4 = 0; b4 = 1; c4 = 2. } : t4) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 28;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 28 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 29;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 29 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a4 *)
    let el = #{ el with a4 = next_el.#a4 } in
    set_idx_mut a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 30;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 30 failed %d %d" size i;
    (* .#b4 *)
    let el = #{ el with b4 = next_el.#b4 } in
    set_idx_mut a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 31;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 31 failed %d %d" size i;
    (* .#c4 *)
    let el = #{ el with c4 = next_el.#c4 } in
    set_idx_mut a ((.(i).#c4) : (t4 array, _) idx_mut) next_el.#c4;
    mark_test_run 32;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 32 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t5 = #{ int; int64 }   *)
  (****************************)
  let eq = (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int64.equal (globalize a) (globalize b)) b51 b52) in
  let mk_value i = (#{ a5 = (i + 0); b5 = Int64.of_int (i + 1) } : t5) in
  (* Create an array of size [size] *)
  let a : t5 array = makearray_dynamic size (#{ a5 = 0; b5 = 1L } : t5) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 33;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 33 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 34;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 34 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a5 *)
    let el = #{ el with a5 = next_el.#a5 } in
    set_idx_mut a ((.(i).#a5) : (t5 array, _) idx_mut) next_el.#a5;
    mark_test_run 35;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 35 failed %d %d" size i;
    (* .#b5 *)
    let el = #{ el with b5 = next_el.#b5 } in
    set_idx_mut a ((.(i).#b5) : (t5 array, _) idx_mut) next_el.#b5;
    mark_test_run 36;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 36 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t6 = #{ int; int64# }   *)
  (*****************************)
  let eq = (fun (#{ a6 = a61; b6 = b61 } : t6) (#{ a6 = a62; b6 = b62 } : t6) -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b61 b62) in
  let mk_value i = (#{ a6 = (i + 0); b6 = Int64_u.of_int (i + 1) } : t6) in
  (* Create an array of size [size] *)
  let a : t6 array = makearray_dynamic size (#{ a6 = 0; b6 = #1L } : t6) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 37;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 37 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 38;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 38 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a6 *)
    let el = #{ el with a6 = next_el.#a6 } in
    set_idx_mut a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 39;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 39 failed %d %d" size i;
    (* .#b6 *)
    let el = #{ el with b6 = next_el.#b6 } in
    set_idx_mut a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 40;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 40 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t7 = #{ int; int32# }   *)
  (*****************************)
  let eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let mk_value i = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7) in
  (* Create an array of size [size] *)
  let a : t7 array = makearray_dynamic size (#{ a7 = 0; b7 = #1l } : t7) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 41;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 41 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 42;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 42 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a7 *)
    let el = #{ el with a7 = next_el.#a7 } in
    set_idx_mut a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 43;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 43 failed %d %d" size i;
    (* .#b7 *)
    let el = #{ el with b7 = next_el.#b7 } in
    set_idx_mut a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 44;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 44 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t8 = #{ int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a8 = a81; b8 = b81; c8 = c81 } : t8) (#{ a8 = a82; b8 = b82; c8 = c82 } : t8) -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b81 b82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c81 c82) in
  let mk_value i = (#{ a8 = (i + 0); b8 = Int32_u.of_int (i + 1); c8 = Int32_u.of_int (i + 2) } : t8) in
  (* Create an array of size [size] *)
  let a : t8 array = makearray_dynamic size (#{ a8 = 0; b8 = #1l; c8 = #2l } : t8) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 45;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 45 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 46;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 46 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a8 *)
    let el = #{ el with a8 = next_el.#a8 } in
    set_idx_mut a ((.(i).#a8) : (t8 array, _) idx_mut) next_el.#a8;
    mark_test_run 47;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 47 failed %d %d" size i;
    (* .#b8 *)
    let el = #{ el with b8 = next_el.#b8 } in
    set_idx_mut a ((.(i).#b8) : (t8 array, _) idx_mut) next_el.#b8;
    mark_test_run 48;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 48 failed %d %d" size i;
    (* .#c8 *)
    let el = #{ el with c8 = next_el.#c8 } in
    set_idx_mut a ((.(i).#c8) : (t8 array, _) idx_mut) next_el.#c8;
    mark_test_run 49;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 49 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t9 = #{ int; nativeint# }   *)
  (*********************************)
  let eq = (fun (#{ a9 = a91; b9 = b91 } : t9) (#{ a9 = a92; b9 = b92 } : t9) -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b91 b92) in
  let mk_value i = (#{ a9 = (i + 0); b9 = Nativeint_u.of_int (i + 1) } : t9) in
  (* Create an array of size [size] *)
  let a : t9 array = makearray_dynamic size (#{ a9 = 0; b9 = #1n } : t9) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 50;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 50 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 51;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 51 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a9 *)
    let el = #{ el with a9 = next_el.#a9 } in
    set_idx_mut a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 52;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 52 failed %d %d" size i;
    (* .#b9 *)
    let el = #{ el with b9 = next_el.#b9 } in
    set_idx_mut a ((.(i).#b9) : (t9 array, _) idx_mut) next_el.#b9;
    mark_test_run 53;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 53 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t10 = #{ int; float }   *)
  (*****************************)
  let eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let mk_value i = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10) in
  (* Create an array of size [size] *)
  let a : t10 array = makearray_dynamic size (#{ a10 = 0; b10 = 1. } : t10) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 54;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 54 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 55;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 55 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a10 *)
    let el = #{ el with a10 = next_el.#a10 } in
    set_idx_mut a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 56;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 56 failed %d %d" size i;
    (* .#b10 *)
    let el = #{ el with b10 = next_el.#b10 } in
    set_idx_mut a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 57;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 57 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t11 = #{ int; float; int }   *)
  (**********************************)
  let eq = (fun (#{ a11 = a111; b11 = b111; c11 = c111 } : t11) (#{ a11 = a112; b11 = b112; c11 = c112 } : t11) -> (fun a b -> Int.equal a b) a111 a112 && (fun a b -> Float.equal (globalize a) (globalize b)) b111 b112 && (fun a b -> Int.equal a b) c111 c112) in
  let mk_value i = (#{ a11 = (i + 0); b11 = Float.of_int (i + 1); c11 = (i + 2) } : t11) in
  (* Create an array of size [size] *)
  let a : t11 array = makearray_dynamic size (#{ a11 = 0; b11 = 1.; c11 = 2 } : t11) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 58;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 58 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 59;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 59 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a11 *)
    let el = #{ el with a11 = next_el.#a11 } in
    set_idx_mut a ((.(i).#a11) : (t11 array, _) idx_mut) next_el.#a11;
    mark_test_run 60;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 60 failed %d %d" size i;
    (* .#b11 *)
    let el = #{ el with b11 = next_el.#b11 } in
    set_idx_mut a ((.(i).#b11) : (t11 array, _) idx_mut) next_el.#b11;
    mark_test_run 61;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 61 failed %d %d" size i;
    (* .#c11 *)
    let el = #{ el with c11 = next_el.#c11 } in
    set_idx_mut a ((.(i).#c11) : (t11 array, _) idx_mut) next_el.#c11;
    mark_test_run 62;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 62 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t12 = #{ int; float; float }   *)
  (************************************)
  let eq = (fun (#{ a12 = a121; b12 = b121; c12 = c121 } : t12) (#{ a12 = a122; b12 = b122; c12 = c122 } : t12) -> (fun a b -> Int.equal a b) a121 a122 && (fun a b -> Float.equal (globalize a) (globalize b)) b121 b122 && (fun a b -> Float.equal (globalize a) (globalize b)) c121 c122) in
  let mk_value i = (#{ a12 = (i + 0); b12 = Float.of_int (i + 1); c12 = Float.of_int (i + 2) } : t12) in
  (* Create an array of size [size] *)
  let a : t12 array = makearray_dynamic size (#{ a12 = 0; b12 = 1.; c12 = 2. } : t12) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 63;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 63 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 64;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 64 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a12 *)
    let el = #{ el with a12 = next_el.#a12 } in
    set_idx_mut a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 65;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 65 failed %d %d" size i;
    (* .#b12 *)
    let el = #{ el with b12 = next_el.#b12 } in
    set_idx_mut a ((.(i).#b12) : (t12 array, _) idx_mut) next_el.#b12;
    mark_test_run 66;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 66 failed %d %d" size i;
    (* .#c12 *)
    let el = #{ el with c12 = next_el.#c12 } in
    set_idx_mut a ((.(i).#c12) : (t12 array, _) idx_mut) next_el.#c12;
    mark_test_run 67;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 67 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t13 = #{ int; #{ int } }   *)
  (********************************)
  let eq = (fun (#{ a13 = a131; b13 = b131 } : t13) (#{ a13 = a132; b13 = b132 } : t13) -> (fun a b -> Int.equal a b) a131 a132 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b131 b132) in
  let mk_value i = (#{ a13 = (i + 0); b13 = (#{ a0 = (i + 1) } : t0) } : t13) in
  (* Create an array of size [size] *)
  let a : t13 array = makearray_dynamic size (#{ a13 = 0; b13 = (#{ a0 = 1 } : t0) } : t13) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 68;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 68 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 69;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 69 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a13 *)
    let el = #{ el with a13 = next_el.#a13 } in
    set_idx_mut a ((.(i).#a13) : (t13 array, _) idx_mut) next_el.#a13;
    mark_test_run 70;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 70 failed %d %d" size i;
    (* .#b13 *)
    let el = #{ el with b13 = next_el.#b13 } in
    set_idx_mut a ((.(i).#b13) : (t13 array, _) idx_mut) next_el.#b13;
    mark_test_run 71;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 71 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b13.#a0 *)
    let el = #{ el with b13 = #{ el.#b13 with a0 = next_el.#b13.#a0 } } in
    set_idx_mut a ((.(i).#b13.#a0) : (t13 array, _) idx_mut) next_el.#b13.#a0;
    mark_test_run 72;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 72 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t14 = #{ int; #{ int; int } }   *)
  (*************************************)
  let eq = (fun (#{ a14 = a141; b14 = b141 } : t14) (#{ a14 = a142; b14 = b142 } : t14) -> (fun a b -> Int.equal a b) a141 a142 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b141 b142) in
  let mk_value i = (#{ a14 = (i + 0); b14 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t14) in
  (* Create an array of size [size] *)
  let a : t14 array = makearray_dynamic size (#{ a14 = 0; b14 = (#{ a1 = 1; b1 = 2 } : t1) } : t14) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 73;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 73 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 74;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 74 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a14 *)
    let el = #{ el with a14 = next_el.#a14 } in
    set_idx_mut a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 75;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 75 failed %d %d" size i;
    (* .#b14 *)
    let el = #{ el with b14 = next_el.#b14 } in
    set_idx_mut a ((.(i).#b14) : (t14 array, _) idx_mut) next_el.#b14;
    mark_test_run 76;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 76 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b14.#a1 *)
    let el = #{ el with b14 = #{ el.#b14 with a1 = next_el.#b14.#a1 } } in
    set_idx_mut a ((.(i).#b14.#a1) : (t14 array, _) idx_mut) next_el.#b14.#a1;
    mark_test_run 77;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 77 failed %d %d" size i;
    (* .#b14.#b1 *)
    let el = #{ el with b14 = #{ el.#b14 with b1 = next_el.#b14.#b1 } } in
    set_idx_mut a ((.(i).#b14.#b1) : (t14 array, _) idx_mut) next_el.#b14.#b1;
    mark_test_run 78;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 78 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t15 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  let eq = (fun (#{ a15 = a151; b15 = b151 } : t15) (#{ a15 = a152; b15 = b152 } : t15) -> (fun a b -> Int.equal a b) a151 a152 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b151 b152) in
  let mk_value i = (#{ a15 = (i + 0); b15 = (#{ a7 = (i + 1); b7 = Int32_u.of_int (i + 2) } : t7) } : t15) in
  (* Create an array of size [size] *)
  let a : t15 array = makearray_dynamic size (#{ a15 = 0; b15 = (#{ a7 = 1; b7 = #2l } : t7) } : t15) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 79;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 79 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 80;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 80 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a15 *)
    let el = #{ el with a15 = next_el.#a15 } in
    set_idx_mut a ((.(i).#a15) : (t15 array, _) idx_mut) next_el.#a15;
    mark_test_run 81;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 81 failed %d %d" size i;
    (* .#b15 *)
    let el = #{ el with b15 = next_el.#b15 } in
    set_idx_mut a ((.(i).#b15) : (t15 array, _) idx_mut) next_el.#b15;
    mark_test_run 82;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 82 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b15.#a7 *)
    let el = #{ el with b15 = #{ el.#b15 with a7 = next_el.#b15.#a7 } } in
    set_idx_mut a ((.(i).#b15.#a7) : (t15 array, _) idx_mut) next_el.#b15.#a7;
    mark_test_run 83;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 83 failed %d %d" size i;
    (* .#b15.#b7 *)
    let el = #{ el with b15 = #{ el.#b15 with b7 = next_el.#b15.#b7 } } in
    set_idx_mut a ((.(i).#b15.#b7) : (t15 array, _) idx_mut) next_el.#b15.#b7;
    mark_test_run 84;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 84 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t16 = #{ int; #{ int; float } }   *)
  (***************************************)
  let eq = (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int.equal a b) a161 a162 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b161 b162) in
  let mk_value i = (#{ a16 = (i + 0); b16 = (#{ a10 = (i + 1); b10 = Float.of_int (i + 2) } : t10) } : t16) in
  (* Create an array of size [size] *)
  let a : t16 array = makearray_dynamic size (#{ a16 = 0; b16 = (#{ a10 = 1; b10 = 2. } : t10) } : t16) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 85;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 85 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 86;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 86 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a16 *)
    let el = #{ el with a16 = next_el.#a16 } in
    set_idx_mut a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 87;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 87 failed %d %d" size i;
    (* .#b16 *)
    let el = #{ el with b16 = next_el.#b16 } in
    set_idx_mut a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 88;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 88 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b16.#a10 *)
    let el = #{ el with b16 = #{ el.#b16 with a10 = next_el.#b16.#a10 } } in
    set_idx_mut a ((.(i).#b16.#a10) : (t16 array, _) idx_mut) next_el.#b16.#a10;
    mark_test_run 89;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 89 failed %d %d" size i;
    (* .#b16.#b10 *)
    let el = #{ el with b16 = #{ el.#b16 with b10 = next_el.#b16.#b10 } } in
    set_idx_mut a ((.(i).#b16.#b10) : (t16 array, _) idx_mut) next_el.#b16.#b10;
    mark_test_run 90;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 90 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t18 = #{ int; #{ int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a18 = a181; b18 = b181 } : t18) (#{ a18 = a182; b18 = b182 } : t18) -> (fun a b -> Int.equal a b) a181 a182 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b181 b182) in
  let mk_value i = (#{ a18 = (i + 0); b18 = (#{ a17 = Int32_u.of_int (i + 1) } : t17) } : t18) in
  (* Create an array of size [size] *)
  let a : t18 array = makearray_dynamic size (#{ a18 = 0; b18 = (#{ a17 = #1l } : t17) } : t18) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 91 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 92;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 92 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a18 *)
    let el = #{ el with a18 = next_el.#a18 } in
    set_idx_mut a ((.(i).#a18) : (t18 array, _) idx_mut) next_el.#a18;
    mark_test_run 93;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 93 failed %d %d" size i;
    (* .#b18 *)
    let el = #{ el with b18 = next_el.#b18 } in
    set_idx_mut a ((.(i).#b18) : (t18 array, _) idx_mut) next_el.#b18;
    mark_test_run 94;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 94 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b18.#a17 *)
    let el = #{ el with b18 = #{ el.#b18 with a17 = next_el.#b18.#a17 } } in
    set_idx_mut a ((.(i).#b18.#a17) : (t18 array, _) idx_mut) next_el.#b18.#a17;
    mark_test_run 95;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 95 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t20 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Int.equal a b) a201 a202 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b201 b202) in
  let mk_value i = (#{ a20 = (i + 0); b20 = (#{ a19 = Int32_u.of_int (i + 1); b19 = Int32_u.of_int (i + 2) } : t19) } : t20) in
  (* Create an array of size [size] *)
  let a : t20 array = makearray_dynamic size (#{ a20 = 0; b20 = (#{ a19 = #1l; b19 = #2l } : t19) } : t20) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 96 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 97;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 97 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a20 *)
    let el = #{ el with a20 = next_el.#a20 } in
    set_idx_mut a ((.(i).#a20) : (t20 array, _) idx_mut) next_el.#a20;
    mark_test_run 98;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 98 failed %d %d" size i;
    (* .#b20 *)
    let el = #{ el with b20 = next_el.#b20 } in
    set_idx_mut a ((.(i).#b20) : (t20 array, _) idx_mut) next_el.#b20;
    mark_test_run 99;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 99 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b20.#a19 *)
    let el = #{ el with b20 = #{ el.#b20 with a19 = next_el.#b20.#a19 } } in
    set_idx_mut a ((.(i).#b20.#a19) : (t20 array, _) idx_mut) next_el.#b20.#a19;
    mark_test_run 100;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 100 failed %d %d" size i;
    (* .#b20.#b19 *)
    let el = #{ el with b20 = #{ el.#b20 with b19 = next_el.#b20.#b19 } } in
    set_idx_mut a ((.(i).#b20.#b19) : (t20 array, _) idx_mut) next_el.#b20.#b19;
    mark_test_run 101;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 101 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t22 = #{ int; #{ float } }   *)
  (**********************************)
  let eq = (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Int.equal a b) a221 a222 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b221 b222) in
  let mk_value i = (#{ a22 = (i + 0); b22 = (#{ a21 = Float.of_int (i + 1) } : t21) } : t22) in
  (* Create an array of size [size] *)
  let a : t22 array = makearray_dynamic size (#{ a22 = 0; b22 = (#{ a21 = 1. } : t21) } : t22) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 102;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 102 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 103;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 103 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a22 *)
    let el = #{ el with a22 = next_el.#a22 } in
    set_idx_mut a ((.(i).#a22) : (t22 array, _) idx_mut) next_el.#a22;
    mark_test_run 104;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 104 failed %d %d" size i;
    (* .#b22 *)
    let el = #{ el with b22 = next_el.#b22 } in
    set_idx_mut a ((.(i).#b22) : (t22 array, _) idx_mut) next_el.#b22;
    mark_test_run 105;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b22.#a21 *)
    let el = #{ el with b22 = #{ el.#b22 with a21 = next_el.#b22.#a21 } } in
    set_idx_mut a ((.(i).#b22.#a21) : (t22 array, _) idx_mut) next_el.#b22.#a21;
    mark_test_run 106;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 106 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t24 = #{ int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun (#{ a24 = a241; b24 = b241 } : t24) (#{ a24 = a242; b24 = b242 } : t24) -> (fun a b -> Int.equal a b) a241 a242 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b241 b242) in
  let mk_value i = (#{ a24 = (i + 0); b24 = (#{ a23 = Float.of_int (i + 1); b23 = (i + 2) } : t23) } : t24) in
  (* Create an array of size [size] *)
  let a : t24 array = makearray_dynamic size (#{ a24 = 0; b24 = (#{ a23 = 1.; b23 = 2 } : t23) } : t24) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 108;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 108 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a24 *)
    let el = #{ el with a24 = next_el.#a24 } in
    set_idx_mut a ((.(i).#a24) : (t24 array, _) idx_mut) next_el.#a24;
    mark_test_run 109;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 109 failed %d %d" size i;
    (* .#b24 *)
    let el = #{ el with b24 = next_el.#b24 } in
    set_idx_mut a ((.(i).#b24) : (t24 array, _) idx_mut) next_el.#b24;
    mark_test_run 110;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 110 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b24.#a23 *)
    let el = #{ el with b24 = #{ el.#b24 with a23 = next_el.#b24.#a23 } } in
    set_idx_mut a ((.(i).#b24.#a23) : (t24 array, _) idx_mut) next_el.#b24.#a23;
    mark_test_run 111;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 111 failed %d %d" size i;
    (* .#b24.#b23 *)
    let el = #{ el with b24 = #{ el.#b24 with b23 = next_el.#b24.#b23 } } in
    set_idx_mut a ((.(i).#b24.#b23) : (t24 array, _) idx_mut) next_el.#b24.#b23;
    mark_test_run 112;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 112 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t26 = #{ int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a26 = a261; b26 = b261 } : t26) (#{ a26 = a262; b26 = b262 } : t26) -> (fun a b -> Int.equal a b) a261 a262 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b261 b262) in
  let mk_value i = (#{ a26 = (i + 0); b26 = (#{ a25 = Float.of_int (i + 1); b25 = Float.of_int (i + 2) } : t25) } : t26) in
  (* Create an array of size [size] *)
  let a : t26 array = makearray_dynamic size (#{ a26 = 0; b26 = (#{ a25 = 1.; b25 = 2. } : t25) } : t26) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 113;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 113 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 114;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 114 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a26 *)
    let el = #{ el with a26 = next_el.#a26 } in
    set_idx_mut a ((.(i).#a26) : (t26 array, _) idx_mut) next_el.#a26;
    mark_test_run 115;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 115 failed %d %d" size i;
    (* .#b26 *)
    let el = #{ el with b26 = next_el.#b26 } in
    set_idx_mut a ((.(i).#b26) : (t26 array, _) idx_mut) next_el.#b26;
    mark_test_run 116;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 116 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b26.#a25 *)
    let el = #{ el with b26 = #{ el.#b26 with a25 = next_el.#b26.#a25 } } in
    set_idx_mut a ((.(i).#b26.#a25) : (t26 array, _) idx_mut) next_el.#b26.#a25;
    mark_test_run 117;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 117 failed %d %d" size i;
    (* .#b26.#b25 *)
    let el = #{ el with b26 = #{ el.#b26 with b25 = next_el.#b26.#b25 } } in
    set_idx_mut a ((.(i).#b26.#b25) : (t26 array, _) idx_mut) next_el.#b26.#b25;
    mark_test_run 118;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 118 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************)
  (*   t27 = #{ int64 }   *)
  (************************)
  let eq = (fun (#{ a27 = a271 } : t27) (#{ a27 = a272 } : t27) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a271 a272) in
  let mk_value i = (#{ a27 = Int64.of_int (i + 0) } : t27) in
  (* Create an array of size [size] *)
  let a : t27 array = makearray_dynamic size (#{ a27 = 0L } : t27) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 119;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 119 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a27 *)
    let el = #{ el with a27 = next_el.#a27 } in
    set_idx_mut a ((.(i).#a27) : (t27 array, _) idx_mut) next_el.#a27;
    mark_test_run 121;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 121 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t28 = #{ int64; int }   *)
  (*****************************)
  let eq = (fun (#{ a28 = a281; b28 = b281 } : t28) (#{ a28 = a282; b28 = b282 } : t28) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) in
  let mk_value i = (#{ a28 = Int64.of_int (i + 0); b28 = (i + 1) } : t28) in
  (* Create an array of size [size] *)
  let a : t28 array = makearray_dynamic size (#{ a28 = 0L; b28 = 1 } : t28) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 122;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 122 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 123;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 123 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a28 *)
    let el = #{ el with a28 = next_el.#a28 } in
    set_idx_mut a ((.(i).#a28) : (t28 array, _) idx_mut) next_el.#a28;
    mark_test_run 124;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 124 failed %d %d" size i;
    (* .#b28 *)
    let el = #{ el with b28 = next_el.#b28 } in
    set_idx_mut a ((.(i).#b28) : (t28 array, _) idx_mut) next_el.#b28;
    mark_test_run 125;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 125 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t29 = #{ int64; int64 }   *)
  (*******************************)
  let eq = (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) in
  let mk_value i = (#{ a29 = Int64.of_int (i + 0); b29 = Int64.of_int (i + 1) } : t29) in
  (* Create an array of size [size] *)
  let a : t29 array = makearray_dynamic size (#{ a29 = 0L; b29 = 1L } : t29) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 126;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 126 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 127;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 127 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a29 *)
    let el = #{ el with a29 = next_el.#a29 } in
    set_idx_mut a ((.(i).#a29) : (t29 array, _) idx_mut) next_el.#a29;
    mark_test_run 128;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 128 failed %d %d" size i;
    (* .#b29 *)
    let el = #{ el with b29 = next_el.#b29 } in
    set_idx_mut a ((.(i).#b29) : (t29 array, _) idx_mut) next_el.#b29;
    mark_test_run 129;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 129 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t30 = #{ int64; float }   *)
  (*******************************)
  let eq = (fun (#{ a30 = a301; b30 = b301 } : t30) (#{ a30 = a302; b30 = b302 } : t30) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) in
  let mk_value i = (#{ a30 = Int64.of_int (i + 0); b30 = Float.of_int (i + 1) } : t30) in
  (* Create an array of size [size] *)
  let a : t30 array = makearray_dynamic size (#{ a30 = 0L; b30 = 1. } : t30) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 130;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 130 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 131 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a30 *)
    let el = #{ el with a30 = next_el.#a30 } in
    set_idx_mut a ((.(i).#a30) : (t30 array, _) idx_mut) next_el.#a30;
    mark_test_run 132;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 132 failed %d %d" size i;
    (* .#b30 *)
    let el = #{ el with b30 = next_el.#b30 } in
    set_idx_mut a ((.(i).#b30) : (t30 array, _) idx_mut) next_el.#b30;
    mark_test_run 133;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 133 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t31 = #{ int64# }   *)
  (*************************)
  let eq = (fun (#{ a31 = a311 } : t31) (#{ a31 = a312 } : t31) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a311 a312) in
  let mk_value i = (#{ a31 = Int64_u.of_int (i + 0) } : t31) in
  (* Create an array of size [size] *)
  let a : t31 array = makearray_dynamic size (#{ a31 = #0L } : t31) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 134;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 134 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 135;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 135 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a31 *)
    let el = #{ el with a31 = next_el.#a31 } in
    set_idx_mut a ((.(i).#a31) : (t31 array, _) idx_mut) next_el.#a31;
    mark_test_run 136;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 136 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t32 = #{ int64#; int64# }   *)
  (*********************************)
  let eq = (fun (#{ a32 = a321; b32 = b321 } : t32) (#{ a32 = a322; b32 = b322 } : t32) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a321 a322 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b321 b322) in
  let mk_value i = (#{ a32 = Int64_u.of_int (i + 0); b32 = Int64_u.of_int (i + 1) } : t32) in
  (* Create an array of size [size] *)
  let a : t32 array = makearray_dynamic size (#{ a32 = #0L; b32 = #1L } : t32) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 137;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 137 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 138;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 138 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a32 *)
    let el = #{ el with a32 = next_el.#a32 } in
    set_idx_mut a ((.(i).#a32) : (t32 array, _) idx_mut) next_el.#a32;
    mark_test_run 139;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 139 failed %d %d" size i;
    (* .#b32 *)
    let el = #{ el with b32 = next_el.#b32 } in
    set_idx_mut a ((.(i).#b32) : (t32 array, _) idx_mut) next_el.#b32;
    mark_test_run 140;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 140 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t33 = #{ int64#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a33 = a331; b33 = b331 } : t33) (#{ a33 = a332; b33 = b332 } : t33) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a331 a332 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b331 b332) in
  let mk_value i = (#{ a33 = Int64_u.of_int (i + 0); b33 = Int32_u.of_int (i + 1) } : t33) in
  (* Create an array of size [size] *)
  let a : t33 array = makearray_dynamic size (#{ a33 = #0L; b33 = #1l } : t33) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 141;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 141 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 142;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 142 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a33 *)
    let el = #{ el with a33 = next_el.#a33 } in
    set_idx_mut a ((.(i).#a33) : (t33 array, _) idx_mut) next_el.#a33;
    mark_test_run 143;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 143 failed %d %d" size i;
    (* .#b33 *)
    let el = #{ el with b33 = next_el.#b33 } in
    set_idx_mut a ((.(i).#b33) : (t33 array, _) idx_mut) next_el.#b33;
    mark_test_run 144;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 144 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t34 = #{ int64#; nativeint# }   *)
  (*************************************)
  let eq = (fun (#{ a34 = a341; b34 = b341 } : t34) (#{ a34 = a342; b34 = b342 } : t34) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a341 a342 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b341 b342) in
  let mk_value i = (#{ a34 = Int64_u.of_int (i + 0); b34 = Nativeint_u.of_int (i + 1) } : t34) in
  (* Create an array of size [size] *)
  let a : t34 array = makearray_dynamic size (#{ a34 = #0L; b34 = #1n } : t34) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 145;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 145 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 146;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 146 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a34 *)
    let el = #{ el with a34 = next_el.#a34 } in
    set_idx_mut a ((.(i).#a34) : (t34 array, _) idx_mut) next_el.#a34;
    mark_test_run 147;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 147 failed %d %d" size i;
    (* .#b34 *)
    let el = #{ el with b34 = next_el.#b34 } in
    set_idx_mut a ((.(i).#b34) : (t34 array, _) idx_mut) next_el.#b34;
    mark_test_run 148;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 148 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t17 = #{ int32# }   *)
  (*************************)
  let eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let mk_value i = (#{ a17 = Int32_u.of_int (i + 0) } : t17) in
  (* Create an array of size [size] *)
  let a : t17 array = makearray_dynamic size (#{ a17 = #0l } : t17) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 149;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 149 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 150;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 150 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a17 *)
    let el = #{ el with a17 = next_el.#a17 } in
    set_idx_mut a ((.(i).#a17) : (t17 array, _) idx_mut) next_el.#a17;
    mark_test_run 151;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 151 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t35 = #{ int32#; int64# }   *)
  (*********************************)
  let eq = (fun (#{ a35 = a351; b35 = b351 } : t35) (#{ a35 = a352; b35 = b352 } : t35) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a351 a352 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b351 b352) in
  let mk_value i = (#{ a35 = Int32_u.of_int (i + 0); b35 = Int64_u.of_int (i + 1) } : t35) in
  (* Create an array of size [size] *)
  let a : t35 array = makearray_dynamic size (#{ a35 = #0l; b35 = #1L } : t35) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 152;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 152 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 153;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 153 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a35 *)
    let el = #{ el with a35 = next_el.#a35 } in
    set_idx_mut a ((.(i).#a35) : (t35 array, _) idx_mut) next_el.#a35;
    mark_test_run 154;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 154 failed %d %d" size i;
    (* .#b35 *)
    let el = #{ el with b35 = next_el.#b35 } in
    set_idx_mut a ((.(i).#b35) : (t35 array, _) idx_mut) next_el.#b35;
    mark_test_run 155;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 155 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t19 = #{ int32#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let mk_value i = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19) in
  (* Create an array of size [size] *)
  let a : t19 array = makearray_dynamic size (#{ a19 = #0l; b19 = #1l } : t19) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 156;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 156 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 157;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 157 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a19 *)
    let el = #{ el with a19 = next_el.#a19 } in
    set_idx_mut a ((.(i).#a19) : (t19 array, _) idx_mut) next_el.#a19;
    mark_test_run 158;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 158 failed %d %d" size i;
    (* .#b19 *)
    let el = #{ el with b19 = next_el.#b19 } in
    set_idx_mut a ((.(i).#b19) : (t19 array, _) idx_mut) next_el.#b19;
    mark_test_run 159;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 159 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t36 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun (#{ a36 = a361; b36 = b361; c36 = c361 } : t36) (#{ a36 = a362; b36 = b362; c36 = c362 } : t36) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a361 a362 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b361 b362 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c361 c362) in
  let mk_value i = (#{ a36 = Int32_u.of_int (i + 0); b36 = Int32_u.of_int (i + 1); c36 = Int32_u.of_int (i + 2) } : t36) in
  (* Create an array of size [size] *)
  let a : t36 array = makearray_dynamic size (#{ a36 = #0l; b36 = #1l; c36 = #2l } : t36) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 160;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 160 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 161;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 161 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a36 *)
    let el = #{ el with a36 = next_el.#a36 } in
    set_idx_mut a ((.(i).#a36) : (t36 array, _) idx_mut) next_el.#a36;
    mark_test_run 162;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 162 failed %d %d" size i;
    (* .#b36 *)
    let el = #{ el with b36 = next_el.#b36 } in
    set_idx_mut a ((.(i).#b36) : (t36 array, _) idx_mut) next_el.#b36;
    mark_test_run 163;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 163 failed %d %d" size i;
    (* .#c36 *)
    let el = #{ el with c36 = next_el.#c36 } in
    set_idx_mut a ((.(i).#c36) : (t36 array, _) idx_mut) next_el.#c36;
    mark_test_run 164;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 164 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t37 = #{ int32#; nativeint# }   *)
  (*************************************)
  let eq = (fun (#{ a37 = a371; b37 = b371 } : t37) (#{ a37 = a372; b37 = b372 } : t37) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a371 a372 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b371 b372) in
  let mk_value i = (#{ a37 = Int32_u.of_int (i + 0); b37 = Nativeint_u.of_int (i + 1) } : t37) in
  (* Create an array of size [size] *)
  let a : t37 array = makearray_dynamic size (#{ a37 = #0l; b37 = #1n } : t37) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 165;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 165 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 166;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 166 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a37 *)
    let el = #{ el with a37 = next_el.#a37 } in
    set_idx_mut a ((.(i).#a37) : (t37 array, _) idx_mut) next_el.#a37;
    mark_test_run 167;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 167 failed %d %d" size i;
    (* .#b37 *)
    let el = #{ el with b37 = next_el.#b37 } in
    set_idx_mut a ((.(i).#b37) : (t37 array, _) idx_mut) next_el.#b37;
    mark_test_run 168;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 168 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t38 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a38 = a381; b38 = b381 } : t38) (#{ a38 = a382; b38 = b382 } : t38) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a381 a382 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b381 b382) in
  let mk_value i = (#{ a38 = Int32_u.of_int (i + 0); b38 = (#{ a17 = Int32_u.of_int (i + 1) } : t17) } : t38) in
  (* Create an array of size [size] *)
  let a : t38 array = makearray_dynamic size (#{ a38 = #0l; b38 = (#{ a17 = #1l } : t17) } : t38) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 169;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 169 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 170;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 170 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a38 *)
    let el = #{ el with a38 = next_el.#a38 } in
    set_idx_mut a ((.(i).#a38) : (t38 array, _) idx_mut) next_el.#a38;
    mark_test_run 171;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 171 failed %d %d" size i;
    (* .#b38 *)
    let el = #{ el with b38 = next_el.#b38 } in
    set_idx_mut a ((.(i).#b38) : (t38 array, _) idx_mut) next_el.#b38;
    mark_test_run 172;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 172 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b38.#a17 *)
    let el = #{ el with b38 = #{ el.#b38 with a17 = next_el.#b38.#a17 } } in
    set_idx_mut a ((.(i).#b38.#a17) : (t38 array, _) idx_mut) next_el.#b38.#a17;
    mark_test_run 173;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 173 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t39 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun (#{ a39 = a391; b39 = b391 } : t39) (#{ a39 = a392; b39 = b392 } : t39) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b391 b392) in
  let mk_value i = (#{ a39 = Int32_u.of_int (i + 0); b39 = (#{ a19 = Int32_u.of_int (i + 1); b19 = Int32_u.of_int (i + 2) } : t19) } : t39) in
  (* Create an array of size [size] *)
  let a : t39 array = makearray_dynamic size (#{ a39 = #0l; b39 = (#{ a19 = #1l; b19 = #2l } : t19) } : t39) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 174;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 174 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 175;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 175 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a39 *)
    let el = #{ el with a39 = next_el.#a39 } in
    set_idx_mut a ((.(i).#a39) : (t39 array, _) idx_mut) next_el.#a39;
    mark_test_run 176;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 176 failed %d %d" size i;
    (* .#b39 *)
    let el = #{ el with b39 = next_el.#b39 } in
    set_idx_mut a ((.(i).#b39) : (t39 array, _) idx_mut) next_el.#b39;
    mark_test_run 177;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 177 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b39.#a19 *)
    let el = #{ el with b39 = #{ el.#b39 with a19 = next_el.#b39.#a19 } } in
    set_idx_mut a ((.(i).#b39.#a19) : (t39 array, _) idx_mut) next_el.#b39.#a19;
    mark_test_run 178;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 178 failed %d %d" size i;
    (* .#b39.#b19 *)
    let el = #{ el with b39 = #{ el.#b39 with b19 = next_el.#b39.#b19 } } in
    set_idx_mut a ((.(i).#b39.#b19) : (t39 array, _) idx_mut) next_el.#b39.#b19;
    mark_test_run 179;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 179 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t40 = #{ nativeint# }   *)
  (*****************************)
  let eq = (fun (#{ a40 = a401 } : t40) (#{ a40 = a402 } : t40) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a401 a402) in
  let mk_value i = (#{ a40 = Nativeint_u.of_int (i + 0) } : t40) in
  (* Create an array of size [size] *)
  let a : t40 array = makearray_dynamic size (#{ a40 = #0n } : t40) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 180;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 180 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 181;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 181 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a40 *)
    let el = #{ el with a40 = next_el.#a40 } in
    set_idx_mut a ((.(i).#a40) : (t40 array, _) idx_mut) next_el.#a40;
    mark_test_run 182;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 182 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t41 = #{ nativeint#; int64# }   *)
  (*************************************)
  let eq = (fun (#{ a41 = a411; b41 = b411 } : t41) (#{ a41 = a412; b41 = b412 } : t41) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a411 a412 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b411 b412) in
  let mk_value i = (#{ a41 = Nativeint_u.of_int (i + 0); b41 = Int64_u.of_int (i + 1) } : t41) in
  (* Create an array of size [size] *)
  let a : t41 array = makearray_dynamic size (#{ a41 = #0n; b41 = #1L } : t41) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 183;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 183 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 184;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 184 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a41 *)
    let el = #{ el with a41 = next_el.#a41 } in
    set_idx_mut a ((.(i).#a41) : (t41 array, _) idx_mut) next_el.#a41;
    mark_test_run 185;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 185 failed %d %d" size i;
    (* .#b41 *)
    let el = #{ el with b41 = next_el.#b41 } in
    set_idx_mut a ((.(i).#b41) : (t41 array, _) idx_mut) next_el.#b41;
    mark_test_run 186;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 186 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t42 = #{ nativeint#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a42 = a421; b42 = b421 } : t42) (#{ a42 = a422; b42 = b422 } : t42) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a421 a422 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b421 b422) in
  let mk_value i = (#{ a42 = Nativeint_u.of_int (i + 0); b42 = Int32_u.of_int (i + 1) } : t42) in
  (* Create an array of size [size] *)
  let a : t42 array = makearray_dynamic size (#{ a42 = #0n; b42 = #1l } : t42) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 187;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 187 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 188;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 188 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a42 *)
    let el = #{ el with a42 = next_el.#a42 } in
    set_idx_mut a ((.(i).#a42) : (t42 array, _) idx_mut) next_el.#a42;
    mark_test_run 189;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 189 failed %d %d" size i;
    (* .#b42 *)
    let el = #{ el with b42 = next_el.#b42 } in
    set_idx_mut a ((.(i).#b42) : (t42 array, _) idx_mut) next_el.#b42;
    mark_test_run 190;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 190 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t43 = #{ nativeint#; nativeint# }   *)
  (*****************************************)
  let eq = (fun (#{ a43 = a431; b43 = b431 } : t43) (#{ a43 = a432; b43 = b432 } : t43) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a431 a432 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b431 b432) in
  let mk_value i = (#{ a43 = Nativeint_u.of_int (i + 0); b43 = Nativeint_u.of_int (i + 1) } : t43) in
  (* Create an array of size [size] *)
  let a : t43 array = makearray_dynamic size (#{ a43 = #0n; b43 = #1n } : t43) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 191;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 191 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 192;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 192 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a43 *)
    let el = #{ el with a43 = next_el.#a43 } in
    set_idx_mut a ((.(i).#a43) : (t43 array, _) idx_mut) next_el.#a43;
    mark_test_run 193;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 193 failed %d %d" size i;
    (* .#b43 *)
    let el = #{ el with b43 = next_el.#b43 } in
    set_idx_mut a ((.(i).#b43) : (t43 array, _) idx_mut) next_el.#b43;
    mark_test_run 194;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 194 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t23 = #{ float; int }   *)
  (*****************************)
  let eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let mk_value i = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23) in
  (* Create an array of size [size] *)
  let a : t23 array = makearray_dynamic size (#{ a23 = 0.; b23 = 1 } : t23) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 195;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 195 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 196;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 196 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a23 *)
    let el = #{ el with a23 = next_el.#a23 } in
    set_idx_mut a ((.(i).#a23) : (t23 array, _) idx_mut) next_el.#a23;
    mark_test_run 197;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 197 failed %d %d" size i;
    (* .#b23 *)
    let el = #{ el with b23 = next_el.#b23 } in
    set_idx_mut a ((.(i).#b23) : (t23 array, _) idx_mut) next_el.#b23;
    mark_test_run 198;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 198 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t44 = #{ float; int; int }   *)
  (**********************************)
  let eq = (fun (#{ a44 = a441; b44 = b441; c44 = c441 } : t44) (#{ a44 = a442; b44 = b442; c44 = c442 } : t44) -> (fun a b -> Float.equal (globalize a) (globalize b)) a441 a442 && (fun a b -> Int.equal a b) b441 b442 && (fun a b -> Int.equal a b) c441 c442) in
  let mk_value i = (#{ a44 = Float.of_int (i + 0); b44 = (i + 1); c44 = (i + 2) } : t44) in
  (* Create an array of size [size] *)
  let a : t44 array = makearray_dynamic size (#{ a44 = 0.; b44 = 1; c44 = 2 } : t44) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 199;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 199 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 200;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 200 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a44 *)
    let el = #{ el with a44 = next_el.#a44 } in
    set_idx_mut a ((.(i).#a44) : (t44 array, _) idx_mut) next_el.#a44;
    mark_test_run 201;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 201 failed %d %d" size i;
    (* .#b44 *)
    let el = #{ el with b44 = next_el.#b44 } in
    set_idx_mut a ((.(i).#b44) : (t44 array, _) idx_mut) next_el.#b44;
    mark_test_run 202;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 202 failed %d %d" size i;
    (* .#c44 *)
    let el = #{ el with c44 = next_el.#c44 } in
    set_idx_mut a ((.(i).#c44) : (t44 array, _) idx_mut) next_el.#c44;
    mark_test_run 203;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 203 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t45 = #{ float; int; float }   *)
  (************************************)
  let eq = (fun (#{ a45 = a451; b45 = b451; c45 = c451 } : t45) (#{ a45 = a452; b45 = b452; c45 = c452 } : t45) -> (fun a b -> Float.equal (globalize a) (globalize b)) a451 a452 && (fun a b -> Int.equal a b) b451 b452 && (fun a b -> Float.equal (globalize a) (globalize b)) c451 c452) in
  let mk_value i = (#{ a45 = Float.of_int (i + 0); b45 = (i + 1); c45 = Float.of_int (i + 2) } : t45) in
  (* Create an array of size [size] *)
  let a : t45 array = makearray_dynamic size (#{ a45 = 0.; b45 = 1; c45 = 2. } : t45) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 204;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 204 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 205;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 205 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a45 *)
    let el = #{ el with a45 = next_el.#a45 } in
    set_idx_mut a ((.(i).#a45) : (t45 array, _) idx_mut) next_el.#a45;
    mark_test_run 206;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 206 failed %d %d" size i;
    (* .#b45 *)
    let el = #{ el with b45 = next_el.#b45 } in
    set_idx_mut a ((.(i).#b45) : (t45 array, _) idx_mut) next_el.#b45;
    mark_test_run 207;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 207 failed %d %d" size i;
    (* .#c45 *)
    let el = #{ el with c45 = next_el.#c45 } in
    set_idx_mut a ((.(i).#c45) : (t45 array, _) idx_mut) next_el.#c45;
    mark_test_run 208;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 208 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t46 = #{ float; int64 }   *)
  (*******************************)
  let eq = (fun (#{ a46 = a461; b46 = b461 } : t46) (#{ a46 = a462; b46 = b462 } : t46) -> (fun a b -> Float.equal (globalize a) (globalize b)) a461 a462 && (fun a b -> Int64.equal (globalize a) (globalize b)) b461 b462) in
  let mk_value i = (#{ a46 = Float.of_int (i + 0); b46 = Int64.of_int (i + 1) } : t46) in
  (* Create an array of size [size] *)
  let a : t46 array = makearray_dynamic size (#{ a46 = 0.; b46 = 1L } : t46) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 209;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 209 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 210;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 210 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a46 *)
    let el = #{ el with a46 = next_el.#a46 } in
    set_idx_mut a ((.(i).#a46) : (t46 array, _) idx_mut) next_el.#a46;
    mark_test_run 211;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 211 failed %d %d" size i;
    (* .#b46 *)
    let el = #{ el with b46 = next_el.#b46 } in
    set_idx_mut a ((.(i).#b46) : (t46 array, _) idx_mut) next_el.#b46;
    mark_test_run 212;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 212 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t25 = #{ float; float }   *)
  (*******************************)
  let eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let mk_value i = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25) in
  (* Create an array of size [size] *)
  let a : t25 array = makearray_dynamic size (#{ a25 = 0.; b25 = 1. } : t25) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 213;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 213 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 214;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 214 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a25 *)
    let el = #{ el with a25 = next_el.#a25 } in
    set_idx_mut a ((.(i).#a25) : (t25 array, _) idx_mut) next_el.#a25;
    mark_test_run 215;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 215 failed %d %d" size i;
    (* .#b25 *)
    let el = #{ el with b25 = next_el.#b25 } in
    set_idx_mut a ((.(i).#b25) : (t25 array, _) idx_mut) next_el.#b25;
    mark_test_run 216;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 216 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t47 = #{ float; float; int }   *)
  (************************************)
  let eq = (fun (#{ a47 = a471; b47 = b471; c47 = c471 } : t47) (#{ a47 = a472; b47 = b472; c47 = c472 } : t47) -> (fun a b -> Float.equal (globalize a) (globalize b)) a471 a472 && (fun a b -> Float.equal (globalize a) (globalize b)) b471 b472 && (fun a b -> Int.equal a b) c471 c472) in
  let mk_value i = (#{ a47 = Float.of_int (i + 0); b47 = Float.of_int (i + 1); c47 = (i + 2) } : t47) in
  (* Create an array of size [size] *)
  let a : t47 array = makearray_dynamic size (#{ a47 = 0.; b47 = 1.; c47 = 2 } : t47) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 217;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 217 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 218;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 218 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a47 *)
    let el = #{ el with a47 = next_el.#a47 } in
    set_idx_mut a ((.(i).#a47) : (t47 array, _) idx_mut) next_el.#a47;
    mark_test_run 219;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 219 failed %d %d" size i;
    (* .#b47 *)
    let el = #{ el with b47 = next_el.#b47 } in
    set_idx_mut a ((.(i).#b47) : (t47 array, _) idx_mut) next_el.#b47;
    mark_test_run 220;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 220 failed %d %d" size i;
    (* .#c47 *)
    let el = #{ el with c47 = next_el.#c47 } in
    set_idx_mut a ((.(i).#c47) : (t47 array, _) idx_mut) next_el.#c47;
    mark_test_run 221;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 221 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t48 = #{ float; float; float }   *)
  (**************************************)
  let eq = (fun (#{ a48 = a481; b48 = b481; c48 = c481 } : t48) (#{ a48 = a482; b48 = b482; c48 = c482 } : t48) -> (fun a b -> Float.equal (globalize a) (globalize b)) a481 a482 && (fun a b -> Float.equal (globalize a) (globalize b)) b481 b482 && (fun a b -> Float.equal (globalize a) (globalize b)) c481 c482) in
  let mk_value i = (#{ a48 = Float.of_int (i + 0); b48 = Float.of_int (i + 1); c48 = Float.of_int (i + 2) } : t48) in
  (* Create an array of size [size] *)
  let a : t48 array = makearray_dynamic size (#{ a48 = 0.; b48 = 1.; c48 = 2. } : t48) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 222;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 222 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 223;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 223 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a48 *)
    let el = #{ el with a48 = next_el.#a48 } in
    set_idx_mut a ((.(i).#a48) : (t48 array, _) idx_mut) next_el.#a48;
    mark_test_run 224;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 224 failed %d %d" size i;
    (* .#b48 *)
    let el = #{ el with b48 = next_el.#b48 } in
    set_idx_mut a ((.(i).#b48) : (t48 array, _) idx_mut) next_el.#b48;
    mark_test_run 225;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 225 failed %d %d" size i;
    (* .#c48 *)
    let el = #{ el with c48 = next_el.#c48 } in
    set_idx_mut a ((.(i).#c48) : (t48 array, _) idx_mut) next_el.#c48;
    mark_test_run 226;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 226 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t49 = #{ float; #{ int } }   *)
  (**********************************)
  let eq = (fun (#{ a49 = a491; b49 = b491 } : t49) (#{ a49 = a492; b49 = b492 } : t49) -> (fun a b -> Float.equal (globalize a) (globalize b)) a491 a492 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b491 b492) in
  let mk_value i = (#{ a49 = Float.of_int (i + 0); b49 = (#{ a0 = (i + 1) } : t0) } : t49) in
  (* Create an array of size [size] *)
  let a : t49 array = makearray_dynamic size (#{ a49 = 0.; b49 = (#{ a0 = 1 } : t0) } : t49) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 227;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 227 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 228;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 228 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a49 *)
    let el = #{ el with a49 = next_el.#a49 } in
    set_idx_mut a ((.(i).#a49) : (t49 array, _) idx_mut) next_el.#a49;
    mark_test_run 229;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 229 failed %d %d" size i;
    (* .#b49 *)
    let el = #{ el with b49 = next_el.#b49 } in
    set_idx_mut a ((.(i).#b49) : (t49 array, _) idx_mut) next_el.#b49;
    mark_test_run 230;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 230 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b49.#a0 *)
    let el = #{ el with b49 = #{ el.#b49 with a0 = next_el.#b49.#a0 } } in
    set_idx_mut a ((.(i).#b49.#a0) : (t49 array, _) idx_mut) next_el.#b49.#a0;
    mark_test_run 231;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 231 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t50 = #{ float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun (#{ a50 = a501; b50 = b501 } : t50) (#{ a50 = a502; b50 = b502 } : t50) -> (fun a b -> Float.equal (globalize a) (globalize b)) a501 a502 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b501 b502) in
  let mk_value i = (#{ a50 = Float.of_int (i + 0); b50 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t50) in
  (* Create an array of size [size] *)
  let a : t50 array = makearray_dynamic size (#{ a50 = 0.; b50 = (#{ a1 = 1; b1 = 2 } : t1) } : t50) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 232;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 232 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 233;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 233 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a50 *)
    let el = #{ el with a50 = next_el.#a50 } in
    set_idx_mut a ((.(i).#a50) : (t50 array, _) idx_mut) next_el.#a50;
    mark_test_run 234;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 234 failed %d %d" size i;
    (* .#b50 *)
    let el = #{ el with b50 = next_el.#b50 } in
    set_idx_mut a ((.(i).#b50) : (t50 array, _) idx_mut) next_el.#b50;
    mark_test_run 235;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 235 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b50.#a1 *)
    let el = #{ el with b50 = #{ el.#b50 with a1 = next_el.#b50.#a1 } } in
    set_idx_mut a ((.(i).#b50.#a1) : (t50 array, _) idx_mut) next_el.#b50.#a1;
    mark_test_run 236;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 236 failed %d %d" size i;
    (* .#b50.#b1 *)
    let el = #{ el with b50 = #{ el.#b50 with b1 = next_el.#b50.#b1 } } in
    set_idx_mut a ((.(i).#b50.#b1) : (t50 array, _) idx_mut) next_el.#b50.#b1;
    mark_test_run 237;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 237 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t51 = #{ float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a51 = a511; b51 = b511 } : t51) (#{ a51 = a512; b51 = b512 } : t51) -> (fun a b -> Float.equal (globalize a) (globalize b)) a511 a512 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b511 b512) in
  let mk_value i = (#{ a51 = Float.of_int (i + 0); b51 = (#{ a10 = (i + 1); b10 = Float.of_int (i + 2) } : t10) } : t51) in
  (* Create an array of size [size] *)
  let a : t51 array = makearray_dynamic size (#{ a51 = 0.; b51 = (#{ a10 = 1; b10 = 2. } : t10) } : t51) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 238;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 238 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 239;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 239 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a51 *)
    let el = #{ el with a51 = next_el.#a51 } in
    set_idx_mut a ((.(i).#a51) : (t51 array, _) idx_mut) next_el.#a51;
    mark_test_run 240;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 240 failed %d %d" size i;
    (* .#b51 *)
    let el = #{ el with b51 = next_el.#b51 } in
    set_idx_mut a ((.(i).#b51) : (t51 array, _) idx_mut) next_el.#b51;
    mark_test_run 241;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 241 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b51.#a10 *)
    let el = #{ el with b51 = #{ el.#b51 with a10 = next_el.#b51.#a10 } } in
    set_idx_mut a ((.(i).#b51.#a10) : (t51 array, _) idx_mut) next_el.#b51.#a10;
    mark_test_run 242;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 242 failed %d %d" size i;
    (* .#b51.#b10 *)
    let el = #{ el with b51 = #{ el.#b51 with b10 = next_el.#b51.#b10 } } in
    set_idx_mut a ((.(i).#b51.#b10) : (t51 array, _) idx_mut) next_el.#b51.#b10;
    mark_test_run 243;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 243 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t52 = #{ float; #{ float } }   *)
  (************************************)
  let eq = (fun (#{ a52 = a521; b52 = b521 } : t52) (#{ a52 = a522; b52 = b522 } : t52) -> (fun a b -> Float.equal (globalize a) (globalize b)) a521 a522 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b521 b522) in
  let mk_value i = (#{ a52 = Float.of_int (i + 0); b52 = (#{ a21 = Float.of_int (i + 1) } : t21) } : t52) in
  (* Create an array of size [size] *)
  let a : t52 array = makearray_dynamic size (#{ a52 = 0.; b52 = (#{ a21 = 1. } : t21) } : t52) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 244;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 244 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 245;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 245 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a52 *)
    let el = #{ el with a52 = next_el.#a52 } in
    set_idx_mut a ((.(i).#a52) : (t52 array, _) idx_mut) next_el.#a52;
    mark_test_run 246;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 246 failed %d %d" size i;
    (* .#b52 *)
    let el = #{ el with b52 = next_el.#b52 } in
    set_idx_mut a ((.(i).#b52) : (t52 array, _) idx_mut) next_el.#b52;
    mark_test_run 247;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 247 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b52.#a21 *)
    let el = #{ el with b52 = #{ el.#b52 with a21 = next_el.#b52.#a21 } } in
    set_idx_mut a ((.(i).#b52.#a21) : (t52 array, _) idx_mut) next_el.#b52.#a21;
    mark_test_run 248;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 248 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t53 = #{ float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun (#{ a53 = a531; b53 = b531 } : t53) (#{ a53 = a532; b53 = b532 } : t53) -> (fun a b -> Float.equal (globalize a) (globalize b)) a531 a532 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b531 b532) in
  let mk_value i = (#{ a53 = Float.of_int (i + 0); b53 = (#{ a23 = Float.of_int (i + 1); b23 = (i + 2) } : t23) } : t53) in
  (* Create an array of size [size] *)
  let a : t53 array = makearray_dynamic size (#{ a53 = 0.; b53 = (#{ a23 = 1.; b23 = 2 } : t23) } : t53) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 249;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 249 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 250;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 250 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a53 *)
    let el = #{ el with a53 = next_el.#a53 } in
    set_idx_mut a ((.(i).#a53) : (t53 array, _) idx_mut) next_el.#a53;
    mark_test_run 251;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 251 failed %d %d" size i;
    (* .#b53 *)
    let el = #{ el with b53 = next_el.#b53 } in
    set_idx_mut a ((.(i).#b53) : (t53 array, _) idx_mut) next_el.#b53;
    mark_test_run 252;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 252 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b53.#a23 *)
    let el = #{ el with b53 = #{ el.#b53 with a23 = next_el.#b53.#a23 } } in
    set_idx_mut a ((.(i).#b53.#a23) : (t53 array, _) idx_mut) next_el.#b53.#a23;
    mark_test_run 253;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 253 failed %d %d" size i;
    (* .#b53.#b23 *)
    let el = #{ el with b53 = #{ el.#b53 with b23 = next_el.#b53.#b23 } } in
    set_idx_mut a ((.(i).#b53.#b23) : (t53 array, _) idx_mut) next_el.#b53.#b23;
    mark_test_run 254;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 254 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t54 = #{ float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun (#{ a54 = a541; b54 = b541 } : t54) (#{ a54 = a542; b54 = b542 } : t54) -> (fun a b -> Float.equal (globalize a) (globalize b)) a541 a542 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b541 b542) in
  let mk_value i = (#{ a54 = Float.of_int (i + 0); b54 = (#{ a25 = Float.of_int (i + 1); b25 = Float.of_int (i + 2) } : t25) } : t54) in
  (* Create an array of size [size] *)
  let a : t54 array = makearray_dynamic size (#{ a54 = 0.; b54 = (#{ a25 = 1.; b25 = 2. } : t25) } : t54) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 255;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 255 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 256;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 256 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a54 *)
    let el = #{ el with a54 = next_el.#a54 } in
    set_idx_mut a ((.(i).#a54) : (t54 array, _) idx_mut) next_el.#a54;
    mark_test_run 257;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 257 failed %d %d" size i;
    (* .#b54 *)
    let el = #{ el with b54 = next_el.#b54 } in
    set_idx_mut a ((.(i).#b54) : (t54 array, _) idx_mut) next_el.#b54;
    mark_test_run 258;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 258 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b54.#a25 *)
    let el = #{ el with b54 = #{ el.#b54 with a25 = next_el.#b54.#a25 } } in
    set_idx_mut a ((.(i).#b54.#a25) : (t54 array, _) idx_mut) next_el.#b54.#a25;
    mark_test_run 259;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 259 failed %d %d" size i;
    (* .#b54.#b25 *)
    let el = #{ el with b54 = #{ el.#b54 with b25 = next_el.#b54.#b25 } } in
    set_idx_mut a ((.(i).#b54.#b25) : (t54 array, _) idx_mut) next_el.#b54.#b25;
    mark_test_run 260;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 260 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************)
  (*   t55 = #{ #{ int } }   *)
  (***************************)
  let eq = (fun (#{ a55 = a551 } : t55) (#{ a55 = a552 } : t55) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a551 a552) in
  let mk_value i = (#{ a55 = (#{ a0 = (i + 0) } : t0) } : t55) in
  (* Create an array of size [size] *)
  let a : t55 array = makearray_dynamic size (#{ a55 = (#{ a0 = 0 } : t0) } : t55) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 261;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 261 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 262;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 262 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a55 *)
    let el = #{ el with a55 = next_el.#a55 } in
    set_idx_mut a ((.(i).#a55) : (t55 array, _) idx_mut) next_el.#a55;
    mark_test_run 263;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 263 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a55.#a0 *)
    let el = #{ el with a55 = #{ el.#a55 with a0 = next_el.#a55.#a0 } } in
    set_idx_mut a ((.(i).#a55.#a0) : (t55 array, _) idx_mut) next_el.#a55.#a0;
    mark_test_run 264;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 264 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t56 = #{ #{ int }; int }   *)
  (********************************)
  let eq = (fun (#{ a56 = a561; b56 = b561 } : t56) (#{ a56 = a562; b56 = b562 } : t56) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a561 a562 && (fun a b -> Int.equal a b) b561 b562) in
  let mk_value i = (#{ a56 = (#{ a0 = (i + 0) } : t0); b56 = (i + 1) } : t56) in
  (* Create an array of size [size] *)
  let a : t56 array = makearray_dynamic size (#{ a56 = (#{ a0 = 0 } : t0); b56 = 1 } : t56) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 265;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 265 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 266;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 266 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a56 *)
    let el = #{ el with a56 = next_el.#a56 } in
    set_idx_mut a ((.(i).#a56) : (t56 array, _) idx_mut) next_el.#a56;
    mark_test_run 267;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 267 failed %d %d" size i;
    (* .#b56 *)
    let el = #{ el with b56 = next_el.#b56 } in
    set_idx_mut a ((.(i).#b56) : (t56 array, _) idx_mut) next_el.#b56;
    mark_test_run 268;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 268 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a56.#a0 *)
    let el = #{ el with a56 = #{ el.#a56 with a0 = next_el.#a56.#a0 } } in
    set_idx_mut a ((.(i).#a56.#a0) : (t56 array, _) idx_mut) next_el.#a56.#a0;
    mark_test_run 269;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 269 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t57 = #{ #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun (#{ a57 = a571; b57 = b571 } : t57) (#{ a57 = a572; b57 = b572 } : t57) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a571 a572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b571 b572) in
  let mk_value i = (#{ a57 = (#{ a0 = (i + 0) } : t0); b57 = Int32_u.of_int (i + 1) } : t57) in
  (* Create an array of size [size] *)
  let a : t57 array = makearray_dynamic size (#{ a57 = (#{ a0 = 0 } : t0); b57 = #1l } : t57) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 270;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 270 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 271;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 271 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a57 *)
    let el = #{ el with a57 = next_el.#a57 } in
    set_idx_mut a ((.(i).#a57) : (t57 array, _) idx_mut) next_el.#a57;
    mark_test_run 272;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 272 failed %d %d" size i;
    (* .#b57 *)
    let el = #{ el with b57 = next_el.#b57 } in
    set_idx_mut a ((.(i).#b57) : (t57 array, _) idx_mut) next_el.#b57;
    mark_test_run 273;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 273 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a57.#a0 *)
    let el = #{ el with a57 = #{ el.#a57 with a0 = next_el.#a57.#a0 } } in
    set_idx_mut a ((.(i).#a57.#a0) : (t57 array, _) idx_mut) next_el.#a57.#a0;
    mark_test_run 274;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 274 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t58 = #{ #{ int }; float }   *)
  (**********************************)
  let eq = (fun (#{ a58 = a581; b58 = b581 } : t58) (#{ a58 = a582; b58 = b582 } : t58) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a581 a582 && (fun a b -> Float.equal (globalize a) (globalize b)) b581 b582) in
  let mk_value i = (#{ a58 = (#{ a0 = (i + 0) } : t0); b58 = Float.of_int (i + 1) } : t58) in
  (* Create an array of size [size] *)
  let a : t58 array = makearray_dynamic size (#{ a58 = (#{ a0 = 0 } : t0); b58 = 1. } : t58) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 275;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 275 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 276;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 276 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a58 *)
    let el = #{ el with a58 = next_el.#a58 } in
    set_idx_mut a ((.(i).#a58) : (t58 array, _) idx_mut) next_el.#a58;
    mark_test_run 277;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 277 failed %d %d" size i;
    (* .#b58 *)
    let el = #{ el with b58 = next_el.#b58 } in
    set_idx_mut a ((.(i).#b58) : (t58 array, _) idx_mut) next_el.#b58;
    mark_test_run 278;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 278 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a58.#a0 *)
    let el = #{ el with a58 = #{ el.#a58 with a0 = next_el.#a58.#a0 } } in
    set_idx_mut a ((.(i).#a58.#a0) : (t58 array, _) idx_mut) next_el.#a58.#a0;
    mark_test_run 279;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 279 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t59 = #{ #{ int; int } }   *)
  (********************************)
  let eq = (fun (#{ a59 = a591 } : t59) (#{ a59 = a592 } : t59) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a591 a592) in
  let mk_value i = (#{ a59 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) } : t59) in
  (* Create an array of size [size] *)
  let a : t59 array = makearray_dynamic size (#{ a59 = (#{ a1 = 0; b1 = 1 } : t1) } : t59) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 280;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 280 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 281;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 281 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a59 *)
    let el = #{ el with a59 = next_el.#a59 } in
    set_idx_mut a ((.(i).#a59) : (t59 array, _) idx_mut) next_el.#a59;
    mark_test_run 282;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 282 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a59.#a1 *)
    let el = #{ el with a59 = #{ el.#a59 with a1 = next_el.#a59.#a1 } } in
    set_idx_mut a ((.(i).#a59.#a1) : (t59 array, _) idx_mut) next_el.#a59.#a1;
    mark_test_run 283;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 283 failed %d %d" size i;
    (* .#a59.#b1 *)
    let el = #{ el with a59 = #{ el.#a59 with b1 = next_el.#a59.#b1 } } in
    set_idx_mut a ((.(i).#a59.#b1) : (t59 array, _) idx_mut) next_el.#a59.#b1;
    mark_test_run 284;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 284 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t60 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun (#{ a60 = a601; b60 = b601 } : t60) (#{ a60 = a602; b60 = b602 } : t60) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a601 a602 && (fun a b -> Int.equal a b) b601 b602) in
  let mk_value i = (#{ a60 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b60 = (i + 2) } : t60) in
  (* Create an array of size [size] *)
  let a : t60 array = makearray_dynamic size (#{ a60 = (#{ a1 = 0; b1 = 1 } : t1); b60 = 2 } : t60) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 285;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 285 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 286;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 286 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a60 *)
    let el = #{ el with a60 = next_el.#a60 } in
    set_idx_mut a ((.(i).#a60) : (t60 array, _) idx_mut) next_el.#a60;
    mark_test_run 287;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 287 failed %d %d" size i;
    (* .#b60 *)
    let el = #{ el with b60 = next_el.#b60 } in
    set_idx_mut a ((.(i).#b60) : (t60 array, _) idx_mut) next_el.#b60;
    mark_test_run 288;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 288 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a60.#a1 *)
    let el = #{ el with a60 = #{ el.#a60 with a1 = next_el.#a60.#a1 } } in
    set_idx_mut a ((.(i).#a60.#a1) : (t60 array, _) idx_mut) next_el.#a60.#a1;
    mark_test_run 289;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 289 failed %d %d" size i;
    (* .#a60.#b1 *)
    let el = #{ el with a60 = #{ el.#a60 with b1 = next_el.#a60.#b1 } } in
    set_idx_mut a ((.(i).#a60.#b1) : (t60 array, _) idx_mut) next_el.#a60.#b1;
    mark_test_run 290;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 290 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t61 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun (#{ a61 = a611; b61 = b611 } : t61) (#{ a61 = a612; b61 = b612 } : t61) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a611 a612 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b611 b612) in
  let mk_value i = (#{ a61 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b61 = Int32_u.of_int (i + 2) } : t61) in
  (* Create an array of size [size] *)
  let a : t61 array = makearray_dynamic size (#{ a61 = (#{ a1 = 0; b1 = 1 } : t1); b61 = #2l } : t61) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 291;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 291 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 292;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 292 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a61 *)
    let el = #{ el with a61 = next_el.#a61 } in
    set_idx_mut a ((.(i).#a61) : (t61 array, _) idx_mut) next_el.#a61;
    mark_test_run 293;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 293 failed %d %d" size i;
    (* .#b61 *)
    let el = #{ el with b61 = next_el.#b61 } in
    set_idx_mut a ((.(i).#b61) : (t61 array, _) idx_mut) next_el.#b61;
    mark_test_run 294;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 294 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a61.#a1 *)
    let el = #{ el with a61 = #{ el.#a61 with a1 = next_el.#a61.#a1 } } in
    set_idx_mut a ((.(i).#a61.#a1) : (t61 array, _) idx_mut) next_el.#a61.#a1;
    mark_test_run 295;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 295 failed %d %d" size i;
    (* .#a61.#b1 *)
    let el = #{ el with a61 = #{ el.#a61 with b1 = next_el.#a61.#b1 } } in
    set_idx_mut a ((.(i).#a61.#b1) : (t61 array, _) idx_mut) next_el.#a61.#b1;
    mark_test_run 296;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 296 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t62 = #{ #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun (#{ a62 = a621; b62 = b621 } : t62) (#{ a62 = a622; b62 = b622 } : t62) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a621 a622 && (fun a b -> Float.equal (globalize a) (globalize b)) b621 b622) in
  let mk_value i = (#{ a62 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b62 = Float.of_int (i + 2) } : t62) in
  (* Create an array of size [size] *)
  let a : t62 array = makearray_dynamic size (#{ a62 = (#{ a1 = 0; b1 = 1 } : t1); b62 = 2. } : t62) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 297;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 297 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 298;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 298 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a62 *)
    let el = #{ el with a62 = next_el.#a62 } in
    set_idx_mut a ((.(i).#a62) : (t62 array, _) idx_mut) next_el.#a62;
    mark_test_run 299;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 299 failed %d %d" size i;
    (* .#b62 *)
    let el = #{ el with b62 = next_el.#b62 } in
    set_idx_mut a ((.(i).#b62) : (t62 array, _) idx_mut) next_el.#b62;
    mark_test_run 300;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 300 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a62.#a1 *)
    let el = #{ el with a62 = #{ el.#a62 with a1 = next_el.#a62.#a1 } } in
    set_idx_mut a ((.(i).#a62.#a1) : (t62 array, _) idx_mut) next_el.#a62.#a1;
    mark_test_run 301;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 301 failed %d %d" size i;
    (* .#a62.#b1 *)
    let el = #{ el with a62 = #{ el.#a62 with b1 = next_el.#a62.#b1 } } in
    set_idx_mut a ((.(i).#a62.#b1) : (t62 array, _) idx_mut) next_el.#a62.#b1;
    mark_test_run 302;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 302 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t63 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a63 = a631 } : t63) (#{ a63 = a632 } : t63) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a631 a632) in
  let mk_value i = (#{ a63 = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7) } : t63) in
  (* Create an array of size [size] *)
  let a : t63 array = makearray_dynamic size (#{ a63 = (#{ a7 = 0; b7 = #1l } : t7) } : t63) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 303;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 303 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 304;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 304 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a63 *)
    let el = #{ el with a63 = next_el.#a63 } in
    set_idx_mut a ((.(i).#a63) : (t63 array, _) idx_mut) next_el.#a63;
    mark_test_run 305;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 305 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a63.#a7 *)
    let el = #{ el with a63 = #{ el.#a63 with a7 = next_el.#a63.#a7 } } in
    set_idx_mut a ((.(i).#a63.#a7) : (t63 array, _) idx_mut) next_el.#a63.#a7;
    mark_test_run 306;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 306 failed %d %d" size i;
    (* .#a63.#b7 *)
    let el = #{ el with a63 = #{ el.#a63 with b7 = next_el.#a63.#b7 } } in
    set_idx_mut a ((.(i).#a63.#b7) : (t63 array, _) idx_mut) next_el.#a63.#b7;
    mark_test_run 307;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 307 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t64 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun (#{ a64 = a641; b64 = b641 } : t64) (#{ a64 = a642; b64 = b642 } : t64) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a641 a642 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b641 b642) in
  let mk_value i = (#{ a64 = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7); b64 = Int32_u.of_int (i + 2) } : t64) in
  (* Create an array of size [size] *)
  let a : t64 array = makearray_dynamic size (#{ a64 = (#{ a7 = 0; b7 = #1l } : t7); b64 = #2l } : t64) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 308;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 308 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 309;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 309 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a64 *)
    let el = #{ el with a64 = next_el.#a64 } in
    set_idx_mut a ((.(i).#a64) : (t64 array, _) idx_mut) next_el.#a64;
    mark_test_run 310;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 310 failed %d %d" size i;
    (* .#b64 *)
    let el = #{ el with b64 = next_el.#b64 } in
    set_idx_mut a ((.(i).#b64) : (t64 array, _) idx_mut) next_el.#b64;
    mark_test_run 311;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 311 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a64.#a7 *)
    let el = #{ el with a64 = #{ el.#a64 with a7 = next_el.#a64.#a7 } } in
    set_idx_mut a ((.(i).#a64.#a7) : (t64 array, _) idx_mut) next_el.#a64.#a7;
    mark_test_run 312;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 312 failed %d %d" size i;
    (* .#a64.#b7 *)
    let el = #{ el with a64 = #{ el.#a64 with b7 = next_el.#a64.#b7 } } in
    set_idx_mut a ((.(i).#a64.#b7) : (t64 array, _) idx_mut) next_el.#a64.#b7;
    mark_test_run 313;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 313 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t65 = #{ #{ int; float } }   *)
  (**********************************)
  let eq = (fun (#{ a65 = a651 } : t65) (#{ a65 = a652 } : t65) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a651 a652) in
  let mk_value i = (#{ a65 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10) } : t65) in
  (* Create an array of size [size] *)
  let a : t65 array = makearray_dynamic size (#{ a65 = (#{ a10 = 0; b10 = 1. } : t10) } : t65) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 314;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 314 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 315;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 315 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a65 *)
    let el = #{ el with a65 = next_el.#a65 } in
    set_idx_mut a ((.(i).#a65) : (t65 array, _) idx_mut) next_el.#a65;
    mark_test_run 316;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 316 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a65.#a10 *)
    let el = #{ el with a65 = #{ el.#a65 with a10 = next_el.#a65.#a10 } } in
    set_idx_mut a ((.(i).#a65.#a10) : (t65 array, _) idx_mut) next_el.#a65.#a10;
    mark_test_run 317;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 317 failed %d %d" size i;
    (* .#a65.#b10 *)
    let el = #{ el with a65 = #{ el.#a65 with b10 = next_el.#a65.#b10 } } in
    set_idx_mut a ((.(i).#a65.#b10) : (t65 array, _) idx_mut) next_el.#a65.#b10;
    mark_test_run 318;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 318 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t66 = #{ #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun (#{ a66 = a661; b66 = b661 } : t66) (#{ a66 = a662; b66 = b662 } : t66) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a661 a662 && (fun a b -> Int.equal a b) b661 b662) in
  let mk_value i = (#{ a66 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10); b66 = (i + 2) } : t66) in
  (* Create an array of size [size] *)
  let a : t66 array = makearray_dynamic size (#{ a66 = (#{ a10 = 0; b10 = 1. } : t10); b66 = 2 } : t66) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 319;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 319 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 320;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 320 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a66 *)
    let el = #{ el with a66 = next_el.#a66 } in
    set_idx_mut a ((.(i).#a66) : (t66 array, _) idx_mut) next_el.#a66;
    mark_test_run 321;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 321 failed %d %d" size i;
    (* .#b66 *)
    let el = #{ el with b66 = next_el.#b66 } in
    set_idx_mut a ((.(i).#b66) : (t66 array, _) idx_mut) next_el.#b66;
    mark_test_run 322;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 322 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a66.#a10 *)
    let el = #{ el with a66 = #{ el.#a66 with a10 = next_el.#a66.#a10 } } in
    set_idx_mut a ((.(i).#a66.#a10) : (t66 array, _) idx_mut) next_el.#a66.#a10;
    mark_test_run 323;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 323 failed %d %d" size i;
    (* .#a66.#b10 *)
    let el = #{ el with a66 = #{ el.#a66 with b10 = next_el.#a66.#b10 } } in
    set_idx_mut a ((.(i).#a66.#b10) : (t66 array, _) idx_mut) next_el.#a66.#b10;
    mark_test_run 324;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 324 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t67 = #{ #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a67 = a671; b67 = b671 } : t67) (#{ a67 = a672; b67 = b672 } : t67) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a671 a672 && (fun a b -> Float.equal (globalize a) (globalize b)) b671 b672) in
  let mk_value i = (#{ a67 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10); b67 = Float.of_int (i + 2) } : t67) in
  (* Create an array of size [size] *)
  let a : t67 array = makearray_dynamic size (#{ a67 = (#{ a10 = 0; b10 = 1. } : t10); b67 = 2. } : t67) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 325;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 325 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 326;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 326 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a67 *)
    let el = #{ el with a67 = next_el.#a67 } in
    set_idx_mut a ((.(i).#a67) : (t67 array, _) idx_mut) next_el.#a67;
    mark_test_run 327;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 327 failed %d %d" size i;
    (* .#b67 *)
    let el = #{ el with b67 = next_el.#b67 } in
    set_idx_mut a ((.(i).#b67) : (t67 array, _) idx_mut) next_el.#b67;
    mark_test_run 328;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 328 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a67.#a10 *)
    let el = #{ el with a67 = #{ el.#a67 with a10 = next_el.#a67.#a10 } } in
    set_idx_mut a ((.(i).#a67.#a10) : (t67 array, _) idx_mut) next_el.#a67.#a10;
    mark_test_run 329;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 329 failed %d %d" size i;
    (* .#a67.#b10 *)
    let el = #{ el with a67 = #{ el.#a67 with b10 = next_el.#a67.#b10 } } in
    set_idx_mut a ((.(i).#a67.#b10) : (t67 array, _) idx_mut) next_el.#a67.#b10;
    mark_test_run 330;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 330 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************)
  (*   t68 = #{ #{ int32# } }   *)
  (******************************)
  let eq = (fun (#{ a68 = a681 } : t68) (#{ a68 = a682 } : t68) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a681 a682) in
  let mk_value i = (#{ a68 = (#{ a17 = Int32_u.of_int (i + 0) } : t17) } : t68) in
  (* Create an array of size [size] *)
  let a : t68 array = makearray_dynamic size (#{ a68 = (#{ a17 = #0l } : t17) } : t68) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 331;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 331 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 332;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 332 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a68 *)
    let el = #{ el with a68 = next_el.#a68 } in
    set_idx_mut a ((.(i).#a68) : (t68 array, _) idx_mut) next_el.#a68;
    mark_test_run 333;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 333 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a68.#a17 *)
    let el = #{ el with a68 = #{ el.#a68 with a17 = next_el.#a68.#a17 } } in
    set_idx_mut a ((.(i).#a68.#a17) : (t68 array, _) idx_mut) next_el.#a68.#a17;
    mark_test_run 334;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 334 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t69 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun (#{ a69 = a691; b69 = b691 } : t69) (#{ a69 = a692; b69 = b692 } : t69) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a691 a692 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b691 b692) in
  let mk_value i = (#{ a69 = (#{ a17 = Int32_u.of_int (i + 0) } : t17); b69 = Int32_u.of_int (i + 1) } : t69) in
  (* Create an array of size [size] *)
  let a : t69 array = makearray_dynamic size (#{ a69 = (#{ a17 = #0l } : t17); b69 = #1l } : t69) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 335;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 335 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 336;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 336 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a69 *)
    let el = #{ el with a69 = next_el.#a69 } in
    set_idx_mut a ((.(i).#a69) : (t69 array, _) idx_mut) next_el.#a69;
    mark_test_run 337;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 337 failed %d %d" size i;
    (* .#b69 *)
    let el = #{ el with b69 = next_el.#b69 } in
    set_idx_mut a ((.(i).#b69) : (t69 array, _) idx_mut) next_el.#b69;
    mark_test_run 338;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 338 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a69.#a17 *)
    let el = #{ el with a69 = #{ el.#a69 with a17 = next_el.#a69.#a17 } } in
    set_idx_mut a ((.(i).#a69.#a17) : (t69 array, _) idx_mut) next_el.#a69.#a17;
    mark_test_run 339;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 339 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t70 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a70 = a701 } : t70) (#{ a70 = a702 } : t70) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a701 a702) in
  let mk_value i = (#{ a70 = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19) } : t70) in
  (* Create an array of size [size] *)
  let a : t70 array = makearray_dynamic size (#{ a70 = (#{ a19 = #0l; b19 = #1l } : t19) } : t70) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 340;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 340 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 341;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 341 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a70 *)
    let el = #{ el with a70 = next_el.#a70 } in
    set_idx_mut a ((.(i).#a70) : (t70 array, _) idx_mut) next_el.#a70;
    mark_test_run 342;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 342 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a70.#a19 *)
    let el = #{ el with a70 = #{ el.#a70 with a19 = next_el.#a70.#a19 } } in
    set_idx_mut a ((.(i).#a70.#a19) : (t70 array, _) idx_mut) next_el.#a70.#a19;
    mark_test_run 343;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 343 failed %d %d" size i;
    (* .#a70.#b19 *)
    let el = #{ el with a70 = #{ el.#a70 with b19 = next_el.#a70.#b19 } } in
    set_idx_mut a ((.(i).#a70.#b19) : (t70 array, _) idx_mut) next_el.#a70.#b19;
    mark_test_run 344;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 344 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t71 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun (#{ a71 = a711; b71 = b711 } : t71) (#{ a71 = a712; b71 = b712 } : t71) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a711 a712 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b711 b712) in
  let mk_value i = (#{ a71 = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19); b71 = Int32_u.of_int (i + 2) } : t71) in
  (* Create an array of size [size] *)
  let a : t71 array = makearray_dynamic size (#{ a71 = (#{ a19 = #0l; b19 = #1l } : t19); b71 = #2l } : t71) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 345;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 345 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 346;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 346 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a71 *)
    let el = #{ el with a71 = next_el.#a71 } in
    set_idx_mut a ((.(i).#a71) : (t71 array, _) idx_mut) next_el.#a71;
    mark_test_run 347;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 347 failed %d %d" size i;
    (* .#b71 *)
    let el = #{ el with b71 = next_el.#b71 } in
    set_idx_mut a ((.(i).#b71) : (t71 array, _) idx_mut) next_el.#b71;
    mark_test_run 348;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 348 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a71.#a19 *)
    let el = #{ el with a71 = #{ el.#a71 with a19 = next_el.#a71.#a19 } } in
    set_idx_mut a ((.(i).#a71.#a19) : (t71 array, _) idx_mut) next_el.#a71.#a19;
    mark_test_run 349;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 349 failed %d %d" size i;
    (* .#a71.#b19 *)
    let el = #{ el with a71 = #{ el.#a71 with b19 = next_el.#a71.#b19 } } in
    set_idx_mut a ((.(i).#a71.#b19) : (t71 array, _) idx_mut) next_el.#a71.#b19;
    mark_test_run 350;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 350 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t72 = #{ #{ float }; int }   *)
  (**********************************)
  let eq = (fun (#{ a72 = a721; b72 = b721 } : t72) (#{ a72 = a722; b72 = b722 } : t72) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a721 a722 && (fun a b -> Int.equal a b) b721 b722) in
  let mk_value i = (#{ a72 = (#{ a21 = Float.of_int (i + 0) } : t21); b72 = (i + 1) } : t72) in
  (* Create an array of size [size] *)
  let a : t72 array = makearray_dynamic size (#{ a72 = (#{ a21 = 0. } : t21); b72 = 1 } : t72) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 351;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 351 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 352;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 352 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a72 *)
    let el = #{ el with a72 = next_el.#a72 } in
    set_idx_mut a ((.(i).#a72) : (t72 array, _) idx_mut) next_el.#a72;
    mark_test_run 353;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 353 failed %d %d" size i;
    (* .#b72 *)
    let el = #{ el with b72 = next_el.#b72 } in
    set_idx_mut a ((.(i).#b72) : (t72 array, _) idx_mut) next_el.#b72;
    mark_test_run 354;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 354 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a72.#a21 *)
    let el = #{ el with a72 = #{ el.#a72 with a21 = next_el.#a72.#a21 } } in
    set_idx_mut a ((.(i).#a72.#a21) : (t72 array, _) idx_mut) next_el.#a72.#a21;
    mark_test_run 355;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 355 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t73 = #{ #{ float }; float }   *)
  (************************************)
  let eq = (fun (#{ a73 = a731; b73 = b731 } : t73) (#{ a73 = a732; b73 = b732 } : t73) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a731 a732 && (fun a b -> Float.equal (globalize a) (globalize b)) b731 b732) in
  let mk_value i = (#{ a73 = (#{ a21 = Float.of_int (i + 0) } : t21); b73 = Float.of_int (i + 1) } : t73) in
  (* Create an array of size [size] *)
  let a : t73 array = makearray_dynamic size (#{ a73 = (#{ a21 = 0. } : t21); b73 = 1. } : t73) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 356;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 356 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 357;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 357 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a73 *)
    let el = #{ el with a73 = next_el.#a73 } in
    set_idx_mut a ((.(i).#a73) : (t73 array, _) idx_mut) next_el.#a73;
    mark_test_run 358;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 358 failed %d %d" size i;
    (* .#b73 *)
    let el = #{ el with b73 = next_el.#b73 } in
    set_idx_mut a ((.(i).#b73) : (t73 array, _) idx_mut) next_el.#b73;
    mark_test_run 359;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 359 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a73.#a21 *)
    let el = #{ el with a73 = #{ el.#a73 with a21 = next_el.#a73.#a21 } } in
    set_idx_mut a ((.(i).#a73.#a21) : (t73 array, _) idx_mut) next_el.#a73.#a21;
    mark_test_run 360;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 360 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t74 = #{ #{ float; int } }   *)
  (**********************************)
  let eq = (fun (#{ a74 = a741 } : t74) (#{ a74 = a742 } : t74) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a741 a742) in
  let mk_value i = (#{ a74 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23) } : t74) in
  (* Create an array of size [size] *)
  let a : t74 array = makearray_dynamic size (#{ a74 = (#{ a23 = 0.; b23 = 1 } : t23) } : t74) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 361;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 361 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 362;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 362 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a74 *)
    let el = #{ el with a74 = next_el.#a74 } in
    set_idx_mut a ((.(i).#a74) : (t74 array, _) idx_mut) next_el.#a74;
    mark_test_run 363;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 363 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a74.#a23 *)
    let el = #{ el with a74 = #{ el.#a74 with a23 = next_el.#a74.#a23 } } in
    set_idx_mut a ((.(i).#a74.#a23) : (t74 array, _) idx_mut) next_el.#a74.#a23;
    mark_test_run 364;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 364 failed %d %d" size i;
    (* .#a74.#b23 *)
    let el = #{ el with a74 = #{ el.#a74 with b23 = next_el.#a74.#b23 } } in
    set_idx_mut a ((.(i).#a74.#b23) : (t74 array, _) idx_mut) next_el.#a74.#b23;
    mark_test_run 365;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 365 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t75 = #{ #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun (#{ a75 = a751; b75 = b751 } : t75) (#{ a75 = a752; b75 = b752 } : t75) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a751 a752 && (fun a b -> Int.equal a b) b751 b752) in
  let mk_value i = (#{ a75 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23); b75 = (i + 2) } : t75) in
  (* Create an array of size [size] *)
  let a : t75 array = makearray_dynamic size (#{ a75 = (#{ a23 = 0.; b23 = 1 } : t23); b75 = 2 } : t75) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 366;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 366 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 367;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 367 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a75 *)
    let el = #{ el with a75 = next_el.#a75 } in
    set_idx_mut a ((.(i).#a75) : (t75 array, _) idx_mut) next_el.#a75;
    mark_test_run 368;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 368 failed %d %d" size i;
    (* .#b75 *)
    let el = #{ el with b75 = next_el.#b75 } in
    set_idx_mut a ((.(i).#b75) : (t75 array, _) idx_mut) next_el.#b75;
    mark_test_run 369;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 369 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a75.#a23 *)
    let el = #{ el with a75 = #{ el.#a75 with a23 = next_el.#a75.#a23 } } in
    set_idx_mut a ((.(i).#a75.#a23) : (t75 array, _) idx_mut) next_el.#a75.#a23;
    mark_test_run 370;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 370 failed %d %d" size i;
    (* .#a75.#b23 *)
    let el = #{ el with a75 = #{ el.#a75 with b23 = next_el.#a75.#b23 } } in
    set_idx_mut a ((.(i).#a75.#b23) : (t75 array, _) idx_mut) next_el.#a75.#b23;
    mark_test_run 371;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 371 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t76 = #{ #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a76 = a761; b76 = b761 } : t76) (#{ a76 = a762; b76 = b762 } : t76) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a761 a762 && (fun a b -> Float.equal (globalize a) (globalize b)) b761 b762) in
  let mk_value i = (#{ a76 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23); b76 = Float.of_int (i + 2) } : t76) in
  (* Create an array of size [size] *)
  let a : t76 array = makearray_dynamic size (#{ a76 = (#{ a23 = 0.; b23 = 1 } : t23); b76 = 2. } : t76) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 372;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 372 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 373;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 373 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a76 *)
    let el = #{ el with a76 = next_el.#a76 } in
    set_idx_mut a ((.(i).#a76) : (t76 array, _) idx_mut) next_el.#a76;
    mark_test_run 374;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 374 failed %d %d" size i;
    (* .#b76 *)
    let el = #{ el with b76 = next_el.#b76 } in
    set_idx_mut a ((.(i).#b76) : (t76 array, _) idx_mut) next_el.#b76;
    mark_test_run 375;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 375 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a76.#a23 *)
    let el = #{ el with a76 = #{ el.#a76 with a23 = next_el.#a76.#a23 } } in
    set_idx_mut a ((.(i).#a76.#a23) : (t76 array, _) idx_mut) next_el.#a76.#a23;
    mark_test_run 376;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 376 failed %d %d" size i;
    (* .#a76.#b23 *)
    let el = #{ el with a76 = #{ el.#a76 with b23 = next_el.#a76.#b23 } } in
    set_idx_mut a ((.(i).#a76.#b23) : (t76 array, _) idx_mut) next_el.#a76.#b23;
    mark_test_run 377;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 377 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t77 = #{ #{ float; float } }   *)
  (************************************)
  let eq = (fun (#{ a77 = a771 } : t77) (#{ a77 = a772 } : t77) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a771 a772) in
  let mk_value i = (#{ a77 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25) } : t77) in
  (* Create an array of size [size] *)
  let a : t77 array = makearray_dynamic size (#{ a77 = (#{ a25 = 0.; b25 = 1. } : t25) } : t77) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 378;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 378 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 379;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 379 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a77 *)
    let el = #{ el with a77 = next_el.#a77 } in
    set_idx_mut a ((.(i).#a77) : (t77 array, _) idx_mut) next_el.#a77;
    mark_test_run 380;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 380 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a77.#a25 *)
    let el = #{ el with a77 = #{ el.#a77 with a25 = next_el.#a77.#a25 } } in
    set_idx_mut a ((.(i).#a77.#a25) : (t77 array, _) idx_mut) next_el.#a77.#a25;
    mark_test_run 381;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 381 failed %d %d" size i;
    (* .#a77.#b25 *)
    let el = #{ el with a77 = #{ el.#a77 with b25 = next_el.#a77.#b25 } } in
    set_idx_mut a ((.(i).#a77.#b25) : (t77 array, _) idx_mut) next_el.#a77.#b25;
    mark_test_run 382;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 382 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t78 = #{ #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun (#{ a78 = a781; b78 = b781 } : t78) (#{ a78 = a782; b78 = b782 } : t78) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a781 a782 && (fun a b -> Int.equal a b) b781 b782) in
  let mk_value i = (#{ a78 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25); b78 = (i + 2) } : t78) in
  (* Create an array of size [size] *)
  let a : t78 array = makearray_dynamic size (#{ a78 = (#{ a25 = 0.; b25 = 1. } : t25); b78 = 2 } : t78) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 383;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 383 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 384;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 384 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a78 *)
    let el = #{ el with a78 = next_el.#a78 } in
    set_idx_mut a ((.(i).#a78) : (t78 array, _) idx_mut) next_el.#a78;
    mark_test_run 385;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 385 failed %d %d" size i;
    (* .#b78 *)
    let el = #{ el with b78 = next_el.#b78 } in
    set_idx_mut a ((.(i).#b78) : (t78 array, _) idx_mut) next_el.#b78;
    mark_test_run 386;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 386 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a78.#a25 *)
    let el = #{ el with a78 = #{ el.#a78 with a25 = next_el.#a78.#a25 } } in
    set_idx_mut a ((.(i).#a78.#a25) : (t78 array, _) idx_mut) next_el.#a78.#a25;
    mark_test_run 387;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 387 failed %d %d" size i;
    (* .#a78.#b25 *)
    let el = #{ el with a78 = #{ el.#a78 with b25 = next_el.#a78.#b25 } } in
    set_idx_mut a ((.(i).#a78.#b25) : (t78 array, _) idx_mut) next_el.#a78.#b25;
    mark_test_run 388;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 388 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t79 = #{ #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun (#{ a79 = a791; b79 = b791 } : t79) (#{ a79 = a792; b79 = b792 } : t79) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a791 a792 && (fun a b -> Float.equal (globalize a) (globalize b)) b791 b792) in
  let mk_value i = (#{ a79 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25); b79 = Float.of_int (i + 2) } : t79) in
  (* Create an array of size [size] *)
  let a : t79 array = makearray_dynamic size (#{ a79 = (#{ a25 = 0.; b25 = 1. } : t25); b79 = 2. } : t79) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 389;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 389 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 390;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 390 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a79 *)
    let el = #{ el with a79 = next_el.#a79 } in
    set_idx_mut a ((.(i).#a79) : (t79 array, _) idx_mut) next_el.#a79;
    mark_test_run 391;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 391 failed %d %d" size i;
    (* .#b79 *)
    let el = #{ el with b79 = next_el.#b79 } in
    set_idx_mut a ((.(i).#b79) : (t79 array, _) idx_mut) next_el.#b79;
    mark_test_run 392;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 392 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a79.#a25 *)
    let el = #{ el with a79 = #{ el.#a79 with a25 = next_el.#a79.#a25 } } in
    set_idx_mut a ((.(i).#a79.#a25) : (t79 array, _) idx_mut) next_el.#a79.#a25;
    mark_test_run 393;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 393 failed %d %d" size i;
    (* .#a79.#b25 *)
    let el = #{ el with a79 = #{ el.#a79 with b25 = next_el.#a79.#b25 } } in
    set_idx_mut a ((.(i).#a79.#b25) : (t79 array, _) idx_mut) next_el.#a79.#b25;
    mark_test_run 394;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 394 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()

let test_array_idx_with_makearray_dynamic_local size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 395;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 395 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 396;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 396 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 397;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 397 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 398;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 398 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 399;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 399 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 400;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 400 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 401;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 401 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 402;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 402 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 403;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 403 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 404;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 404 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  let eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let mk_value i = (#{ a0 = (i + 0) } : t0) in
  (* Create an array of size [size] *)
  let a : t0 array = makearray_dynamic_local size (#{ a0 = 0 } : t0) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 405;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 405 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 406;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 406 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a0 *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 407;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 407 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  let eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let mk_value i = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) in
  (* Create an array of size [size] *)
  let a : t1 array = makearray_dynamic_local size (#{ a1 = 0; b1 = 1 } : t1) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 408;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 408 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 409;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 409 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a1 *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 410;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 410 failed %d %d" size i;
    (* .#b1 *)
    let el = #{ el with b1 = next_el.#b1 } in
    set_idx_mut a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 411;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 411 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  let eq = (fun (#{ a2 = a21; b2 = b21; c2 = c21 } : t2) (#{ a2 = a22; b2 = b22; c2 = c22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = (i + 1); c2 = (i + 2) } : t2) in
  (* Create an array of size [size] *)
  let a : t2 array = makearray_dynamic_local size (#{ a2 = 0; b2 = 1; c2 = 2 } : t2) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 412;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 412 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 413;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 413 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a2 *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 414;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 414 failed %d %d" size i;
    (* .#b2 *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 415;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 415 failed %d %d" size i;
    (* .#c2 *)
    let el = #{ el with c2 = next_el.#c2 } in
    set_idx_mut a ((.(i).#c2) : (t2 array, _) idx_mut) next_el.#c2;
    mark_test_run 416;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 416 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  let eq = (fun (#{ a3 = a31; b3 = b31; c3 = c31 } : t3) (#{ a3 = a32; b3 = b32; c3 = c32 } : t3) -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let mk_value i = (#{ a3 = (i + 0); b3 = (i + 1); c3 = Int32_u.of_int (i + 2) } : t3) in
  (* Create an array of size [size] *)
  let a : t3 array = makearray_dynamic_local size (#{ a3 = 0; b3 = 1; c3 = #2l } : t3) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 417;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 417 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 418;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 418 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a3 *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 419;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 419 failed %d %d" size i;
    (* .#b3 *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 420;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 420 failed %d %d" size i;
    (* .#c3 *)
    let el = #{ el with c3 = next_el.#c3 } in
    set_idx_mut a ((.(i).#c3) : (t3 array, _) idx_mut) next_el.#c3;
    mark_test_run 421;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 421 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  let eq = (fun (#{ a4 = a41; b4 = b41; c4 = c41 } : t4) (#{ a4 = a42; b4 = b42; c4 = c42 } : t4) -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let mk_value i = (#{ a4 = (i + 0); b4 = (i + 1); c4 = Float.of_int (i + 2) } : t4) in
  (* Create an array of size [size] *)
  let a : t4 array = makearray_dynamic_local size (#{ a4 = 0; b4 = 1; c4 = 2. } : t4) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 422;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 422 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 423;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 423 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a4 *)
    let el = #{ el with a4 = next_el.#a4 } in
    set_idx_mut a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 424;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 424 failed %d %d" size i;
    (* .#b4 *)
    let el = #{ el with b4 = next_el.#b4 } in
    set_idx_mut a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 425;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 425 failed %d %d" size i;
    (* .#c4 *)
    let el = #{ el with c4 = next_el.#c4 } in
    set_idx_mut a ((.(i).#c4) : (t4 array, _) idx_mut) next_el.#c4;
    mark_test_run 426;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 426 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t5 = #{ int; int64 }   *)
  (****************************)
  let eq = (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int64.equal (globalize a) (globalize b)) b51 b52) in
  let mk_value i = (#{ a5 = (i + 0); b5 = Int64.of_int (i + 1) } : t5) in
  (* Create an array of size [size] *)
  let a : t5 array = makearray_dynamic_local size (#{ a5 = 0; b5 = 1L } : t5) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 427;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 427 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 428;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 428 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a5 *)
    let el = #{ el with a5 = next_el.#a5 } in
    set_idx_mut a ((.(i).#a5) : (t5 array, _) idx_mut) next_el.#a5;
    mark_test_run 429;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 429 failed %d %d" size i;
    (* .#b5 *)
    let el = #{ el with b5 = next_el.#b5 } in
    set_idx_mut a ((.(i).#b5) : (t5 array, _) idx_mut) next_el.#b5;
    mark_test_run 430;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 430 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t6 = #{ int; int64# }   *)
  (*****************************)
  let eq = (fun (#{ a6 = a61; b6 = b61 } : t6) (#{ a6 = a62; b6 = b62 } : t6) -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b61 b62) in
  let mk_value i = (#{ a6 = (i + 0); b6 = Int64_u.of_int (i + 1) } : t6) in
  (* Create an array of size [size] *)
  let a : t6 array = makearray_dynamic_local size (#{ a6 = 0; b6 = #1L } : t6) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 431;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 431 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 432;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 432 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a6 *)
    let el = #{ el with a6 = next_el.#a6 } in
    set_idx_mut a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 433;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 433 failed %d %d" size i;
    (* .#b6 *)
    let el = #{ el with b6 = next_el.#b6 } in
    set_idx_mut a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 434;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 434 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t7 = #{ int; int32# }   *)
  (*****************************)
  let eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let mk_value i = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7) in
  (* Create an array of size [size] *)
  let a : t7 array = makearray_dynamic_local size (#{ a7 = 0; b7 = #1l } : t7) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 435;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 435 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 436;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 436 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a7 *)
    let el = #{ el with a7 = next_el.#a7 } in
    set_idx_mut a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 437;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 437 failed %d %d" size i;
    (* .#b7 *)
    let el = #{ el with b7 = next_el.#b7 } in
    set_idx_mut a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 438;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 438 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t8 = #{ int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a8 = a81; b8 = b81; c8 = c81 } : t8) (#{ a8 = a82; b8 = b82; c8 = c82 } : t8) -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b81 b82 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c81 c82) in
  let mk_value i = (#{ a8 = (i + 0); b8 = Int32_u.of_int (i + 1); c8 = Int32_u.of_int (i + 2) } : t8) in
  (* Create an array of size [size] *)
  let a : t8 array = makearray_dynamic_local size (#{ a8 = 0; b8 = #1l; c8 = #2l } : t8) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 439;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 439 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 440;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 440 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a8 *)
    let el = #{ el with a8 = next_el.#a8 } in
    set_idx_mut a ((.(i).#a8) : (t8 array, _) idx_mut) next_el.#a8;
    mark_test_run 441;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 441 failed %d %d" size i;
    (* .#b8 *)
    let el = #{ el with b8 = next_el.#b8 } in
    set_idx_mut a ((.(i).#b8) : (t8 array, _) idx_mut) next_el.#b8;
    mark_test_run 442;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 442 failed %d %d" size i;
    (* .#c8 *)
    let el = #{ el with c8 = next_el.#c8 } in
    set_idx_mut a ((.(i).#c8) : (t8 array, _) idx_mut) next_el.#c8;
    mark_test_run 443;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 443 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t9 = #{ int; nativeint# }   *)
  (*********************************)
  let eq = (fun (#{ a9 = a91; b9 = b91 } : t9) (#{ a9 = a92; b9 = b92 } : t9) -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b91 b92) in
  let mk_value i = (#{ a9 = (i + 0); b9 = Nativeint_u.of_int (i + 1) } : t9) in
  (* Create an array of size [size] *)
  let a : t9 array = makearray_dynamic_local size (#{ a9 = 0; b9 = #1n } : t9) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 444;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 444 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 445;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 445 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a9 *)
    let el = #{ el with a9 = next_el.#a9 } in
    set_idx_mut a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 446;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 446 failed %d %d" size i;
    (* .#b9 *)
    let el = #{ el with b9 = next_el.#b9 } in
    set_idx_mut a ((.(i).#b9) : (t9 array, _) idx_mut) next_el.#b9;
    mark_test_run 447;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 447 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t10 = #{ int; float }   *)
  (*****************************)
  let eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let mk_value i = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10) in
  (* Create an array of size [size] *)
  let a : t10 array = makearray_dynamic_local size (#{ a10 = 0; b10 = 1. } : t10) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 448;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 448 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 449;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 449 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a10 *)
    let el = #{ el with a10 = next_el.#a10 } in
    set_idx_mut a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 450;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 450 failed %d %d" size i;
    (* .#b10 *)
    let el = #{ el with b10 = next_el.#b10 } in
    set_idx_mut a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 451;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 451 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t11 = #{ int; float; int }   *)
  (**********************************)
  let eq = (fun (#{ a11 = a111; b11 = b111; c11 = c111 } : t11) (#{ a11 = a112; b11 = b112; c11 = c112 } : t11) -> (fun a b -> Int.equal a b) a111 a112 && (fun a b -> Float.equal (globalize a) (globalize b)) b111 b112 && (fun a b -> Int.equal a b) c111 c112) in
  let mk_value i = (#{ a11 = (i + 0); b11 = Float.of_int (i + 1); c11 = (i + 2) } : t11) in
  (* Create an array of size [size] *)
  let a : t11 array = makearray_dynamic_local size (#{ a11 = 0; b11 = 1.; c11 = 2 } : t11) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 452;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 452 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 453;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 453 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a11 *)
    let el = #{ el with a11 = next_el.#a11 } in
    set_idx_mut a ((.(i).#a11) : (t11 array, _) idx_mut) next_el.#a11;
    mark_test_run 454;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 454 failed %d %d" size i;
    (* .#b11 *)
    let el = #{ el with b11 = next_el.#b11 } in
    set_idx_mut a ((.(i).#b11) : (t11 array, _) idx_mut) next_el.#b11;
    mark_test_run 455;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 455 failed %d %d" size i;
    (* .#c11 *)
    let el = #{ el with c11 = next_el.#c11 } in
    set_idx_mut a ((.(i).#c11) : (t11 array, _) idx_mut) next_el.#c11;
    mark_test_run 456;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 456 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t12 = #{ int; float; float }   *)
  (************************************)
  let eq = (fun (#{ a12 = a121; b12 = b121; c12 = c121 } : t12) (#{ a12 = a122; b12 = b122; c12 = c122 } : t12) -> (fun a b -> Int.equal a b) a121 a122 && (fun a b -> Float.equal (globalize a) (globalize b)) b121 b122 && (fun a b -> Float.equal (globalize a) (globalize b)) c121 c122) in
  let mk_value i = (#{ a12 = (i + 0); b12 = Float.of_int (i + 1); c12 = Float.of_int (i + 2) } : t12) in
  (* Create an array of size [size] *)
  let a : t12 array = makearray_dynamic_local size (#{ a12 = 0; b12 = 1.; c12 = 2. } : t12) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 457;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 457 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 458;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 458 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a12 *)
    let el = #{ el with a12 = next_el.#a12 } in
    set_idx_mut a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 459;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 459 failed %d %d" size i;
    (* .#b12 *)
    let el = #{ el with b12 = next_el.#b12 } in
    set_idx_mut a ((.(i).#b12) : (t12 array, _) idx_mut) next_el.#b12;
    mark_test_run 460;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 460 failed %d %d" size i;
    (* .#c12 *)
    let el = #{ el with c12 = next_el.#c12 } in
    set_idx_mut a ((.(i).#c12) : (t12 array, _) idx_mut) next_el.#c12;
    mark_test_run 461;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 461 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t13 = #{ int; #{ int } }   *)
  (********************************)
  let eq = (fun (#{ a13 = a131; b13 = b131 } : t13) (#{ a13 = a132; b13 = b132 } : t13) -> (fun a b -> Int.equal a b) a131 a132 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b131 b132) in
  let mk_value i = (#{ a13 = (i + 0); b13 = (#{ a0 = (i + 1) } : t0) } : t13) in
  (* Create an array of size [size] *)
  let a : t13 array = makearray_dynamic_local size (#{ a13 = 0; b13 = (#{ a0 = 1 } : t0) } : t13) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 462;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 462 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 463;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 463 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a13 *)
    let el = #{ el with a13 = next_el.#a13 } in
    set_idx_mut a ((.(i).#a13) : (t13 array, _) idx_mut) next_el.#a13;
    mark_test_run 464;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 464 failed %d %d" size i;
    (* .#b13 *)
    let el = #{ el with b13 = next_el.#b13 } in
    set_idx_mut a ((.(i).#b13) : (t13 array, _) idx_mut) next_el.#b13;
    mark_test_run 465;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 465 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b13.#a0 *)
    let el = #{ el with b13 = #{ el.#b13 with a0 = next_el.#b13.#a0 } } in
    set_idx_mut a ((.(i).#b13.#a0) : (t13 array, _) idx_mut) next_el.#b13.#a0;
    mark_test_run 466;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 466 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t14 = #{ int; #{ int; int } }   *)
  (*************************************)
  let eq = (fun (#{ a14 = a141; b14 = b141 } : t14) (#{ a14 = a142; b14 = b142 } : t14) -> (fun a b -> Int.equal a b) a141 a142 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b141 b142) in
  let mk_value i = (#{ a14 = (i + 0); b14 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t14) in
  (* Create an array of size [size] *)
  let a : t14 array = makearray_dynamic_local size (#{ a14 = 0; b14 = (#{ a1 = 1; b1 = 2 } : t1) } : t14) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 467;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 467 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 468;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 468 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a14 *)
    let el = #{ el with a14 = next_el.#a14 } in
    set_idx_mut a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 469;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 469 failed %d %d" size i;
    (* .#b14 *)
    let el = #{ el with b14 = next_el.#b14 } in
    set_idx_mut a ((.(i).#b14) : (t14 array, _) idx_mut) next_el.#b14;
    mark_test_run 470;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 470 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b14.#a1 *)
    let el = #{ el with b14 = #{ el.#b14 with a1 = next_el.#b14.#a1 } } in
    set_idx_mut a ((.(i).#b14.#a1) : (t14 array, _) idx_mut) next_el.#b14.#a1;
    mark_test_run 471;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 471 failed %d %d" size i;
    (* .#b14.#b1 *)
    let el = #{ el with b14 = #{ el.#b14 with b1 = next_el.#b14.#b1 } } in
    set_idx_mut a ((.(i).#b14.#b1) : (t14 array, _) idx_mut) next_el.#b14.#b1;
    mark_test_run 472;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 472 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t15 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  let eq = (fun (#{ a15 = a151; b15 = b151 } : t15) (#{ a15 = a152; b15 = b152 } : t15) -> (fun a b -> Int.equal a b) a151 a152 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b151 b152) in
  let mk_value i = (#{ a15 = (i + 0); b15 = (#{ a7 = (i + 1); b7 = Int32_u.of_int (i + 2) } : t7) } : t15) in
  (* Create an array of size [size] *)
  let a : t15 array = makearray_dynamic_local size (#{ a15 = 0; b15 = (#{ a7 = 1; b7 = #2l } : t7) } : t15) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 473;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 473 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 474;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 474 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a15 *)
    let el = #{ el with a15 = next_el.#a15 } in
    set_idx_mut a ((.(i).#a15) : (t15 array, _) idx_mut) next_el.#a15;
    mark_test_run 475;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 475 failed %d %d" size i;
    (* .#b15 *)
    let el = #{ el with b15 = next_el.#b15 } in
    set_idx_mut a ((.(i).#b15) : (t15 array, _) idx_mut) next_el.#b15;
    mark_test_run 476;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 476 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b15.#a7 *)
    let el = #{ el with b15 = #{ el.#b15 with a7 = next_el.#b15.#a7 } } in
    set_idx_mut a ((.(i).#b15.#a7) : (t15 array, _) idx_mut) next_el.#b15.#a7;
    mark_test_run 477;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 477 failed %d %d" size i;
    (* .#b15.#b7 *)
    let el = #{ el with b15 = #{ el.#b15 with b7 = next_el.#b15.#b7 } } in
    set_idx_mut a ((.(i).#b15.#b7) : (t15 array, _) idx_mut) next_el.#b15.#b7;
    mark_test_run 478;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 478 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t16 = #{ int; #{ int; float } }   *)
  (***************************************)
  let eq = (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int.equal a b) a161 a162 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b161 b162) in
  let mk_value i = (#{ a16 = (i + 0); b16 = (#{ a10 = (i + 1); b10 = Float.of_int (i + 2) } : t10) } : t16) in
  (* Create an array of size [size] *)
  let a : t16 array = makearray_dynamic_local size (#{ a16 = 0; b16 = (#{ a10 = 1; b10 = 2. } : t10) } : t16) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 479;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 479 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 480;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 480 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a16 *)
    let el = #{ el with a16 = next_el.#a16 } in
    set_idx_mut a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 481;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 481 failed %d %d" size i;
    (* .#b16 *)
    let el = #{ el with b16 = next_el.#b16 } in
    set_idx_mut a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 482;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 482 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b16.#a10 *)
    let el = #{ el with b16 = #{ el.#b16 with a10 = next_el.#b16.#a10 } } in
    set_idx_mut a ((.(i).#b16.#a10) : (t16 array, _) idx_mut) next_el.#b16.#a10;
    mark_test_run 483;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 483 failed %d %d" size i;
    (* .#b16.#b10 *)
    let el = #{ el with b16 = #{ el.#b16 with b10 = next_el.#b16.#b10 } } in
    set_idx_mut a ((.(i).#b16.#b10) : (t16 array, _) idx_mut) next_el.#b16.#b10;
    mark_test_run 484;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 484 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t18 = #{ int; #{ int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a18 = a181; b18 = b181 } : t18) (#{ a18 = a182; b18 = b182 } : t18) -> (fun a b -> Int.equal a b) a181 a182 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b181 b182) in
  let mk_value i = (#{ a18 = (i + 0); b18 = (#{ a17 = Int32_u.of_int (i + 1) } : t17) } : t18) in
  (* Create an array of size [size] *)
  let a : t18 array = makearray_dynamic_local size (#{ a18 = 0; b18 = (#{ a17 = #1l } : t17) } : t18) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 485;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 485 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 486;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 486 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a18 *)
    let el = #{ el with a18 = next_el.#a18 } in
    set_idx_mut a ((.(i).#a18) : (t18 array, _) idx_mut) next_el.#a18;
    mark_test_run 487;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 487 failed %d %d" size i;
    (* .#b18 *)
    let el = #{ el with b18 = next_el.#b18 } in
    set_idx_mut a ((.(i).#b18) : (t18 array, _) idx_mut) next_el.#b18;
    mark_test_run 488;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 488 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b18.#a17 *)
    let el = #{ el with b18 = #{ el.#b18 with a17 = next_el.#b18.#a17 } } in
    set_idx_mut a ((.(i).#b18.#a17) : (t18 array, _) idx_mut) next_el.#b18.#a17;
    mark_test_run 489;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 489 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t20 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Int.equal a b) a201 a202 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b201 b202) in
  let mk_value i = (#{ a20 = (i + 0); b20 = (#{ a19 = Int32_u.of_int (i + 1); b19 = Int32_u.of_int (i + 2) } : t19) } : t20) in
  (* Create an array of size [size] *)
  let a : t20 array = makearray_dynamic_local size (#{ a20 = 0; b20 = (#{ a19 = #1l; b19 = #2l } : t19) } : t20) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 490;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 490 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 491;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 491 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a20 *)
    let el = #{ el with a20 = next_el.#a20 } in
    set_idx_mut a ((.(i).#a20) : (t20 array, _) idx_mut) next_el.#a20;
    mark_test_run 492;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 492 failed %d %d" size i;
    (* .#b20 *)
    let el = #{ el with b20 = next_el.#b20 } in
    set_idx_mut a ((.(i).#b20) : (t20 array, _) idx_mut) next_el.#b20;
    mark_test_run 493;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 493 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b20.#a19 *)
    let el = #{ el with b20 = #{ el.#b20 with a19 = next_el.#b20.#a19 } } in
    set_idx_mut a ((.(i).#b20.#a19) : (t20 array, _) idx_mut) next_el.#b20.#a19;
    mark_test_run 494;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 494 failed %d %d" size i;
    (* .#b20.#b19 *)
    let el = #{ el with b20 = #{ el.#b20 with b19 = next_el.#b20.#b19 } } in
    set_idx_mut a ((.(i).#b20.#b19) : (t20 array, _) idx_mut) next_el.#b20.#b19;
    mark_test_run 495;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 495 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t22 = #{ int; #{ float } }   *)
  (**********************************)
  let eq = (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Int.equal a b) a221 a222 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b221 b222) in
  let mk_value i = (#{ a22 = (i + 0); b22 = (#{ a21 = Float.of_int (i + 1) } : t21) } : t22) in
  (* Create an array of size [size] *)
  let a : t22 array = makearray_dynamic_local size (#{ a22 = 0; b22 = (#{ a21 = 1. } : t21) } : t22) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 496;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 496 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 497;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 497 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a22 *)
    let el = #{ el with a22 = next_el.#a22 } in
    set_idx_mut a ((.(i).#a22) : (t22 array, _) idx_mut) next_el.#a22;
    mark_test_run 498;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 498 failed %d %d" size i;
    (* .#b22 *)
    let el = #{ el with b22 = next_el.#b22 } in
    set_idx_mut a ((.(i).#b22) : (t22 array, _) idx_mut) next_el.#b22;
    mark_test_run 499;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 499 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b22.#a21 *)
    let el = #{ el with b22 = #{ el.#b22 with a21 = next_el.#b22.#a21 } } in
    set_idx_mut a ((.(i).#b22.#a21) : (t22 array, _) idx_mut) next_el.#b22.#a21;
    mark_test_run 500;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 500 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t24 = #{ int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun (#{ a24 = a241; b24 = b241 } : t24) (#{ a24 = a242; b24 = b242 } : t24) -> (fun a b -> Int.equal a b) a241 a242 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b241 b242) in
  let mk_value i = (#{ a24 = (i + 0); b24 = (#{ a23 = Float.of_int (i + 1); b23 = (i + 2) } : t23) } : t24) in
  (* Create an array of size [size] *)
  let a : t24 array = makearray_dynamic_local size (#{ a24 = 0; b24 = (#{ a23 = 1.; b23 = 2 } : t23) } : t24) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 501;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 501 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 502;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 502 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a24 *)
    let el = #{ el with a24 = next_el.#a24 } in
    set_idx_mut a ((.(i).#a24) : (t24 array, _) idx_mut) next_el.#a24;
    mark_test_run 503;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 503 failed %d %d" size i;
    (* .#b24 *)
    let el = #{ el with b24 = next_el.#b24 } in
    set_idx_mut a ((.(i).#b24) : (t24 array, _) idx_mut) next_el.#b24;
    mark_test_run 504;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 504 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b24.#a23 *)
    let el = #{ el with b24 = #{ el.#b24 with a23 = next_el.#b24.#a23 } } in
    set_idx_mut a ((.(i).#b24.#a23) : (t24 array, _) idx_mut) next_el.#b24.#a23;
    mark_test_run 505;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 505 failed %d %d" size i;
    (* .#b24.#b23 *)
    let el = #{ el with b24 = #{ el.#b24 with b23 = next_el.#b24.#b23 } } in
    set_idx_mut a ((.(i).#b24.#b23) : (t24 array, _) idx_mut) next_el.#b24.#b23;
    mark_test_run 506;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 506 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t26 = #{ int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a26 = a261; b26 = b261 } : t26) (#{ a26 = a262; b26 = b262 } : t26) -> (fun a b -> Int.equal a b) a261 a262 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b261 b262) in
  let mk_value i = (#{ a26 = (i + 0); b26 = (#{ a25 = Float.of_int (i + 1); b25 = Float.of_int (i + 2) } : t25) } : t26) in
  (* Create an array of size [size] *)
  let a : t26 array = makearray_dynamic_local size (#{ a26 = 0; b26 = (#{ a25 = 1.; b25 = 2. } : t25) } : t26) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 507;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 507 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 508;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 508 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a26 *)
    let el = #{ el with a26 = next_el.#a26 } in
    set_idx_mut a ((.(i).#a26) : (t26 array, _) idx_mut) next_el.#a26;
    mark_test_run 509;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 509 failed %d %d" size i;
    (* .#b26 *)
    let el = #{ el with b26 = next_el.#b26 } in
    set_idx_mut a ((.(i).#b26) : (t26 array, _) idx_mut) next_el.#b26;
    mark_test_run 510;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 510 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b26.#a25 *)
    let el = #{ el with b26 = #{ el.#b26 with a25 = next_el.#b26.#a25 } } in
    set_idx_mut a ((.(i).#b26.#a25) : (t26 array, _) idx_mut) next_el.#b26.#a25;
    mark_test_run 511;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 511 failed %d %d" size i;
    (* .#b26.#b25 *)
    let el = #{ el with b26 = #{ el.#b26 with b25 = next_el.#b26.#b25 } } in
    set_idx_mut a ((.(i).#b26.#b25) : (t26 array, _) idx_mut) next_el.#b26.#b25;
    mark_test_run 512;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 512 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************)
  (*   t27 = #{ int64 }   *)
  (************************)
  let eq = (fun (#{ a27 = a271 } : t27) (#{ a27 = a272 } : t27) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a271 a272) in
  let mk_value i = (#{ a27 = Int64.of_int (i + 0) } : t27) in
  (* Create an array of size [size] *)
  let a : t27 array = makearray_dynamic_local size (#{ a27 = 0L } : t27) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 513;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 513 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 514;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 514 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a27 *)
    let el = #{ el with a27 = next_el.#a27 } in
    set_idx_mut a ((.(i).#a27) : (t27 array, _) idx_mut) next_el.#a27;
    mark_test_run 515;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 515 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t28 = #{ int64; int }   *)
  (*****************************)
  let eq = (fun (#{ a28 = a281; b28 = b281 } : t28) (#{ a28 = a282; b28 = b282 } : t28) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a281 a282 && (fun a b -> Int.equal a b) b281 b282) in
  let mk_value i = (#{ a28 = Int64.of_int (i + 0); b28 = (i + 1) } : t28) in
  (* Create an array of size [size] *)
  let a : t28 array = makearray_dynamic_local size (#{ a28 = 0L; b28 = 1 } : t28) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 516;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 516 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 517;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 517 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a28 *)
    let el = #{ el with a28 = next_el.#a28 } in
    set_idx_mut a ((.(i).#a28) : (t28 array, _) idx_mut) next_el.#a28;
    mark_test_run 518;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 518 failed %d %d" size i;
    (* .#b28 *)
    let el = #{ el with b28 = next_el.#b28 } in
    set_idx_mut a ((.(i).#b28) : (t28 array, _) idx_mut) next_el.#b28;
    mark_test_run 519;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 519 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t29 = #{ int64; int64 }   *)
  (*******************************)
  let eq = (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) in
  let mk_value i = (#{ a29 = Int64.of_int (i + 0); b29 = Int64.of_int (i + 1) } : t29) in
  (* Create an array of size [size] *)
  let a : t29 array = makearray_dynamic_local size (#{ a29 = 0L; b29 = 1L } : t29) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 520;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 520 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 521;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 521 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a29 *)
    let el = #{ el with a29 = next_el.#a29 } in
    set_idx_mut a ((.(i).#a29) : (t29 array, _) idx_mut) next_el.#a29;
    mark_test_run 522;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 522 failed %d %d" size i;
    (* .#b29 *)
    let el = #{ el with b29 = next_el.#b29 } in
    set_idx_mut a ((.(i).#b29) : (t29 array, _) idx_mut) next_el.#b29;
    mark_test_run 523;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 523 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t30 = #{ int64; float }   *)
  (*******************************)
  let eq = (fun (#{ a30 = a301; b30 = b301 } : t30) (#{ a30 = a302; b30 = b302 } : t30) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Float.equal (globalize a) (globalize b)) b301 b302) in
  let mk_value i = (#{ a30 = Int64.of_int (i + 0); b30 = Float.of_int (i + 1) } : t30) in
  (* Create an array of size [size] *)
  let a : t30 array = makearray_dynamic_local size (#{ a30 = 0L; b30 = 1. } : t30) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 524;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 524 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 525;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 525 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a30 *)
    let el = #{ el with a30 = next_el.#a30 } in
    set_idx_mut a ((.(i).#a30) : (t30 array, _) idx_mut) next_el.#a30;
    mark_test_run 526;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 526 failed %d %d" size i;
    (* .#b30 *)
    let el = #{ el with b30 = next_el.#b30 } in
    set_idx_mut a ((.(i).#b30) : (t30 array, _) idx_mut) next_el.#b30;
    mark_test_run 527;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 527 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t31 = #{ int64# }   *)
  (*************************)
  let eq = (fun (#{ a31 = a311 } : t31) (#{ a31 = a312 } : t31) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a311 a312) in
  let mk_value i = (#{ a31 = Int64_u.of_int (i + 0) } : t31) in
  (* Create an array of size [size] *)
  let a : t31 array = makearray_dynamic_local size (#{ a31 = #0L } : t31) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 528;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 528 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 529;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 529 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a31 *)
    let el = #{ el with a31 = next_el.#a31 } in
    set_idx_mut a ((.(i).#a31) : (t31 array, _) idx_mut) next_el.#a31;
    mark_test_run 530;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 530 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t32 = #{ int64#; int64# }   *)
  (*********************************)
  let eq = (fun (#{ a32 = a321; b32 = b321 } : t32) (#{ a32 = a322; b32 = b322 } : t32) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a321 a322 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b321 b322) in
  let mk_value i = (#{ a32 = Int64_u.of_int (i + 0); b32 = Int64_u.of_int (i + 1) } : t32) in
  (* Create an array of size [size] *)
  let a : t32 array = makearray_dynamic_local size (#{ a32 = #0L; b32 = #1L } : t32) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 531;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 531 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 532;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 532 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a32 *)
    let el = #{ el with a32 = next_el.#a32 } in
    set_idx_mut a ((.(i).#a32) : (t32 array, _) idx_mut) next_el.#a32;
    mark_test_run 533;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 533 failed %d %d" size i;
    (* .#b32 *)
    let el = #{ el with b32 = next_el.#b32 } in
    set_idx_mut a ((.(i).#b32) : (t32 array, _) idx_mut) next_el.#b32;
    mark_test_run 534;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 534 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t33 = #{ int64#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a33 = a331; b33 = b331 } : t33) (#{ a33 = a332; b33 = b332 } : t33) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a331 a332 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b331 b332) in
  let mk_value i = (#{ a33 = Int64_u.of_int (i + 0); b33 = Int32_u.of_int (i + 1) } : t33) in
  (* Create an array of size [size] *)
  let a : t33 array = makearray_dynamic_local size (#{ a33 = #0L; b33 = #1l } : t33) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 535;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 535 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 536;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 536 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a33 *)
    let el = #{ el with a33 = next_el.#a33 } in
    set_idx_mut a ((.(i).#a33) : (t33 array, _) idx_mut) next_el.#a33;
    mark_test_run 537;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 537 failed %d %d" size i;
    (* .#b33 *)
    let el = #{ el with b33 = next_el.#b33 } in
    set_idx_mut a ((.(i).#b33) : (t33 array, _) idx_mut) next_el.#b33;
    mark_test_run 538;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 538 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t34 = #{ int64#; nativeint# }   *)
  (*************************************)
  let eq = (fun (#{ a34 = a341; b34 = b341 } : t34) (#{ a34 = a342; b34 = b342 } : t34) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a341 a342 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b341 b342) in
  let mk_value i = (#{ a34 = Int64_u.of_int (i + 0); b34 = Nativeint_u.of_int (i + 1) } : t34) in
  (* Create an array of size [size] *)
  let a : t34 array = makearray_dynamic_local size (#{ a34 = #0L; b34 = #1n } : t34) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 539;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 539 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 540;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 540 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a34 *)
    let el = #{ el with a34 = next_el.#a34 } in
    set_idx_mut a ((.(i).#a34) : (t34 array, _) idx_mut) next_el.#a34;
    mark_test_run 541;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 541 failed %d %d" size i;
    (* .#b34 *)
    let el = #{ el with b34 = next_el.#b34 } in
    set_idx_mut a ((.(i).#b34) : (t34 array, _) idx_mut) next_el.#b34;
    mark_test_run 542;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 542 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t17 = #{ int32# }   *)
  (*************************)
  let eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let mk_value i = (#{ a17 = Int32_u.of_int (i + 0) } : t17) in
  (* Create an array of size [size] *)
  let a : t17 array = makearray_dynamic_local size (#{ a17 = #0l } : t17) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 543;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 543 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 544;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 544 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a17 *)
    let el = #{ el with a17 = next_el.#a17 } in
    set_idx_mut a ((.(i).#a17) : (t17 array, _) idx_mut) next_el.#a17;
    mark_test_run 545;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 545 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t35 = #{ int32#; int64# }   *)
  (*********************************)
  let eq = (fun (#{ a35 = a351; b35 = b351 } : t35) (#{ a35 = a352; b35 = b352 } : t35) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a351 a352 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b351 b352) in
  let mk_value i = (#{ a35 = Int32_u.of_int (i + 0); b35 = Int64_u.of_int (i + 1) } : t35) in
  (* Create an array of size [size] *)
  let a : t35 array = makearray_dynamic_local size (#{ a35 = #0l; b35 = #1L } : t35) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 546;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 546 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 547;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 547 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a35 *)
    let el = #{ el with a35 = next_el.#a35 } in
    set_idx_mut a ((.(i).#a35) : (t35 array, _) idx_mut) next_el.#a35;
    mark_test_run 548;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 548 failed %d %d" size i;
    (* .#b35 *)
    let el = #{ el with b35 = next_el.#b35 } in
    set_idx_mut a ((.(i).#b35) : (t35 array, _) idx_mut) next_el.#b35;
    mark_test_run 549;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 549 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t19 = #{ int32#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let mk_value i = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19) in
  (* Create an array of size [size] *)
  let a : t19 array = makearray_dynamic_local size (#{ a19 = #0l; b19 = #1l } : t19) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 550;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 550 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 551;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 551 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a19 *)
    let el = #{ el with a19 = next_el.#a19 } in
    set_idx_mut a ((.(i).#a19) : (t19 array, _) idx_mut) next_el.#a19;
    mark_test_run 552;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 552 failed %d %d" size i;
    (* .#b19 *)
    let el = #{ el with b19 = next_el.#b19 } in
    set_idx_mut a ((.(i).#b19) : (t19 array, _) idx_mut) next_el.#b19;
    mark_test_run 553;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 553 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t36 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun (#{ a36 = a361; b36 = b361; c36 = c361 } : t36) (#{ a36 = a362; b36 = b362; c36 = c362 } : t36) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a361 a362 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b361 b362 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c361 c362) in
  let mk_value i = (#{ a36 = Int32_u.of_int (i + 0); b36 = Int32_u.of_int (i + 1); c36 = Int32_u.of_int (i + 2) } : t36) in
  (* Create an array of size [size] *)
  let a : t36 array = makearray_dynamic_local size (#{ a36 = #0l; b36 = #1l; c36 = #2l } : t36) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 554;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 554 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 555;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 555 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a36 *)
    let el = #{ el with a36 = next_el.#a36 } in
    set_idx_mut a ((.(i).#a36) : (t36 array, _) idx_mut) next_el.#a36;
    mark_test_run 556;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 556 failed %d %d" size i;
    (* .#b36 *)
    let el = #{ el with b36 = next_el.#b36 } in
    set_idx_mut a ((.(i).#b36) : (t36 array, _) idx_mut) next_el.#b36;
    mark_test_run 557;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 557 failed %d %d" size i;
    (* .#c36 *)
    let el = #{ el with c36 = next_el.#c36 } in
    set_idx_mut a ((.(i).#c36) : (t36 array, _) idx_mut) next_el.#c36;
    mark_test_run 558;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 558 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t37 = #{ int32#; nativeint# }   *)
  (*************************************)
  let eq = (fun (#{ a37 = a371; b37 = b371 } : t37) (#{ a37 = a372; b37 = b372 } : t37) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a371 a372 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b371 b372) in
  let mk_value i = (#{ a37 = Int32_u.of_int (i + 0); b37 = Nativeint_u.of_int (i + 1) } : t37) in
  (* Create an array of size [size] *)
  let a : t37 array = makearray_dynamic_local size (#{ a37 = #0l; b37 = #1n } : t37) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 559;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 559 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 560;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 560 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a37 *)
    let el = #{ el with a37 = next_el.#a37 } in
    set_idx_mut a ((.(i).#a37) : (t37 array, _) idx_mut) next_el.#a37;
    mark_test_run 561;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 561 failed %d %d" size i;
    (* .#b37 *)
    let el = #{ el with b37 = next_el.#b37 } in
    set_idx_mut a ((.(i).#b37) : (t37 array, _) idx_mut) next_el.#b37;
    mark_test_run 562;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 562 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t38 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a38 = a381; b38 = b381 } : t38) (#{ a38 = a382; b38 = b382 } : t38) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a381 a382 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b381 b382) in
  let mk_value i = (#{ a38 = Int32_u.of_int (i + 0); b38 = (#{ a17 = Int32_u.of_int (i + 1) } : t17) } : t38) in
  (* Create an array of size [size] *)
  let a : t38 array = makearray_dynamic_local size (#{ a38 = #0l; b38 = (#{ a17 = #1l } : t17) } : t38) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 563;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 563 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 564;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 564 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a38 *)
    let el = #{ el with a38 = next_el.#a38 } in
    set_idx_mut a ((.(i).#a38) : (t38 array, _) idx_mut) next_el.#a38;
    mark_test_run 565;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 565 failed %d %d" size i;
    (* .#b38 *)
    let el = #{ el with b38 = next_el.#b38 } in
    set_idx_mut a ((.(i).#b38) : (t38 array, _) idx_mut) next_el.#b38;
    mark_test_run 566;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 566 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b38.#a17 *)
    let el = #{ el with b38 = #{ el.#b38 with a17 = next_el.#b38.#a17 } } in
    set_idx_mut a ((.(i).#b38.#a17) : (t38 array, _) idx_mut) next_el.#b38.#a17;
    mark_test_run 567;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 567 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t39 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun (#{ a39 = a391; b39 = b391 } : t39) (#{ a39 = a392; b39 = b392 } : t39) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a391 a392 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b391 b392) in
  let mk_value i = (#{ a39 = Int32_u.of_int (i + 0); b39 = (#{ a19 = Int32_u.of_int (i + 1); b19 = Int32_u.of_int (i + 2) } : t19) } : t39) in
  (* Create an array of size [size] *)
  let a : t39 array = makearray_dynamic_local size (#{ a39 = #0l; b39 = (#{ a19 = #1l; b19 = #2l } : t19) } : t39) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 568;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 568 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 569;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 569 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a39 *)
    let el = #{ el with a39 = next_el.#a39 } in
    set_idx_mut a ((.(i).#a39) : (t39 array, _) idx_mut) next_el.#a39;
    mark_test_run 570;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 570 failed %d %d" size i;
    (* .#b39 *)
    let el = #{ el with b39 = next_el.#b39 } in
    set_idx_mut a ((.(i).#b39) : (t39 array, _) idx_mut) next_el.#b39;
    mark_test_run 571;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 571 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b39.#a19 *)
    let el = #{ el with b39 = #{ el.#b39 with a19 = next_el.#b39.#a19 } } in
    set_idx_mut a ((.(i).#b39.#a19) : (t39 array, _) idx_mut) next_el.#b39.#a19;
    mark_test_run 572;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 572 failed %d %d" size i;
    (* .#b39.#b19 *)
    let el = #{ el with b39 = #{ el.#b39 with b19 = next_el.#b39.#b19 } } in
    set_idx_mut a ((.(i).#b39.#b19) : (t39 array, _) idx_mut) next_el.#b39.#b19;
    mark_test_run 573;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 573 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t40 = #{ nativeint# }   *)
  (*****************************)
  let eq = (fun (#{ a40 = a401 } : t40) (#{ a40 = a402 } : t40) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a401 a402) in
  let mk_value i = (#{ a40 = Nativeint_u.of_int (i + 0) } : t40) in
  (* Create an array of size [size] *)
  let a : t40 array = makearray_dynamic_local size (#{ a40 = #0n } : t40) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 574;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 574 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 575;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 575 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a40 *)
    let el = #{ el with a40 = next_el.#a40 } in
    set_idx_mut a ((.(i).#a40) : (t40 array, _) idx_mut) next_el.#a40;
    mark_test_run 576;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 576 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t41 = #{ nativeint#; int64# }   *)
  (*************************************)
  let eq = (fun (#{ a41 = a411; b41 = b411 } : t41) (#{ a41 = a412; b41 = b412 } : t41) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a411 a412 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b411 b412) in
  let mk_value i = (#{ a41 = Nativeint_u.of_int (i + 0); b41 = Int64_u.of_int (i + 1) } : t41) in
  (* Create an array of size [size] *)
  let a : t41 array = makearray_dynamic_local size (#{ a41 = #0n; b41 = #1L } : t41) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 577;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 577 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 578;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 578 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a41 *)
    let el = #{ el with a41 = next_el.#a41 } in
    set_idx_mut a ((.(i).#a41) : (t41 array, _) idx_mut) next_el.#a41;
    mark_test_run 579;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 579 failed %d %d" size i;
    (* .#b41 *)
    let el = #{ el with b41 = next_el.#b41 } in
    set_idx_mut a ((.(i).#b41) : (t41 array, _) idx_mut) next_el.#b41;
    mark_test_run 580;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 580 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t42 = #{ nativeint#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a42 = a421; b42 = b421 } : t42) (#{ a42 = a422; b42 = b422 } : t42) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a421 a422 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b421 b422) in
  let mk_value i = (#{ a42 = Nativeint_u.of_int (i + 0); b42 = Int32_u.of_int (i + 1) } : t42) in
  (* Create an array of size [size] *)
  let a : t42 array = makearray_dynamic_local size (#{ a42 = #0n; b42 = #1l } : t42) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 581;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 581 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 582;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 582 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a42 *)
    let el = #{ el with a42 = next_el.#a42 } in
    set_idx_mut a ((.(i).#a42) : (t42 array, _) idx_mut) next_el.#a42;
    mark_test_run 583;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 583 failed %d %d" size i;
    (* .#b42 *)
    let el = #{ el with b42 = next_el.#b42 } in
    set_idx_mut a ((.(i).#b42) : (t42 array, _) idx_mut) next_el.#b42;
    mark_test_run 584;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 584 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t43 = #{ nativeint#; nativeint# }   *)
  (*****************************************)
  let eq = (fun (#{ a43 = a431; b43 = b431 } : t43) (#{ a43 = a432; b43 = b432 } : t43) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a431 a432 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b431 b432) in
  let mk_value i = (#{ a43 = Nativeint_u.of_int (i + 0); b43 = Nativeint_u.of_int (i + 1) } : t43) in
  (* Create an array of size [size] *)
  let a : t43 array = makearray_dynamic_local size (#{ a43 = #0n; b43 = #1n } : t43) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 585;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 585 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 586;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 586 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a43 *)
    let el = #{ el with a43 = next_el.#a43 } in
    set_idx_mut a ((.(i).#a43) : (t43 array, _) idx_mut) next_el.#a43;
    mark_test_run 587;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 587 failed %d %d" size i;
    (* .#b43 *)
    let el = #{ el with b43 = next_el.#b43 } in
    set_idx_mut a ((.(i).#b43) : (t43 array, _) idx_mut) next_el.#b43;
    mark_test_run 588;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 588 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t23 = #{ float; int }   *)
  (*****************************)
  let eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let mk_value i = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23) in
  (* Create an array of size [size] *)
  let a : t23 array = makearray_dynamic_local size (#{ a23 = 0.; b23 = 1 } : t23) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 589;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 589 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 590;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 590 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a23 *)
    let el = #{ el with a23 = next_el.#a23 } in
    set_idx_mut a ((.(i).#a23) : (t23 array, _) idx_mut) next_el.#a23;
    mark_test_run 591;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 591 failed %d %d" size i;
    (* .#b23 *)
    let el = #{ el with b23 = next_el.#b23 } in
    set_idx_mut a ((.(i).#b23) : (t23 array, _) idx_mut) next_el.#b23;
    mark_test_run 592;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 592 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t44 = #{ float; int; int }   *)
  (**********************************)
  let eq = (fun (#{ a44 = a441; b44 = b441; c44 = c441 } : t44) (#{ a44 = a442; b44 = b442; c44 = c442 } : t44) -> (fun a b -> Float.equal (globalize a) (globalize b)) a441 a442 && (fun a b -> Int.equal a b) b441 b442 && (fun a b -> Int.equal a b) c441 c442) in
  let mk_value i = (#{ a44 = Float.of_int (i + 0); b44 = (i + 1); c44 = (i + 2) } : t44) in
  (* Create an array of size [size] *)
  let a : t44 array = makearray_dynamic_local size (#{ a44 = 0.; b44 = 1; c44 = 2 } : t44) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 593;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 593 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 594;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 594 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a44 *)
    let el = #{ el with a44 = next_el.#a44 } in
    set_idx_mut a ((.(i).#a44) : (t44 array, _) idx_mut) next_el.#a44;
    mark_test_run 595;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 595 failed %d %d" size i;
    (* .#b44 *)
    let el = #{ el with b44 = next_el.#b44 } in
    set_idx_mut a ((.(i).#b44) : (t44 array, _) idx_mut) next_el.#b44;
    mark_test_run 596;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 596 failed %d %d" size i;
    (* .#c44 *)
    let el = #{ el with c44 = next_el.#c44 } in
    set_idx_mut a ((.(i).#c44) : (t44 array, _) idx_mut) next_el.#c44;
    mark_test_run 597;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 597 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t45 = #{ float; int; float }   *)
  (************************************)
  let eq = (fun (#{ a45 = a451; b45 = b451; c45 = c451 } : t45) (#{ a45 = a452; b45 = b452; c45 = c452 } : t45) -> (fun a b -> Float.equal (globalize a) (globalize b)) a451 a452 && (fun a b -> Int.equal a b) b451 b452 && (fun a b -> Float.equal (globalize a) (globalize b)) c451 c452) in
  let mk_value i = (#{ a45 = Float.of_int (i + 0); b45 = (i + 1); c45 = Float.of_int (i + 2) } : t45) in
  (* Create an array of size [size] *)
  let a : t45 array = makearray_dynamic_local size (#{ a45 = 0.; b45 = 1; c45 = 2. } : t45) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 598;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 598 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 599;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 599 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a45 *)
    let el = #{ el with a45 = next_el.#a45 } in
    set_idx_mut a ((.(i).#a45) : (t45 array, _) idx_mut) next_el.#a45;
    mark_test_run 600;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 600 failed %d %d" size i;
    (* .#b45 *)
    let el = #{ el with b45 = next_el.#b45 } in
    set_idx_mut a ((.(i).#b45) : (t45 array, _) idx_mut) next_el.#b45;
    mark_test_run 601;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 601 failed %d %d" size i;
    (* .#c45 *)
    let el = #{ el with c45 = next_el.#c45 } in
    set_idx_mut a ((.(i).#c45) : (t45 array, _) idx_mut) next_el.#c45;
    mark_test_run 602;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 602 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t46 = #{ float; int64 }   *)
  (*******************************)
  let eq = (fun (#{ a46 = a461; b46 = b461 } : t46) (#{ a46 = a462; b46 = b462 } : t46) -> (fun a b -> Float.equal (globalize a) (globalize b)) a461 a462 && (fun a b -> Int64.equal (globalize a) (globalize b)) b461 b462) in
  let mk_value i = (#{ a46 = Float.of_int (i + 0); b46 = Int64.of_int (i + 1) } : t46) in
  (* Create an array of size [size] *)
  let a : t46 array = makearray_dynamic_local size (#{ a46 = 0.; b46 = 1L } : t46) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 603;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 603 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 604;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 604 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a46 *)
    let el = #{ el with a46 = next_el.#a46 } in
    set_idx_mut a ((.(i).#a46) : (t46 array, _) idx_mut) next_el.#a46;
    mark_test_run 605;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 605 failed %d %d" size i;
    (* .#b46 *)
    let el = #{ el with b46 = next_el.#b46 } in
    set_idx_mut a ((.(i).#b46) : (t46 array, _) idx_mut) next_el.#b46;
    mark_test_run 606;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 606 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t25 = #{ float; float }   *)
  (*******************************)
  let eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let mk_value i = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25) in
  (* Create an array of size [size] *)
  let a : t25 array = makearray_dynamic_local size (#{ a25 = 0.; b25 = 1. } : t25) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 607;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 607 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 608;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 608 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a25 *)
    let el = #{ el with a25 = next_el.#a25 } in
    set_idx_mut a ((.(i).#a25) : (t25 array, _) idx_mut) next_el.#a25;
    mark_test_run 609;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 609 failed %d %d" size i;
    (* .#b25 *)
    let el = #{ el with b25 = next_el.#b25 } in
    set_idx_mut a ((.(i).#b25) : (t25 array, _) idx_mut) next_el.#b25;
    mark_test_run 610;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 610 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t47 = #{ float; float; int }   *)
  (************************************)
  let eq = (fun (#{ a47 = a471; b47 = b471; c47 = c471 } : t47) (#{ a47 = a472; b47 = b472; c47 = c472 } : t47) -> (fun a b -> Float.equal (globalize a) (globalize b)) a471 a472 && (fun a b -> Float.equal (globalize a) (globalize b)) b471 b472 && (fun a b -> Int.equal a b) c471 c472) in
  let mk_value i = (#{ a47 = Float.of_int (i + 0); b47 = Float.of_int (i + 1); c47 = (i + 2) } : t47) in
  (* Create an array of size [size] *)
  let a : t47 array = makearray_dynamic_local size (#{ a47 = 0.; b47 = 1.; c47 = 2 } : t47) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 611;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 611 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 612;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 612 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a47 *)
    let el = #{ el with a47 = next_el.#a47 } in
    set_idx_mut a ((.(i).#a47) : (t47 array, _) idx_mut) next_el.#a47;
    mark_test_run 613;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 613 failed %d %d" size i;
    (* .#b47 *)
    let el = #{ el with b47 = next_el.#b47 } in
    set_idx_mut a ((.(i).#b47) : (t47 array, _) idx_mut) next_el.#b47;
    mark_test_run 614;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 614 failed %d %d" size i;
    (* .#c47 *)
    let el = #{ el with c47 = next_el.#c47 } in
    set_idx_mut a ((.(i).#c47) : (t47 array, _) idx_mut) next_el.#c47;
    mark_test_run 615;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 615 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t48 = #{ float; float; float }   *)
  (**************************************)
  let eq = (fun (#{ a48 = a481; b48 = b481; c48 = c481 } : t48) (#{ a48 = a482; b48 = b482; c48 = c482 } : t48) -> (fun a b -> Float.equal (globalize a) (globalize b)) a481 a482 && (fun a b -> Float.equal (globalize a) (globalize b)) b481 b482 && (fun a b -> Float.equal (globalize a) (globalize b)) c481 c482) in
  let mk_value i = (#{ a48 = Float.of_int (i + 0); b48 = Float.of_int (i + 1); c48 = Float.of_int (i + 2) } : t48) in
  (* Create an array of size [size] *)
  let a : t48 array = makearray_dynamic_local size (#{ a48 = 0.; b48 = 1.; c48 = 2. } : t48) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 616;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 616 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 617;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 617 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a48 *)
    let el = #{ el with a48 = next_el.#a48 } in
    set_idx_mut a ((.(i).#a48) : (t48 array, _) idx_mut) next_el.#a48;
    mark_test_run 618;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 618 failed %d %d" size i;
    (* .#b48 *)
    let el = #{ el with b48 = next_el.#b48 } in
    set_idx_mut a ((.(i).#b48) : (t48 array, _) idx_mut) next_el.#b48;
    mark_test_run 619;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 619 failed %d %d" size i;
    (* .#c48 *)
    let el = #{ el with c48 = next_el.#c48 } in
    set_idx_mut a ((.(i).#c48) : (t48 array, _) idx_mut) next_el.#c48;
    mark_test_run 620;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 620 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t49 = #{ float; #{ int } }   *)
  (**********************************)
  let eq = (fun (#{ a49 = a491; b49 = b491 } : t49) (#{ a49 = a492; b49 = b492 } : t49) -> (fun a b -> Float.equal (globalize a) (globalize b)) a491 a492 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b491 b492) in
  let mk_value i = (#{ a49 = Float.of_int (i + 0); b49 = (#{ a0 = (i + 1) } : t0) } : t49) in
  (* Create an array of size [size] *)
  let a : t49 array = makearray_dynamic_local size (#{ a49 = 0.; b49 = (#{ a0 = 1 } : t0) } : t49) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 621;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 621 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 622;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 622 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a49 *)
    let el = #{ el with a49 = next_el.#a49 } in
    set_idx_mut a ((.(i).#a49) : (t49 array, _) idx_mut) next_el.#a49;
    mark_test_run 623;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 623 failed %d %d" size i;
    (* .#b49 *)
    let el = #{ el with b49 = next_el.#b49 } in
    set_idx_mut a ((.(i).#b49) : (t49 array, _) idx_mut) next_el.#b49;
    mark_test_run 624;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 624 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b49.#a0 *)
    let el = #{ el with b49 = #{ el.#b49 with a0 = next_el.#b49.#a0 } } in
    set_idx_mut a ((.(i).#b49.#a0) : (t49 array, _) idx_mut) next_el.#b49.#a0;
    mark_test_run 625;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 625 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t50 = #{ float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun (#{ a50 = a501; b50 = b501 } : t50) (#{ a50 = a502; b50 = b502 } : t50) -> (fun a b -> Float.equal (globalize a) (globalize b)) a501 a502 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b501 b502) in
  let mk_value i = (#{ a50 = Float.of_int (i + 0); b50 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t50) in
  (* Create an array of size [size] *)
  let a : t50 array = makearray_dynamic_local size (#{ a50 = 0.; b50 = (#{ a1 = 1; b1 = 2 } : t1) } : t50) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 626;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 626 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 627;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 627 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a50 *)
    let el = #{ el with a50 = next_el.#a50 } in
    set_idx_mut a ((.(i).#a50) : (t50 array, _) idx_mut) next_el.#a50;
    mark_test_run 628;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 628 failed %d %d" size i;
    (* .#b50 *)
    let el = #{ el with b50 = next_el.#b50 } in
    set_idx_mut a ((.(i).#b50) : (t50 array, _) idx_mut) next_el.#b50;
    mark_test_run 629;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 629 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b50.#a1 *)
    let el = #{ el with b50 = #{ el.#b50 with a1 = next_el.#b50.#a1 } } in
    set_idx_mut a ((.(i).#b50.#a1) : (t50 array, _) idx_mut) next_el.#b50.#a1;
    mark_test_run 630;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 630 failed %d %d" size i;
    (* .#b50.#b1 *)
    let el = #{ el with b50 = #{ el.#b50 with b1 = next_el.#b50.#b1 } } in
    set_idx_mut a ((.(i).#b50.#b1) : (t50 array, _) idx_mut) next_el.#b50.#b1;
    mark_test_run 631;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 631 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t51 = #{ float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a51 = a511; b51 = b511 } : t51) (#{ a51 = a512; b51 = b512 } : t51) -> (fun a b -> Float.equal (globalize a) (globalize b)) a511 a512 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b511 b512) in
  let mk_value i = (#{ a51 = Float.of_int (i + 0); b51 = (#{ a10 = (i + 1); b10 = Float.of_int (i + 2) } : t10) } : t51) in
  (* Create an array of size [size] *)
  let a : t51 array = makearray_dynamic_local size (#{ a51 = 0.; b51 = (#{ a10 = 1; b10 = 2. } : t10) } : t51) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 632;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 632 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 633;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 633 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a51 *)
    let el = #{ el with a51 = next_el.#a51 } in
    set_idx_mut a ((.(i).#a51) : (t51 array, _) idx_mut) next_el.#a51;
    mark_test_run 634;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 634 failed %d %d" size i;
    (* .#b51 *)
    let el = #{ el with b51 = next_el.#b51 } in
    set_idx_mut a ((.(i).#b51) : (t51 array, _) idx_mut) next_el.#b51;
    mark_test_run 635;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 635 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b51.#a10 *)
    let el = #{ el with b51 = #{ el.#b51 with a10 = next_el.#b51.#a10 } } in
    set_idx_mut a ((.(i).#b51.#a10) : (t51 array, _) idx_mut) next_el.#b51.#a10;
    mark_test_run 636;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 636 failed %d %d" size i;
    (* .#b51.#b10 *)
    let el = #{ el with b51 = #{ el.#b51 with b10 = next_el.#b51.#b10 } } in
    set_idx_mut a ((.(i).#b51.#b10) : (t51 array, _) idx_mut) next_el.#b51.#b10;
    mark_test_run 637;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 637 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t52 = #{ float; #{ float } }   *)
  (************************************)
  let eq = (fun (#{ a52 = a521; b52 = b521 } : t52) (#{ a52 = a522; b52 = b522 } : t52) -> (fun a b -> Float.equal (globalize a) (globalize b)) a521 a522 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b521 b522) in
  let mk_value i = (#{ a52 = Float.of_int (i + 0); b52 = (#{ a21 = Float.of_int (i + 1) } : t21) } : t52) in
  (* Create an array of size [size] *)
  let a : t52 array = makearray_dynamic_local size (#{ a52 = 0.; b52 = (#{ a21 = 1. } : t21) } : t52) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 638;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 638 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 639;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 639 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a52 *)
    let el = #{ el with a52 = next_el.#a52 } in
    set_idx_mut a ((.(i).#a52) : (t52 array, _) idx_mut) next_el.#a52;
    mark_test_run 640;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 640 failed %d %d" size i;
    (* .#b52 *)
    let el = #{ el with b52 = next_el.#b52 } in
    set_idx_mut a ((.(i).#b52) : (t52 array, _) idx_mut) next_el.#b52;
    mark_test_run 641;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 641 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b52.#a21 *)
    let el = #{ el with b52 = #{ el.#b52 with a21 = next_el.#b52.#a21 } } in
    set_idx_mut a ((.(i).#b52.#a21) : (t52 array, _) idx_mut) next_el.#b52.#a21;
    mark_test_run 642;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 642 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t53 = #{ float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun (#{ a53 = a531; b53 = b531 } : t53) (#{ a53 = a532; b53 = b532 } : t53) -> (fun a b -> Float.equal (globalize a) (globalize b)) a531 a532 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b531 b532) in
  let mk_value i = (#{ a53 = Float.of_int (i + 0); b53 = (#{ a23 = Float.of_int (i + 1); b23 = (i + 2) } : t23) } : t53) in
  (* Create an array of size [size] *)
  let a : t53 array = makearray_dynamic_local size (#{ a53 = 0.; b53 = (#{ a23 = 1.; b23 = 2 } : t23) } : t53) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 643;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 643 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 644;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 644 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a53 *)
    let el = #{ el with a53 = next_el.#a53 } in
    set_idx_mut a ((.(i).#a53) : (t53 array, _) idx_mut) next_el.#a53;
    mark_test_run 645;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 645 failed %d %d" size i;
    (* .#b53 *)
    let el = #{ el with b53 = next_el.#b53 } in
    set_idx_mut a ((.(i).#b53) : (t53 array, _) idx_mut) next_el.#b53;
    mark_test_run 646;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 646 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b53.#a23 *)
    let el = #{ el with b53 = #{ el.#b53 with a23 = next_el.#b53.#a23 } } in
    set_idx_mut a ((.(i).#b53.#a23) : (t53 array, _) idx_mut) next_el.#b53.#a23;
    mark_test_run 647;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 647 failed %d %d" size i;
    (* .#b53.#b23 *)
    let el = #{ el with b53 = #{ el.#b53 with b23 = next_el.#b53.#b23 } } in
    set_idx_mut a ((.(i).#b53.#b23) : (t53 array, _) idx_mut) next_el.#b53.#b23;
    mark_test_run 648;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 648 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t54 = #{ float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun (#{ a54 = a541; b54 = b541 } : t54) (#{ a54 = a542; b54 = b542 } : t54) -> (fun a b -> Float.equal (globalize a) (globalize b)) a541 a542 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b541 b542) in
  let mk_value i = (#{ a54 = Float.of_int (i + 0); b54 = (#{ a25 = Float.of_int (i + 1); b25 = Float.of_int (i + 2) } : t25) } : t54) in
  (* Create an array of size [size] *)
  let a : t54 array = makearray_dynamic_local size (#{ a54 = 0.; b54 = (#{ a25 = 1.; b25 = 2. } : t25) } : t54) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 649;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 649 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 650;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 650 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a54 *)
    let el = #{ el with a54 = next_el.#a54 } in
    set_idx_mut a ((.(i).#a54) : (t54 array, _) idx_mut) next_el.#a54;
    mark_test_run 651;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 651 failed %d %d" size i;
    (* .#b54 *)
    let el = #{ el with b54 = next_el.#b54 } in
    set_idx_mut a ((.(i).#b54) : (t54 array, _) idx_mut) next_el.#b54;
    mark_test_run 652;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 652 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b54.#a25 *)
    let el = #{ el with b54 = #{ el.#b54 with a25 = next_el.#b54.#a25 } } in
    set_idx_mut a ((.(i).#b54.#a25) : (t54 array, _) idx_mut) next_el.#b54.#a25;
    mark_test_run 653;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 653 failed %d %d" size i;
    (* .#b54.#b25 *)
    let el = #{ el with b54 = #{ el.#b54 with b25 = next_el.#b54.#b25 } } in
    set_idx_mut a ((.(i).#b54.#b25) : (t54 array, _) idx_mut) next_el.#b54.#b25;
    mark_test_run 654;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 654 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************)
  (*   t55 = #{ #{ int } }   *)
  (***************************)
  let eq = (fun (#{ a55 = a551 } : t55) (#{ a55 = a552 } : t55) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a551 a552) in
  let mk_value i = (#{ a55 = (#{ a0 = (i + 0) } : t0) } : t55) in
  (* Create an array of size [size] *)
  let a : t55 array = makearray_dynamic_local size (#{ a55 = (#{ a0 = 0 } : t0) } : t55) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 655;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 655 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 656;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 656 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a55 *)
    let el = #{ el with a55 = next_el.#a55 } in
    set_idx_mut a ((.(i).#a55) : (t55 array, _) idx_mut) next_el.#a55;
    mark_test_run 657;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 657 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a55.#a0 *)
    let el = #{ el with a55 = #{ el.#a55 with a0 = next_el.#a55.#a0 } } in
    set_idx_mut a ((.(i).#a55.#a0) : (t55 array, _) idx_mut) next_el.#a55.#a0;
    mark_test_run 658;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 658 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t56 = #{ #{ int }; int }   *)
  (********************************)
  let eq = (fun (#{ a56 = a561; b56 = b561 } : t56) (#{ a56 = a562; b56 = b562 } : t56) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a561 a562 && (fun a b -> Int.equal a b) b561 b562) in
  let mk_value i = (#{ a56 = (#{ a0 = (i + 0) } : t0); b56 = (i + 1) } : t56) in
  (* Create an array of size [size] *)
  let a : t56 array = makearray_dynamic_local size (#{ a56 = (#{ a0 = 0 } : t0); b56 = 1 } : t56) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 659;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 659 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 660;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 660 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a56 *)
    let el = #{ el with a56 = next_el.#a56 } in
    set_idx_mut a ((.(i).#a56) : (t56 array, _) idx_mut) next_el.#a56;
    mark_test_run 661;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 661 failed %d %d" size i;
    (* .#b56 *)
    let el = #{ el with b56 = next_el.#b56 } in
    set_idx_mut a ((.(i).#b56) : (t56 array, _) idx_mut) next_el.#b56;
    mark_test_run 662;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 662 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a56.#a0 *)
    let el = #{ el with a56 = #{ el.#a56 with a0 = next_el.#a56.#a0 } } in
    set_idx_mut a ((.(i).#a56.#a0) : (t56 array, _) idx_mut) next_el.#a56.#a0;
    mark_test_run 663;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 663 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t57 = #{ #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun (#{ a57 = a571; b57 = b571 } : t57) (#{ a57 = a572; b57 = b572 } : t57) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a571 a572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b571 b572) in
  let mk_value i = (#{ a57 = (#{ a0 = (i + 0) } : t0); b57 = Int32_u.of_int (i + 1) } : t57) in
  (* Create an array of size [size] *)
  let a : t57 array = makearray_dynamic_local size (#{ a57 = (#{ a0 = 0 } : t0); b57 = #1l } : t57) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 664;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 664 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 665;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 665 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a57 *)
    let el = #{ el with a57 = next_el.#a57 } in
    set_idx_mut a ((.(i).#a57) : (t57 array, _) idx_mut) next_el.#a57;
    mark_test_run 666;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 666 failed %d %d" size i;
    (* .#b57 *)
    let el = #{ el with b57 = next_el.#b57 } in
    set_idx_mut a ((.(i).#b57) : (t57 array, _) idx_mut) next_el.#b57;
    mark_test_run 667;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 667 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a57.#a0 *)
    let el = #{ el with a57 = #{ el.#a57 with a0 = next_el.#a57.#a0 } } in
    set_idx_mut a ((.(i).#a57.#a0) : (t57 array, _) idx_mut) next_el.#a57.#a0;
    mark_test_run 668;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 668 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t58 = #{ #{ int }; float }   *)
  (**********************************)
  let eq = (fun (#{ a58 = a581; b58 = b581 } : t58) (#{ a58 = a582; b58 = b582 } : t58) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a581 a582 && (fun a b -> Float.equal (globalize a) (globalize b)) b581 b582) in
  let mk_value i = (#{ a58 = (#{ a0 = (i + 0) } : t0); b58 = Float.of_int (i + 1) } : t58) in
  (* Create an array of size [size] *)
  let a : t58 array = makearray_dynamic_local size (#{ a58 = (#{ a0 = 0 } : t0); b58 = 1. } : t58) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 669;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 669 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 670;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 670 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a58 *)
    let el = #{ el with a58 = next_el.#a58 } in
    set_idx_mut a ((.(i).#a58) : (t58 array, _) idx_mut) next_el.#a58;
    mark_test_run 671;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 671 failed %d %d" size i;
    (* .#b58 *)
    let el = #{ el with b58 = next_el.#b58 } in
    set_idx_mut a ((.(i).#b58) : (t58 array, _) idx_mut) next_el.#b58;
    mark_test_run 672;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 672 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a58.#a0 *)
    let el = #{ el with a58 = #{ el.#a58 with a0 = next_el.#a58.#a0 } } in
    set_idx_mut a ((.(i).#a58.#a0) : (t58 array, _) idx_mut) next_el.#a58.#a0;
    mark_test_run 673;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 673 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t59 = #{ #{ int; int } }   *)
  (********************************)
  let eq = (fun (#{ a59 = a591 } : t59) (#{ a59 = a592 } : t59) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a591 a592) in
  let mk_value i = (#{ a59 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) } : t59) in
  (* Create an array of size [size] *)
  let a : t59 array = makearray_dynamic_local size (#{ a59 = (#{ a1 = 0; b1 = 1 } : t1) } : t59) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 674;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 674 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 675;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 675 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a59 *)
    let el = #{ el with a59 = next_el.#a59 } in
    set_idx_mut a ((.(i).#a59) : (t59 array, _) idx_mut) next_el.#a59;
    mark_test_run 676;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 676 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a59.#a1 *)
    let el = #{ el with a59 = #{ el.#a59 with a1 = next_el.#a59.#a1 } } in
    set_idx_mut a ((.(i).#a59.#a1) : (t59 array, _) idx_mut) next_el.#a59.#a1;
    mark_test_run 677;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 677 failed %d %d" size i;
    (* .#a59.#b1 *)
    let el = #{ el with a59 = #{ el.#a59 with b1 = next_el.#a59.#b1 } } in
    set_idx_mut a ((.(i).#a59.#b1) : (t59 array, _) idx_mut) next_el.#a59.#b1;
    mark_test_run 678;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 678 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t60 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun (#{ a60 = a601; b60 = b601 } : t60) (#{ a60 = a602; b60 = b602 } : t60) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a601 a602 && (fun a b -> Int.equal a b) b601 b602) in
  let mk_value i = (#{ a60 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b60 = (i + 2) } : t60) in
  (* Create an array of size [size] *)
  let a : t60 array = makearray_dynamic_local size (#{ a60 = (#{ a1 = 0; b1 = 1 } : t1); b60 = 2 } : t60) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 679;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 679 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 680;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 680 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a60 *)
    let el = #{ el with a60 = next_el.#a60 } in
    set_idx_mut a ((.(i).#a60) : (t60 array, _) idx_mut) next_el.#a60;
    mark_test_run 681;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 681 failed %d %d" size i;
    (* .#b60 *)
    let el = #{ el with b60 = next_el.#b60 } in
    set_idx_mut a ((.(i).#b60) : (t60 array, _) idx_mut) next_el.#b60;
    mark_test_run 682;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 682 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a60.#a1 *)
    let el = #{ el with a60 = #{ el.#a60 with a1 = next_el.#a60.#a1 } } in
    set_idx_mut a ((.(i).#a60.#a1) : (t60 array, _) idx_mut) next_el.#a60.#a1;
    mark_test_run 683;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 683 failed %d %d" size i;
    (* .#a60.#b1 *)
    let el = #{ el with a60 = #{ el.#a60 with b1 = next_el.#a60.#b1 } } in
    set_idx_mut a ((.(i).#a60.#b1) : (t60 array, _) idx_mut) next_el.#a60.#b1;
    mark_test_run 684;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 684 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t61 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun (#{ a61 = a611; b61 = b611 } : t61) (#{ a61 = a612; b61 = b612 } : t61) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a611 a612 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b611 b612) in
  let mk_value i = (#{ a61 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b61 = Int32_u.of_int (i + 2) } : t61) in
  (* Create an array of size [size] *)
  let a : t61 array = makearray_dynamic_local size (#{ a61 = (#{ a1 = 0; b1 = 1 } : t1); b61 = #2l } : t61) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 685;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 685 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 686;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 686 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a61 *)
    let el = #{ el with a61 = next_el.#a61 } in
    set_idx_mut a ((.(i).#a61) : (t61 array, _) idx_mut) next_el.#a61;
    mark_test_run 687;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 687 failed %d %d" size i;
    (* .#b61 *)
    let el = #{ el with b61 = next_el.#b61 } in
    set_idx_mut a ((.(i).#b61) : (t61 array, _) idx_mut) next_el.#b61;
    mark_test_run 688;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 688 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a61.#a1 *)
    let el = #{ el with a61 = #{ el.#a61 with a1 = next_el.#a61.#a1 } } in
    set_idx_mut a ((.(i).#a61.#a1) : (t61 array, _) idx_mut) next_el.#a61.#a1;
    mark_test_run 689;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 689 failed %d %d" size i;
    (* .#a61.#b1 *)
    let el = #{ el with a61 = #{ el.#a61 with b1 = next_el.#a61.#b1 } } in
    set_idx_mut a ((.(i).#a61.#b1) : (t61 array, _) idx_mut) next_el.#a61.#b1;
    mark_test_run 690;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 690 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t62 = #{ #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun (#{ a62 = a621; b62 = b621 } : t62) (#{ a62 = a622; b62 = b622 } : t62) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a621 a622 && (fun a b -> Float.equal (globalize a) (globalize b)) b621 b622) in
  let mk_value i = (#{ a62 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b62 = Float.of_int (i + 2) } : t62) in
  (* Create an array of size [size] *)
  let a : t62 array = makearray_dynamic_local size (#{ a62 = (#{ a1 = 0; b1 = 1 } : t1); b62 = 2. } : t62) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 691;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 691 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 692;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 692 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a62 *)
    let el = #{ el with a62 = next_el.#a62 } in
    set_idx_mut a ((.(i).#a62) : (t62 array, _) idx_mut) next_el.#a62;
    mark_test_run 693;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 693 failed %d %d" size i;
    (* .#b62 *)
    let el = #{ el with b62 = next_el.#b62 } in
    set_idx_mut a ((.(i).#b62) : (t62 array, _) idx_mut) next_el.#b62;
    mark_test_run 694;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 694 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a62.#a1 *)
    let el = #{ el with a62 = #{ el.#a62 with a1 = next_el.#a62.#a1 } } in
    set_idx_mut a ((.(i).#a62.#a1) : (t62 array, _) idx_mut) next_el.#a62.#a1;
    mark_test_run 695;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 695 failed %d %d" size i;
    (* .#a62.#b1 *)
    let el = #{ el with a62 = #{ el.#a62 with b1 = next_el.#a62.#b1 } } in
    set_idx_mut a ((.(i).#a62.#b1) : (t62 array, _) idx_mut) next_el.#a62.#b1;
    mark_test_run 696;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 696 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t63 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a63 = a631 } : t63) (#{ a63 = a632 } : t63) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a631 a632) in
  let mk_value i = (#{ a63 = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7) } : t63) in
  (* Create an array of size [size] *)
  let a : t63 array = makearray_dynamic_local size (#{ a63 = (#{ a7 = 0; b7 = #1l } : t7) } : t63) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 697;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 697 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 698;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 698 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a63 *)
    let el = #{ el with a63 = next_el.#a63 } in
    set_idx_mut a ((.(i).#a63) : (t63 array, _) idx_mut) next_el.#a63;
    mark_test_run 699;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 699 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a63.#a7 *)
    let el = #{ el with a63 = #{ el.#a63 with a7 = next_el.#a63.#a7 } } in
    set_idx_mut a ((.(i).#a63.#a7) : (t63 array, _) idx_mut) next_el.#a63.#a7;
    mark_test_run 700;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 700 failed %d %d" size i;
    (* .#a63.#b7 *)
    let el = #{ el with a63 = #{ el.#a63 with b7 = next_el.#a63.#b7 } } in
    set_idx_mut a ((.(i).#a63.#b7) : (t63 array, _) idx_mut) next_el.#a63.#b7;
    mark_test_run 701;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 701 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t64 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun (#{ a64 = a641; b64 = b641 } : t64) (#{ a64 = a642; b64 = b642 } : t64) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a641 a642 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b641 b642) in
  let mk_value i = (#{ a64 = (#{ a7 = (i + 0); b7 = Int32_u.of_int (i + 1) } : t7); b64 = Int32_u.of_int (i + 2) } : t64) in
  (* Create an array of size [size] *)
  let a : t64 array = makearray_dynamic_local size (#{ a64 = (#{ a7 = 0; b7 = #1l } : t7); b64 = #2l } : t64) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 702;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 702 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 703;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 703 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a64 *)
    let el = #{ el with a64 = next_el.#a64 } in
    set_idx_mut a ((.(i).#a64) : (t64 array, _) idx_mut) next_el.#a64;
    mark_test_run 704;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 704 failed %d %d" size i;
    (* .#b64 *)
    let el = #{ el with b64 = next_el.#b64 } in
    set_idx_mut a ((.(i).#b64) : (t64 array, _) idx_mut) next_el.#b64;
    mark_test_run 705;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 705 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a64.#a7 *)
    let el = #{ el with a64 = #{ el.#a64 with a7 = next_el.#a64.#a7 } } in
    set_idx_mut a ((.(i).#a64.#a7) : (t64 array, _) idx_mut) next_el.#a64.#a7;
    mark_test_run 706;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 706 failed %d %d" size i;
    (* .#a64.#b7 *)
    let el = #{ el with a64 = #{ el.#a64 with b7 = next_el.#a64.#b7 } } in
    set_idx_mut a ((.(i).#a64.#b7) : (t64 array, _) idx_mut) next_el.#a64.#b7;
    mark_test_run 707;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 707 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t65 = #{ #{ int; float } }   *)
  (**********************************)
  let eq = (fun (#{ a65 = a651 } : t65) (#{ a65 = a652 } : t65) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a651 a652) in
  let mk_value i = (#{ a65 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10) } : t65) in
  (* Create an array of size [size] *)
  let a : t65 array = makearray_dynamic_local size (#{ a65 = (#{ a10 = 0; b10 = 1. } : t10) } : t65) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 708;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 708 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 709;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 709 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a65 *)
    let el = #{ el with a65 = next_el.#a65 } in
    set_idx_mut a ((.(i).#a65) : (t65 array, _) idx_mut) next_el.#a65;
    mark_test_run 710;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 710 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a65.#a10 *)
    let el = #{ el with a65 = #{ el.#a65 with a10 = next_el.#a65.#a10 } } in
    set_idx_mut a ((.(i).#a65.#a10) : (t65 array, _) idx_mut) next_el.#a65.#a10;
    mark_test_run 711;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 711 failed %d %d" size i;
    (* .#a65.#b10 *)
    let el = #{ el with a65 = #{ el.#a65 with b10 = next_el.#a65.#b10 } } in
    set_idx_mut a ((.(i).#a65.#b10) : (t65 array, _) idx_mut) next_el.#a65.#b10;
    mark_test_run 712;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 712 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t66 = #{ #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun (#{ a66 = a661; b66 = b661 } : t66) (#{ a66 = a662; b66 = b662 } : t66) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a661 a662 && (fun a b -> Int.equal a b) b661 b662) in
  let mk_value i = (#{ a66 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10); b66 = (i + 2) } : t66) in
  (* Create an array of size [size] *)
  let a : t66 array = makearray_dynamic_local size (#{ a66 = (#{ a10 = 0; b10 = 1. } : t10); b66 = 2 } : t66) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 713;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 713 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 714;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 714 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a66 *)
    let el = #{ el with a66 = next_el.#a66 } in
    set_idx_mut a ((.(i).#a66) : (t66 array, _) idx_mut) next_el.#a66;
    mark_test_run 715;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 715 failed %d %d" size i;
    (* .#b66 *)
    let el = #{ el with b66 = next_el.#b66 } in
    set_idx_mut a ((.(i).#b66) : (t66 array, _) idx_mut) next_el.#b66;
    mark_test_run 716;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 716 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a66.#a10 *)
    let el = #{ el with a66 = #{ el.#a66 with a10 = next_el.#a66.#a10 } } in
    set_idx_mut a ((.(i).#a66.#a10) : (t66 array, _) idx_mut) next_el.#a66.#a10;
    mark_test_run 717;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 717 failed %d %d" size i;
    (* .#a66.#b10 *)
    let el = #{ el with a66 = #{ el.#a66 with b10 = next_el.#a66.#b10 } } in
    set_idx_mut a ((.(i).#a66.#b10) : (t66 array, _) idx_mut) next_el.#a66.#b10;
    mark_test_run 718;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 718 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t67 = #{ #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a67 = a671; b67 = b671 } : t67) (#{ a67 = a672; b67 = b672 } : t67) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a671 a672 && (fun a b -> Float.equal (globalize a) (globalize b)) b671 b672) in
  let mk_value i = (#{ a67 = (#{ a10 = (i + 0); b10 = Float.of_int (i + 1) } : t10); b67 = Float.of_int (i + 2) } : t67) in
  (* Create an array of size [size] *)
  let a : t67 array = makearray_dynamic_local size (#{ a67 = (#{ a10 = 0; b10 = 1. } : t10); b67 = 2. } : t67) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 719;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 719 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 720;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 720 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a67 *)
    let el = #{ el with a67 = next_el.#a67 } in
    set_idx_mut a ((.(i).#a67) : (t67 array, _) idx_mut) next_el.#a67;
    mark_test_run 721;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 721 failed %d %d" size i;
    (* .#b67 *)
    let el = #{ el with b67 = next_el.#b67 } in
    set_idx_mut a ((.(i).#b67) : (t67 array, _) idx_mut) next_el.#b67;
    mark_test_run 722;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 722 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a67.#a10 *)
    let el = #{ el with a67 = #{ el.#a67 with a10 = next_el.#a67.#a10 } } in
    set_idx_mut a ((.(i).#a67.#a10) : (t67 array, _) idx_mut) next_el.#a67.#a10;
    mark_test_run 723;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 723 failed %d %d" size i;
    (* .#a67.#b10 *)
    let el = #{ el with a67 = #{ el.#a67 with b10 = next_el.#a67.#b10 } } in
    set_idx_mut a ((.(i).#a67.#b10) : (t67 array, _) idx_mut) next_el.#a67.#b10;
    mark_test_run 724;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 724 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************)
  (*   t68 = #{ #{ int32# } }   *)
  (******************************)
  let eq = (fun (#{ a68 = a681 } : t68) (#{ a68 = a682 } : t68) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a681 a682) in
  let mk_value i = (#{ a68 = (#{ a17 = Int32_u.of_int (i + 0) } : t17) } : t68) in
  (* Create an array of size [size] *)
  let a : t68 array = makearray_dynamic_local size (#{ a68 = (#{ a17 = #0l } : t17) } : t68) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 725;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 725 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 726;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 726 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a68 *)
    let el = #{ el with a68 = next_el.#a68 } in
    set_idx_mut a ((.(i).#a68) : (t68 array, _) idx_mut) next_el.#a68;
    mark_test_run 727;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 727 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a68.#a17 *)
    let el = #{ el with a68 = #{ el.#a68 with a17 = next_el.#a68.#a17 } } in
    set_idx_mut a ((.(i).#a68.#a17) : (t68 array, _) idx_mut) next_el.#a68.#a17;
    mark_test_run 728;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 728 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t69 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun (#{ a69 = a691; b69 = b691 } : t69) (#{ a69 = a692; b69 = b692 } : t69) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a691 a692 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b691 b692) in
  let mk_value i = (#{ a69 = (#{ a17 = Int32_u.of_int (i + 0) } : t17); b69 = Int32_u.of_int (i + 1) } : t69) in
  (* Create an array of size [size] *)
  let a : t69 array = makearray_dynamic_local size (#{ a69 = (#{ a17 = #0l } : t17); b69 = #1l } : t69) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 729;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 729 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 730;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 730 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a69 *)
    let el = #{ el with a69 = next_el.#a69 } in
    set_idx_mut a ((.(i).#a69) : (t69 array, _) idx_mut) next_el.#a69;
    mark_test_run 731;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 731 failed %d %d" size i;
    (* .#b69 *)
    let el = #{ el with b69 = next_el.#b69 } in
    set_idx_mut a ((.(i).#b69) : (t69 array, _) idx_mut) next_el.#b69;
    mark_test_run 732;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 732 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a69.#a17 *)
    let el = #{ el with a69 = #{ el.#a69 with a17 = next_el.#a69.#a17 } } in
    set_idx_mut a ((.(i).#a69.#a17) : (t69 array, _) idx_mut) next_el.#a69.#a17;
    mark_test_run 733;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 733 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t70 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a70 = a701 } : t70) (#{ a70 = a702 } : t70) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a701 a702) in
  let mk_value i = (#{ a70 = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19) } : t70) in
  (* Create an array of size [size] *)
  let a : t70 array = makearray_dynamic_local size (#{ a70 = (#{ a19 = #0l; b19 = #1l } : t19) } : t70) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 734;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 734 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 735;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 735 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a70 *)
    let el = #{ el with a70 = next_el.#a70 } in
    set_idx_mut a ((.(i).#a70) : (t70 array, _) idx_mut) next_el.#a70;
    mark_test_run 736;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 736 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a70.#a19 *)
    let el = #{ el with a70 = #{ el.#a70 with a19 = next_el.#a70.#a19 } } in
    set_idx_mut a ((.(i).#a70.#a19) : (t70 array, _) idx_mut) next_el.#a70.#a19;
    mark_test_run 737;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 737 failed %d %d" size i;
    (* .#a70.#b19 *)
    let el = #{ el with a70 = #{ el.#a70 with b19 = next_el.#a70.#b19 } } in
    set_idx_mut a ((.(i).#a70.#b19) : (t70 array, _) idx_mut) next_el.#a70.#b19;
    mark_test_run 738;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 738 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t71 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun (#{ a71 = a711; b71 = b711 } : t71) (#{ a71 = a712; b71 = b712 } : t71) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a711 a712 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b711 b712) in
  let mk_value i = (#{ a71 = (#{ a19 = Int32_u.of_int (i + 0); b19 = Int32_u.of_int (i + 1) } : t19); b71 = Int32_u.of_int (i + 2) } : t71) in
  (* Create an array of size [size] *)
  let a : t71 array = makearray_dynamic_local size (#{ a71 = (#{ a19 = #0l; b19 = #1l } : t19); b71 = #2l } : t71) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 739;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 739 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 740;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 740 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a71 *)
    let el = #{ el with a71 = next_el.#a71 } in
    set_idx_mut a ((.(i).#a71) : (t71 array, _) idx_mut) next_el.#a71;
    mark_test_run 741;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 741 failed %d %d" size i;
    (* .#b71 *)
    let el = #{ el with b71 = next_el.#b71 } in
    set_idx_mut a ((.(i).#b71) : (t71 array, _) idx_mut) next_el.#b71;
    mark_test_run 742;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 742 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a71.#a19 *)
    let el = #{ el with a71 = #{ el.#a71 with a19 = next_el.#a71.#a19 } } in
    set_idx_mut a ((.(i).#a71.#a19) : (t71 array, _) idx_mut) next_el.#a71.#a19;
    mark_test_run 743;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 743 failed %d %d" size i;
    (* .#a71.#b19 *)
    let el = #{ el with a71 = #{ el.#a71 with b19 = next_el.#a71.#b19 } } in
    set_idx_mut a ((.(i).#a71.#b19) : (t71 array, _) idx_mut) next_el.#a71.#b19;
    mark_test_run 744;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 744 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t72 = #{ #{ float }; int }   *)
  (**********************************)
  let eq = (fun (#{ a72 = a721; b72 = b721 } : t72) (#{ a72 = a722; b72 = b722 } : t72) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a721 a722 && (fun a b -> Int.equal a b) b721 b722) in
  let mk_value i = (#{ a72 = (#{ a21 = Float.of_int (i + 0) } : t21); b72 = (i + 1) } : t72) in
  (* Create an array of size [size] *)
  let a : t72 array = makearray_dynamic_local size (#{ a72 = (#{ a21 = 0. } : t21); b72 = 1 } : t72) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 745;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 745 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 746;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 746 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a72 *)
    let el = #{ el with a72 = next_el.#a72 } in
    set_idx_mut a ((.(i).#a72) : (t72 array, _) idx_mut) next_el.#a72;
    mark_test_run 747;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 747 failed %d %d" size i;
    (* .#b72 *)
    let el = #{ el with b72 = next_el.#b72 } in
    set_idx_mut a ((.(i).#b72) : (t72 array, _) idx_mut) next_el.#b72;
    mark_test_run 748;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 748 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a72.#a21 *)
    let el = #{ el with a72 = #{ el.#a72 with a21 = next_el.#a72.#a21 } } in
    set_idx_mut a ((.(i).#a72.#a21) : (t72 array, _) idx_mut) next_el.#a72.#a21;
    mark_test_run 749;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 749 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t73 = #{ #{ float }; float }   *)
  (************************************)
  let eq = (fun (#{ a73 = a731; b73 = b731 } : t73) (#{ a73 = a732; b73 = b732 } : t73) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a731 a732 && (fun a b -> Float.equal (globalize a) (globalize b)) b731 b732) in
  let mk_value i = (#{ a73 = (#{ a21 = Float.of_int (i + 0) } : t21); b73 = Float.of_int (i + 1) } : t73) in
  (* Create an array of size [size] *)
  let a : t73 array = makearray_dynamic_local size (#{ a73 = (#{ a21 = 0. } : t21); b73 = 1. } : t73) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 750;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 750 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 751;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 751 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a73 *)
    let el = #{ el with a73 = next_el.#a73 } in
    set_idx_mut a ((.(i).#a73) : (t73 array, _) idx_mut) next_el.#a73;
    mark_test_run 752;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 752 failed %d %d" size i;
    (* .#b73 *)
    let el = #{ el with b73 = next_el.#b73 } in
    set_idx_mut a ((.(i).#b73) : (t73 array, _) idx_mut) next_el.#b73;
    mark_test_run 753;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 753 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a73.#a21 *)
    let el = #{ el with a73 = #{ el.#a73 with a21 = next_el.#a73.#a21 } } in
    set_idx_mut a ((.(i).#a73.#a21) : (t73 array, _) idx_mut) next_el.#a73.#a21;
    mark_test_run 754;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 754 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t74 = #{ #{ float; int } }   *)
  (**********************************)
  let eq = (fun (#{ a74 = a741 } : t74) (#{ a74 = a742 } : t74) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a741 a742) in
  let mk_value i = (#{ a74 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23) } : t74) in
  (* Create an array of size [size] *)
  let a : t74 array = makearray_dynamic_local size (#{ a74 = (#{ a23 = 0.; b23 = 1 } : t23) } : t74) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 755;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 755 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 756;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 756 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a74 *)
    let el = #{ el with a74 = next_el.#a74 } in
    set_idx_mut a ((.(i).#a74) : (t74 array, _) idx_mut) next_el.#a74;
    mark_test_run 757;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 757 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a74.#a23 *)
    let el = #{ el with a74 = #{ el.#a74 with a23 = next_el.#a74.#a23 } } in
    set_idx_mut a ((.(i).#a74.#a23) : (t74 array, _) idx_mut) next_el.#a74.#a23;
    mark_test_run 758;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 758 failed %d %d" size i;
    (* .#a74.#b23 *)
    let el = #{ el with a74 = #{ el.#a74 with b23 = next_el.#a74.#b23 } } in
    set_idx_mut a ((.(i).#a74.#b23) : (t74 array, _) idx_mut) next_el.#a74.#b23;
    mark_test_run 759;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 759 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t75 = #{ #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun (#{ a75 = a751; b75 = b751 } : t75) (#{ a75 = a752; b75 = b752 } : t75) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a751 a752 && (fun a b -> Int.equal a b) b751 b752) in
  let mk_value i = (#{ a75 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23); b75 = (i + 2) } : t75) in
  (* Create an array of size [size] *)
  let a : t75 array = makearray_dynamic_local size (#{ a75 = (#{ a23 = 0.; b23 = 1 } : t23); b75 = 2 } : t75) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 760;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 760 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 761;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 761 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a75 *)
    let el = #{ el with a75 = next_el.#a75 } in
    set_idx_mut a ((.(i).#a75) : (t75 array, _) idx_mut) next_el.#a75;
    mark_test_run 762;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 762 failed %d %d" size i;
    (* .#b75 *)
    let el = #{ el with b75 = next_el.#b75 } in
    set_idx_mut a ((.(i).#b75) : (t75 array, _) idx_mut) next_el.#b75;
    mark_test_run 763;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 763 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a75.#a23 *)
    let el = #{ el with a75 = #{ el.#a75 with a23 = next_el.#a75.#a23 } } in
    set_idx_mut a ((.(i).#a75.#a23) : (t75 array, _) idx_mut) next_el.#a75.#a23;
    mark_test_run 764;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 764 failed %d %d" size i;
    (* .#a75.#b23 *)
    let el = #{ el with a75 = #{ el.#a75 with b23 = next_el.#a75.#b23 } } in
    set_idx_mut a ((.(i).#a75.#b23) : (t75 array, _) idx_mut) next_el.#a75.#b23;
    mark_test_run 765;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 765 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t76 = #{ #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a76 = a761; b76 = b761 } : t76) (#{ a76 = a762; b76 = b762 } : t76) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a761 a762 && (fun a b -> Float.equal (globalize a) (globalize b)) b761 b762) in
  let mk_value i = (#{ a76 = (#{ a23 = Float.of_int (i + 0); b23 = (i + 1) } : t23); b76 = Float.of_int (i + 2) } : t76) in
  (* Create an array of size [size] *)
  let a : t76 array = makearray_dynamic_local size (#{ a76 = (#{ a23 = 0.; b23 = 1 } : t23); b76 = 2. } : t76) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 766;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 766 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 767;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 767 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a76 *)
    let el = #{ el with a76 = next_el.#a76 } in
    set_idx_mut a ((.(i).#a76) : (t76 array, _) idx_mut) next_el.#a76;
    mark_test_run 768;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 768 failed %d %d" size i;
    (* .#b76 *)
    let el = #{ el with b76 = next_el.#b76 } in
    set_idx_mut a ((.(i).#b76) : (t76 array, _) idx_mut) next_el.#b76;
    mark_test_run 769;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 769 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a76.#a23 *)
    let el = #{ el with a76 = #{ el.#a76 with a23 = next_el.#a76.#a23 } } in
    set_idx_mut a ((.(i).#a76.#a23) : (t76 array, _) idx_mut) next_el.#a76.#a23;
    mark_test_run 770;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 770 failed %d %d" size i;
    (* .#a76.#b23 *)
    let el = #{ el with a76 = #{ el.#a76 with b23 = next_el.#a76.#b23 } } in
    set_idx_mut a ((.(i).#a76.#b23) : (t76 array, _) idx_mut) next_el.#a76.#b23;
    mark_test_run 771;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 771 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t77 = #{ #{ float; float } }   *)
  (************************************)
  let eq = (fun (#{ a77 = a771 } : t77) (#{ a77 = a772 } : t77) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a771 a772) in
  let mk_value i = (#{ a77 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25) } : t77) in
  (* Create an array of size [size] *)
  let a : t77 array = makearray_dynamic_local size (#{ a77 = (#{ a25 = 0.; b25 = 1. } : t25) } : t77) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 772;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 772 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 773;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 773 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a77 *)
    let el = #{ el with a77 = next_el.#a77 } in
    set_idx_mut a ((.(i).#a77) : (t77 array, _) idx_mut) next_el.#a77;
    mark_test_run 774;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 774 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a77.#a25 *)
    let el = #{ el with a77 = #{ el.#a77 with a25 = next_el.#a77.#a25 } } in
    set_idx_mut a ((.(i).#a77.#a25) : (t77 array, _) idx_mut) next_el.#a77.#a25;
    mark_test_run 775;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 775 failed %d %d" size i;
    (* .#a77.#b25 *)
    let el = #{ el with a77 = #{ el.#a77 with b25 = next_el.#a77.#b25 } } in
    set_idx_mut a ((.(i).#a77.#b25) : (t77 array, _) idx_mut) next_el.#a77.#b25;
    mark_test_run 776;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 776 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t78 = #{ #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun (#{ a78 = a781; b78 = b781 } : t78) (#{ a78 = a782; b78 = b782 } : t78) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a781 a782 && (fun a b -> Int.equal a b) b781 b782) in
  let mk_value i = (#{ a78 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25); b78 = (i + 2) } : t78) in
  (* Create an array of size [size] *)
  let a : t78 array = makearray_dynamic_local size (#{ a78 = (#{ a25 = 0.; b25 = 1. } : t25); b78 = 2 } : t78) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 777;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 777 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 778;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 778 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a78 *)
    let el = #{ el with a78 = next_el.#a78 } in
    set_idx_mut a ((.(i).#a78) : (t78 array, _) idx_mut) next_el.#a78;
    mark_test_run 779;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 779 failed %d %d" size i;
    (* .#b78 *)
    let el = #{ el with b78 = next_el.#b78 } in
    set_idx_mut a ((.(i).#b78) : (t78 array, _) idx_mut) next_el.#b78;
    mark_test_run 780;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 780 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a78.#a25 *)
    let el = #{ el with a78 = #{ el.#a78 with a25 = next_el.#a78.#a25 } } in
    set_idx_mut a ((.(i).#a78.#a25) : (t78 array, _) idx_mut) next_el.#a78.#a25;
    mark_test_run 781;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 781 failed %d %d" size i;
    (* .#a78.#b25 *)
    let el = #{ el with a78 = #{ el.#a78 with b25 = next_el.#a78.#b25 } } in
    set_idx_mut a ((.(i).#a78.#b25) : (t78 array, _) idx_mut) next_el.#a78.#b25;
    mark_test_run 782;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 782 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t79 = #{ #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun (#{ a79 = a791; b79 = b791 } : t79) (#{ a79 = a792; b79 = b792 } : t79) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a791 a792 && (fun a b -> Float.equal (globalize a) (globalize b)) b791 b792) in
  let mk_value i = (#{ a79 = (#{ a25 = Float.of_int (i + 0); b25 = Float.of_int (i + 1) } : t25); b79 = Float.of_int (i + 2) } : t79) in
  (* Create an array of size [size] *)
  let a : t79 array = makearray_dynamic_local size (#{ a79 = (#{ a25 = 0.; b25 = 1. } : t25); b79 = 2. } : t79) in
  (* Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 783;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 783 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 784;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 784 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a79 *)
    let el = #{ el with a79 = next_el.#a79 } in
    set_idx_mut a ((.(i).#a79) : (t79 array, _) idx_mut) next_el.#a79;
    mark_test_run 785;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 785 failed %d %d" size i;
    (* .#b79 *)
    let el = #{ el with b79 = next_el.#b79 } in
    set_idx_mut a ((.(i).#b79) : (t79 array, _) idx_mut) next_el.#b79;
    mark_test_run 786;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 786 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a79.#a25 *)
    let el = #{ el with a79 = #{ el.#a79 with a25 = next_el.#a79.#a25 } } in
    set_idx_mut a ((.(i).#a79.#a25) : (t79 array, _) idx_mut) next_el.#a79.#a25;
    mark_test_run 787;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 787 failed %d %d" size i;
    (* .#a79.#b25 *)
    let el = #{ el with a79 = #{ el.#a79 with b25 = next_el.#a79.#b25 } } in
    set_idx_mut a ((.(i).#a79.#b25) : (t79 array, _) idx_mut) next_el.#a79.#b25;
    mark_test_run 788;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 788 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()

(* Test array idx deepening *)
let () =
  (***********)
  (*   int   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int array, _) idx_mut = (.(i)) in
    let shallow : (int array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 789;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 789 failed";
  );

  (*************)
  (*   int64   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64 array, _) idx_mut = (.(i)) in
    let shallow : (int64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 790;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 790 failed";
  );

  (**************)
  (*   int64#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64# array, _) idx_mut = (.(i)) in
    let shallow : (int64# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 791;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 791 failed";
  );

  (**************)
  (*   int32#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int32# array, _) idx_mut = (.(i)) in
    let shallow : (int32# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 792;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 792 failed";
  );

  (******************)
  (*   nativeint#   *)
  (******************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (nativeint# array, _) idx_mut = (.(i)) in
    let shallow : (nativeint# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 793;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 793 failed";
  );

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i)) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 794;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 794 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i).#a0) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 795;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 795 failed";
    let shallow : (t0 array, _) idx_mut = (.(i).#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 796;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 796 failed";
  );

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i)) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 797;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 797 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i).#a1) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 798;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 798 failed";
    let shallow : (t1 array, _) idx_mut = (.(i).#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 799;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 799 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i).#b1) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 800;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 800 failed";
    let shallow : (t1 array, _) idx_mut = (.(i).#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 801;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 801 failed";
  );

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i)) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 802;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 802 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#a2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a2) in
    mark_test_run 803;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 803 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#a2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 804;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 804 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#b2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b2) in
    mark_test_run 805;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 805 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#b2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 806;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 806 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#c2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c2) in
    mark_test_run 807;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 807 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#c2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 808;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 808 failed";
  );

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i)) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 809;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 809 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#a3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a3) in
    mark_test_run 810;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 810 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 811;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 811 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#b3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b3) in
    mark_test_run 812;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 812 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#b3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 813;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 813 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#c3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c3) in
    mark_test_run 814;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 814 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#c3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 815;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 815 failed";
  );

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i)) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 816;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 816 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i).#a4) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a4) in
    mark_test_run 817;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 817 failed";
    let shallow : (t4 array, _) idx_mut = (.(i).#a4) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 818;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 818 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i).#b4) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b4) in
    mark_test_run 819;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 819 failed";
    let shallow : (t4 array, _) idx_mut = (.(i).#b4) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 820;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 820 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i).#c4) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c4) in
    mark_test_run 821;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 821 failed";
    let shallow : (t4 array, _) idx_mut = (.(i).#c4) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 822;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 822 failed";
  );

  (****************************)
  (*   t5 = #{ int; int64 }   *)
  (****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t5 array, _) idx_mut = (.(i)) in
    let shallow : (t5 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 823;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 823 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t5 array, _) idx_mut = (.(i).#a5) in
    let shallow : (t5 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a5) in
    mark_test_run 824;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 824 failed";
    let shallow : (t5 array, _) idx_mut = (.(i).#a5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 825;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 825 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t5 array, _) idx_mut = (.(i).#b5) in
    let shallow : (t5 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b5) in
    mark_test_run 826;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 826 failed";
    let shallow : (t5 array, _) idx_mut = (.(i).#b5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 827;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 827 failed";
  );

  (*****************************)
  (*   t6 = #{ int; int64# }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i)) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 828;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 828 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i).#a6) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a6) in
    mark_test_run 829;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 829 failed";
    let shallow : (t6 array, _) idx_mut = (.(i).#a6) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 830;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 830 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i).#b6) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b6) in
    mark_test_run 831;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 831 failed";
    let shallow : (t6 array, _) idx_mut = (.(i).#b6) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 832;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 832 failed";
  );

  (*****************************)
  (*   t7 = #{ int; int32# }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t7 array, _) idx_mut = (.(i)) in
    let shallow : (t7 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 833;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 833 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t7 array, _) idx_mut = (.(i).#a7) in
    let shallow : (t7 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 834;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 834 failed";
    let shallow : (t7 array, _) idx_mut = (.(i).#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 835;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 835 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t7 array, _) idx_mut = (.(i).#b7) in
    let shallow : (t7 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 836;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 836 failed";
    let shallow : (t7 array, _) idx_mut = (.(i).#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 837;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 837 failed";
  );

  (*************************************)
  (*   t8 = #{ int; int32#; int32# }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i)) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 838;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 838 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i).#a8) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a8) in
    mark_test_run 839;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 839 failed";
    let shallow : (t8 array, _) idx_mut = (.(i).#a8) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 840;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 840 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i).#b8) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b8) in
    mark_test_run 841;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 841 failed";
    let shallow : (t8 array, _) idx_mut = (.(i).#b8) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 842;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 842 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i).#c8) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c8) in
    mark_test_run 843;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 843 failed";
    let shallow : (t8 array, _) idx_mut = (.(i).#c8) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 844;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 844 failed";
  );

  (*********************************)
  (*   t9 = #{ int; nativeint# }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i)) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 845;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 845 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i).#a9) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a9) in
    mark_test_run 846;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 846 failed";
    let shallow : (t9 array, _) idx_mut = (.(i).#a9) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 847;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 847 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i).#b9) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b9) in
    mark_test_run 848;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 848 failed";
    let shallow : (t9 array, _) idx_mut = (.(i).#b9) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 849;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 849 failed";
  );

  (*****************************)
  (*   t10 = #{ int; float }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i)) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 850;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 850 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i).#a10) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 851;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 851 failed";
    let shallow : (t10 array, _) idx_mut = (.(i).#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 852;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 852 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i).#b10) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 853;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 853 failed";
    let shallow : (t10 array, _) idx_mut = (.(i).#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 854;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 854 failed";
  );

  (**********************************)
  (*   t11 = #{ int; float; int }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i)) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 855;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 855 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#a11) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a11) in
    mark_test_run 856;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 856 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#a11) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 857;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 857 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#b11) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b11) in
    mark_test_run 858;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 858 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#b11) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 859;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 859 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#c11) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c11) in
    mark_test_run 860;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 860 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#c11) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 861;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 861 failed";
  );

  (************************************)
  (*   t12 = #{ int; float; float }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i)) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 862;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 862 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#a12) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a12) in
    mark_test_run 863;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 863 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#a12) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 864;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 864 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#b12) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b12) in
    mark_test_run 865;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 865 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#b12) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 866;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 866 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#c12) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c12) in
    mark_test_run 867;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 867 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#c12) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 868;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 868 failed";
  );

  (********************************)
  (*   t13 = #{ int; #{ int } }   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i)) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 869;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 869 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#a13) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a13) in
    mark_test_run 870;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 870 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#a13) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 871;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 871 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#b13) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b13) in
    mark_test_run 872;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 872 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 873;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 873 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#b13.#a0) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b13.#a0) in
    mark_test_run 874;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 874 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 875;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 875 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 876;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 876 failed";
  );

  (*************************************)
  (*   t14 = #{ int; #{ int; int } }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i)) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 877;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 877 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i).#a14) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a14) in
    mark_test_run 878;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 878 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#a14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 879;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 879 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i).#b14) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b14) in
    mark_test_run 880;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 880 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#b14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 881;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 881 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i).#b14.#a1) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b14.#a1) in
    mark_test_run 882;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 882 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#b14) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 883;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 883 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#b14.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 884;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 884 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i).#b14.#b1) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b14.#b1) in
    mark_test_run 885;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 885 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#b14) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 886;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 886 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#b14.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 887;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 887 failed";
  );

  (****************************************)
  (*   t15 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i)) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 888;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 888 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#a15) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a15) in
    mark_test_run 889;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 889 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#a15) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 890;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 890 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#b15) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b15) in
    mark_test_run 891;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 891 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 892;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 892 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#b15.#a7) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b15.#a7) in
    mark_test_run 893;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 893 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 894;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 894 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 895;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 895 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#b15.#b7) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b15.#b7) in
    mark_test_run 896;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 896 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 897;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 897 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 898;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 898 failed";
  );

  (***************************************)
  (*   t16 = #{ int; #{ int; float } }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i)) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 899;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 899 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i).#a16) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a16) in
    mark_test_run 900;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 900 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#a16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 901;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 901 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i).#b16) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b16) in
    mark_test_run 902;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 902 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#b16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 903;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 903 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i).#b16.#a10) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b16.#a10) in
    mark_test_run 904;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 904 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#b16) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 905;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 905 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#b16.#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 906;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 906 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i).#b16.#b10) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b16.#b10) in
    mark_test_run 907;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 907 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#b16) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 908;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 908 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#b16.#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 909;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 909 failed";
  );

  (***********************************)
  (*   t18 = #{ int; #{ int32# } }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t18 array, _) idx_mut = (.(i)) in
    let shallow : (t18 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 910;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 910 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t18 array, _) idx_mut = (.(i).#a18) in
    let shallow : (t18 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a18) in
    mark_test_run 911;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 911 failed";
    let shallow : (t18 array, _) idx_mut = (.(i).#a18) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 912;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 912 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t18 array, _) idx_mut = (.(i).#b18) in
    let shallow : (t18 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b18) in
    mark_test_run 913;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 913 failed";
    let shallow : (t18 array, _) idx_mut = (.(i).#b18) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 914;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 914 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t18 array, _) idx_mut = (.(i).#b18.#a17) in
    let shallow : (t18 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b18.#a17) in
    mark_test_run 915;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 915 failed";
    let shallow : (t18 array, _) idx_mut = (.(i).#b18) in
    let deepened = (.idx_mut(shallow).#a17) in
    mark_test_run 916;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 916 failed";
    let shallow : (t18 array, _) idx_mut = (.(i).#b18.#a17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 917;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 917 failed";
  );

  (*******************************************)
  (*   t20 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i)) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 918;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 918 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i).#a20) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 919;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 919 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 920;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 920 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i).#b20) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 921;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 921 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 922;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 922 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i).#b20.#a19) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b20.#a19) in
    mark_test_run 923;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 923 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#b20) in
    let deepened = (.idx_mut(shallow).#a19) in
    mark_test_run 924;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 924 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#b20.#a19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 925;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 925 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i).#b20.#b19) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b20.#b19) in
    mark_test_run 926;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 926 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#b20) in
    let deepened = (.idx_mut(shallow).#b19) in
    mark_test_run 927;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 927 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#b20.#b19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 928;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 928 failed";
  );

  (**********************************)
  (*   t22 = #{ int; #{ float } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i)) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 929;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 929 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i).#a22) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 930;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 930 failed";
    let shallow : (t22 array, _) idx_mut = (.(i).#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 931;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 931 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i).#b22) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 932;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 932 failed";
    let shallow : (t22 array, _) idx_mut = (.(i).#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 933;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 933 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i).#b22.#a21) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b22.#a21) in
    mark_test_run 934;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 934 failed";
    let shallow : (t22 array, _) idx_mut = (.(i).#b22) in
    let deepened = (.idx_mut(shallow).#a21) in
    mark_test_run 935;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 935 failed";
    let shallow : (t22 array, _) idx_mut = (.(i).#b22.#a21) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 936;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 936 failed";
  );

  (***************************************)
  (*   t24 = #{ int; #{ float; int } }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i)) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 937;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 937 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i).#a24) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a24) in
    mark_test_run 938;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 938 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#a24) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 939;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 939 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i).#b24) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b24) in
    mark_test_run 940;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 940 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#b24) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 941;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 941 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i).#b24.#a23) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b24.#a23) in
    mark_test_run 942;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 942 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#b24) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 943;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 943 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#b24.#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 944;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 944 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i).#b24.#b23) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b24.#b23) in
    mark_test_run 945;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 945 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#b24) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 946;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 946 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#b24.#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 947;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 947 failed";
  );

  (*****************************************)
  (*   t26 = #{ int; #{ float; float } }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i)) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 948;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 948 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#a26) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a26) in
    mark_test_run 949;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 949 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#a26) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 950;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 950 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#b26) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b26) in
    mark_test_run 951;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 951 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#b26) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 952;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 952 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#b26.#a25) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b26.#a25) in
    mark_test_run 953;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 953 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#b26) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 954;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 954 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#b26.#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 955;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 955 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#b26.#b25) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b26.#b25) in
    mark_test_run 956;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 956 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#b26) in
    let deepened = (.idx_mut(shallow).#b25) in
    mark_test_run 957;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 957 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#b26.#b25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 958;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 958 failed";
  );

  (************************)
  (*   t27 = #{ int64 }   *)
  (************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t27 array, _) idx_mut = (.(i)) in
    let shallow : (t27 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 959;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 959 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t27 array, _) idx_mut = (.(i).#a27) in
    let shallow : (t27 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a27) in
    mark_test_run 960;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 960 failed";
    let shallow : (t27 array, _) idx_mut = (.(i).#a27) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 961;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 961 failed";
  );

  (*****************************)
  (*   t28 = #{ int64; int }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i)) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 962;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 962 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i).#a28) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a28) in
    mark_test_run 963;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 963 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#a28) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 964;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 964 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i).#b28) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b28) in
    mark_test_run 965;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 965 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#b28) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 966;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 966 failed";
  );

  (*******************************)
  (*   t29 = #{ int64; int64 }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t29 array, _) idx_mut = (.(i)) in
    let shallow : (t29 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 967;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 967 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t29 array, _) idx_mut = (.(i).#a29) in
    let shallow : (t29 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a29) in
    mark_test_run 968;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 968 failed";
    let shallow : (t29 array, _) idx_mut = (.(i).#a29) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 969;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 969 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t29 array, _) idx_mut = (.(i).#b29) in
    let shallow : (t29 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b29) in
    mark_test_run 970;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 970 failed";
    let shallow : (t29 array, _) idx_mut = (.(i).#b29) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 971;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 971 failed";
  );

  (*******************************)
  (*   t30 = #{ int64; float }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i)) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 972;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 972 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i).#a30) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a30) in
    mark_test_run 973;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 973 failed";
    let shallow : (t30 array, _) idx_mut = (.(i).#a30) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 974;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 974 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i).#b30) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b30) in
    mark_test_run 975;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 975 failed";
    let shallow : (t30 array, _) idx_mut = (.(i).#b30) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 976;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 976 failed";
  );

  (*************************)
  (*   t31 = #{ int64# }   *)
  (*************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t31 array, _) idx_mut = (.(i)) in
    let shallow : (t31 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 977;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 977 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t31 array, _) idx_mut = (.(i).#a31) in
    let shallow : (t31 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a31) in
    mark_test_run 978;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 978 failed";
    let shallow : (t31 array, _) idx_mut = (.(i).#a31) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 979;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 979 failed";
  );

  (*********************************)
  (*   t32 = #{ int64#; int64# }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i)) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 980;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 980 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i).#a32) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a32) in
    mark_test_run 981;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 981 failed";
    let shallow : (t32 array, _) idx_mut = (.(i).#a32) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 982;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 982 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i).#b32) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b32) in
    mark_test_run 983;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 983 failed";
    let shallow : (t32 array, _) idx_mut = (.(i).#b32) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 984;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 984 failed";
  );

  (*********************************)
  (*   t33 = #{ int64#; int32# }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i)) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 985;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 985 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i).#a33) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a33) in
    mark_test_run 986;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 986 failed";
    let shallow : (t33 array, _) idx_mut = (.(i).#a33) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 987;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 987 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i).#b33) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b33) in
    mark_test_run 988;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 988 failed";
    let shallow : (t33 array, _) idx_mut = (.(i).#b33) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 989;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 989 failed";
  );

  (*************************************)
  (*   t34 = #{ int64#; nativeint# }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i)) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 990;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 990 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i).#a34) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a34) in
    mark_test_run 991;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 991 failed";
    let shallow : (t34 array, _) idx_mut = (.(i).#a34) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 992;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 992 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i).#b34) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b34) in
    mark_test_run 993;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 993 failed";
    let shallow : (t34 array, _) idx_mut = (.(i).#b34) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 994;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 994 failed";
  );

  (*************************)
  (*   t17 = #{ int32# }   *)
  (*************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i)) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 995;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 995 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i).#a17) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a17) in
    mark_test_run 996;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 996 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#a17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 997;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 997 failed";
  );

  (*********************************)
  (*   t35 = #{ int32#; int64# }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i)) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 998;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 998 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i).#a35) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a35) in
    mark_test_run 999;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 999 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#a35) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1000;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1000 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i).#b35) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b35) in
    mark_test_run 1001;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1001 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#b35) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1002;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1002 failed";
  );

  (*********************************)
  (*   t19 = #{ int32#; int32# }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i)) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1003;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1003 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i).#a19) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a19) in
    mark_test_run 1004;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1004 failed";
    let shallow : (t19 array, _) idx_mut = (.(i).#a19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1005;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1005 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i).#b19) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b19) in
    mark_test_run 1006;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1006 failed";
    let shallow : (t19 array, _) idx_mut = (.(i).#b19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1007;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1007 failed";
  );

  (*****************************************)
  (*   t36 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i)) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1008;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1008 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#a36) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a36) in
    mark_test_run 1009;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1009 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#a36) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1010;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1010 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#b36) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b36) in
    mark_test_run 1011;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1011 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#b36) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1012;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1012 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#c36) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c36) in
    mark_test_run 1013;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1013 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#c36) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1014;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1014 failed";
  );

  (*************************************)
  (*   t37 = #{ int32#; nativeint# }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i)) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1015;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1015 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i).#a37) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a37) in
    mark_test_run 1016;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1016 failed";
    let shallow : (t37 array, _) idx_mut = (.(i).#a37) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1017;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1017 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i).#b37) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b37) in
    mark_test_run 1018;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1018 failed";
    let shallow : (t37 array, _) idx_mut = (.(i).#b37) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1019;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1019 failed";
  );

  (**************************************)
  (*   t38 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i)) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1020;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1020 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#a38) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a38) in
    mark_test_run 1021;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1021 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#a38) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1022;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1022 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#b38) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b38) in
    mark_test_run 1023;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1023 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1024;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1024 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#b38.#a17) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b38.#a17) in
    mark_test_run 1025;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1025 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38) in
    let deepened = (.idx_mut(shallow).#a17) in
    mark_test_run 1026;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1026 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38.#a17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1027;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1027 failed";
  );

  (**********************************************)
  (*   t39 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i)) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1028;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1028 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#a39) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a39) in
    mark_test_run 1029;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1029 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#a39) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1030;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1030 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#b39) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b39) in
    mark_test_run 1031;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1031 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1032;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1032 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#b39.#a19) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b39.#a19) in
    mark_test_run 1033;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1033 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39) in
    let deepened = (.idx_mut(shallow).#a19) in
    mark_test_run 1034;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1034 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39.#a19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1035;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1035 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#b39.#b19) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b39.#b19) in
    mark_test_run 1036;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1036 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39) in
    let deepened = (.idx_mut(shallow).#b19) in
    mark_test_run 1037;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1037 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39.#b19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1038;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1038 failed";
  );

  (*****************************)
  (*   t40 = #{ nativeint# }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t40 array, _) idx_mut = (.(i)) in
    let shallow : (t40 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1039;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1039 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t40 array, _) idx_mut = (.(i).#a40) in
    let shallow : (t40 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a40) in
    mark_test_run 1040;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1040 failed";
    let shallow : (t40 array, _) idx_mut = (.(i).#a40) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1041;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1041 failed";
  );

  (*************************************)
  (*   t41 = #{ nativeint#; int64# }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i)) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1042;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1042 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i).#a41) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a41) in
    mark_test_run 1043;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1043 failed";
    let shallow : (t41 array, _) idx_mut = (.(i).#a41) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1044;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1044 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i).#b41) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b41) in
    mark_test_run 1045;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1045 failed";
    let shallow : (t41 array, _) idx_mut = (.(i).#b41) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1046;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1046 failed";
  );

  (*************************************)
  (*   t42 = #{ nativeint#; int32# }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i)) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1047;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1047 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i).#a42) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a42) in
    mark_test_run 1048;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1048 failed";
    let shallow : (t42 array, _) idx_mut = (.(i).#a42) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1049;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1049 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i).#b42) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b42) in
    mark_test_run 1050;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1050 failed";
    let shallow : (t42 array, _) idx_mut = (.(i).#b42) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1051;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1051 failed";
  );

  (*****************************************)
  (*   t43 = #{ nativeint#; nativeint# }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i)) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1052;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1052 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i).#a43) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a43) in
    mark_test_run 1053;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1053 failed";
    let shallow : (t43 array, _) idx_mut = (.(i).#a43) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1054;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1054 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i).#b43) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b43) in
    mark_test_run 1055;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1055 failed";
    let shallow : (t43 array, _) idx_mut = (.(i).#b43) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1056;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1056 failed";
  );

  (*****************************)
  (*   t23 = #{ float; int }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i)) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1057;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1057 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i).#a23) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 1058;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1058 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1059;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1059 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i).#b23) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 1060;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1060 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1061;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1061 failed";
  );

  (**********************************)
  (*   t44 = #{ float; int; int }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i)) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1062;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1062 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i).#a44) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a44) in
    mark_test_run 1063;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1063 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#a44) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1064;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1064 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i).#b44) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b44) in
    mark_test_run 1065;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1065 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#b44) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1066;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1066 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i).#c44) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c44) in
    mark_test_run 1067;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1067 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#c44) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1068;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1068 failed";
  );

  (************************************)
  (*   t45 = #{ float; int; float }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i)) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1069;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1069 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#a45) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a45) in
    mark_test_run 1070;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1070 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#a45) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1071;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1071 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#b45) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b45) in
    mark_test_run 1072;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1072 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#b45) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1073;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1073 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#c45) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c45) in
    mark_test_run 1074;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1074 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#c45) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1075;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1075 failed";
  );

  (*******************************)
  (*   t46 = #{ float; int64 }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i)) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1076;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1076 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i).#a46) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a46) in
    mark_test_run 1077;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1077 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#a46) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1078;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1078 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i).#b46) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b46) in
    mark_test_run 1079;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1079 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#b46) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1080;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1080 failed";
  );

  (*******************************)
  (*   t25 = #{ float; float }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t25 array, _) idx_mut = (.(i)) in
    let shallow : (t25 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1081;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1081 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t25 array, _) idx_mut = (.(i).#a25) in
    let shallow : (t25 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 1082;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1082 failed";
    let shallow : (t25 array, _) idx_mut = (.(i).#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1083;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1083 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t25 array, _) idx_mut = (.(i).#b25) in
    let shallow : (t25 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b25) in
    mark_test_run 1084;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1084 failed";
    let shallow : (t25 array, _) idx_mut = (.(i).#b25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1085;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1085 failed";
  );

  (************************************)
  (*   t47 = #{ float; float; int }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i)) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1086;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1086 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#a47) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a47) in
    mark_test_run 1087;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1087 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#a47) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1088;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1088 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#b47) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b47) in
    mark_test_run 1089;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1089 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#b47) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1090;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1090 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#c47) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c47) in
    mark_test_run 1091;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1091 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#c47) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1092;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1092 failed";
  );

  (**************************************)
  (*   t48 = #{ float; float; float }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t48 array, _) idx_mut = (.(i)) in
    let shallow : (t48 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1093;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1093 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t48 array, _) idx_mut = (.(i).#a48) in
    let shallow : (t48 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a48) in
    mark_test_run 1094;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1094 failed";
    let shallow : (t48 array, _) idx_mut = (.(i).#a48) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1095;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1095 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t48 array, _) idx_mut = (.(i).#b48) in
    let shallow : (t48 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b48) in
    mark_test_run 1096;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1096 failed";
    let shallow : (t48 array, _) idx_mut = (.(i).#b48) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1097;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1097 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t48 array, _) idx_mut = (.(i).#c48) in
    let shallow : (t48 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c48) in
    mark_test_run 1098;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1098 failed";
    let shallow : (t48 array, _) idx_mut = (.(i).#c48) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1099;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1099 failed";
  );

  (**********************************)
  (*   t49 = #{ float; #{ int } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t49 array, _) idx_mut = (.(i)) in
    let shallow : (t49 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1100;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1100 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t49 array, _) idx_mut = (.(i).#a49) in
    let shallow : (t49 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a49) in
    mark_test_run 1101;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1101 failed";
    let shallow : (t49 array, _) idx_mut = (.(i).#a49) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1102;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1102 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t49 array, _) idx_mut = (.(i).#b49) in
    let shallow : (t49 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b49) in
    mark_test_run 1103;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1103 failed";
    let shallow : (t49 array, _) idx_mut = (.(i).#b49) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1104;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1104 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t49 array, _) idx_mut = (.(i).#b49.#a0) in
    let shallow : (t49 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b49.#a0) in
    mark_test_run 1105;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1105 failed";
    let shallow : (t49 array, _) idx_mut = (.(i).#b49) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1106;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1106 failed";
    let shallow : (t49 array, _) idx_mut = (.(i).#b49.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1107;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1107 failed";
  );

  (***************************************)
  (*   t50 = #{ float; #{ int; int } }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i)) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1108;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1108 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#a50) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a50) in
    mark_test_run 1109;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1109 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#a50) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1110;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1110 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#b50) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b50) in
    mark_test_run 1111;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1111 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1112;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1112 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#b50.#a1) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b50.#a1) in
    mark_test_run 1113;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1113 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1114;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1114 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1115;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1115 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#b50.#b1) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b50.#b1) in
    mark_test_run 1116;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1116 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1117;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1117 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1118;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1118 failed";
  );

  (*****************************************)
  (*   t51 = #{ float; #{ int; float } }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i)) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1119;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1119 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#a51) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a51) in
    mark_test_run 1120;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1120 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#a51) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1121;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1121 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#b51) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b51) in
    mark_test_run 1122;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1122 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#b51) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1123;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1123 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#b51.#a10) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b51.#a10) in
    mark_test_run 1124;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1124 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#b51) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 1125;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1125 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#b51.#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1126;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1126 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#b51.#b10) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b51.#b10) in
    mark_test_run 1127;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1127 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#b51) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 1128;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1128 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#b51.#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1129;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1129 failed";
  );

  (************************************)
  (*   t52 = #{ float; #{ float } }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i)) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1130;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1130 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#a52) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a52) in
    mark_test_run 1131;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1131 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#a52) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1132;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1132 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#b52) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b52) in
    mark_test_run 1133;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1133 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#b52) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1134;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1134 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#b52.#a21) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b52.#a21) in
    mark_test_run 1135;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1135 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#b52) in
    let deepened = (.idx_mut(shallow).#a21) in
    mark_test_run 1136;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1136 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#b52.#a21) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1137;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1137 failed";
  );

  (*****************************************)
  (*   t53 = #{ float; #{ float; int } }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i)) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1138;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1138 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#a53) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a53) in
    mark_test_run 1139;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1139 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#a53) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1140;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1140 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#b53) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b53) in
    mark_test_run 1141;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1141 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#b53) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1142;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1142 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#b53.#a23) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b53.#a23) in
    mark_test_run 1143;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1143 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#b53) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 1144;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1144 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#b53.#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1145;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1145 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#b53.#b23) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b53.#b23) in
    mark_test_run 1146;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1146 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#b53) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 1147;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1147 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#b53.#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1148;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1148 failed";
  );

  (*******************************************)
  (*   t54 = #{ float; #{ float; float } }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i)) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1149;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1149 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#a54) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a54) in
    mark_test_run 1150;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1150 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#a54) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1151;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1151 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#b54) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b54) in
    mark_test_run 1152;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1152 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#b54) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1153;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1153 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#b54.#a25) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b54.#a25) in
    mark_test_run 1154;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1154 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#b54) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 1155;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1155 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#b54.#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1156;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1156 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#b54.#b25) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b54.#b25) in
    mark_test_run 1157;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1157 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#b54) in
    let deepened = (.idx_mut(shallow).#b25) in
    mark_test_run 1158;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1158 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#b54.#b25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1159;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1159 failed";
  );

  (***************************)
  (*   t55 = #{ #{ int } }   *)
  (***************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i)) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1160;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1160 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i).#a55) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a55) in
    mark_test_run 1161;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1161 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1162;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1162 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i).#a55.#a0) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a55.#a0) in
    mark_test_run 1163;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1163 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1164;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1164 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1165;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1165 failed";
  );

  (********************************)
  (*   t56 = #{ #{ int }; int }   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i)) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1166;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1166 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i).#a56) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a56) in
    mark_test_run 1167;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1167 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#a56) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1168;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1168 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i).#b56) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b56) in
    mark_test_run 1169;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1169 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#b56) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1170;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1170 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i).#a56.#a0) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a56.#a0) in
    mark_test_run 1171;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1171 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#a56) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1172;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1172 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#a56.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1173;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1173 failed";
  );

  (***********************************)
  (*   t57 = #{ #{ int }; int32# }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i)) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1174;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1174 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i).#a57) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a57) in
    mark_test_run 1175;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1175 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#a57) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1176;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1176 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i).#b57) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b57) in
    mark_test_run 1177;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1177 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#b57) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1178;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1178 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i).#a57.#a0) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a57.#a0) in
    mark_test_run 1179;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1179 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#a57) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1180;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1180 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#a57.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1181;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1181 failed";
  );

  (**********************************)
  (*   t58 = #{ #{ int }; float }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i)) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1182;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1182 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i).#a58) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a58) in
    mark_test_run 1183;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1183 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1184;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1184 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i).#b58) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b58) in
    mark_test_run 1185;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1185 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#b58) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1186;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1186 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i).#a58.#a0) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a58.#a0) in
    mark_test_run 1187;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1187 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1188;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1188 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1189;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1189 failed";
  );

  (********************************)
  (*   t59 = #{ #{ int; int } }   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i)) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1190;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1190 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#a59) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a59) in
    mark_test_run 1191;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1191 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1192;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1192 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#a59.#a1) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a59.#a1) in
    mark_test_run 1193;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1193 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1194;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1194 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1195;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1195 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#a59.#b1) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a59.#b1) in
    mark_test_run 1196;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1196 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1197;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1197 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1198;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1198 failed";
  );

  (*************************************)
  (*   t60 = #{ #{ int; int }; int }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i)) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1199;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1199 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#a60) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a60) in
    mark_test_run 1200;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1200 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1201;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1201 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#b60) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b60) in
    mark_test_run 1202;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1202 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#b60) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1203;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1203 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#a60.#a1) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a60.#a1) in
    mark_test_run 1204;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1204 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1205;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1205 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1206;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1206 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#a60.#b1) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a60.#b1) in
    mark_test_run 1207;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1207 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1208;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1208 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1209;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1209 failed";
  );

  (****************************************)
  (*   t61 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i)) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1210;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1210 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#a61) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a61) in
    mark_test_run 1211;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1211 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1212;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1212 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#b61) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b61) in
    mark_test_run 1213;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1213 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#b61) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1214;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1214 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#a61.#a1) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a61.#a1) in
    mark_test_run 1215;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1215 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1216;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1216 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1217;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1217 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#a61.#b1) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a61.#b1) in
    mark_test_run 1218;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1218 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1219;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1219 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1220;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1220 failed";
  );

  (***************************************)
  (*   t62 = #{ #{ int; int }; float }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i)) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1221;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1221 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#a62) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a62) in
    mark_test_run 1222;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1222 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1223;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1223 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#b62) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b62) in
    mark_test_run 1224;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1224 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#b62) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1225;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1225 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#a62.#a1) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a62.#a1) in
    mark_test_run 1226;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1226 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1227;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1227 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1228;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1228 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#a62.#b1) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a62.#b1) in
    mark_test_run 1229;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1229 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1230;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1230 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1231;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1231 failed";
  );

  (***********************************)
  (*   t63 = #{ #{ int; int32# } }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i)) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1232;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1232 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#a63) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a63) in
    mark_test_run 1233;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1233 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1234;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1234 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#a63.#a7) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a63.#a7) in
    mark_test_run 1235;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1235 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 1236;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1236 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1237;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1237 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#a63.#b7) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a63.#b7) in
    mark_test_run 1238;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1238 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 1239;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1239 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1240;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1240 failed";
  );

  (*******************************************)
  (*   t64 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i)) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1241;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1241 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#a64) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a64) in
    mark_test_run 1242;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1242 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1243;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1243 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#b64) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b64) in
    mark_test_run 1244;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1244 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#b64) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1245;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1245 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#a64.#a7) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a64.#a7) in
    mark_test_run 1246;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1246 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 1247;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1247 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1248;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1248 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#a64.#b7) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a64.#b7) in
    mark_test_run 1249;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1249 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 1250;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1250 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1251;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1251 failed";
  );

  (**********************************)
  (*   t65 = #{ #{ int; float } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i)) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1252;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1252 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i).#a65) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a65) in
    mark_test_run 1253;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1253 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1254;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1254 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i).#a65.#a10) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a65.#a10) in
    mark_test_run 1255;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1255 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 1256;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1256 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65.#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1257;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1257 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i).#a65.#b10) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a65.#b10) in
    mark_test_run 1258;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1258 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 1259;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1259 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65.#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1260;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1260 failed";
  );

  (***************************************)
  (*   t66 = #{ #{ int; float }; int }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i)) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1261;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1261 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#a66) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a66) in
    mark_test_run 1262;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1262 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1263;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1263 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#b66) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b66) in
    mark_test_run 1264;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1264 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#b66) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1265;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1265 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#a66.#a10) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a66.#a10) in
    mark_test_run 1266;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1266 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 1267;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1267 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66.#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1268;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1268 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#a66.#b10) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a66.#b10) in
    mark_test_run 1269;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1269 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 1270;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1270 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66.#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1271;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1271 failed";
  );

  (*****************************************)
  (*   t67 = #{ #{ int; float }; float }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i)) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1272;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1272 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#a67) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a67) in
    mark_test_run 1273;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1273 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1274;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1274 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#b67) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b67) in
    mark_test_run 1275;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1275 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#b67) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1276;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1276 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#a67.#a10) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a67.#a10) in
    mark_test_run 1277;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1277 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 1278;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1278 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67.#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1279;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1279 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#a67.#b10) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a67.#b10) in
    mark_test_run 1280;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1280 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 1281;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1281 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67.#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1282;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1282 failed";
  );

  (******************************)
  (*   t68 = #{ #{ int32# } }   *)
  (******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t68 array, _) idx_mut = (.(i)) in
    let shallow : (t68 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1283;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1283 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t68 array, _) idx_mut = (.(i).#a68) in
    let shallow : (t68 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a68) in
    mark_test_run 1284;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1284 failed";
    let shallow : (t68 array, _) idx_mut = (.(i).#a68) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1285;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1285 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t68 array, _) idx_mut = (.(i).#a68.#a17) in
    let shallow : (t68 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a68.#a17) in
    mark_test_run 1286;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1286 failed";
    let shallow : (t68 array, _) idx_mut = (.(i).#a68) in
    let deepened = (.idx_mut(shallow).#a17) in
    mark_test_run 1287;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1287 failed";
    let shallow : (t68 array, _) idx_mut = (.(i).#a68.#a17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1288;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1288 failed";
  );

  (**************************************)
  (*   t69 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t69 array, _) idx_mut = (.(i)) in
    let shallow : (t69 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1289;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1289 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t69 array, _) idx_mut = (.(i).#a69) in
    let shallow : (t69 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a69) in
    mark_test_run 1290;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1290 failed";
    let shallow : (t69 array, _) idx_mut = (.(i).#a69) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1291;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1291 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t69 array, _) idx_mut = (.(i).#b69) in
    let shallow : (t69 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b69) in
    mark_test_run 1292;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1292 failed";
    let shallow : (t69 array, _) idx_mut = (.(i).#b69) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1293;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1293 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t69 array, _) idx_mut = (.(i).#a69.#a17) in
    let shallow : (t69 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a69.#a17) in
    mark_test_run 1294;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1294 failed";
    let shallow : (t69 array, _) idx_mut = (.(i).#a69) in
    let deepened = (.idx_mut(shallow).#a17) in
    mark_test_run 1295;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1295 failed";
    let shallow : (t69 array, _) idx_mut = (.(i).#a69.#a17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1296;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1296 failed";
  );

  (**************************************)
  (*   t70 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t70 array, _) idx_mut = (.(i)) in
    let shallow : (t70 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1297;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1297 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t70 array, _) idx_mut = (.(i).#a70) in
    let shallow : (t70 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a70) in
    mark_test_run 1298;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1298 failed";
    let shallow : (t70 array, _) idx_mut = (.(i).#a70) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1299;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1299 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t70 array, _) idx_mut = (.(i).#a70.#a19) in
    let shallow : (t70 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a70.#a19) in
    mark_test_run 1300;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1300 failed";
    let shallow : (t70 array, _) idx_mut = (.(i).#a70) in
    let deepened = (.idx_mut(shallow).#a19) in
    mark_test_run 1301;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1301 failed";
    let shallow : (t70 array, _) idx_mut = (.(i).#a70.#a19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1302;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1302 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t70 array, _) idx_mut = (.(i).#a70.#b19) in
    let shallow : (t70 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a70.#b19) in
    mark_test_run 1303;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1303 failed";
    let shallow : (t70 array, _) idx_mut = (.(i).#a70) in
    let deepened = (.idx_mut(shallow).#b19) in
    mark_test_run 1304;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1304 failed";
    let shallow : (t70 array, _) idx_mut = (.(i).#a70.#b19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1305;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1305 failed";
  );

  (**********************************************)
  (*   t71 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t71 array, _) idx_mut = (.(i)) in
    let shallow : (t71 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1306;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1306 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t71 array, _) idx_mut = (.(i).#a71) in
    let shallow : (t71 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a71) in
    mark_test_run 1307;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1307 failed";
    let shallow : (t71 array, _) idx_mut = (.(i).#a71) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1308;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1308 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t71 array, _) idx_mut = (.(i).#b71) in
    let shallow : (t71 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b71) in
    mark_test_run 1309;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1309 failed";
    let shallow : (t71 array, _) idx_mut = (.(i).#b71) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1310;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1310 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t71 array, _) idx_mut = (.(i).#a71.#a19) in
    let shallow : (t71 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a71.#a19) in
    mark_test_run 1311;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1311 failed";
    let shallow : (t71 array, _) idx_mut = (.(i).#a71) in
    let deepened = (.idx_mut(shallow).#a19) in
    mark_test_run 1312;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1312 failed";
    let shallow : (t71 array, _) idx_mut = (.(i).#a71.#a19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1313;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1313 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t71 array, _) idx_mut = (.(i).#a71.#b19) in
    let shallow : (t71 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a71.#b19) in
    mark_test_run 1314;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1314 failed";
    let shallow : (t71 array, _) idx_mut = (.(i).#a71) in
    let deepened = (.idx_mut(shallow).#b19) in
    mark_test_run 1315;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1315 failed";
    let shallow : (t71 array, _) idx_mut = (.(i).#a71.#b19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1316;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1316 failed";
  );

  (**********************************)
  (*   t72 = #{ #{ float }; int }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t72 array, _) idx_mut = (.(i)) in
    let shallow : (t72 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1317;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1317 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t72 array, _) idx_mut = (.(i).#a72) in
    let shallow : (t72 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a72) in
    mark_test_run 1318;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1318 failed";
    let shallow : (t72 array, _) idx_mut = (.(i).#a72) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1319;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1319 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t72 array, _) idx_mut = (.(i).#b72) in
    let shallow : (t72 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b72) in
    mark_test_run 1320;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1320 failed";
    let shallow : (t72 array, _) idx_mut = (.(i).#b72) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1321;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1321 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t72 array, _) idx_mut = (.(i).#a72.#a21) in
    let shallow : (t72 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a72.#a21) in
    mark_test_run 1322;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1322 failed";
    let shallow : (t72 array, _) idx_mut = (.(i).#a72) in
    let deepened = (.idx_mut(shallow).#a21) in
    mark_test_run 1323;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1323 failed";
    let shallow : (t72 array, _) idx_mut = (.(i).#a72.#a21) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1324;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1324 failed";
  );

  (************************************)
  (*   t73 = #{ #{ float }; float }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t73 array, _) idx_mut = (.(i)) in
    let shallow : (t73 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1325;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1325 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t73 array, _) idx_mut = (.(i).#a73) in
    let shallow : (t73 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a73) in
    mark_test_run 1326;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1326 failed";
    let shallow : (t73 array, _) idx_mut = (.(i).#a73) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1327;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1327 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t73 array, _) idx_mut = (.(i).#b73) in
    let shallow : (t73 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b73) in
    mark_test_run 1328;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1328 failed";
    let shallow : (t73 array, _) idx_mut = (.(i).#b73) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1329;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1329 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t73 array, _) idx_mut = (.(i).#a73.#a21) in
    let shallow : (t73 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a73.#a21) in
    mark_test_run 1330;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1330 failed";
    let shallow : (t73 array, _) idx_mut = (.(i).#a73) in
    let deepened = (.idx_mut(shallow).#a21) in
    mark_test_run 1331;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1331 failed";
    let shallow : (t73 array, _) idx_mut = (.(i).#a73.#a21) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1332;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1332 failed";
  );

  (**********************************)
  (*   t74 = #{ #{ float; int } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t74 array, _) idx_mut = (.(i)) in
    let shallow : (t74 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1333;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1333 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t74 array, _) idx_mut = (.(i).#a74) in
    let shallow : (t74 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a74) in
    mark_test_run 1334;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1334 failed";
    let shallow : (t74 array, _) idx_mut = (.(i).#a74) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1335;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1335 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t74 array, _) idx_mut = (.(i).#a74.#a23) in
    let shallow : (t74 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a74.#a23) in
    mark_test_run 1336;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1336 failed";
    let shallow : (t74 array, _) idx_mut = (.(i).#a74) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 1337;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1337 failed";
    let shallow : (t74 array, _) idx_mut = (.(i).#a74.#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1338;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1338 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t74 array, _) idx_mut = (.(i).#a74.#b23) in
    let shallow : (t74 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a74.#b23) in
    mark_test_run 1339;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1339 failed";
    let shallow : (t74 array, _) idx_mut = (.(i).#a74) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 1340;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1340 failed";
    let shallow : (t74 array, _) idx_mut = (.(i).#a74.#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1341;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1341 failed";
  );

  (***************************************)
  (*   t75 = #{ #{ float; int }; int }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t75 array, _) idx_mut = (.(i)) in
    let shallow : (t75 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1342;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1342 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t75 array, _) idx_mut = (.(i).#a75) in
    let shallow : (t75 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a75) in
    mark_test_run 1343;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1343 failed";
    let shallow : (t75 array, _) idx_mut = (.(i).#a75) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1344;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1344 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t75 array, _) idx_mut = (.(i).#b75) in
    let shallow : (t75 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b75) in
    mark_test_run 1345;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1345 failed";
    let shallow : (t75 array, _) idx_mut = (.(i).#b75) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1346;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1346 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t75 array, _) idx_mut = (.(i).#a75.#a23) in
    let shallow : (t75 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a75.#a23) in
    mark_test_run 1347;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1347 failed";
    let shallow : (t75 array, _) idx_mut = (.(i).#a75) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 1348;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1348 failed";
    let shallow : (t75 array, _) idx_mut = (.(i).#a75.#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1349;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1349 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t75 array, _) idx_mut = (.(i).#a75.#b23) in
    let shallow : (t75 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a75.#b23) in
    mark_test_run 1350;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1350 failed";
    let shallow : (t75 array, _) idx_mut = (.(i).#a75) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 1351;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1351 failed";
    let shallow : (t75 array, _) idx_mut = (.(i).#a75.#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1352;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1352 failed";
  );

  (*****************************************)
  (*   t76 = #{ #{ float; int }; float }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t76 array, _) idx_mut = (.(i)) in
    let shallow : (t76 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1353;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1353 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t76 array, _) idx_mut = (.(i).#a76) in
    let shallow : (t76 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a76) in
    mark_test_run 1354;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1354 failed";
    let shallow : (t76 array, _) idx_mut = (.(i).#a76) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1355;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1355 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t76 array, _) idx_mut = (.(i).#b76) in
    let shallow : (t76 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b76) in
    mark_test_run 1356;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1356 failed";
    let shallow : (t76 array, _) idx_mut = (.(i).#b76) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1357;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1357 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t76 array, _) idx_mut = (.(i).#a76.#a23) in
    let shallow : (t76 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a76.#a23) in
    mark_test_run 1358;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1358 failed";
    let shallow : (t76 array, _) idx_mut = (.(i).#a76) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 1359;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1359 failed";
    let shallow : (t76 array, _) idx_mut = (.(i).#a76.#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1360;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1360 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t76 array, _) idx_mut = (.(i).#a76.#b23) in
    let shallow : (t76 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a76.#b23) in
    mark_test_run 1361;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1361 failed";
    let shallow : (t76 array, _) idx_mut = (.(i).#a76) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 1362;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1362 failed";
    let shallow : (t76 array, _) idx_mut = (.(i).#a76.#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1363;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1363 failed";
  );

  (************************************)
  (*   t77 = #{ #{ float; float } }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t77 array, _) idx_mut = (.(i)) in
    let shallow : (t77 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1364;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1364 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t77 array, _) idx_mut = (.(i).#a77) in
    let shallow : (t77 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a77) in
    mark_test_run 1365;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1365 failed";
    let shallow : (t77 array, _) idx_mut = (.(i).#a77) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1366;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1366 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t77 array, _) idx_mut = (.(i).#a77.#a25) in
    let shallow : (t77 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a77.#a25) in
    mark_test_run 1367;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1367 failed";
    let shallow : (t77 array, _) idx_mut = (.(i).#a77) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 1368;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1368 failed";
    let shallow : (t77 array, _) idx_mut = (.(i).#a77.#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1369;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1369 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t77 array, _) idx_mut = (.(i).#a77.#b25) in
    let shallow : (t77 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a77.#b25) in
    mark_test_run 1370;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1370 failed";
    let shallow : (t77 array, _) idx_mut = (.(i).#a77) in
    let deepened = (.idx_mut(shallow).#b25) in
    mark_test_run 1371;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1371 failed";
    let shallow : (t77 array, _) idx_mut = (.(i).#a77.#b25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1372;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1372 failed";
  );

  (*****************************************)
  (*   t78 = #{ #{ float; float }; int }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t78 array, _) idx_mut = (.(i)) in
    let shallow : (t78 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1373;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1373 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t78 array, _) idx_mut = (.(i).#a78) in
    let shallow : (t78 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a78) in
    mark_test_run 1374;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1374 failed";
    let shallow : (t78 array, _) idx_mut = (.(i).#a78) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1375;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1375 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t78 array, _) idx_mut = (.(i).#b78) in
    let shallow : (t78 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b78) in
    mark_test_run 1376;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1376 failed";
    let shallow : (t78 array, _) idx_mut = (.(i).#b78) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1377;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1377 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t78 array, _) idx_mut = (.(i).#a78.#a25) in
    let shallow : (t78 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a78.#a25) in
    mark_test_run 1378;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1378 failed";
    let shallow : (t78 array, _) idx_mut = (.(i).#a78) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 1379;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1379 failed";
    let shallow : (t78 array, _) idx_mut = (.(i).#a78.#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1380;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1380 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t78 array, _) idx_mut = (.(i).#a78.#b25) in
    let shallow : (t78 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a78.#b25) in
    mark_test_run 1381;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1381 failed";
    let shallow : (t78 array, _) idx_mut = (.(i).#a78) in
    let deepened = (.idx_mut(shallow).#b25) in
    mark_test_run 1382;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1382 failed";
    let shallow : (t78 array, _) idx_mut = (.(i).#a78.#b25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1383;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1383 failed";
  );

  (*******************************************)
  (*   t79 = #{ #{ float; float }; float }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t79 array, _) idx_mut = (.(i)) in
    let shallow : (t79 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1384;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1384 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t79 array, _) idx_mut = (.(i).#a79) in
    let shallow : (t79 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a79) in
    mark_test_run 1385;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1385 failed";
    let shallow : (t79 array, _) idx_mut = (.(i).#a79) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1386;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1386 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t79 array, _) idx_mut = (.(i).#b79) in
    let shallow : (t79 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b79) in
    mark_test_run 1387;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1387 failed";
    let shallow : (t79 array, _) idx_mut = (.(i).#b79) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1388;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1388 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t79 array, _) idx_mut = (.(i).#a79.#a25) in
    let shallow : (t79 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a79.#a25) in
    mark_test_run 1389;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1389 failed";
    let shallow : (t79 array, _) idx_mut = (.(i).#a79) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 1390;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1390 failed";
    let shallow : (t79 array, _) idx_mut = (.(i).#a79.#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1391;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1391 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t79 array, _) idx_mut = (.(i).#a79.#b25) in
    let shallow : (t79 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a79.#b25) in
    mark_test_run 1392;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1392 failed";
    let shallow : (t79 array, _) idx_mut = (.(i).#a79) in
    let deepened = (.idx_mut(shallow).#b25) in
    mark_test_run 1393;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1393 failed";
    let shallow : (t79 array, _) idx_mut = (.(i).#a79.#b25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1394;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1394 failed";
  );

  ()

(* Test record idx get and set *)
let () =
  (*********************)
  (*   t80 = { int }   *)
  (*********************)
  let eq = (fun ({ a80 = a801 } : t80) ({ a80 = a802 } : t80) -> (fun a b -> Int.equal a b) a801 a802) in
  let r = ({ a80 = 0 } : t80) in
  (* Paths of depth 0 *)
  let next_r = ({ a80 = 100 } : t80) in
  (* .a80 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a80 = next_r.a80 } in
  set_idx_mut r ((.a80) : (t80, _) idx_mut) next_r.a80;
  mark_test_run 1395;
  let test = eq r expected in
  if not test then failwithf "test 1395 failed";
  mark_test_run 1396;
  let test = sub_eq (get_idx_mut r ((.a80) : (t80, _) idx_mut)) next_r.a80 in
  if not test then failwithf "test 1396 failed";
  (**************************)
  (*   t81 = { int; int }   *)
  (**************************)
  let eq = (fun ({ a81 = a811; b81 = b811 } : t81) ({ a81 = a812; b81 = b812 } : t81) -> (fun a b -> Int.equal a b) a811 a812 && (fun a b -> Int.equal a b) b811 b812) in
  let r = ({ a81 = 0; b81 = 1 } : t81) in
  (* Paths of depth 0 *)
  let next_r = ({ a81 = 100; b81 = 101 } : t81) in
  (* .a81 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a81 = next_r.a81 } in
  set_idx_mut r ((.a81) : (t81, _) idx_mut) next_r.a81;
  mark_test_run 1397;
  let test = eq r expected in
  if not test then failwithf "test 1397 failed";
  mark_test_run 1398;
  let test = sub_eq (get_idx_mut r ((.a81) : (t81, _) idx_mut)) next_r.a81 in
  if not test then failwithf "test 1398 failed";
  let r = ({ a81 = 0; b81 = 1 } : t81) in
  (* Paths of depth 0 *)
  let next_r = ({ a81 = 100; b81 = 101 } : t81) in
  (* .b81 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b81 = next_r.b81 } in
  set_idx_mut r ((.b81) : (t81, _) idx_mut) next_r.b81;
  mark_test_run 1399;
  let test = eq r expected in
  if not test then failwithf "test 1399 failed";
  mark_test_run 1400;
  let test = sub_eq (get_idx_mut r ((.b81) : (t81, _) idx_mut)) next_r.b81 in
  if not test then failwithf "test 1400 failed";
  (*******************************)
  (*   t82 = { int; int; int }   *)
  (*******************************)
  let eq = (fun ({ a82 = a821; b82 = b821; c82 = c821 } : t82) ({ a82 = a822; b82 = b822; c82 = c822 } : t82) -> (fun a b -> Int.equal a b) a821 a822 && (fun a b -> Int.equal a b) b821 b822 && (fun a b -> Int.equal a b) c821 c822) in
  let r = ({ a82 = 0; b82 = 1; c82 = 2 } : t82) in
  (* Paths of depth 0 *)
  let next_r = ({ a82 = 100; b82 = 101; c82 = 102 } : t82) in
  (* .a82 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a82 = next_r.a82 } in
  set_idx_mut r ((.a82) : (t82, _) idx_mut) next_r.a82;
  mark_test_run 1401;
  let test = eq r expected in
  if not test then failwithf "test 1401 failed";
  mark_test_run 1402;
  let test = sub_eq (get_idx_mut r ((.a82) : (t82, _) idx_mut)) next_r.a82 in
  if not test then failwithf "test 1402 failed";
  let r = ({ a82 = 0; b82 = 1; c82 = 2 } : t82) in
  (* Paths of depth 0 *)
  let next_r = ({ a82 = 100; b82 = 101; c82 = 102 } : t82) in
  (* .b82 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b82 = next_r.b82 } in
  set_idx_mut r ((.b82) : (t82, _) idx_mut) next_r.b82;
  mark_test_run 1403;
  let test = eq r expected in
  if not test then failwithf "test 1403 failed";
  mark_test_run 1404;
  let test = sub_eq (get_idx_mut r ((.b82) : (t82, _) idx_mut)) next_r.b82 in
  if not test then failwithf "test 1404 failed";
  let r = ({ a82 = 0; b82 = 1; c82 = 2 } : t82) in
  (* Paths of depth 0 *)
  let next_r = ({ a82 = 100; b82 = 101; c82 = 102 } : t82) in
  (* .c82 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c82 = next_r.c82 } in
  set_idx_mut r ((.c82) : (t82, _) idx_mut) next_r.c82;
  mark_test_run 1405;
  let test = eq r expected in
  if not test then failwithf "test 1405 failed";
  mark_test_run 1406;
  let test = sub_eq (get_idx_mut r ((.c82) : (t82, _) idx_mut)) next_r.c82 in
  if not test then failwithf "test 1406 failed";
  (**********************************)
  (*   t83 = { int; int; int32# }   *)
  (**********************************)
  let eq = (fun ({ a83 = a831; b83 = b831; c83 = c831 } : t83) ({ a83 = a832; b83 = b832; c83 = c832 } : t83) -> (fun a b -> Int.equal a b) a831 a832 && (fun a b -> Int.equal a b) b831 b832 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c831 c832) in
  let r = ({ a83 = 0; b83 = 1; c83 = #2l } : t83) in
  (* Paths of depth 0 *)
  let next_r = ({ a83 = 100; b83 = 101; c83 = #102l } : t83) in
  (* .a83 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a83 = next_r.a83 } in
  set_idx_mut r ((.a83) : (t83, _) idx_mut) next_r.a83;
  mark_test_run 1407;
  let test = eq r expected in
  if not test then failwithf "test 1407 failed";
  mark_test_run 1408;
  let test = sub_eq (get_idx_mut r ((.a83) : (t83, _) idx_mut)) next_r.a83 in
  if not test then failwithf "test 1408 failed";
  let r = ({ a83 = 0; b83 = 1; c83 = #2l } : t83) in
  (* Paths of depth 0 *)
  let next_r = ({ a83 = 100; b83 = 101; c83 = #102l } : t83) in
  (* .b83 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b83 = next_r.b83 } in
  set_idx_mut r ((.b83) : (t83, _) idx_mut) next_r.b83;
  mark_test_run 1409;
  let test = eq r expected in
  if not test then failwithf "test 1409 failed";
  mark_test_run 1410;
  let test = sub_eq (get_idx_mut r ((.b83) : (t83, _) idx_mut)) next_r.b83 in
  if not test then failwithf "test 1410 failed";
  let r = ({ a83 = 0; b83 = 1; c83 = #2l } : t83) in
  (* Paths of depth 0 *)
  let next_r = ({ a83 = 100; b83 = 101; c83 = #102l } : t83) in
  (* .c83 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c83 = next_r.c83 } in
  set_idx_mut r ((.c83) : (t83, _) idx_mut) next_r.c83;
  mark_test_run 1411;
  let test = eq r expected in
  if not test then failwithf "test 1411 failed";
  mark_test_run 1412;
  let test = sub_eq (get_idx_mut r ((.c83) : (t83, _) idx_mut)) next_r.c83 in
  if not test then failwithf "test 1412 failed";
  (*********************************)
  (*   t84 = { int; int; float }   *)
  (*********************************)
  let eq = (fun ({ a84 = a841; b84 = b841; c84 = c841 } : t84) ({ a84 = a842; b84 = b842; c84 = c842 } : t84) -> (fun a b -> Int.equal a b) a841 a842 && (fun a b -> Int.equal a b) b841 b842 && (fun a b -> Float.equal (globalize a) (globalize b)) c841 c842) in
  let r = ({ a84 = 0; b84 = 1; c84 = 2. } : t84) in
  (* Paths of depth 0 *)
  let next_r = ({ a84 = 100; b84 = 101; c84 = 102. } : t84) in
  (* .a84 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a84 = next_r.a84 } in
  set_idx_mut r ((.a84) : (t84, _) idx_mut) next_r.a84;
  mark_test_run 1413;
  let test = eq r expected in
  if not test then failwithf "test 1413 failed";
  mark_test_run 1414;
  let test = sub_eq (get_idx_mut r ((.a84) : (t84, _) idx_mut)) next_r.a84 in
  if not test then failwithf "test 1414 failed";
  let r = ({ a84 = 0; b84 = 1; c84 = 2. } : t84) in
  (* Paths of depth 0 *)
  let next_r = ({ a84 = 100; b84 = 101; c84 = 102. } : t84) in
  (* .b84 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b84 = next_r.b84 } in
  set_idx_mut r ((.b84) : (t84, _) idx_mut) next_r.b84;
  mark_test_run 1415;
  let test = eq r expected in
  if not test then failwithf "test 1415 failed";
  mark_test_run 1416;
  let test = sub_eq (get_idx_mut r ((.b84) : (t84, _) idx_mut)) next_r.b84 in
  if not test then failwithf "test 1416 failed";
  let r = ({ a84 = 0; b84 = 1; c84 = 2. } : t84) in
  (* Paths of depth 0 *)
  let next_r = ({ a84 = 100; b84 = 101; c84 = 102. } : t84) in
  (* .c84 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with c84 = next_r.c84 } in
  set_idx_mut r ((.c84) : (t84, _) idx_mut) next_r.c84;
  mark_test_run 1417;
  let test = eq r expected in
  if not test then failwithf "test 1417 failed";
  mark_test_run 1418;
  let test = sub_eq (get_idx_mut r ((.c84) : (t84, _) idx_mut)) next_r.c84 in
  if not test then failwithf "test 1418 failed";
  (****************************)
  (*   t85 = { int; int64 }   *)
  (****************************)
  let eq = (fun ({ a85 = a851; b85 = b851 } : t85) ({ a85 = a852; b85 = b852 } : t85) -> (fun a b -> Int.equal a b) a851 a852 && (fun a b -> Int64.equal (globalize a) (globalize b)) b851 b852) in
  let r = ({ a85 = 0; b85 = 1L } : t85) in
  (* Paths of depth 0 *)
  let next_r = ({ a85 = 100; b85 = 101L } : t85) in
  (* .a85 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a85 = next_r.a85 } in
  set_idx_mut r ((.a85) : (t85, _) idx_mut) next_r.a85;
  mark_test_run 1419;
  let test = eq r expected in
  if not test then failwithf "test 1419 failed";
  mark_test_run 1420;
  let test = sub_eq (get_idx_mut r ((.a85) : (t85, _) idx_mut)) next_r.a85 in
  if not test then failwithf "test 1420 failed";
  let r = ({ a85 = 0; b85 = 1L } : t85) in
  (* Paths of depth 0 *)
  let next_r = ({ a85 = 100; b85 = 101L } : t85) in
  (* .b85 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b85 = next_r.b85 } in
  set_idx_mut r ((.b85) : (t85, _) idx_mut) next_r.b85;
  mark_test_run 1421;
  let test = eq r expected in
  if not test then failwithf "test 1421 failed";
  mark_test_run 1422;
  let test = sub_eq (get_idx_mut r ((.b85) : (t85, _) idx_mut)) next_r.b85 in
  if not test then failwithf "test 1422 failed";
  (*****************************)
  (*   t86 = { int; int64# }   *)
  (*****************************)
  let eq = (fun ({ a86 = a861; b86 = b861 } : t86) ({ a86 = a862; b86 = b862 } : t86) -> (fun a b -> Int.equal a b) a861 a862 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b861 b862) in
  let r = ({ a86 = 0; b86 = #1L } : t86) in
  (* Paths of depth 0 *)
  let next_r = ({ a86 = 100; b86 = #101L } : t86) in
  (* .a86 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a86 = next_r.a86 } in
  set_idx_mut r ((.a86) : (t86, _) idx_mut) next_r.a86;
  mark_test_run 1423;
  let test = eq r expected in
  if not test then failwithf "test 1423 failed";
  mark_test_run 1424;
  let test = sub_eq (get_idx_mut r ((.a86) : (t86, _) idx_mut)) next_r.a86 in
  if not test then failwithf "test 1424 failed";
  let r = ({ a86 = 0; b86 = #1L } : t86) in
  (* Paths of depth 0 *)
  let next_r = ({ a86 = 100; b86 = #101L } : t86) in
  (* .b86 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b86 = next_r.b86 } in
  set_idx_mut r ((.b86) : (t86, _) idx_mut) next_r.b86;
  mark_test_run 1425;
  let test = eq r expected in
  if not test then failwithf "test 1425 failed";
  mark_test_run 1426;
  let test = sub_eq (get_idx_mut r ((.b86) : (t86, _) idx_mut)) next_r.b86 in
  if not test then failwithf "test 1426 failed";
  (*****************************)
  (*   t87 = { int; int32# }   *)
  (*****************************)
  let eq = (fun ({ a87 = a871; b87 = b871 } : t87) ({ a87 = a872; b87 = b872 } : t87) -> (fun a b -> Int.equal a b) a871 a872 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b871 b872) in
  let r = ({ a87 = 0; b87 = #1l } : t87) in
  (* Paths of depth 0 *)
  let next_r = ({ a87 = 100; b87 = #101l } : t87) in
  (* .a87 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a87 = next_r.a87 } in
  set_idx_mut r ((.a87) : (t87, _) idx_mut) next_r.a87;
  mark_test_run 1427;
  let test = eq r expected in
  if not test then failwithf "test 1427 failed";
  mark_test_run 1428;
  let test = sub_eq (get_idx_mut r ((.a87) : (t87, _) idx_mut)) next_r.a87 in
  if not test then failwithf "test 1428 failed";
  let r = ({ a87 = 0; b87 = #1l } : t87) in
  (* Paths of depth 0 *)
  let next_r = ({ a87 = 100; b87 = #101l } : t87) in
  (* .b87 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b87 = next_r.b87 } in
  set_idx_mut r ((.b87) : (t87, _) idx_mut) next_r.b87;
  mark_test_run 1429;
  let test = eq r expected in
  if not test then failwithf "test 1429 failed";
  mark_test_run 1430;
  let test = sub_eq (get_idx_mut r ((.b87) : (t87, _) idx_mut)) next_r.b87 in
  if not test then failwithf "test 1430 failed";
  (**********************************)
  (*   t88 = { int; int32#; int }   *)
  (**********************************)
  let eq = (fun ({ a88 = a881; b88 = b881; c88 = c881 } : t88) ({ a88 = a882; b88 = b882; c88 = c882 } : t88) -> (fun a b -> Int.equal a b) a881 a882 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b881 b882 && (fun a b -> Int.equal a b) c881 c882) in
  let r = ({ a88 = 0; b88 = #1l; c88 = 2 } : t88) in
  (* Paths of depth 0 *)
  let next_r = ({ a88 = 100; b88 = #101l; c88 = 102 } : t88) in
  (* .a88 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a88 = next_r.a88 } in
  set_idx_mut r ((.a88) : (t88, _) idx_mut) next_r.a88;
  mark_test_run 1431;
  let test = eq r expected in
  if not test then failwithf "test 1431 failed";
  mark_test_run 1432;
  let test = sub_eq (get_idx_mut r ((.a88) : (t88, _) idx_mut)) next_r.a88 in
  if not test then failwithf "test 1432 failed";
  let r = ({ a88 = 0; b88 = #1l; c88 = 2 } : t88) in
  (* Paths of depth 0 *)
  let next_r = ({ a88 = 100; b88 = #101l; c88 = 102 } : t88) in
  (* .b88 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b88 = next_r.b88 } in
  set_idx_mut r ((.b88) : (t88, _) idx_mut) next_r.b88;
  mark_test_run 1433;
  let test = eq r expected in
  if not test then failwithf "test 1433 failed";
  mark_test_run 1434;
  let test = sub_eq (get_idx_mut r ((.b88) : (t88, _) idx_mut)) next_r.b88 in
  if not test then failwithf "test 1434 failed";
  let r = ({ a88 = 0; b88 = #1l; c88 = 2 } : t88) in
  (* Paths of depth 0 *)
  let next_r = ({ a88 = 100; b88 = #101l; c88 = 102 } : t88) in
  (* .c88 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c88 = next_r.c88 } in
  set_idx_mut r ((.c88) : (t88, _) idx_mut) next_r.c88;
  mark_test_run 1435;
  let test = eq r expected in
  if not test then failwithf "test 1435 failed";
  mark_test_run 1436;
  let test = sub_eq (get_idx_mut r ((.c88) : (t88, _) idx_mut)) next_r.c88 in
  if not test then failwithf "test 1436 failed";
  (*************************************)
  (*   t89 = { int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun ({ a89 = a891; b89 = b891; c89 = c891 } : t89) ({ a89 = a892; b89 = b892; c89 = c892 } : t89) -> (fun a b -> Int.equal a b) a891 a892 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b891 b892 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c891 c892) in
  let r = ({ a89 = 0; b89 = #1l; c89 = #2l } : t89) in
  (* Paths of depth 0 *)
  let next_r = ({ a89 = 100; b89 = #101l; c89 = #102l } : t89) in
  (* .a89 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a89 = next_r.a89 } in
  set_idx_mut r ((.a89) : (t89, _) idx_mut) next_r.a89;
  mark_test_run 1437;
  let test = eq r expected in
  if not test then failwithf "test 1437 failed";
  mark_test_run 1438;
  let test = sub_eq (get_idx_mut r ((.a89) : (t89, _) idx_mut)) next_r.a89 in
  if not test then failwithf "test 1438 failed";
  let r = ({ a89 = 0; b89 = #1l; c89 = #2l } : t89) in
  (* Paths of depth 0 *)
  let next_r = ({ a89 = 100; b89 = #101l; c89 = #102l } : t89) in
  (* .b89 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b89 = next_r.b89 } in
  set_idx_mut r ((.b89) : (t89, _) idx_mut) next_r.b89;
  mark_test_run 1439;
  let test = eq r expected in
  if not test then failwithf "test 1439 failed";
  mark_test_run 1440;
  let test = sub_eq (get_idx_mut r ((.b89) : (t89, _) idx_mut)) next_r.b89 in
  if not test then failwithf "test 1440 failed";
  let r = ({ a89 = 0; b89 = #1l; c89 = #2l } : t89) in
  (* Paths of depth 0 *)
  let next_r = ({ a89 = 100; b89 = #101l; c89 = #102l } : t89) in
  (* .c89 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c89 = next_r.c89 } in
  set_idx_mut r ((.c89) : (t89, _) idx_mut) next_r.c89;
  mark_test_run 1441;
  let test = eq r expected in
  if not test then failwithf "test 1441 failed";
  mark_test_run 1442;
  let test = sub_eq (get_idx_mut r ((.c89) : (t89, _) idx_mut)) next_r.c89 in
  if not test then failwithf "test 1442 failed";
  (*********************************)
  (*   t90 = { int; nativeint# }   *)
  (*********************************)
  let eq = (fun ({ a90 = a901; b90 = b901 } : t90) ({ a90 = a902; b90 = b902 } : t90) -> (fun a b -> Int.equal a b) a901 a902 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b901 b902) in
  let r = ({ a90 = 0; b90 = #1n } : t90) in
  (* Paths of depth 0 *)
  let next_r = ({ a90 = 100; b90 = #101n } : t90) in
  (* .a90 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a90 = next_r.a90 } in
  set_idx_mut r ((.a90) : (t90, _) idx_mut) next_r.a90;
  mark_test_run 1443;
  let test = eq r expected in
  if not test then failwithf "test 1443 failed";
  mark_test_run 1444;
  let test = sub_eq (get_idx_mut r ((.a90) : (t90, _) idx_mut)) next_r.a90 in
  if not test then failwithf "test 1444 failed";
  let r = ({ a90 = 0; b90 = #1n } : t90) in
  (* Paths of depth 0 *)
  let next_r = ({ a90 = 100; b90 = #101n } : t90) in
  (* .b90 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b90 = next_r.b90 } in
  set_idx_mut r ((.b90) : (t90, _) idx_mut) next_r.b90;
  mark_test_run 1445;
  let test = eq r expected in
  if not test then failwithf "test 1445 failed";
  mark_test_run 1446;
  let test = sub_eq (get_idx_mut r ((.b90) : (t90, _) idx_mut)) next_r.b90 in
  if not test then failwithf "test 1446 failed";
  (****************************)
  (*   t91 = { int; float }   *)
  (****************************)
  let eq = (fun ({ a91 = a911; b91 = b911 } : t91) ({ a91 = a912; b91 = b912 } : t91) -> (fun a b -> Int.equal a b) a911 a912 && (fun a b -> Float.equal (globalize a) (globalize b)) b911 b912) in
  let r = ({ a91 = 0; b91 = 1. } : t91) in
  (* Paths of depth 0 *)
  let next_r = ({ a91 = 100; b91 = 101. } : t91) in
  (* .a91 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a91 = next_r.a91 } in
  set_idx_mut r ((.a91) : (t91, _) idx_mut) next_r.a91;
  mark_test_run 1447;
  let test = eq r expected in
  if not test then failwithf "test 1447 failed";
  mark_test_run 1448;
  let test = sub_eq (get_idx_mut r ((.a91) : (t91, _) idx_mut)) next_r.a91 in
  if not test then failwithf "test 1448 failed";
  let r = ({ a91 = 0; b91 = 1. } : t91) in
  (* Paths of depth 0 *)
  let next_r = ({ a91 = 100; b91 = 101. } : t91) in
  (* .b91 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b91 = next_r.b91 } in
  set_idx_mut r ((.b91) : (t91, _) idx_mut) next_r.b91;
  mark_test_run 1449;
  let test = eq r expected in
  if not test then failwithf "test 1449 failed";
  mark_test_run 1450;
  let test = sub_eq (get_idx_mut r ((.b91) : (t91, _) idx_mut)) next_r.b91 in
  if not test then failwithf "test 1450 failed";
  (*********************************)
  (*   t92 = { int; float; int }   *)
  (*********************************)
  let eq = (fun ({ a92 = a921; b92 = b921; c92 = c921 } : t92) ({ a92 = a922; b92 = b922; c92 = c922 } : t92) -> (fun a b -> Int.equal a b) a921 a922 && (fun a b -> Float.equal (globalize a) (globalize b)) b921 b922 && (fun a b -> Int.equal a b) c921 c922) in
  let r = ({ a92 = 0; b92 = 1.; c92 = 2 } : t92) in
  (* Paths of depth 0 *)
  let next_r = ({ a92 = 100; b92 = 101.; c92 = 102 } : t92) in
  (* .a92 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a92 = next_r.a92 } in
  set_idx_mut r ((.a92) : (t92, _) idx_mut) next_r.a92;
  mark_test_run 1451;
  let test = eq r expected in
  if not test then failwithf "test 1451 failed";
  mark_test_run 1452;
  let test = sub_eq (get_idx_mut r ((.a92) : (t92, _) idx_mut)) next_r.a92 in
  if not test then failwithf "test 1452 failed";
  let r = ({ a92 = 0; b92 = 1.; c92 = 2 } : t92) in
  (* Paths of depth 0 *)
  let next_r = ({ a92 = 100; b92 = 101.; c92 = 102 } : t92) in
  (* .b92 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b92 = next_r.b92 } in
  set_idx_mut r ((.b92) : (t92, _) idx_mut) next_r.b92;
  mark_test_run 1453;
  let test = eq r expected in
  if not test then failwithf "test 1453 failed";
  mark_test_run 1454;
  let test = sub_eq (get_idx_mut r ((.b92) : (t92, _) idx_mut)) next_r.b92 in
  if not test then failwithf "test 1454 failed";
  let r = ({ a92 = 0; b92 = 1.; c92 = 2 } : t92) in
  (* Paths of depth 0 *)
  let next_r = ({ a92 = 100; b92 = 101.; c92 = 102 } : t92) in
  (* .c92 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c92 = next_r.c92 } in
  set_idx_mut r ((.c92) : (t92, _) idx_mut) next_r.c92;
  mark_test_run 1455;
  let test = eq r expected in
  if not test then failwithf "test 1455 failed";
  mark_test_run 1456;
  let test = sub_eq (get_idx_mut r ((.c92) : (t92, _) idx_mut)) next_r.c92 in
  if not test then failwithf "test 1456 failed";
  (***********************************)
  (*   t93 = { int; float; float }   *)
  (***********************************)
  let eq = (fun ({ a93 = a931; b93 = b931; c93 = c931 } : t93) ({ a93 = a932; b93 = b932; c93 = c932 } : t93) -> (fun a b -> Int.equal a b) a931 a932 && (fun a b -> Float.equal (globalize a) (globalize b)) b931 b932 && (fun a b -> Float.equal (globalize a) (globalize b)) c931 c932) in
  let r = ({ a93 = 0; b93 = 1.; c93 = 2. } : t93) in
  (* Paths of depth 0 *)
  let next_r = ({ a93 = 100; b93 = 101.; c93 = 102. } : t93) in
  (* .a93 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a93 = next_r.a93 } in
  set_idx_mut r ((.a93) : (t93, _) idx_mut) next_r.a93;
  mark_test_run 1457;
  let test = eq r expected in
  if not test then failwithf "test 1457 failed";
  mark_test_run 1458;
  let test = sub_eq (get_idx_mut r ((.a93) : (t93, _) idx_mut)) next_r.a93 in
  if not test then failwithf "test 1458 failed";
  let r = ({ a93 = 0; b93 = 1.; c93 = 2. } : t93) in
  (* Paths of depth 0 *)
  let next_r = ({ a93 = 100; b93 = 101.; c93 = 102. } : t93) in
  (* .b93 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b93 = next_r.b93 } in
  set_idx_mut r ((.b93) : (t93, _) idx_mut) next_r.b93;
  mark_test_run 1459;
  let test = eq r expected in
  if not test then failwithf "test 1459 failed";
  mark_test_run 1460;
  let test = sub_eq (get_idx_mut r ((.b93) : (t93, _) idx_mut)) next_r.b93 in
  if not test then failwithf "test 1460 failed";
  let r = ({ a93 = 0; b93 = 1.; c93 = 2. } : t93) in
  (* Paths of depth 0 *)
  let next_r = ({ a93 = 100; b93 = 101.; c93 = 102. } : t93) in
  (* .c93 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with c93 = next_r.c93 } in
  set_idx_mut r ((.c93) : (t93, _) idx_mut) next_r.c93;
  mark_test_run 1461;
  let test = eq r expected in
  if not test then failwithf "test 1461 failed";
  mark_test_run 1462;
  let test = sub_eq (get_idx_mut r ((.c93) : (t93, _) idx_mut)) next_r.c93 in
  if not test then failwithf "test 1462 failed";
  (*******************************)
  (*   t94 = { int; #{ int } }   *)
  (*******************************)
  let eq = (fun ({ a94 = a941; b94 = b941 } : t94) ({ a94 = a942; b94 = b942 } : t94) -> (fun a b -> Int.equal a b) a941 a942 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b941 b942) in
  let r = ({ a94 = 0; b94 = (#{ a0 = 1 } : t0) } : t94) in
  (* Paths of depth 0 *)
  let next_r = ({ a94 = 100; b94 = (#{ a0 = 101 } : t0) } : t94) in
  (* .a94 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a94 = next_r.a94 } in
  set_idx_mut r ((.a94) : (t94, _) idx_mut) next_r.a94;
  mark_test_run 1463;
  let test = eq r expected in
  if not test then failwithf "test 1463 failed";
  mark_test_run 1464;
  let test = sub_eq (get_idx_mut r ((.a94) : (t94, _) idx_mut)) next_r.a94 in
  if not test then failwithf "test 1464 failed";
  let r = ({ a94 = 0; b94 = (#{ a0 = 1 } : t0) } : t94) in
  (* Paths of depth 0 *)
  let next_r = ({ a94 = 100; b94 = (#{ a0 = 101 } : t0) } : t94) in
  (* .b94 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with b94 = next_r.b94 } in
  set_idx_mut r ((.b94) : (t94, _) idx_mut) next_r.b94;
  mark_test_run 1465;
  let test = eq r expected in
  if not test then failwithf "test 1465 failed";
  mark_test_run 1466;
  let test = sub_eq (get_idx_mut r ((.b94) : (t94, _) idx_mut)) next_r.b94 in
  if not test then failwithf "test 1466 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a94 = 200; b94 = (#{ a0 = 201 } : t0) } : t94) in
  (* .b94.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b94 = #{ r.b94 with a0 = next_r.b94.#a0 } } in
  set_idx_mut r ((.b94.#a0) : (t94, _) idx_mut) next_r.b94.#a0;
  mark_test_run 1467;
  let test = eq r expected in
  if not test then failwithf "test 1467 failed";
  mark_test_run 1468;
  let test = sub_eq (get_idx_mut r ((.b94.#a0) : (t94, _) idx_mut)) next_r.b94.#a0 in
  if not test then failwithf "test 1468 failed";
  (************************************)
  (*   t95 = { int; #{ int; int } }   *)
  (************************************)
  let eq = (fun ({ a95 = a951; b95 = b951 } : t95) ({ a95 = a952; b95 = b952 } : t95) -> (fun a b -> Int.equal a b) a951 a952 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b951 b952) in
  let r = ({ a95 = 0; b95 = (#{ a1 = 1; b1 = 2 } : t1) } : t95) in
  (* Paths of depth 0 *)
  let next_r = ({ a95 = 100; b95 = (#{ a1 = 101; b1 = 102 } : t1) } : t95) in
  (* .a95 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a95 = next_r.a95 } in
  set_idx_mut r ((.a95) : (t95, _) idx_mut) next_r.a95;
  mark_test_run 1469;
  let test = eq r expected in
  if not test then failwithf "test 1469 failed";
  mark_test_run 1470;
  let test = sub_eq (get_idx_mut r ((.a95) : (t95, _) idx_mut)) next_r.a95 in
  if not test then failwithf "test 1470 failed";
  let r = ({ a95 = 0; b95 = (#{ a1 = 1; b1 = 2 } : t1) } : t95) in
  (* Paths of depth 0 *)
  let next_r = ({ a95 = 100; b95 = (#{ a1 = 101; b1 = 102 } : t1) } : t95) in
  (* .b95 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with b95 = next_r.b95 } in
  set_idx_mut r ((.b95) : (t95, _) idx_mut) next_r.b95;
  mark_test_run 1471;
  let test = eq r expected in
  if not test then failwithf "test 1471 failed";
  mark_test_run 1472;
  let test = sub_eq (get_idx_mut r ((.b95) : (t95, _) idx_mut)) next_r.b95 in
  if not test then failwithf "test 1472 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a95 = 200; b95 = (#{ a1 = 201; b1 = 202 } : t1) } : t95) in
  (* .b95.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b95 = #{ r.b95 with a1 = next_r.b95.#a1 } } in
  set_idx_mut r ((.b95.#a1) : (t95, _) idx_mut) next_r.b95.#a1;
  mark_test_run 1473;
  let test = eq r expected in
  if not test then failwithf "test 1473 failed";
  mark_test_run 1474;
  let test = sub_eq (get_idx_mut r ((.b95.#a1) : (t95, _) idx_mut)) next_r.b95.#a1 in
  if not test then failwithf "test 1474 failed";
  (* .b95.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b95 = #{ r.b95 with b1 = next_r.b95.#b1 } } in
  set_idx_mut r ((.b95.#b1) : (t95, _) idx_mut) next_r.b95.#b1;
  mark_test_run 1475;
  let test = eq r expected in
  if not test then failwithf "test 1475 failed";
  mark_test_run 1476;
  let test = sub_eq (get_idx_mut r ((.b95.#b1) : (t95, _) idx_mut)) next_r.b95.#b1 in
  if not test then failwithf "test 1476 failed";
  (***************************************)
  (*   t96 = { int; #{ int; int32# } }   *)
  (***************************************)
  let eq = (fun ({ a96 = a961; b96 = b961 } : t96) ({ a96 = a962; b96 = b962 } : t96) -> (fun a b -> Int.equal a b) a961 a962 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b961 b962) in
  let r = ({ a96 = 0; b96 = (#{ a7 = 1; b7 = #2l } : t7) } : t96) in
  (* Paths of depth 0 *)
  let next_r = ({ a96 = 100; b96 = (#{ a7 = 101; b7 = #102l } : t7) } : t96) in
  (* .a96 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a96 = next_r.a96 } in
  set_idx_mut r ((.a96) : (t96, _) idx_mut) next_r.a96;
  mark_test_run 1477;
  let test = eq r expected in
  if not test then failwithf "test 1477 failed";
  mark_test_run 1478;
  let test = sub_eq (get_idx_mut r ((.a96) : (t96, _) idx_mut)) next_r.a96 in
  if not test then failwithf "test 1478 failed";
  let r = ({ a96 = 0; b96 = (#{ a7 = 1; b7 = #2l } : t7) } : t96) in
  (* Paths of depth 0 *)
  let next_r = ({ a96 = 100; b96 = (#{ a7 = 101; b7 = #102l } : t7) } : t96) in
  (* .b96 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with b96 = next_r.b96 } in
  set_idx_mut r ((.b96) : (t96, _) idx_mut) next_r.b96;
  mark_test_run 1479;
  let test = eq r expected in
  if not test then failwithf "test 1479 failed";
  mark_test_run 1480;
  let test = sub_eq (get_idx_mut r ((.b96) : (t96, _) idx_mut)) next_r.b96 in
  if not test then failwithf "test 1480 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a96 = 200; b96 = (#{ a7 = 201; b7 = #202l } : t7) } : t96) in
  (* .b96.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b96 = #{ r.b96 with a7 = next_r.b96.#a7 } } in
  set_idx_mut r ((.b96.#a7) : (t96, _) idx_mut) next_r.b96.#a7;
  mark_test_run 1481;
  let test = eq r expected in
  if not test then failwithf "test 1481 failed";
  mark_test_run 1482;
  let test = sub_eq (get_idx_mut r ((.b96.#a7) : (t96, _) idx_mut)) next_r.b96.#a7 in
  if not test then failwithf "test 1482 failed";
  (* .b96.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b96 = #{ r.b96 with b7 = next_r.b96.#b7 } } in
  set_idx_mut r ((.b96.#b7) : (t96, _) idx_mut) next_r.b96.#b7;
  mark_test_run 1483;
  let test = eq r expected in
  if not test then failwithf "test 1483 failed";
  mark_test_run 1484;
  let test = sub_eq (get_idx_mut r ((.b96.#b7) : (t96, _) idx_mut)) next_r.b96.#b7 in
  if not test then failwithf "test 1484 failed";
  (**************************************)
  (*   t97 = { int; #{ int; float } }   *)
  (**************************************)
  let eq = (fun ({ a97 = a971; b97 = b971 } : t97) ({ a97 = a972; b97 = b972 } : t97) -> (fun a b -> Int.equal a b) a971 a972 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b971 b972) in
  let r = ({ a97 = 0; b97 = (#{ a10 = 1; b10 = 2. } : t10) } : t97) in
  (* Paths of depth 0 *)
  let next_r = ({ a97 = 100; b97 = (#{ a10 = 101; b10 = 102. } : t10) } : t97) in
  (* .a97 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a97 = next_r.a97 } in
  set_idx_mut r ((.a97) : (t97, _) idx_mut) next_r.a97;
  mark_test_run 1485;
  let test = eq r expected in
  if not test then failwithf "test 1485 failed";
  mark_test_run 1486;
  let test = sub_eq (get_idx_mut r ((.a97) : (t97, _) idx_mut)) next_r.a97 in
  if not test then failwithf "test 1486 failed";
  let r = ({ a97 = 0; b97 = (#{ a10 = 1; b10 = 2. } : t10) } : t97) in
  (* Paths of depth 0 *)
  let next_r = ({ a97 = 100; b97 = (#{ a10 = 101; b10 = 102. } : t10) } : t97) in
  (* .b97 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with b97 = next_r.b97 } in
  set_idx_mut r ((.b97) : (t97, _) idx_mut) next_r.b97;
  mark_test_run 1487;
  let test = eq r expected in
  if not test then failwithf "test 1487 failed";
  mark_test_run 1488;
  let test = sub_eq (get_idx_mut r ((.b97) : (t97, _) idx_mut)) next_r.b97 in
  if not test then failwithf "test 1488 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a97 = 200; b97 = (#{ a10 = 201; b10 = 202. } : t10) } : t97) in
  (* .b97.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b97 = #{ r.b97 with a10 = next_r.b97.#a10 } } in
  set_idx_mut r ((.b97.#a10) : (t97, _) idx_mut) next_r.b97.#a10;
  mark_test_run 1489;
  let test = eq r expected in
  if not test then failwithf "test 1489 failed";
  mark_test_run 1490;
  let test = sub_eq (get_idx_mut r ((.b97.#a10) : (t97, _) idx_mut)) next_r.b97.#a10 in
  if not test then failwithf "test 1490 failed";
  (* .b97.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b97 = #{ r.b97 with b10 = next_r.b97.#b10 } } in
  set_idx_mut r ((.b97.#b10) : (t97, _) idx_mut) next_r.b97.#b10;
  mark_test_run 1491;
  let test = eq r expected in
  if not test then failwithf "test 1491 failed";
  mark_test_run 1492;
  let test = sub_eq (get_idx_mut r ((.b97.#b10) : (t97, _) idx_mut)) next_r.b97.#b10 in
  if not test then failwithf "test 1492 failed";
  (**********************************)
  (*   t98 = { int; #{ int32# } }   *)
  (**********************************)
  let eq = (fun ({ a98 = a981; b98 = b981 } : t98) ({ a98 = a982; b98 = b982 } : t98) -> (fun a b -> Int.equal a b) a981 a982 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b981 b982) in
  let r = ({ a98 = 0; b98 = (#{ a17 = #1l } : t17) } : t98) in
  (* Paths of depth 0 *)
  let next_r = ({ a98 = 100; b98 = (#{ a17 = #101l } : t17) } : t98) in
  (* .a98 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a98 = next_r.a98 } in
  set_idx_mut r ((.a98) : (t98, _) idx_mut) next_r.a98;
  mark_test_run 1493;
  let test = eq r expected in
  if not test then failwithf "test 1493 failed";
  mark_test_run 1494;
  let test = sub_eq (get_idx_mut r ((.a98) : (t98, _) idx_mut)) next_r.a98 in
  if not test then failwithf "test 1494 failed";
  let r = ({ a98 = 0; b98 = (#{ a17 = #1l } : t17) } : t98) in
  (* Paths of depth 0 *)
  let next_r = ({ a98 = 100; b98 = (#{ a17 = #101l } : t17) } : t98) in
  (* .b98 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with b98 = next_r.b98 } in
  set_idx_mut r ((.b98) : (t98, _) idx_mut) next_r.b98;
  mark_test_run 1495;
  let test = eq r expected in
  if not test then failwithf "test 1495 failed";
  mark_test_run 1496;
  let test = sub_eq (get_idx_mut r ((.b98) : (t98, _) idx_mut)) next_r.b98 in
  if not test then failwithf "test 1496 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a98 = 200; b98 = (#{ a17 = #201l } : t17) } : t98) in
  (* .b98.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b98 = #{ r.b98 with a17 = next_r.b98.#a17 } } in
  set_idx_mut r ((.b98.#a17) : (t98, _) idx_mut) next_r.b98.#a17;
  mark_test_run 1497;
  let test = eq r expected in
  if not test then failwithf "test 1497 failed";
  mark_test_run 1498;
  let test = sub_eq (get_idx_mut r ((.b98.#a17) : (t98, _) idx_mut)) next_r.b98.#a17 in
  if not test then failwithf "test 1498 failed";
  (****************************************)
  (*   t100 = { int; #{ int32#; int } }   *)
  (****************************************)
  let eq = (fun ({ a100 = a1001; b100 = b1001 } : t100) ({ a100 = a1002; b100 = b1002 } : t100) -> (fun a b -> Int.equal a b) a1001 a1002 && (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) b1001 b1002) in
  let r = ({ a100 = 0; b100 = (#{ a99 = #1l; b99 = 2 } : t99) } : t100) in
  (* Paths of depth 0 *)
  let next_r = ({ a100 = 100; b100 = (#{ a99 = #101l; b99 = 102 } : t99) } : t100) in
  (* .a100 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a100 = next_r.a100 } in
  set_idx_mut r ((.a100) : (t100, _) idx_mut) next_r.a100;
  mark_test_run 1499;
  let test = eq r expected in
  if not test then failwithf "test 1499 failed";
  mark_test_run 1500;
  let test = sub_eq (get_idx_mut r ((.a100) : (t100, _) idx_mut)) next_r.a100 in
  if not test then failwithf "test 1500 failed";
  let r = ({ a100 = 0; b100 = (#{ a99 = #1l; b99 = 2 } : t99) } : t100) in
  (* Paths of depth 0 *)
  let next_r = ({ a100 = 100; b100 = (#{ a99 = #101l; b99 = 102 } : t99) } : t100) in
  (* .b100 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with b100 = next_r.b100 } in
  set_idx_mut r ((.b100) : (t100, _) idx_mut) next_r.b100;
  mark_test_run 1501;
  let test = eq r expected in
  if not test then failwithf "test 1501 failed";
  mark_test_run 1502;
  let test = sub_eq (get_idx_mut r ((.b100) : (t100, _) idx_mut)) next_r.b100 in
  if not test then failwithf "test 1502 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a100 = 200; b100 = (#{ a99 = #201l; b99 = 202 } : t99) } : t100) in
  (* .b100.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b100 = #{ r.b100 with a99 = next_r.b100.#a99 } } in
  set_idx_mut r ((.b100.#a99) : (t100, _) idx_mut) next_r.b100.#a99;
  mark_test_run 1503;
  let test = eq r expected in
  if not test then failwithf "test 1503 failed";
  mark_test_run 1504;
  let test = sub_eq (get_idx_mut r ((.b100.#a99) : (t100, _) idx_mut)) next_r.b100.#a99 in
  if not test then failwithf "test 1504 failed";
  (* .b100.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b100 = #{ r.b100 with b99 = next_r.b100.#b99 } } in
  set_idx_mut r ((.b100.#b99) : (t100, _) idx_mut) next_r.b100.#b99;
  mark_test_run 1505;
  let test = eq r expected in
  if not test then failwithf "test 1505 failed";
  mark_test_run 1506;
  let test = sub_eq (get_idx_mut r ((.b100.#b99) : (t100, _) idx_mut)) next_r.b100.#b99 in
  if not test then failwithf "test 1506 failed";
  (*******************************************)
  (*   t101 = { int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun ({ a101 = a1011; b101 = b1011 } : t101) ({ a101 = a1012; b101 = b1012 } : t101) -> (fun a b -> Int.equal a b) a1011 a1012 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b1011 b1012) in
  let r = ({ a101 = 0; b101 = (#{ a19 = #1l; b19 = #2l } : t19) } : t101) in
  (* Paths of depth 0 *)
  let next_r = ({ a101 = 100; b101 = (#{ a19 = #101l; b19 = #102l } : t19) } : t101) in
  (* .a101 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a101 = next_r.a101 } in
  set_idx_mut r ((.a101) : (t101, _) idx_mut) next_r.a101;
  mark_test_run 1507;
  let test = eq r expected in
  if not test then failwithf "test 1507 failed";
  mark_test_run 1508;
  let test = sub_eq (get_idx_mut r ((.a101) : (t101, _) idx_mut)) next_r.a101 in
  if not test then failwithf "test 1508 failed";
  let r = ({ a101 = 0; b101 = (#{ a19 = #1l; b19 = #2l } : t19) } : t101) in
  (* Paths of depth 0 *)
  let next_r = ({ a101 = 100; b101 = (#{ a19 = #101l; b19 = #102l } : t19) } : t101) in
  (* .b101 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with b101 = next_r.b101 } in
  set_idx_mut r ((.b101) : (t101, _) idx_mut) next_r.b101;
  mark_test_run 1509;
  let test = eq r expected in
  if not test then failwithf "test 1509 failed";
  mark_test_run 1510;
  let test = sub_eq (get_idx_mut r ((.b101) : (t101, _) idx_mut)) next_r.b101 in
  if not test then failwithf "test 1510 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a101 = 200; b101 = (#{ a19 = #201l; b19 = #202l } : t19) } : t101) in
  (* .b101.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b101 = #{ r.b101 with a19 = next_r.b101.#a19 } } in
  set_idx_mut r ((.b101.#a19) : (t101, _) idx_mut) next_r.b101.#a19;
  mark_test_run 1511;
  let test = eq r expected in
  if not test then failwithf "test 1511 failed";
  mark_test_run 1512;
  let test = sub_eq (get_idx_mut r ((.b101.#a19) : (t101, _) idx_mut)) next_r.b101.#a19 in
  if not test then failwithf "test 1512 failed";
  (* .b101.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b101 = #{ r.b101 with b19 = next_r.b101.#b19 } } in
  set_idx_mut r ((.b101.#b19) : (t101, _) idx_mut) next_r.b101.#b19;
  mark_test_run 1513;
  let test = eq r expected in
  if not test then failwithf "test 1513 failed";
  mark_test_run 1514;
  let test = sub_eq (get_idx_mut r ((.b101.#b19) : (t101, _) idx_mut)) next_r.b101.#b19 in
  if not test then failwithf "test 1514 failed";
  (**********************************)
  (*   t102 = { int; #{ float } }   *)
  (**********************************)
  let eq = (fun ({ a102 = a1021; b102 = b1021 } : t102) ({ a102 = a1022; b102 = b1022 } : t102) -> (fun a b -> Int.equal a b) a1021 a1022 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b1021 b1022) in
  let r = ({ a102 = 0; b102 = (#{ a21 = 1. } : t21) } : t102) in
  (* Paths of depth 0 *)
  let next_r = ({ a102 = 100; b102 = (#{ a21 = 101. } : t21) } : t102) in
  (* .a102 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a102 = next_r.a102 } in
  set_idx_mut r ((.a102) : (t102, _) idx_mut) next_r.a102;
  mark_test_run 1515;
  let test = eq r expected in
  if not test then failwithf "test 1515 failed";
  mark_test_run 1516;
  let test = sub_eq (get_idx_mut r ((.a102) : (t102, _) idx_mut)) next_r.a102 in
  if not test then failwithf "test 1516 failed";
  let r = ({ a102 = 0; b102 = (#{ a21 = 1. } : t21) } : t102) in
  (* Paths of depth 0 *)
  let next_r = ({ a102 = 100; b102 = (#{ a21 = 101. } : t21) } : t102) in
  (* .b102 *)
  let sub_eq = (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) in
  let expected = { r with b102 = next_r.b102 } in
  set_idx_mut r ((.b102) : (t102, _) idx_mut) next_r.b102;
  mark_test_run 1517;
  let test = eq r expected in
  if not test then failwithf "test 1517 failed";
  mark_test_run 1518;
  let test = sub_eq (get_idx_mut r ((.b102) : (t102, _) idx_mut)) next_r.b102 in
  if not test then failwithf "test 1518 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a102 = 200; b102 = (#{ a21 = 201. } : t21) } : t102) in
  (* .b102.#a21 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b102 = #{ r.b102 with a21 = next_r.b102.#a21 } } in
  set_idx_mut r ((.b102.#a21) : (t102, _) idx_mut) next_r.b102.#a21;
  mark_test_run 1519;
  let test = eq r expected in
  if not test then failwithf "test 1519 failed";
  mark_test_run 1520;
  let test = sub_eq (get_idx_mut r ((.b102.#a21) : (t102, _) idx_mut)) next_r.b102.#a21 in
  if not test then failwithf "test 1520 failed";
  (***************************************)
  (*   t103 = { int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun ({ a103 = a1031; b103 = b1031 } : t103) ({ a103 = a1032; b103 = b1032 } : t103) -> (fun a b -> Int.equal a b) a1031 a1032 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b1031 b1032) in
  let r = ({ a103 = 0; b103 = (#{ a23 = 1.; b23 = 2 } : t23) } : t103) in
  (* Paths of depth 0 *)
  let next_r = ({ a103 = 100; b103 = (#{ a23 = 101.; b23 = 102 } : t23) } : t103) in
  (* .a103 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a103 = next_r.a103 } in
  set_idx_mut r ((.a103) : (t103, _) idx_mut) next_r.a103;
  mark_test_run 1521;
  let test = eq r expected in
  if not test then failwithf "test 1521 failed";
  mark_test_run 1522;
  let test = sub_eq (get_idx_mut r ((.a103) : (t103, _) idx_mut)) next_r.a103 in
  if not test then failwithf "test 1522 failed";
  let r = ({ a103 = 0; b103 = (#{ a23 = 1.; b23 = 2 } : t23) } : t103) in
  (* Paths of depth 0 *)
  let next_r = ({ a103 = 100; b103 = (#{ a23 = 101.; b23 = 102 } : t23) } : t103) in
  (* .b103 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with b103 = next_r.b103 } in
  set_idx_mut r ((.b103) : (t103, _) idx_mut) next_r.b103;
  mark_test_run 1523;
  let test = eq r expected in
  if not test then failwithf "test 1523 failed";
  mark_test_run 1524;
  let test = sub_eq (get_idx_mut r ((.b103) : (t103, _) idx_mut)) next_r.b103 in
  if not test then failwithf "test 1524 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a103 = 200; b103 = (#{ a23 = 201.; b23 = 202 } : t23) } : t103) in
  (* .b103.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b103 = #{ r.b103 with a23 = next_r.b103.#a23 } } in
  set_idx_mut r ((.b103.#a23) : (t103, _) idx_mut) next_r.b103.#a23;
  mark_test_run 1525;
  let test = eq r expected in
  if not test then failwithf "test 1525 failed";
  mark_test_run 1526;
  let test = sub_eq (get_idx_mut r ((.b103.#a23) : (t103, _) idx_mut)) next_r.b103.#a23 in
  if not test then failwithf "test 1526 failed";
  (* .b103.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b103 = #{ r.b103 with b23 = next_r.b103.#b23 } } in
  set_idx_mut r ((.b103.#b23) : (t103, _) idx_mut) next_r.b103.#b23;
  mark_test_run 1527;
  let test = eq r expected in
  if not test then failwithf "test 1527 failed";
  mark_test_run 1528;
  let test = sub_eq (get_idx_mut r ((.b103.#b23) : (t103, _) idx_mut)) next_r.b103.#b23 in
  if not test then failwithf "test 1528 failed";
  (*****************************************)
  (*   t104 = { int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun ({ a104 = a1041; b104 = b1041 } : t104) ({ a104 = a1042; b104 = b1042 } : t104) -> (fun a b -> Int.equal a b) a1041 a1042 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b1041 b1042) in
  let r = ({ a104 = 0; b104 = (#{ a25 = 1.; b25 = 2. } : t25) } : t104) in
  (* Paths of depth 0 *)
  let next_r = ({ a104 = 100; b104 = (#{ a25 = 101.; b25 = 102. } : t25) } : t104) in
  (* .a104 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a104 = next_r.a104 } in
  set_idx_mut r ((.a104) : (t104, _) idx_mut) next_r.a104;
  mark_test_run 1529;
  let test = eq r expected in
  if not test then failwithf "test 1529 failed";
  mark_test_run 1530;
  let test = sub_eq (get_idx_mut r ((.a104) : (t104, _) idx_mut)) next_r.a104 in
  if not test then failwithf "test 1530 failed";
  let r = ({ a104 = 0; b104 = (#{ a25 = 1.; b25 = 2. } : t25) } : t104) in
  (* Paths of depth 0 *)
  let next_r = ({ a104 = 100; b104 = (#{ a25 = 101.; b25 = 102. } : t25) } : t104) in
  (* .b104 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with b104 = next_r.b104 } in
  set_idx_mut r ((.b104) : (t104, _) idx_mut) next_r.b104;
  mark_test_run 1531;
  let test = eq r expected in
  if not test then failwithf "test 1531 failed";
  mark_test_run 1532;
  let test = sub_eq (get_idx_mut r ((.b104) : (t104, _) idx_mut)) next_r.b104 in
  if not test then failwithf "test 1532 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a104 = 200; b104 = (#{ a25 = 201.; b25 = 202. } : t25) } : t104) in
  (* .b104.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b104 = #{ r.b104 with a25 = next_r.b104.#a25 } } in
  set_idx_mut r ((.b104.#a25) : (t104, _) idx_mut) next_r.b104.#a25;
  mark_test_run 1533;
  let test = eq r expected in
  if not test then failwithf "test 1533 failed";
  mark_test_run 1534;
  let test = sub_eq (get_idx_mut r ((.b104.#a25) : (t104, _) idx_mut)) next_r.b104.#a25 in
  if not test then failwithf "test 1534 failed";
  (* .b104.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b104 = #{ r.b104 with b25 = next_r.b104.#b25 } } in
  set_idx_mut r ((.b104.#b25) : (t104, _) idx_mut) next_r.b104.#b25;
  mark_test_run 1535;
  let test = eq r expected in
  if not test then failwithf "test 1535 failed";
  mark_test_run 1536;
  let test = sub_eq (get_idx_mut r ((.b104.#b25) : (t104, _) idx_mut)) next_r.b104.#b25 in
  if not test then failwithf "test 1536 failed";
  (************************)
  (*   t105 = { int64 }   *)
  (************************)
  let eq = (fun ({ a105 = a1051 } : t105) ({ a105 = a1052 } : t105) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1051 a1052) in
  let r = ({ a105 = 0L } : t105) in
  (* Paths of depth 0 *)
  let next_r = ({ a105 = 100L } : t105) in
  (* .a105 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a105 = next_r.a105 } in
  set_idx_mut r ((.a105) : (t105, _) idx_mut) next_r.a105;
  mark_test_run 1537;
  let test = eq r expected in
  if not test then failwithf "test 1537 failed";
  mark_test_run 1538;
  let test = sub_eq (get_idx_mut r ((.a105) : (t105, _) idx_mut)) next_r.a105 in
  if not test then failwithf "test 1538 failed";
  (*****************************)
  (*   t106 = { int64; int }   *)
  (*****************************)
  let eq = (fun ({ a106 = a1061; b106 = b1061 } : t106) ({ a106 = a1062; b106 = b1062 } : t106) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1061 a1062 && (fun a b -> Int.equal a b) b1061 b1062) in
  let r = ({ a106 = 0L; b106 = 1 } : t106) in
  (* Paths of depth 0 *)
  let next_r = ({ a106 = 100L; b106 = 101 } : t106) in
  (* .a106 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a106 = next_r.a106 } in
  set_idx_mut r ((.a106) : (t106, _) idx_mut) next_r.a106;
  mark_test_run 1539;
  let test = eq r expected in
  if not test then failwithf "test 1539 failed";
  mark_test_run 1540;
  let test = sub_eq (get_idx_mut r ((.a106) : (t106, _) idx_mut)) next_r.a106 in
  if not test then failwithf "test 1540 failed";
  let r = ({ a106 = 0L; b106 = 1 } : t106) in
  (* Paths of depth 0 *)
  let next_r = ({ a106 = 100L; b106 = 101 } : t106) in
  (* .b106 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b106 = next_r.b106 } in
  set_idx_mut r ((.b106) : (t106, _) idx_mut) next_r.b106;
  mark_test_run 1541;
  let test = eq r expected in
  if not test then failwithf "test 1541 failed";
  mark_test_run 1542;
  let test = sub_eq (get_idx_mut r ((.b106) : (t106, _) idx_mut)) next_r.b106 in
  if not test then failwithf "test 1542 failed";
  (*******************************)
  (*   t107 = { int64; int64 }   *)
  (*******************************)
  let eq = (fun ({ a107 = a1071; b107 = b1071 } : t107) ({ a107 = a1072; b107 = b1072 } : t107) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1071 a1072 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1071 b1072) in
  let r = ({ a107 = 0L; b107 = 1L } : t107) in
  (* Paths of depth 0 *)
  let next_r = ({ a107 = 100L; b107 = 101L } : t107) in
  (* .a107 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a107 = next_r.a107 } in
  set_idx_mut r ((.a107) : (t107, _) idx_mut) next_r.a107;
  mark_test_run 1543;
  let test = eq r expected in
  if not test then failwithf "test 1543 failed";
  mark_test_run 1544;
  let test = sub_eq (get_idx_mut r ((.a107) : (t107, _) idx_mut)) next_r.a107 in
  if not test then failwithf "test 1544 failed";
  let r = ({ a107 = 0L; b107 = 1L } : t107) in
  (* Paths of depth 0 *)
  let next_r = ({ a107 = 100L; b107 = 101L } : t107) in
  (* .b107 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b107 = next_r.b107 } in
  set_idx_mut r ((.b107) : (t107, _) idx_mut) next_r.b107;
  mark_test_run 1545;
  let test = eq r expected in
  if not test then failwithf "test 1545 failed";
  mark_test_run 1546;
  let test = sub_eq (get_idx_mut r ((.b107) : (t107, _) idx_mut)) next_r.b107 in
  if not test then failwithf "test 1546 failed";
  (********************************)
  (*   t108 = { int64; int64# }   *)
  (********************************)
  let eq = (fun ({ a108 = a1081; b108 = b1081 } : t108) ({ a108 = a1082; b108 = b1082 } : t108) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1081 a1082 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1081 b1082) in
  let r = ({ a108 = 0L; b108 = #1L } : t108) in
  (* Paths of depth 0 *)
  let next_r = ({ a108 = 100L; b108 = #101L } : t108) in
  (* .a108 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a108 = next_r.a108 } in
  set_idx_mut r ((.a108) : (t108, _) idx_mut) next_r.a108;
  mark_test_run 1547;
  let test = eq r expected in
  if not test then failwithf "test 1547 failed";
  mark_test_run 1548;
  let test = sub_eq (get_idx_mut r ((.a108) : (t108, _) idx_mut)) next_r.a108 in
  if not test then failwithf "test 1548 failed";
  let r = ({ a108 = 0L; b108 = #1L } : t108) in
  (* Paths of depth 0 *)
  let next_r = ({ a108 = 100L; b108 = #101L } : t108) in
  (* .b108 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b108 = next_r.b108 } in
  set_idx_mut r ((.b108) : (t108, _) idx_mut) next_r.b108;
  mark_test_run 1549;
  let test = eq r expected in
  if not test then failwithf "test 1549 failed";
  mark_test_run 1550;
  let test = sub_eq (get_idx_mut r ((.b108) : (t108, _) idx_mut)) next_r.b108 in
  if not test then failwithf "test 1550 failed";
  (********************************)
  (*   t109 = { int64; int32# }   *)
  (********************************)
  let eq = (fun ({ a109 = a1091; b109 = b1091 } : t109) ({ a109 = a1092; b109 = b1092 } : t109) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1091 a1092 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1091 b1092) in
  let r = ({ a109 = 0L; b109 = #1l } : t109) in
  (* Paths of depth 0 *)
  let next_r = ({ a109 = 100L; b109 = #101l } : t109) in
  (* .a109 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a109 = next_r.a109 } in
  set_idx_mut r ((.a109) : (t109, _) idx_mut) next_r.a109;
  mark_test_run 1551;
  let test = eq r expected in
  if not test then failwithf "test 1551 failed";
  mark_test_run 1552;
  let test = sub_eq (get_idx_mut r ((.a109) : (t109, _) idx_mut)) next_r.a109 in
  if not test then failwithf "test 1552 failed";
  let r = ({ a109 = 0L; b109 = #1l } : t109) in
  (* Paths of depth 0 *)
  let next_r = ({ a109 = 100L; b109 = #101l } : t109) in
  (* .b109 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b109 = next_r.b109 } in
  set_idx_mut r ((.b109) : (t109, _) idx_mut) next_r.b109;
  mark_test_run 1553;
  let test = eq r expected in
  if not test then failwithf "test 1553 failed";
  mark_test_run 1554;
  let test = sub_eq (get_idx_mut r ((.b109) : (t109, _) idx_mut)) next_r.b109 in
  if not test then failwithf "test 1554 failed";
  (************************************)
  (*   t110 = { int64; nativeint# }   *)
  (************************************)
  let eq = (fun ({ a110 = a1101; b110 = b1101 } : t110) ({ a110 = a1102; b110 = b1102 } : t110) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1101 a1102 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1101 b1102) in
  let r = ({ a110 = 0L; b110 = #1n } : t110) in
  (* Paths of depth 0 *)
  let next_r = ({ a110 = 100L; b110 = #101n } : t110) in
  (* .a110 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a110 = next_r.a110 } in
  set_idx_mut r ((.a110) : (t110, _) idx_mut) next_r.a110;
  mark_test_run 1555;
  let test = eq r expected in
  if not test then failwithf "test 1555 failed";
  mark_test_run 1556;
  let test = sub_eq (get_idx_mut r ((.a110) : (t110, _) idx_mut)) next_r.a110 in
  if not test then failwithf "test 1556 failed";
  let r = ({ a110 = 0L; b110 = #1n } : t110) in
  (* Paths of depth 0 *)
  let next_r = ({ a110 = 100L; b110 = #101n } : t110) in
  (* .b110 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b110 = next_r.b110 } in
  set_idx_mut r ((.b110) : (t110, _) idx_mut) next_r.b110;
  mark_test_run 1557;
  let test = eq r expected in
  if not test then failwithf "test 1557 failed";
  mark_test_run 1558;
  let test = sub_eq (get_idx_mut r ((.b110) : (t110, _) idx_mut)) next_r.b110 in
  if not test then failwithf "test 1558 failed";
  (*******************************)
  (*   t111 = { int64; float }   *)
  (*******************************)
  let eq = (fun ({ a111 = a1111; b111 = b1111 } : t111) ({ a111 = a1112; b111 = b1112 } : t111) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1111 a1112 && (fun a b -> Float.equal (globalize a) (globalize b)) b1111 b1112) in
  let r = ({ a111 = 0L; b111 = 1. } : t111) in
  (* Paths of depth 0 *)
  let next_r = ({ a111 = 100L; b111 = 101. } : t111) in
  (* .a111 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a111 = next_r.a111 } in
  set_idx_mut r ((.a111) : (t111, _) idx_mut) next_r.a111;
  mark_test_run 1559;
  let test = eq r expected in
  if not test then failwithf "test 1559 failed";
  mark_test_run 1560;
  let test = sub_eq (get_idx_mut r ((.a111) : (t111, _) idx_mut)) next_r.a111 in
  if not test then failwithf "test 1560 failed";
  let r = ({ a111 = 0L; b111 = 1. } : t111) in
  (* Paths of depth 0 *)
  let next_r = ({ a111 = 100L; b111 = 101. } : t111) in
  (* .b111 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b111 = next_r.b111 } in
  set_idx_mut r ((.b111) : (t111, _) idx_mut) next_r.b111;
  mark_test_run 1561;
  let test = eq r expected in
  if not test then failwithf "test 1561 failed";
  mark_test_run 1562;
  let test = sub_eq (get_idx_mut r ((.b111) : (t111, _) idx_mut)) next_r.b111 in
  if not test then failwithf "test 1562 failed";
  (*************************)
  (*   t112 = { int64# }   *)
  (*************************)
  let eq = (fun ({ a112 = a1121 } : t112) ({ a112 = a1122 } : t112) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1121 a1122) in
  let r = ({ a112 = #0L } : t112) in
  (* Paths of depth 0 *)
  let next_r = ({ a112 = #100L } : t112) in
  (* .a112 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a112 = next_r.a112 } in
  set_idx_mut r ((.a112) : (t112, _) idx_mut) next_r.a112;
  mark_test_run 1563;
  let test = eq r expected in
  if not test then failwithf "test 1563 failed";
  mark_test_run 1564;
  let test = sub_eq (get_idx_mut r ((.a112) : (t112, _) idx_mut)) next_r.a112 in
  if not test then failwithf "test 1564 failed";
  (******************************)
  (*   t113 = { int64#; int }   *)
  (******************************)
  let eq = (fun ({ a113 = a1131; b113 = b1131 } : t113) ({ a113 = a1132; b113 = b1132 } : t113) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1131 a1132 && (fun a b -> Int.equal a b) b1131 b1132) in
  let r = ({ a113 = #0L; b113 = 1 } : t113) in
  (* Paths of depth 0 *)
  let next_r = ({ a113 = #100L; b113 = 101 } : t113) in
  (* .a113 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a113 = next_r.a113 } in
  set_idx_mut r ((.a113) : (t113, _) idx_mut) next_r.a113;
  mark_test_run 1565;
  let test = eq r expected in
  if not test then failwithf "test 1565 failed";
  mark_test_run 1566;
  let test = sub_eq (get_idx_mut r ((.a113) : (t113, _) idx_mut)) next_r.a113 in
  if not test then failwithf "test 1566 failed";
  let r = ({ a113 = #0L; b113 = 1 } : t113) in
  (* Paths of depth 0 *)
  let next_r = ({ a113 = #100L; b113 = 101 } : t113) in
  (* .b113 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b113 = next_r.b113 } in
  set_idx_mut r ((.b113) : (t113, _) idx_mut) next_r.b113;
  mark_test_run 1567;
  let test = eq r expected in
  if not test then failwithf "test 1567 failed";
  mark_test_run 1568;
  let test = sub_eq (get_idx_mut r ((.b113) : (t113, _) idx_mut)) next_r.b113 in
  if not test then failwithf "test 1568 failed";
  (********************************)
  (*   t114 = { int64#; int64 }   *)
  (********************************)
  let eq = (fun ({ a114 = a1141; b114 = b1141 } : t114) ({ a114 = a1142; b114 = b1142 } : t114) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1141 a1142 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1141 b1142) in
  let r = ({ a114 = #0L; b114 = 1L } : t114) in
  (* Paths of depth 0 *)
  let next_r = ({ a114 = #100L; b114 = 101L } : t114) in
  (* .a114 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a114 = next_r.a114 } in
  set_idx_mut r ((.a114) : (t114, _) idx_mut) next_r.a114;
  mark_test_run 1569;
  let test = eq r expected in
  if not test then failwithf "test 1569 failed";
  mark_test_run 1570;
  let test = sub_eq (get_idx_mut r ((.a114) : (t114, _) idx_mut)) next_r.a114 in
  if not test then failwithf "test 1570 failed";
  let r = ({ a114 = #0L; b114 = 1L } : t114) in
  (* Paths of depth 0 *)
  let next_r = ({ a114 = #100L; b114 = 101L } : t114) in
  (* .b114 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b114 = next_r.b114 } in
  set_idx_mut r ((.b114) : (t114, _) idx_mut) next_r.b114;
  mark_test_run 1571;
  let test = eq r expected in
  if not test then failwithf "test 1571 failed";
  mark_test_run 1572;
  let test = sub_eq (get_idx_mut r ((.b114) : (t114, _) idx_mut)) next_r.b114 in
  if not test then failwithf "test 1572 failed";
  (*********************************)
  (*   t115 = { int64#; int64# }   *)
  (*********************************)
  let eq = (fun ({ a115 = a1151; b115 = b1151 } : t115) ({ a115 = a1152; b115 = b1152 } : t115) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1151 a1152 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1151 b1152) in
  let r = ({ a115 = #0L; b115 = #1L } : t115) in
  (* Paths of depth 0 *)
  let next_r = ({ a115 = #100L; b115 = #101L } : t115) in
  (* .a115 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a115 = next_r.a115 } in
  set_idx_mut r ((.a115) : (t115, _) idx_mut) next_r.a115;
  mark_test_run 1573;
  let test = eq r expected in
  if not test then failwithf "test 1573 failed";
  mark_test_run 1574;
  let test = sub_eq (get_idx_mut r ((.a115) : (t115, _) idx_mut)) next_r.a115 in
  if not test then failwithf "test 1574 failed";
  let r = ({ a115 = #0L; b115 = #1L } : t115) in
  (* Paths of depth 0 *)
  let next_r = ({ a115 = #100L; b115 = #101L } : t115) in
  (* .b115 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b115 = next_r.b115 } in
  set_idx_mut r ((.b115) : (t115, _) idx_mut) next_r.b115;
  mark_test_run 1575;
  let test = eq r expected in
  if not test then failwithf "test 1575 failed";
  mark_test_run 1576;
  let test = sub_eq (get_idx_mut r ((.b115) : (t115, _) idx_mut)) next_r.b115 in
  if not test then failwithf "test 1576 failed";
  (*********************************)
  (*   t116 = { int64#; int32# }   *)
  (*********************************)
  let eq = (fun ({ a116 = a1161; b116 = b1161 } : t116) ({ a116 = a1162; b116 = b1162 } : t116) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1161 a1162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1161 b1162) in
  let r = ({ a116 = #0L; b116 = #1l } : t116) in
  (* Paths of depth 0 *)
  let next_r = ({ a116 = #100L; b116 = #101l } : t116) in
  (* .a116 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a116 = next_r.a116 } in
  set_idx_mut r ((.a116) : (t116, _) idx_mut) next_r.a116;
  mark_test_run 1577;
  let test = eq r expected in
  if not test then failwithf "test 1577 failed";
  mark_test_run 1578;
  let test = sub_eq (get_idx_mut r ((.a116) : (t116, _) idx_mut)) next_r.a116 in
  if not test then failwithf "test 1578 failed";
  let r = ({ a116 = #0L; b116 = #1l } : t116) in
  (* Paths of depth 0 *)
  let next_r = ({ a116 = #100L; b116 = #101l } : t116) in
  (* .b116 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b116 = next_r.b116 } in
  set_idx_mut r ((.b116) : (t116, _) idx_mut) next_r.b116;
  mark_test_run 1579;
  let test = eq r expected in
  if not test then failwithf "test 1579 failed";
  mark_test_run 1580;
  let test = sub_eq (get_idx_mut r ((.b116) : (t116, _) idx_mut)) next_r.b116 in
  if not test then failwithf "test 1580 failed";
  (*************************************)
  (*   t117 = { int64#; nativeint# }   *)
  (*************************************)
  let eq = (fun ({ a117 = a1171; b117 = b1171 } : t117) ({ a117 = a1172; b117 = b1172 } : t117) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1171 a1172 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1171 b1172) in
  let r = ({ a117 = #0L; b117 = #1n } : t117) in
  (* Paths of depth 0 *)
  let next_r = ({ a117 = #100L; b117 = #101n } : t117) in
  (* .a117 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a117 = next_r.a117 } in
  set_idx_mut r ((.a117) : (t117, _) idx_mut) next_r.a117;
  mark_test_run 1581;
  let test = eq r expected in
  if not test then failwithf "test 1581 failed";
  mark_test_run 1582;
  let test = sub_eq (get_idx_mut r ((.a117) : (t117, _) idx_mut)) next_r.a117 in
  if not test then failwithf "test 1582 failed";
  let r = ({ a117 = #0L; b117 = #1n } : t117) in
  (* Paths of depth 0 *)
  let next_r = ({ a117 = #100L; b117 = #101n } : t117) in
  (* .b117 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b117 = next_r.b117 } in
  set_idx_mut r ((.b117) : (t117, _) idx_mut) next_r.b117;
  mark_test_run 1583;
  let test = eq r expected in
  if not test then failwithf "test 1583 failed";
  mark_test_run 1584;
  let test = sub_eq (get_idx_mut r ((.b117) : (t117, _) idx_mut)) next_r.b117 in
  if not test then failwithf "test 1584 failed";
  (********************************)
  (*   t118 = { int64#; float }   *)
  (********************************)
  let eq = (fun ({ a118 = a1181; b118 = b1181 } : t118) ({ a118 = a1182; b118 = b1182 } : t118) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1181 a1182 && (fun a b -> Float.equal (globalize a) (globalize b)) b1181 b1182) in
  let r = ({ a118 = #0L; b118 = 1. } : t118) in
  (* Paths of depth 0 *)
  let next_r = ({ a118 = #100L; b118 = 101. } : t118) in
  (* .a118 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a118 = next_r.a118 } in
  set_idx_mut r ((.a118) : (t118, _) idx_mut) next_r.a118;
  mark_test_run 1585;
  let test = eq r expected in
  if not test then failwithf "test 1585 failed";
  mark_test_run 1586;
  let test = sub_eq (get_idx_mut r ((.a118) : (t118, _) idx_mut)) next_r.a118 in
  if not test then failwithf "test 1586 failed";
  let r = ({ a118 = #0L; b118 = 1. } : t118) in
  (* Paths of depth 0 *)
  let next_r = ({ a118 = #100L; b118 = 101. } : t118) in
  (* .b118 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b118 = next_r.b118 } in
  set_idx_mut r ((.b118) : (t118, _) idx_mut) next_r.b118;
  mark_test_run 1587;
  let test = eq r expected in
  if not test then failwithf "test 1587 failed";
  mark_test_run 1588;
  let test = sub_eq (get_idx_mut r ((.b118) : (t118, _) idx_mut)) next_r.b118 in
  if not test then failwithf "test 1588 failed";
  (*************************)
  (*   t119 = { int32# }   *)
  (*************************)
  let eq = (fun ({ a119 = a1191 } : t119) ({ a119 = a1192 } : t119) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1191 a1192) in
  let r = ({ a119 = #0l } : t119) in
  (* Paths of depth 0 *)
  let next_r = ({ a119 = #100l } : t119) in
  (* .a119 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a119 = next_r.a119 } in
  set_idx_mut r ((.a119) : (t119, _) idx_mut) next_r.a119;
  mark_test_run 1589;
  let test = eq r expected in
  if not test then failwithf "test 1589 failed";
  mark_test_run 1590;
  let test = sub_eq (get_idx_mut r ((.a119) : (t119, _) idx_mut)) next_r.a119 in
  if not test then failwithf "test 1590 failed";
  (******************************)
  (*   t120 = { int32#; int }   *)
  (******************************)
  let eq = (fun ({ a120 = a1201; b120 = b1201 } : t120) ({ a120 = a1202; b120 = b1202 } : t120) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1201 a1202 && (fun a b -> Int.equal a b) b1201 b1202) in
  let r = ({ a120 = #0l; b120 = 1 } : t120) in
  (* Paths of depth 0 *)
  let next_r = ({ a120 = #100l; b120 = 101 } : t120) in
  (* .a120 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a120 = next_r.a120 } in
  set_idx_mut r ((.a120) : (t120, _) idx_mut) next_r.a120;
  mark_test_run 1591;
  let test = eq r expected in
  if not test then failwithf "test 1591 failed";
  mark_test_run 1592;
  let test = sub_eq (get_idx_mut r ((.a120) : (t120, _) idx_mut)) next_r.a120 in
  if not test then failwithf "test 1592 failed";
  let r = ({ a120 = #0l; b120 = 1 } : t120) in
  (* Paths of depth 0 *)
  let next_r = ({ a120 = #100l; b120 = 101 } : t120) in
  (* .b120 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b120 = next_r.b120 } in
  set_idx_mut r ((.b120) : (t120, _) idx_mut) next_r.b120;
  mark_test_run 1593;
  let test = eq r expected in
  if not test then failwithf "test 1593 failed";
  mark_test_run 1594;
  let test = sub_eq (get_idx_mut r ((.b120) : (t120, _) idx_mut)) next_r.b120 in
  if not test then failwithf "test 1594 failed";
  (***********************************)
  (*   t121 = { int32#; int; int }   *)
  (***********************************)
  let eq = (fun ({ a121 = a1211; b121 = b1211; c121 = c1211 } : t121) ({ a121 = a1212; b121 = b1212; c121 = c1212 } : t121) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1211 a1212 && (fun a b -> Int.equal a b) b1211 b1212 && (fun a b -> Int.equal a b) c1211 c1212) in
  let r = ({ a121 = #0l; b121 = 1; c121 = 2 } : t121) in
  (* Paths of depth 0 *)
  let next_r = ({ a121 = #100l; b121 = 101; c121 = 102 } : t121) in
  (* .a121 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a121 = next_r.a121 } in
  set_idx_mut r ((.a121) : (t121, _) idx_mut) next_r.a121;
  mark_test_run 1595;
  let test = eq r expected in
  if not test then failwithf "test 1595 failed";
  mark_test_run 1596;
  let test = sub_eq (get_idx_mut r ((.a121) : (t121, _) idx_mut)) next_r.a121 in
  if not test then failwithf "test 1596 failed";
  let r = ({ a121 = #0l; b121 = 1; c121 = 2 } : t121) in
  (* Paths of depth 0 *)
  let next_r = ({ a121 = #100l; b121 = 101; c121 = 102 } : t121) in
  (* .b121 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b121 = next_r.b121 } in
  set_idx_mut r ((.b121) : (t121, _) idx_mut) next_r.b121;
  mark_test_run 1597;
  let test = eq r expected in
  if not test then failwithf "test 1597 failed";
  mark_test_run 1598;
  let test = sub_eq (get_idx_mut r ((.b121) : (t121, _) idx_mut)) next_r.b121 in
  if not test then failwithf "test 1598 failed";
  let r = ({ a121 = #0l; b121 = 1; c121 = 2 } : t121) in
  (* Paths of depth 0 *)
  let next_r = ({ a121 = #100l; b121 = 101; c121 = 102 } : t121) in
  (* .c121 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c121 = next_r.c121 } in
  set_idx_mut r ((.c121) : (t121, _) idx_mut) next_r.c121;
  mark_test_run 1599;
  let test = eq r expected in
  if not test then failwithf "test 1599 failed";
  mark_test_run 1600;
  let test = sub_eq (get_idx_mut r ((.c121) : (t121, _) idx_mut)) next_r.c121 in
  if not test then failwithf "test 1600 failed";
  (**************************************)
  (*   t122 = { int32#; int; int32# }   *)
  (**************************************)
  let eq = (fun ({ a122 = a1221; b122 = b1221; c122 = c1221 } : t122) ({ a122 = a1222; b122 = b1222; c122 = c1222 } : t122) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1221 a1222 && (fun a b -> Int.equal a b) b1221 b1222 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c1221 c1222) in
  let r = ({ a122 = #0l; b122 = 1; c122 = #2l } : t122) in
  (* Paths of depth 0 *)
  let next_r = ({ a122 = #100l; b122 = 101; c122 = #102l } : t122) in
  (* .a122 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a122 = next_r.a122 } in
  set_idx_mut r ((.a122) : (t122, _) idx_mut) next_r.a122;
  mark_test_run 1601;
  let test = eq r expected in
  if not test then failwithf "test 1601 failed";
  mark_test_run 1602;
  let test = sub_eq (get_idx_mut r ((.a122) : (t122, _) idx_mut)) next_r.a122 in
  if not test then failwithf "test 1602 failed";
  let r = ({ a122 = #0l; b122 = 1; c122 = #2l } : t122) in
  (* Paths of depth 0 *)
  let next_r = ({ a122 = #100l; b122 = 101; c122 = #102l } : t122) in
  (* .b122 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b122 = next_r.b122 } in
  set_idx_mut r ((.b122) : (t122, _) idx_mut) next_r.b122;
  mark_test_run 1603;
  let test = eq r expected in
  if not test then failwithf "test 1603 failed";
  mark_test_run 1604;
  let test = sub_eq (get_idx_mut r ((.b122) : (t122, _) idx_mut)) next_r.b122 in
  if not test then failwithf "test 1604 failed";
  let r = ({ a122 = #0l; b122 = 1; c122 = #2l } : t122) in
  (* Paths of depth 0 *)
  let next_r = ({ a122 = #100l; b122 = 101; c122 = #102l } : t122) in
  (* .c122 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c122 = next_r.c122 } in
  set_idx_mut r ((.c122) : (t122, _) idx_mut) next_r.c122;
  mark_test_run 1605;
  let test = eq r expected in
  if not test then failwithf "test 1605 failed";
  mark_test_run 1606;
  let test = sub_eq (get_idx_mut r ((.c122) : (t122, _) idx_mut)) next_r.c122 in
  if not test then failwithf "test 1606 failed";
  (********************************)
  (*   t123 = { int32#; int64 }   *)
  (********************************)
  let eq = (fun ({ a123 = a1231; b123 = b1231 } : t123) ({ a123 = a1232; b123 = b1232 } : t123) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1231 a1232 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1231 b1232) in
  let r = ({ a123 = #0l; b123 = 1L } : t123) in
  (* Paths of depth 0 *)
  let next_r = ({ a123 = #100l; b123 = 101L } : t123) in
  (* .a123 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a123 = next_r.a123 } in
  set_idx_mut r ((.a123) : (t123, _) idx_mut) next_r.a123;
  mark_test_run 1607;
  let test = eq r expected in
  if not test then failwithf "test 1607 failed";
  mark_test_run 1608;
  let test = sub_eq (get_idx_mut r ((.a123) : (t123, _) idx_mut)) next_r.a123 in
  if not test then failwithf "test 1608 failed";
  let r = ({ a123 = #0l; b123 = 1L } : t123) in
  (* Paths of depth 0 *)
  let next_r = ({ a123 = #100l; b123 = 101L } : t123) in
  (* .b123 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b123 = next_r.b123 } in
  set_idx_mut r ((.b123) : (t123, _) idx_mut) next_r.b123;
  mark_test_run 1609;
  let test = eq r expected in
  if not test then failwithf "test 1609 failed";
  mark_test_run 1610;
  let test = sub_eq (get_idx_mut r ((.b123) : (t123, _) idx_mut)) next_r.b123 in
  if not test then failwithf "test 1610 failed";
  (*********************************)
  (*   t124 = { int32#; int64# }   *)
  (*********************************)
  let eq = (fun ({ a124 = a1241; b124 = b1241 } : t124) ({ a124 = a1242; b124 = b1242 } : t124) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1241 a1242 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1241 b1242) in
  let r = ({ a124 = #0l; b124 = #1L } : t124) in
  (* Paths of depth 0 *)
  let next_r = ({ a124 = #100l; b124 = #101L } : t124) in
  (* .a124 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a124 = next_r.a124 } in
  set_idx_mut r ((.a124) : (t124, _) idx_mut) next_r.a124;
  mark_test_run 1611;
  let test = eq r expected in
  if not test then failwithf "test 1611 failed";
  mark_test_run 1612;
  let test = sub_eq (get_idx_mut r ((.a124) : (t124, _) idx_mut)) next_r.a124 in
  if not test then failwithf "test 1612 failed";
  let r = ({ a124 = #0l; b124 = #1L } : t124) in
  (* Paths of depth 0 *)
  let next_r = ({ a124 = #100l; b124 = #101L } : t124) in
  (* .b124 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b124 = next_r.b124 } in
  set_idx_mut r ((.b124) : (t124, _) idx_mut) next_r.b124;
  mark_test_run 1613;
  let test = eq r expected in
  if not test then failwithf "test 1613 failed";
  mark_test_run 1614;
  let test = sub_eq (get_idx_mut r ((.b124) : (t124, _) idx_mut)) next_r.b124 in
  if not test then failwithf "test 1614 failed";
  (*********************************)
  (*   t125 = { int32#; int32# }   *)
  (*********************************)
  let eq = (fun ({ a125 = a1251; b125 = b1251 } : t125) ({ a125 = a1252; b125 = b1252 } : t125) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1251 a1252 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1251 b1252) in
  let r = ({ a125 = #0l; b125 = #1l } : t125) in
  (* Paths of depth 0 *)
  let next_r = ({ a125 = #100l; b125 = #101l } : t125) in
  (* .a125 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a125 = next_r.a125 } in
  set_idx_mut r ((.a125) : (t125, _) idx_mut) next_r.a125;
  mark_test_run 1615;
  let test = eq r expected in
  if not test then failwithf "test 1615 failed";
  mark_test_run 1616;
  let test = sub_eq (get_idx_mut r ((.a125) : (t125, _) idx_mut)) next_r.a125 in
  if not test then failwithf "test 1616 failed";
  let r = ({ a125 = #0l; b125 = #1l } : t125) in
  (* Paths of depth 0 *)
  let next_r = ({ a125 = #100l; b125 = #101l } : t125) in
  (* .b125 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b125 = next_r.b125 } in
  set_idx_mut r ((.b125) : (t125, _) idx_mut) next_r.b125;
  mark_test_run 1617;
  let test = eq r expected in
  if not test then failwithf "test 1617 failed";
  mark_test_run 1618;
  let test = sub_eq (get_idx_mut r ((.b125) : (t125, _) idx_mut)) next_r.b125 in
  if not test then failwithf "test 1618 failed";
  (**************************************)
  (*   t126 = { int32#; int32#; int }   *)
  (**************************************)
  let eq = (fun ({ a126 = a1261; b126 = b1261; c126 = c1261 } : t126) ({ a126 = a1262; b126 = b1262; c126 = c1262 } : t126) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1261 a1262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1261 b1262 && (fun a b -> Int.equal a b) c1261 c1262) in
  let r = ({ a126 = #0l; b126 = #1l; c126 = 2 } : t126) in
  (* Paths of depth 0 *)
  let next_r = ({ a126 = #100l; b126 = #101l; c126 = 102 } : t126) in
  (* .a126 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a126 = next_r.a126 } in
  set_idx_mut r ((.a126) : (t126, _) idx_mut) next_r.a126;
  mark_test_run 1619;
  let test = eq r expected in
  if not test then failwithf "test 1619 failed";
  mark_test_run 1620;
  let test = sub_eq (get_idx_mut r ((.a126) : (t126, _) idx_mut)) next_r.a126 in
  if not test then failwithf "test 1620 failed";
  let r = ({ a126 = #0l; b126 = #1l; c126 = 2 } : t126) in
  (* Paths of depth 0 *)
  let next_r = ({ a126 = #100l; b126 = #101l; c126 = 102 } : t126) in
  (* .b126 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b126 = next_r.b126 } in
  set_idx_mut r ((.b126) : (t126, _) idx_mut) next_r.b126;
  mark_test_run 1621;
  let test = eq r expected in
  if not test then failwithf "test 1621 failed";
  mark_test_run 1622;
  let test = sub_eq (get_idx_mut r ((.b126) : (t126, _) idx_mut)) next_r.b126 in
  if not test then failwithf "test 1622 failed";
  let r = ({ a126 = #0l; b126 = #1l; c126 = 2 } : t126) in
  (* Paths of depth 0 *)
  let next_r = ({ a126 = #100l; b126 = #101l; c126 = 102 } : t126) in
  (* .c126 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c126 = next_r.c126 } in
  set_idx_mut r ((.c126) : (t126, _) idx_mut) next_r.c126;
  mark_test_run 1623;
  let test = eq r expected in
  if not test then failwithf "test 1623 failed";
  mark_test_run 1624;
  let test = sub_eq (get_idx_mut r ((.c126) : (t126, _) idx_mut)) next_r.c126 in
  if not test then failwithf "test 1624 failed";
  (*****************************************)
  (*   t127 = { int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun ({ a127 = a1271; b127 = b1271; c127 = c1271 } : t127) ({ a127 = a1272; b127 = b1272; c127 = c1272 } : t127) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1271 a1272 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1271 b1272 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c1271 c1272) in
  let r = ({ a127 = #0l; b127 = #1l; c127 = #2l } : t127) in
  (* Paths of depth 0 *)
  let next_r = ({ a127 = #100l; b127 = #101l; c127 = #102l } : t127) in
  (* .a127 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a127 = next_r.a127 } in
  set_idx_mut r ((.a127) : (t127, _) idx_mut) next_r.a127;
  mark_test_run 1625;
  let test = eq r expected in
  if not test then failwithf "test 1625 failed";
  mark_test_run 1626;
  let test = sub_eq (get_idx_mut r ((.a127) : (t127, _) idx_mut)) next_r.a127 in
  if not test then failwithf "test 1626 failed";
  let r = ({ a127 = #0l; b127 = #1l; c127 = #2l } : t127) in
  (* Paths of depth 0 *)
  let next_r = ({ a127 = #100l; b127 = #101l; c127 = #102l } : t127) in
  (* .b127 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b127 = next_r.b127 } in
  set_idx_mut r ((.b127) : (t127, _) idx_mut) next_r.b127;
  mark_test_run 1627;
  let test = eq r expected in
  if not test then failwithf "test 1627 failed";
  mark_test_run 1628;
  let test = sub_eq (get_idx_mut r ((.b127) : (t127, _) idx_mut)) next_r.b127 in
  if not test then failwithf "test 1628 failed";
  let r = ({ a127 = #0l; b127 = #1l; c127 = #2l } : t127) in
  (* Paths of depth 0 *)
  let next_r = ({ a127 = #100l; b127 = #101l; c127 = #102l } : t127) in
  (* .c127 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c127 = next_r.c127 } in
  set_idx_mut r ((.c127) : (t127, _) idx_mut) next_r.c127;
  mark_test_run 1629;
  let test = eq r expected in
  if not test then failwithf "test 1629 failed";
  mark_test_run 1630;
  let test = sub_eq (get_idx_mut r ((.c127) : (t127, _) idx_mut)) next_r.c127 in
  if not test then failwithf "test 1630 failed";
  (*************************************)
  (*   t128 = { int32#; nativeint# }   *)
  (*************************************)
  let eq = (fun ({ a128 = a1281; b128 = b1281 } : t128) ({ a128 = a1282; b128 = b1282 } : t128) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1281 a1282 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1281 b1282) in
  let r = ({ a128 = #0l; b128 = #1n } : t128) in
  (* Paths of depth 0 *)
  let next_r = ({ a128 = #100l; b128 = #101n } : t128) in
  (* .a128 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a128 = next_r.a128 } in
  set_idx_mut r ((.a128) : (t128, _) idx_mut) next_r.a128;
  mark_test_run 1631;
  let test = eq r expected in
  if not test then failwithf "test 1631 failed";
  mark_test_run 1632;
  let test = sub_eq (get_idx_mut r ((.a128) : (t128, _) idx_mut)) next_r.a128 in
  if not test then failwithf "test 1632 failed";
  let r = ({ a128 = #0l; b128 = #1n } : t128) in
  (* Paths of depth 0 *)
  let next_r = ({ a128 = #100l; b128 = #101n } : t128) in
  (* .b128 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b128 = next_r.b128 } in
  set_idx_mut r ((.b128) : (t128, _) idx_mut) next_r.b128;
  mark_test_run 1633;
  let test = eq r expected in
  if not test then failwithf "test 1633 failed";
  mark_test_run 1634;
  let test = sub_eq (get_idx_mut r ((.b128) : (t128, _) idx_mut)) next_r.b128 in
  if not test then failwithf "test 1634 failed";
  (********************************)
  (*   t129 = { int32#; float }   *)
  (********************************)
  let eq = (fun ({ a129 = a1291; b129 = b1291 } : t129) ({ a129 = a1292; b129 = b1292 } : t129) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1291 a1292 && (fun a b -> Float.equal (globalize a) (globalize b)) b1291 b1292) in
  let r = ({ a129 = #0l; b129 = 1. } : t129) in
  (* Paths of depth 0 *)
  let next_r = ({ a129 = #100l; b129 = 101. } : t129) in
  (* .a129 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a129 = next_r.a129 } in
  set_idx_mut r ((.a129) : (t129, _) idx_mut) next_r.a129;
  mark_test_run 1635;
  let test = eq r expected in
  if not test then failwithf "test 1635 failed";
  mark_test_run 1636;
  let test = sub_eq (get_idx_mut r ((.a129) : (t129, _) idx_mut)) next_r.a129 in
  if not test then failwithf "test 1636 failed";
  let r = ({ a129 = #0l; b129 = 1. } : t129) in
  (* Paths of depth 0 *)
  let next_r = ({ a129 = #100l; b129 = 101. } : t129) in
  (* .b129 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b129 = next_r.b129 } in
  set_idx_mut r ((.b129) : (t129, _) idx_mut) next_r.b129;
  mark_test_run 1637;
  let test = eq r expected in
  if not test then failwithf "test 1637 failed";
  mark_test_run 1638;
  let test = sub_eq (get_idx_mut r ((.b129) : (t129, _) idx_mut)) next_r.b129 in
  if not test then failwithf "test 1638 failed";
  (***********************************)
  (*   t130 = { int32#; #{ int } }   *)
  (***********************************)
  let eq = (fun ({ a130 = a1301; b130 = b1301 } : t130) ({ a130 = a1302; b130 = b1302 } : t130) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1301 a1302 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b1301 b1302) in
  let r = ({ a130 = #0l; b130 = (#{ a0 = 1 } : t0) } : t130) in
  (* Paths of depth 0 *)
  let next_r = ({ a130 = #100l; b130 = (#{ a0 = 101 } : t0) } : t130) in
  (* .a130 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a130 = next_r.a130 } in
  set_idx_mut r ((.a130) : (t130, _) idx_mut) next_r.a130;
  mark_test_run 1639;
  let test = eq r expected in
  if not test then failwithf "test 1639 failed";
  mark_test_run 1640;
  let test = sub_eq (get_idx_mut r ((.a130) : (t130, _) idx_mut)) next_r.a130 in
  if not test then failwithf "test 1640 failed";
  let r = ({ a130 = #0l; b130 = (#{ a0 = 1 } : t0) } : t130) in
  (* Paths of depth 0 *)
  let next_r = ({ a130 = #100l; b130 = (#{ a0 = 101 } : t0) } : t130) in
  (* .b130 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with b130 = next_r.b130 } in
  set_idx_mut r ((.b130) : (t130, _) idx_mut) next_r.b130;
  mark_test_run 1641;
  let test = eq r expected in
  if not test then failwithf "test 1641 failed";
  mark_test_run 1642;
  let test = sub_eq (get_idx_mut r ((.b130) : (t130, _) idx_mut)) next_r.b130 in
  if not test then failwithf "test 1642 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a130 = #200l; b130 = (#{ a0 = 201 } : t0) } : t130) in
  (* .b130.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b130 = #{ r.b130 with a0 = next_r.b130.#a0 } } in
  set_idx_mut r ((.b130.#a0) : (t130, _) idx_mut) next_r.b130.#a0;
  mark_test_run 1643;
  let test = eq r expected in
  if not test then failwithf "test 1643 failed";
  mark_test_run 1644;
  let test = sub_eq (get_idx_mut r ((.b130.#a0) : (t130, _) idx_mut)) next_r.b130.#a0 in
  if not test then failwithf "test 1644 failed";
  (****************************************)
  (*   t131 = { int32#; #{ int; int } }   *)
  (****************************************)
  let eq = (fun ({ a131 = a1311; b131 = b1311 } : t131) ({ a131 = a1312; b131 = b1312 } : t131) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1311 a1312 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b1311 b1312) in
  let r = ({ a131 = #0l; b131 = (#{ a1 = 1; b1 = 2 } : t1) } : t131) in
  (* Paths of depth 0 *)
  let next_r = ({ a131 = #100l; b131 = (#{ a1 = 101; b1 = 102 } : t1) } : t131) in
  (* .a131 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a131 = next_r.a131 } in
  set_idx_mut r ((.a131) : (t131, _) idx_mut) next_r.a131;
  mark_test_run 1645;
  let test = eq r expected in
  if not test then failwithf "test 1645 failed";
  mark_test_run 1646;
  let test = sub_eq (get_idx_mut r ((.a131) : (t131, _) idx_mut)) next_r.a131 in
  if not test then failwithf "test 1646 failed";
  let r = ({ a131 = #0l; b131 = (#{ a1 = 1; b1 = 2 } : t1) } : t131) in
  (* Paths of depth 0 *)
  let next_r = ({ a131 = #100l; b131 = (#{ a1 = 101; b1 = 102 } : t1) } : t131) in
  (* .b131 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with b131 = next_r.b131 } in
  set_idx_mut r ((.b131) : (t131, _) idx_mut) next_r.b131;
  mark_test_run 1647;
  let test = eq r expected in
  if not test then failwithf "test 1647 failed";
  mark_test_run 1648;
  let test = sub_eq (get_idx_mut r ((.b131) : (t131, _) idx_mut)) next_r.b131 in
  if not test then failwithf "test 1648 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a131 = #200l; b131 = (#{ a1 = 201; b1 = 202 } : t1) } : t131) in
  (* .b131.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b131 = #{ r.b131 with a1 = next_r.b131.#a1 } } in
  set_idx_mut r ((.b131.#a1) : (t131, _) idx_mut) next_r.b131.#a1;
  mark_test_run 1649;
  let test = eq r expected in
  if not test then failwithf "test 1649 failed";
  mark_test_run 1650;
  let test = sub_eq (get_idx_mut r ((.b131.#a1) : (t131, _) idx_mut)) next_r.b131.#a1 in
  if not test then failwithf "test 1650 failed";
  (* .b131.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b131 = #{ r.b131 with b1 = next_r.b131.#b1 } } in
  set_idx_mut r ((.b131.#b1) : (t131, _) idx_mut) next_r.b131.#b1;
  mark_test_run 1651;
  let test = eq r expected in
  if not test then failwithf "test 1651 failed";
  mark_test_run 1652;
  let test = sub_eq (get_idx_mut r ((.b131.#b1) : (t131, _) idx_mut)) next_r.b131.#b1 in
  if not test then failwithf "test 1652 failed";
  (*******************************************)
  (*   t132 = { int32#; #{ int; int32# } }   *)
  (*******************************************)
  let eq = (fun ({ a132 = a1321; b132 = b1321 } : t132) ({ a132 = a1322; b132 = b1322 } : t132) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1321 a1322 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b1321 b1322) in
  let r = ({ a132 = #0l; b132 = (#{ a7 = 1; b7 = #2l } : t7) } : t132) in
  (* Paths of depth 0 *)
  let next_r = ({ a132 = #100l; b132 = (#{ a7 = 101; b7 = #102l } : t7) } : t132) in
  (* .a132 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a132 = next_r.a132 } in
  set_idx_mut r ((.a132) : (t132, _) idx_mut) next_r.a132;
  mark_test_run 1653;
  let test = eq r expected in
  if not test then failwithf "test 1653 failed";
  mark_test_run 1654;
  let test = sub_eq (get_idx_mut r ((.a132) : (t132, _) idx_mut)) next_r.a132 in
  if not test then failwithf "test 1654 failed";
  let r = ({ a132 = #0l; b132 = (#{ a7 = 1; b7 = #2l } : t7) } : t132) in
  (* Paths of depth 0 *)
  let next_r = ({ a132 = #100l; b132 = (#{ a7 = 101; b7 = #102l } : t7) } : t132) in
  (* .b132 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with b132 = next_r.b132 } in
  set_idx_mut r ((.b132) : (t132, _) idx_mut) next_r.b132;
  mark_test_run 1655;
  let test = eq r expected in
  if not test then failwithf "test 1655 failed";
  mark_test_run 1656;
  let test = sub_eq (get_idx_mut r ((.b132) : (t132, _) idx_mut)) next_r.b132 in
  if not test then failwithf "test 1656 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a132 = #200l; b132 = (#{ a7 = 201; b7 = #202l } : t7) } : t132) in
  (* .b132.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b132 = #{ r.b132 with a7 = next_r.b132.#a7 } } in
  set_idx_mut r ((.b132.#a7) : (t132, _) idx_mut) next_r.b132.#a7;
  mark_test_run 1657;
  let test = eq r expected in
  if not test then failwithf "test 1657 failed";
  mark_test_run 1658;
  let test = sub_eq (get_idx_mut r ((.b132.#a7) : (t132, _) idx_mut)) next_r.b132.#a7 in
  if not test then failwithf "test 1658 failed";
  (* .b132.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b132 = #{ r.b132 with b7 = next_r.b132.#b7 } } in
  set_idx_mut r ((.b132.#b7) : (t132, _) idx_mut) next_r.b132.#b7;
  mark_test_run 1659;
  let test = eq r expected in
  if not test then failwithf "test 1659 failed";
  mark_test_run 1660;
  let test = sub_eq (get_idx_mut r ((.b132.#b7) : (t132, _) idx_mut)) next_r.b132.#b7 in
  if not test then failwithf "test 1660 failed";
  (**************************************)
  (*   t133 = { int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun ({ a133 = a1331; b133 = b1331 } : t133) ({ a133 = a1332; b133 = b1332 } : t133) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1331 a1332 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b1331 b1332) in
  let r = ({ a133 = #0l; b133 = (#{ a17 = #1l } : t17) } : t133) in
  (* Paths of depth 0 *)
  let next_r = ({ a133 = #100l; b133 = (#{ a17 = #101l } : t17) } : t133) in
  (* .a133 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a133 = next_r.a133 } in
  set_idx_mut r ((.a133) : (t133, _) idx_mut) next_r.a133;
  mark_test_run 1661;
  let test = eq r expected in
  if not test then failwithf "test 1661 failed";
  mark_test_run 1662;
  let test = sub_eq (get_idx_mut r ((.a133) : (t133, _) idx_mut)) next_r.a133 in
  if not test then failwithf "test 1662 failed";
  let r = ({ a133 = #0l; b133 = (#{ a17 = #1l } : t17) } : t133) in
  (* Paths of depth 0 *)
  let next_r = ({ a133 = #100l; b133 = (#{ a17 = #101l } : t17) } : t133) in
  (* .b133 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with b133 = next_r.b133 } in
  set_idx_mut r ((.b133) : (t133, _) idx_mut) next_r.b133;
  mark_test_run 1663;
  let test = eq r expected in
  if not test then failwithf "test 1663 failed";
  mark_test_run 1664;
  let test = sub_eq (get_idx_mut r ((.b133) : (t133, _) idx_mut)) next_r.b133 in
  if not test then failwithf "test 1664 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a133 = #200l; b133 = (#{ a17 = #201l } : t17) } : t133) in
  (* .b133.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b133 = #{ r.b133 with a17 = next_r.b133.#a17 } } in
  set_idx_mut r ((.b133.#a17) : (t133, _) idx_mut) next_r.b133.#a17;
  mark_test_run 1665;
  let test = eq r expected in
  if not test then failwithf "test 1665 failed";
  mark_test_run 1666;
  let test = sub_eq (get_idx_mut r ((.b133.#a17) : (t133, _) idx_mut)) next_r.b133.#a17 in
  if not test then failwithf "test 1666 failed";
  (*******************************************)
  (*   t134 = { int32#; #{ int32#; int } }   *)
  (*******************************************)
  let eq = (fun ({ a134 = a1341; b134 = b1341 } : t134) ({ a134 = a1342; b134 = b1342 } : t134) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1341 a1342 && (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) b1341 b1342) in
  let r = ({ a134 = #0l; b134 = (#{ a99 = #1l; b99 = 2 } : t99) } : t134) in
  (* Paths of depth 0 *)
  let next_r = ({ a134 = #100l; b134 = (#{ a99 = #101l; b99 = 102 } : t99) } : t134) in
  (* .a134 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a134 = next_r.a134 } in
  set_idx_mut r ((.a134) : (t134, _) idx_mut) next_r.a134;
  mark_test_run 1667;
  let test = eq r expected in
  if not test then failwithf "test 1667 failed";
  mark_test_run 1668;
  let test = sub_eq (get_idx_mut r ((.a134) : (t134, _) idx_mut)) next_r.a134 in
  if not test then failwithf "test 1668 failed";
  let r = ({ a134 = #0l; b134 = (#{ a99 = #1l; b99 = 2 } : t99) } : t134) in
  (* Paths of depth 0 *)
  let next_r = ({ a134 = #100l; b134 = (#{ a99 = #101l; b99 = 102 } : t99) } : t134) in
  (* .b134 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with b134 = next_r.b134 } in
  set_idx_mut r ((.b134) : (t134, _) idx_mut) next_r.b134;
  mark_test_run 1669;
  let test = eq r expected in
  if not test then failwithf "test 1669 failed";
  mark_test_run 1670;
  let test = sub_eq (get_idx_mut r ((.b134) : (t134, _) idx_mut)) next_r.b134 in
  if not test then failwithf "test 1670 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a134 = #200l; b134 = (#{ a99 = #201l; b99 = 202 } : t99) } : t134) in
  (* .b134.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b134 = #{ r.b134 with a99 = next_r.b134.#a99 } } in
  set_idx_mut r ((.b134.#a99) : (t134, _) idx_mut) next_r.b134.#a99;
  mark_test_run 1671;
  let test = eq r expected in
  if not test then failwithf "test 1671 failed";
  mark_test_run 1672;
  let test = sub_eq (get_idx_mut r ((.b134.#a99) : (t134, _) idx_mut)) next_r.b134.#a99 in
  if not test then failwithf "test 1672 failed";
  (* .b134.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b134 = #{ r.b134 with b99 = next_r.b134.#b99 } } in
  set_idx_mut r ((.b134.#b99) : (t134, _) idx_mut) next_r.b134.#b99;
  mark_test_run 1673;
  let test = eq r expected in
  if not test then failwithf "test 1673 failed";
  mark_test_run 1674;
  let test = sub_eq (get_idx_mut r ((.b134.#b99) : (t134, _) idx_mut)) next_r.b134.#b99 in
  if not test then failwithf "test 1674 failed";
  (**********************************************)
  (*   t135 = { int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun ({ a135 = a1351; b135 = b1351 } : t135) ({ a135 = a1352; b135 = b1352 } : t135) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1351 a1352 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b1351 b1352) in
  let r = ({ a135 = #0l; b135 = (#{ a19 = #1l; b19 = #2l } : t19) } : t135) in
  (* Paths of depth 0 *)
  let next_r = ({ a135 = #100l; b135 = (#{ a19 = #101l; b19 = #102l } : t19) } : t135) in
  (* .a135 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a135 = next_r.a135 } in
  set_idx_mut r ((.a135) : (t135, _) idx_mut) next_r.a135;
  mark_test_run 1675;
  let test = eq r expected in
  if not test then failwithf "test 1675 failed";
  mark_test_run 1676;
  let test = sub_eq (get_idx_mut r ((.a135) : (t135, _) idx_mut)) next_r.a135 in
  if not test then failwithf "test 1676 failed";
  let r = ({ a135 = #0l; b135 = (#{ a19 = #1l; b19 = #2l } : t19) } : t135) in
  (* Paths of depth 0 *)
  let next_r = ({ a135 = #100l; b135 = (#{ a19 = #101l; b19 = #102l } : t19) } : t135) in
  (* .b135 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with b135 = next_r.b135 } in
  set_idx_mut r ((.b135) : (t135, _) idx_mut) next_r.b135;
  mark_test_run 1677;
  let test = eq r expected in
  if not test then failwithf "test 1677 failed";
  mark_test_run 1678;
  let test = sub_eq (get_idx_mut r ((.b135) : (t135, _) idx_mut)) next_r.b135 in
  if not test then failwithf "test 1678 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a135 = #200l; b135 = (#{ a19 = #201l; b19 = #202l } : t19) } : t135) in
  (* .b135.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b135 = #{ r.b135 with a19 = next_r.b135.#a19 } } in
  set_idx_mut r ((.b135.#a19) : (t135, _) idx_mut) next_r.b135.#a19;
  mark_test_run 1679;
  let test = eq r expected in
  if not test then failwithf "test 1679 failed";
  mark_test_run 1680;
  let test = sub_eq (get_idx_mut r ((.b135.#a19) : (t135, _) idx_mut)) next_r.b135.#a19 in
  if not test then failwithf "test 1680 failed";
  (* .b135.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b135 = #{ r.b135 with b19 = next_r.b135.#b19 } } in
  set_idx_mut r ((.b135.#b19) : (t135, _) idx_mut) next_r.b135.#b19;
  mark_test_run 1681;
  let test = eq r expected in
  if not test then failwithf "test 1681 failed";
  mark_test_run 1682;
  let test = sub_eq (get_idx_mut r ((.b135.#b19) : (t135, _) idx_mut)) next_r.b135.#b19 in
  if not test then failwithf "test 1682 failed";
  (*****************************)
  (*   t136 = { nativeint# }   *)
  (*****************************)
  let eq = (fun ({ a136 = a1361 } : t136) ({ a136 = a1362 } : t136) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1361 a1362) in
  let r = ({ a136 = #0n } : t136) in
  (* Paths of depth 0 *)
  let next_r = ({ a136 = #100n } : t136) in
  (* .a136 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a136 = next_r.a136 } in
  set_idx_mut r ((.a136) : (t136, _) idx_mut) next_r.a136;
  mark_test_run 1683;
  let test = eq r expected in
  if not test then failwithf "test 1683 failed";
  mark_test_run 1684;
  let test = sub_eq (get_idx_mut r ((.a136) : (t136, _) idx_mut)) next_r.a136 in
  if not test then failwithf "test 1684 failed";
  (**********************************)
  (*   t137 = { nativeint#; int }   *)
  (**********************************)
  let eq = (fun ({ a137 = a1371; b137 = b1371 } : t137) ({ a137 = a1372; b137 = b1372 } : t137) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1371 a1372 && (fun a b -> Int.equal a b) b1371 b1372) in
  let r = ({ a137 = #0n; b137 = 1 } : t137) in
  (* Paths of depth 0 *)
  let next_r = ({ a137 = #100n; b137 = 101 } : t137) in
  (* .a137 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a137 = next_r.a137 } in
  set_idx_mut r ((.a137) : (t137, _) idx_mut) next_r.a137;
  mark_test_run 1685;
  let test = eq r expected in
  if not test then failwithf "test 1685 failed";
  mark_test_run 1686;
  let test = sub_eq (get_idx_mut r ((.a137) : (t137, _) idx_mut)) next_r.a137 in
  if not test then failwithf "test 1686 failed";
  let r = ({ a137 = #0n; b137 = 1 } : t137) in
  (* Paths of depth 0 *)
  let next_r = ({ a137 = #100n; b137 = 101 } : t137) in
  (* .b137 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b137 = next_r.b137 } in
  set_idx_mut r ((.b137) : (t137, _) idx_mut) next_r.b137;
  mark_test_run 1687;
  let test = eq r expected in
  if not test then failwithf "test 1687 failed";
  mark_test_run 1688;
  let test = sub_eq (get_idx_mut r ((.b137) : (t137, _) idx_mut)) next_r.b137 in
  if not test then failwithf "test 1688 failed";
  (************************************)
  (*   t138 = { nativeint#; int64 }   *)
  (************************************)
  let eq = (fun ({ a138 = a1381; b138 = b1381 } : t138) ({ a138 = a1382; b138 = b1382 } : t138) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1381 a1382 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1381 b1382) in
  let r = ({ a138 = #0n; b138 = 1L } : t138) in
  (* Paths of depth 0 *)
  let next_r = ({ a138 = #100n; b138 = 101L } : t138) in
  (* .a138 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a138 = next_r.a138 } in
  set_idx_mut r ((.a138) : (t138, _) idx_mut) next_r.a138;
  mark_test_run 1689;
  let test = eq r expected in
  if not test then failwithf "test 1689 failed";
  mark_test_run 1690;
  let test = sub_eq (get_idx_mut r ((.a138) : (t138, _) idx_mut)) next_r.a138 in
  if not test then failwithf "test 1690 failed";
  let r = ({ a138 = #0n; b138 = 1L } : t138) in
  (* Paths of depth 0 *)
  let next_r = ({ a138 = #100n; b138 = 101L } : t138) in
  (* .b138 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b138 = next_r.b138 } in
  set_idx_mut r ((.b138) : (t138, _) idx_mut) next_r.b138;
  mark_test_run 1691;
  let test = eq r expected in
  if not test then failwithf "test 1691 failed";
  mark_test_run 1692;
  let test = sub_eq (get_idx_mut r ((.b138) : (t138, _) idx_mut)) next_r.b138 in
  if not test then failwithf "test 1692 failed";
  (*************************************)
  (*   t139 = { nativeint#; int64# }   *)
  (*************************************)
  let eq = (fun ({ a139 = a1391; b139 = b1391 } : t139) ({ a139 = a1392; b139 = b1392 } : t139) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1391 a1392 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1391 b1392) in
  let r = ({ a139 = #0n; b139 = #1L } : t139) in
  (* Paths of depth 0 *)
  let next_r = ({ a139 = #100n; b139 = #101L } : t139) in
  (* .a139 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a139 = next_r.a139 } in
  set_idx_mut r ((.a139) : (t139, _) idx_mut) next_r.a139;
  mark_test_run 1693;
  let test = eq r expected in
  if not test then failwithf "test 1693 failed";
  mark_test_run 1694;
  let test = sub_eq (get_idx_mut r ((.a139) : (t139, _) idx_mut)) next_r.a139 in
  if not test then failwithf "test 1694 failed";
  let r = ({ a139 = #0n; b139 = #1L } : t139) in
  (* Paths of depth 0 *)
  let next_r = ({ a139 = #100n; b139 = #101L } : t139) in
  (* .b139 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b139 = next_r.b139 } in
  set_idx_mut r ((.b139) : (t139, _) idx_mut) next_r.b139;
  mark_test_run 1695;
  let test = eq r expected in
  if not test then failwithf "test 1695 failed";
  mark_test_run 1696;
  let test = sub_eq (get_idx_mut r ((.b139) : (t139, _) idx_mut)) next_r.b139 in
  if not test then failwithf "test 1696 failed";
  (*************************************)
  (*   t140 = { nativeint#; int32# }   *)
  (*************************************)
  let eq = (fun ({ a140 = a1401; b140 = b1401 } : t140) ({ a140 = a1402; b140 = b1402 } : t140) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1401 a1402 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1401 b1402) in
  let r = ({ a140 = #0n; b140 = #1l } : t140) in
  (* Paths of depth 0 *)
  let next_r = ({ a140 = #100n; b140 = #101l } : t140) in
  (* .a140 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a140 = next_r.a140 } in
  set_idx_mut r ((.a140) : (t140, _) idx_mut) next_r.a140;
  mark_test_run 1697;
  let test = eq r expected in
  if not test then failwithf "test 1697 failed";
  mark_test_run 1698;
  let test = sub_eq (get_idx_mut r ((.a140) : (t140, _) idx_mut)) next_r.a140 in
  if not test then failwithf "test 1698 failed";
  let r = ({ a140 = #0n; b140 = #1l } : t140) in
  (* Paths of depth 0 *)
  let next_r = ({ a140 = #100n; b140 = #101l } : t140) in
  (* .b140 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b140 = next_r.b140 } in
  set_idx_mut r ((.b140) : (t140, _) idx_mut) next_r.b140;
  mark_test_run 1699;
  let test = eq r expected in
  if not test then failwithf "test 1699 failed";
  mark_test_run 1700;
  let test = sub_eq (get_idx_mut r ((.b140) : (t140, _) idx_mut)) next_r.b140 in
  if not test then failwithf "test 1700 failed";
  (*****************************************)
  (*   t141 = { nativeint#; nativeint# }   *)
  (*****************************************)
  let eq = (fun ({ a141 = a1411; b141 = b1411 } : t141) ({ a141 = a1412; b141 = b1412 } : t141) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1411 a1412 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1411 b1412) in
  let r = ({ a141 = #0n; b141 = #1n } : t141) in
  (* Paths of depth 0 *)
  let next_r = ({ a141 = #100n; b141 = #101n } : t141) in
  (* .a141 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a141 = next_r.a141 } in
  set_idx_mut r ((.a141) : (t141, _) idx_mut) next_r.a141;
  mark_test_run 1701;
  let test = eq r expected in
  if not test then failwithf "test 1701 failed";
  mark_test_run 1702;
  let test = sub_eq (get_idx_mut r ((.a141) : (t141, _) idx_mut)) next_r.a141 in
  if not test then failwithf "test 1702 failed";
  let r = ({ a141 = #0n; b141 = #1n } : t141) in
  (* Paths of depth 0 *)
  let next_r = ({ a141 = #100n; b141 = #101n } : t141) in
  (* .b141 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b141 = next_r.b141 } in
  set_idx_mut r ((.b141) : (t141, _) idx_mut) next_r.b141;
  mark_test_run 1703;
  let test = eq r expected in
  if not test then failwithf "test 1703 failed";
  mark_test_run 1704;
  let test = sub_eq (get_idx_mut r ((.b141) : (t141, _) idx_mut)) next_r.b141 in
  if not test then failwithf "test 1704 failed";
  (************************************)
  (*   t142 = { nativeint#; float }   *)
  (************************************)
  let eq = (fun ({ a142 = a1421; b142 = b1421 } : t142) ({ a142 = a1422; b142 = b1422 } : t142) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1421 a1422 && (fun a b -> Float.equal (globalize a) (globalize b)) b1421 b1422) in
  let r = ({ a142 = #0n; b142 = 1. } : t142) in
  (* Paths of depth 0 *)
  let next_r = ({ a142 = #100n; b142 = 101. } : t142) in
  (* .a142 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a142 = next_r.a142 } in
  set_idx_mut r ((.a142) : (t142, _) idx_mut) next_r.a142;
  mark_test_run 1705;
  let test = eq r expected in
  if not test then failwithf "test 1705 failed";
  mark_test_run 1706;
  let test = sub_eq (get_idx_mut r ((.a142) : (t142, _) idx_mut)) next_r.a142 in
  if not test then failwithf "test 1706 failed";
  let r = ({ a142 = #0n; b142 = 1. } : t142) in
  (* Paths of depth 0 *)
  let next_r = ({ a142 = #100n; b142 = 101. } : t142) in
  (* .b142 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b142 = next_r.b142 } in
  set_idx_mut r ((.b142) : (t142, _) idx_mut) next_r.b142;
  mark_test_run 1707;
  let test = eq r expected in
  if not test then failwithf "test 1707 failed";
  mark_test_run 1708;
  let test = sub_eq (get_idx_mut r ((.b142) : (t142, _) idx_mut)) next_r.b142 in
  if not test then failwithf "test 1708 failed";
  (************************)
  (*   t143 = { float }   *)
  (************************)
  let eq = (fun ({ a143 = a1431 } : t143) ({ a143 = a1432 } : t143) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1431 a1432) in
  let r = ({ a143 = 0. } : t143) in
  (* Paths of depth 0 *)
  let next_r = ({ a143 = 100. } : t143) in
  (* .a143 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a143 = next_r.a143 } in
  set_idx_mut r ((.a143) : (t143, _) idx_mut) (Float_u.of_float next_r.a143);
  mark_test_run 1709;
  let test = eq r expected in
  if not test then failwithf "test 1709 failed";
  mark_test_run 1710;
  let test = sub_eq (get_idx_mut r ((.a143) : (t143, _) idx_mut)) (Float_u.of_float next_r.a143) in
  if not test then failwithf "test 1710 failed";
  (*****************************)
  (*   t144 = { float; int }   *)
  (*****************************)
  let eq = (fun ({ a144 = a1441; b144 = b1441 } : t144) ({ a144 = a1442; b144 = b1442 } : t144) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1441 a1442 && (fun a b -> Int.equal a b) b1441 b1442) in
  let r = ({ a144 = 0.; b144 = 1 } : t144) in
  (* Paths of depth 0 *)
  let next_r = ({ a144 = 100.; b144 = 101 } : t144) in
  (* .a144 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a144 = next_r.a144 } in
  set_idx_mut r ((.a144) : (t144, _) idx_mut) next_r.a144;
  mark_test_run 1711;
  let test = eq r expected in
  if not test then failwithf "test 1711 failed";
  mark_test_run 1712;
  let test = sub_eq (get_idx_mut r ((.a144) : (t144, _) idx_mut)) next_r.a144 in
  if not test then failwithf "test 1712 failed";
  let r = ({ a144 = 0.; b144 = 1 } : t144) in
  (* Paths of depth 0 *)
  let next_r = ({ a144 = 100.; b144 = 101 } : t144) in
  (* .b144 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b144 = next_r.b144 } in
  set_idx_mut r ((.b144) : (t144, _) idx_mut) next_r.b144;
  mark_test_run 1713;
  let test = eq r expected in
  if not test then failwithf "test 1713 failed";
  mark_test_run 1714;
  let test = sub_eq (get_idx_mut r ((.b144) : (t144, _) idx_mut)) next_r.b144 in
  if not test then failwithf "test 1714 failed";
  (**********************************)
  (*   t145 = { float; int; int }   *)
  (**********************************)
  let eq = (fun ({ a145 = a1451; b145 = b1451; c145 = c1451 } : t145) ({ a145 = a1452; b145 = b1452; c145 = c1452 } : t145) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1451 a1452 && (fun a b -> Int.equal a b) b1451 b1452 && (fun a b -> Int.equal a b) c1451 c1452) in
  let r = ({ a145 = 0.; b145 = 1; c145 = 2 } : t145) in
  (* Paths of depth 0 *)
  let next_r = ({ a145 = 100.; b145 = 101; c145 = 102 } : t145) in
  (* .a145 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a145 = next_r.a145 } in
  set_idx_mut r ((.a145) : (t145, _) idx_mut) next_r.a145;
  mark_test_run 1715;
  let test = eq r expected in
  if not test then failwithf "test 1715 failed";
  mark_test_run 1716;
  let test = sub_eq (get_idx_mut r ((.a145) : (t145, _) idx_mut)) next_r.a145 in
  if not test then failwithf "test 1716 failed";
  let r = ({ a145 = 0.; b145 = 1; c145 = 2 } : t145) in
  (* Paths of depth 0 *)
  let next_r = ({ a145 = 100.; b145 = 101; c145 = 102 } : t145) in
  (* .b145 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b145 = next_r.b145 } in
  set_idx_mut r ((.b145) : (t145, _) idx_mut) next_r.b145;
  mark_test_run 1717;
  let test = eq r expected in
  if not test then failwithf "test 1717 failed";
  mark_test_run 1718;
  let test = sub_eq (get_idx_mut r ((.b145) : (t145, _) idx_mut)) next_r.b145 in
  if not test then failwithf "test 1718 failed";
  let r = ({ a145 = 0.; b145 = 1; c145 = 2 } : t145) in
  (* Paths of depth 0 *)
  let next_r = ({ a145 = 100.; b145 = 101; c145 = 102 } : t145) in
  (* .c145 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c145 = next_r.c145 } in
  set_idx_mut r ((.c145) : (t145, _) idx_mut) next_r.c145;
  mark_test_run 1719;
  let test = eq r expected in
  if not test then failwithf "test 1719 failed";
  mark_test_run 1720;
  let test = sub_eq (get_idx_mut r ((.c145) : (t145, _) idx_mut)) next_r.c145 in
  if not test then failwithf "test 1720 failed";
  (************************************)
  (*   t146 = { float; int; float }   *)
  (************************************)
  let eq = (fun ({ a146 = a1461; b146 = b1461; c146 = c1461 } : t146) ({ a146 = a1462; b146 = b1462; c146 = c1462 } : t146) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1461 a1462 && (fun a b -> Int.equal a b) b1461 b1462 && (fun a b -> Float.equal (globalize a) (globalize b)) c1461 c1462) in
  let r = ({ a146 = 0.; b146 = 1; c146 = 2. } : t146) in
  (* Paths of depth 0 *)
  let next_r = ({ a146 = 100.; b146 = 101; c146 = 102. } : t146) in
  (* .a146 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a146 = next_r.a146 } in
  set_idx_mut r ((.a146) : (t146, _) idx_mut) next_r.a146;
  mark_test_run 1721;
  let test = eq r expected in
  if not test then failwithf "test 1721 failed";
  mark_test_run 1722;
  let test = sub_eq (get_idx_mut r ((.a146) : (t146, _) idx_mut)) next_r.a146 in
  if not test then failwithf "test 1722 failed";
  let r = ({ a146 = 0.; b146 = 1; c146 = 2. } : t146) in
  (* Paths of depth 0 *)
  let next_r = ({ a146 = 100.; b146 = 101; c146 = 102. } : t146) in
  (* .b146 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b146 = next_r.b146 } in
  set_idx_mut r ((.b146) : (t146, _) idx_mut) next_r.b146;
  mark_test_run 1723;
  let test = eq r expected in
  if not test then failwithf "test 1723 failed";
  mark_test_run 1724;
  let test = sub_eq (get_idx_mut r ((.b146) : (t146, _) idx_mut)) next_r.b146 in
  if not test then failwithf "test 1724 failed";
  let r = ({ a146 = 0.; b146 = 1; c146 = 2. } : t146) in
  (* Paths of depth 0 *)
  let next_r = ({ a146 = 100.; b146 = 101; c146 = 102. } : t146) in
  (* .c146 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with c146 = next_r.c146 } in
  set_idx_mut r ((.c146) : (t146, _) idx_mut) next_r.c146;
  mark_test_run 1725;
  let test = eq r expected in
  if not test then failwithf "test 1725 failed";
  mark_test_run 1726;
  let test = sub_eq (get_idx_mut r ((.c146) : (t146, _) idx_mut)) next_r.c146 in
  if not test then failwithf "test 1726 failed";
  (*******************************)
  (*   t147 = { float; int64 }   *)
  (*******************************)
  let eq = (fun ({ a147 = a1471; b147 = b1471 } : t147) ({ a147 = a1472; b147 = b1472 } : t147) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1471 a1472 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1471 b1472) in
  let r = ({ a147 = 0.; b147 = 1L } : t147) in
  (* Paths of depth 0 *)
  let next_r = ({ a147 = 100.; b147 = 101L } : t147) in
  (* .a147 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a147 = next_r.a147 } in
  set_idx_mut r ((.a147) : (t147, _) idx_mut) next_r.a147;
  mark_test_run 1727;
  let test = eq r expected in
  if not test then failwithf "test 1727 failed";
  mark_test_run 1728;
  let test = sub_eq (get_idx_mut r ((.a147) : (t147, _) idx_mut)) next_r.a147 in
  if not test then failwithf "test 1728 failed";
  let r = ({ a147 = 0.; b147 = 1L } : t147) in
  (* Paths of depth 0 *)
  let next_r = ({ a147 = 100.; b147 = 101L } : t147) in
  (* .b147 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b147 = next_r.b147 } in
  set_idx_mut r ((.b147) : (t147, _) idx_mut) next_r.b147;
  mark_test_run 1729;
  let test = eq r expected in
  if not test then failwithf "test 1729 failed";
  mark_test_run 1730;
  let test = sub_eq (get_idx_mut r ((.b147) : (t147, _) idx_mut)) next_r.b147 in
  if not test then failwithf "test 1730 failed";
  (********************************)
  (*   t148 = { float; int64# }   *)
  (********************************)
  let eq = (fun ({ a148 = a1481; b148 = b1481 } : t148) ({ a148 = a1482; b148 = b1482 } : t148) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1481 a1482 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1481 b1482) in
  let r = ({ a148 = 0.; b148 = #1L } : t148) in
  (* Paths of depth 0 *)
  let next_r = ({ a148 = 100.; b148 = #101L } : t148) in
  (* .a148 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a148 = next_r.a148 } in
  set_idx_mut r ((.a148) : (t148, _) idx_mut) next_r.a148;
  mark_test_run 1731;
  let test = eq r expected in
  if not test then failwithf "test 1731 failed";
  mark_test_run 1732;
  let test = sub_eq (get_idx_mut r ((.a148) : (t148, _) idx_mut)) next_r.a148 in
  if not test then failwithf "test 1732 failed";
  let r = ({ a148 = 0.; b148 = #1L } : t148) in
  (* Paths of depth 0 *)
  let next_r = ({ a148 = 100.; b148 = #101L } : t148) in
  (* .b148 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b148 = next_r.b148 } in
  set_idx_mut r ((.b148) : (t148, _) idx_mut) next_r.b148;
  mark_test_run 1733;
  let test = eq r expected in
  if not test then failwithf "test 1733 failed";
  mark_test_run 1734;
  let test = sub_eq (get_idx_mut r ((.b148) : (t148, _) idx_mut)) next_r.b148 in
  if not test then failwithf "test 1734 failed";
  (********************************)
  (*   t149 = { float; int32# }   *)
  (********************************)
  let eq = (fun ({ a149 = a1491; b149 = b1491 } : t149) ({ a149 = a1492; b149 = b1492 } : t149) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1491 a1492 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1491 b1492) in
  let r = ({ a149 = 0.; b149 = #1l } : t149) in
  (* Paths of depth 0 *)
  let next_r = ({ a149 = 100.; b149 = #101l } : t149) in
  (* .a149 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a149 = next_r.a149 } in
  set_idx_mut r ((.a149) : (t149, _) idx_mut) next_r.a149;
  mark_test_run 1735;
  let test = eq r expected in
  if not test then failwithf "test 1735 failed";
  mark_test_run 1736;
  let test = sub_eq (get_idx_mut r ((.a149) : (t149, _) idx_mut)) next_r.a149 in
  if not test then failwithf "test 1736 failed";
  let r = ({ a149 = 0.; b149 = #1l } : t149) in
  (* Paths of depth 0 *)
  let next_r = ({ a149 = 100.; b149 = #101l } : t149) in
  (* .b149 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b149 = next_r.b149 } in
  set_idx_mut r ((.b149) : (t149, _) idx_mut) next_r.b149;
  mark_test_run 1737;
  let test = eq r expected in
  if not test then failwithf "test 1737 failed";
  mark_test_run 1738;
  let test = sub_eq (get_idx_mut r ((.b149) : (t149, _) idx_mut)) next_r.b149 in
  if not test then failwithf "test 1738 failed";
  (************************************)
  (*   t150 = { float; nativeint# }   *)
  (************************************)
  let eq = (fun ({ a150 = a1501; b150 = b1501 } : t150) ({ a150 = a1502; b150 = b1502 } : t150) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1501 a1502 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1501 b1502) in
  let r = ({ a150 = 0.; b150 = #1n } : t150) in
  (* Paths of depth 0 *)
  let next_r = ({ a150 = 100.; b150 = #101n } : t150) in
  (* .a150 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a150 = next_r.a150 } in
  set_idx_mut r ((.a150) : (t150, _) idx_mut) next_r.a150;
  mark_test_run 1739;
  let test = eq r expected in
  if not test then failwithf "test 1739 failed";
  mark_test_run 1740;
  let test = sub_eq (get_idx_mut r ((.a150) : (t150, _) idx_mut)) next_r.a150 in
  if not test then failwithf "test 1740 failed";
  let r = ({ a150 = 0.; b150 = #1n } : t150) in
  (* Paths of depth 0 *)
  let next_r = ({ a150 = 100.; b150 = #101n } : t150) in
  (* .b150 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b150 = next_r.b150 } in
  set_idx_mut r ((.b150) : (t150, _) idx_mut) next_r.b150;
  mark_test_run 1741;
  let test = eq r expected in
  if not test then failwithf "test 1741 failed";
  mark_test_run 1742;
  let test = sub_eq (get_idx_mut r ((.b150) : (t150, _) idx_mut)) next_r.b150 in
  if not test then failwithf "test 1742 failed";
  (*******************************)
  (*   t151 = { float; float }   *)
  (*******************************)
  let eq = (fun ({ a151 = a1511; b151 = b1511 } : t151) ({ a151 = a1512; b151 = b1512 } : t151) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1511 a1512 && (fun a b -> Float.equal (globalize a) (globalize b)) b1511 b1512) in
  let r = ({ a151 = 0.; b151 = 1. } : t151) in
  (* Paths of depth 0 *)
  let next_r = ({ a151 = 100.; b151 = 101. } : t151) in
  (* .a151 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a151 = next_r.a151 } in
  set_idx_mut r ((.a151) : (t151, _) idx_mut) (Float_u.of_float next_r.a151);
  mark_test_run 1743;
  let test = eq r expected in
  if not test then failwithf "test 1743 failed";
  mark_test_run 1744;
  let test = sub_eq (get_idx_mut r ((.a151) : (t151, _) idx_mut)) (Float_u.of_float next_r.a151) in
  if not test then failwithf "test 1744 failed";
  let r = ({ a151 = 0.; b151 = 1. } : t151) in
  (* Paths of depth 0 *)
  let next_r = ({ a151 = 100.; b151 = 101. } : t151) in
  (* .b151 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b151 = next_r.b151 } in
  set_idx_mut r ((.b151) : (t151, _) idx_mut) (Float_u.of_float next_r.b151);
  mark_test_run 1745;
  let test = eq r expected in
  if not test then failwithf "test 1745 failed";
  mark_test_run 1746;
  let test = sub_eq (get_idx_mut r ((.b151) : (t151, _) idx_mut)) (Float_u.of_float next_r.b151) in
  if not test then failwithf "test 1746 failed";
  (************************************)
  (*   t152 = { float; float; int }   *)
  (************************************)
  let eq = (fun ({ a152 = a1521; b152 = b1521; c152 = c1521 } : t152) ({ a152 = a1522; b152 = b1522; c152 = c1522 } : t152) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1521 a1522 && (fun a b -> Float.equal (globalize a) (globalize b)) b1521 b1522 && (fun a b -> Int.equal a b) c1521 c1522) in
  let r = ({ a152 = 0.; b152 = 1.; c152 = 2 } : t152) in
  (* Paths of depth 0 *)
  let next_r = ({ a152 = 100.; b152 = 101.; c152 = 102 } : t152) in
  (* .a152 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a152 = next_r.a152 } in
  set_idx_mut r ((.a152) : (t152, _) idx_mut) next_r.a152;
  mark_test_run 1747;
  let test = eq r expected in
  if not test then failwithf "test 1747 failed";
  mark_test_run 1748;
  let test = sub_eq (get_idx_mut r ((.a152) : (t152, _) idx_mut)) next_r.a152 in
  if not test then failwithf "test 1748 failed";
  let r = ({ a152 = 0.; b152 = 1.; c152 = 2 } : t152) in
  (* Paths of depth 0 *)
  let next_r = ({ a152 = 100.; b152 = 101.; c152 = 102 } : t152) in
  (* .b152 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b152 = next_r.b152 } in
  set_idx_mut r ((.b152) : (t152, _) idx_mut) next_r.b152;
  mark_test_run 1749;
  let test = eq r expected in
  if not test then failwithf "test 1749 failed";
  mark_test_run 1750;
  let test = sub_eq (get_idx_mut r ((.b152) : (t152, _) idx_mut)) next_r.b152 in
  if not test then failwithf "test 1750 failed";
  let r = ({ a152 = 0.; b152 = 1.; c152 = 2 } : t152) in
  (* Paths of depth 0 *)
  let next_r = ({ a152 = 100.; b152 = 101.; c152 = 102 } : t152) in
  (* .c152 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c152 = next_r.c152 } in
  set_idx_mut r ((.c152) : (t152, _) idx_mut) next_r.c152;
  mark_test_run 1751;
  let test = eq r expected in
  if not test then failwithf "test 1751 failed";
  mark_test_run 1752;
  let test = sub_eq (get_idx_mut r ((.c152) : (t152, _) idx_mut)) next_r.c152 in
  if not test then failwithf "test 1752 failed";
  (**************************************)
  (*   t153 = { float; float; float }   *)
  (**************************************)
  let eq = (fun ({ a153 = a1531; b153 = b1531; c153 = c1531 } : t153) ({ a153 = a1532; b153 = b1532; c153 = c1532 } : t153) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1531 a1532 && (fun a b -> Float.equal (globalize a) (globalize b)) b1531 b1532 && (fun a b -> Float.equal (globalize a) (globalize b)) c1531 c1532) in
  let r = ({ a153 = 0.; b153 = 1.; c153 = 2. } : t153) in
  (* Paths of depth 0 *)
  let next_r = ({ a153 = 100.; b153 = 101.; c153 = 102. } : t153) in
  (* .a153 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a153 = next_r.a153 } in
  set_idx_mut r ((.a153) : (t153, _) idx_mut) (Float_u.of_float next_r.a153);
  mark_test_run 1753;
  let test = eq r expected in
  if not test then failwithf "test 1753 failed";
  mark_test_run 1754;
  let test = sub_eq (get_idx_mut r ((.a153) : (t153, _) idx_mut)) (Float_u.of_float next_r.a153) in
  if not test then failwithf "test 1754 failed";
  let r = ({ a153 = 0.; b153 = 1.; c153 = 2. } : t153) in
  (* Paths of depth 0 *)
  let next_r = ({ a153 = 100.; b153 = 101.; c153 = 102. } : t153) in
  (* .b153 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b153 = next_r.b153 } in
  set_idx_mut r ((.b153) : (t153, _) idx_mut) (Float_u.of_float next_r.b153);
  mark_test_run 1755;
  let test = eq r expected in
  if not test then failwithf "test 1755 failed";
  mark_test_run 1756;
  let test = sub_eq (get_idx_mut r ((.b153) : (t153, _) idx_mut)) (Float_u.of_float next_r.b153) in
  if not test then failwithf "test 1756 failed";
  let r = ({ a153 = 0.; b153 = 1.; c153 = 2. } : t153) in
  (* Paths of depth 0 *)
  let next_r = ({ a153 = 100.; b153 = 101.; c153 = 102. } : t153) in
  (* .c153 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with c153 = next_r.c153 } in
  set_idx_mut r ((.c153) : (t153, _) idx_mut) (Float_u.of_float next_r.c153);
  mark_test_run 1757;
  let test = eq r expected in
  if not test then failwithf "test 1757 failed";
  mark_test_run 1758;
  let test = sub_eq (get_idx_mut r ((.c153) : (t153, _) idx_mut)) (Float_u.of_float next_r.c153) in
  if not test then failwithf "test 1758 failed";
  (**********************************)
  (*   t154 = { float; #{ int } }   *)
  (**********************************)
  let eq = (fun ({ a154 = a1541; b154 = b1541 } : t154) ({ a154 = a1542; b154 = b1542 } : t154) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1541 a1542 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b1541 b1542) in
  let r = ({ a154 = 0.; b154 = (#{ a0 = 1 } : t0) } : t154) in
  (* Paths of depth 0 *)
  let next_r = ({ a154 = 100.; b154 = (#{ a0 = 101 } : t0) } : t154) in
  (* .a154 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a154 = next_r.a154 } in
  set_idx_mut r ((.a154) : (t154, _) idx_mut) next_r.a154;
  mark_test_run 1759;
  let test = eq r expected in
  if not test then failwithf "test 1759 failed";
  mark_test_run 1760;
  let test = sub_eq (get_idx_mut r ((.a154) : (t154, _) idx_mut)) next_r.a154 in
  if not test then failwithf "test 1760 failed";
  let r = ({ a154 = 0.; b154 = (#{ a0 = 1 } : t0) } : t154) in
  (* Paths of depth 0 *)
  let next_r = ({ a154 = 100.; b154 = (#{ a0 = 101 } : t0) } : t154) in
  (* .b154 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with b154 = next_r.b154 } in
  set_idx_mut r ((.b154) : (t154, _) idx_mut) next_r.b154;
  mark_test_run 1761;
  let test = eq r expected in
  if not test then failwithf "test 1761 failed";
  mark_test_run 1762;
  let test = sub_eq (get_idx_mut r ((.b154) : (t154, _) idx_mut)) next_r.b154 in
  if not test then failwithf "test 1762 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a154 = 200.; b154 = (#{ a0 = 201 } : t0) } : t154) in
  (* .b154.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b154 = #{ r.b154 with a0 = next_r.b154.#a0 } } in
  set_idx_mut r ((.b154.#a0) : (t154, _) idx_mut) next_r.b154.#a0;
  mark_test_run 1763;
  let test = eq r expected in
  if not test then failwithf "test 1763 failed";
  mark_test_run 1764;
  let test = sub_eq (get_idx_mut r ((.b154.#a0) : (t154, _) idx_mut)) next_r.b154.#a0 in
  if not test then failwithf "test 1764 failed";
  (***************************************)
  (*   t155 = { float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun ({ a155 = a1551; b155 = b1551 } : t155) ({ a155 = a1552; b155 = b1552 } : t155) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1551 a1552 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b1551 b1552) in
  let r = ({ a155 = 0.; b155 = (#{ a1 = 1; b1 = 2 } : t1) } : t155) in
  (* Paths of depth 0 *)
  let next_r = ({ a155 = 100.; b155 = (#{ a1 = 101; b1 = 102 } : t1) } : t155) in
  (* .a155 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a155 = next_r.a155 } in
  set_idx_mut r ((.a155) : (t155, _) idx_mut) next_r.a155;
  mark_test_run 1765;
  let test = eq r expected in
  if not test then failwithf "test 1765 failed";
  mark_test_run 1766;
  let test = sub_eq (get_idx_mut r ((.a155) : (t155, _) idx_mut)) next_r.a155 in
  if not test then failwithf "test 1766 failed";
  let r = ({ a155 = 0.; b155 = (#{ a1 = 1; b1 = 2 } : t1) } : t155) in
  (* Paths of depth 0 *)
  let next_r = ({ a155 = 100.; b155 = (#{ a1 = 101; b1 = 102 } : t1) } : t155) in
  (* .b155 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with b155 = next_r.b155 } in
  set_idx_mut r ((.b155) : (t155, _) idx_mut) next_r.b155;
  mark_test_run 1767;
  let test = eq r expected in
  if not test then failwithf "test 1767 failed";
  mark_test_run 1768;
  let test = sub_eq (get_idx_mut r ((.b155) : (t155, _) idx_mut)) next_r.b155 in
  if not test then failwithf "test 1768 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a155 = 200.; b155 = (#{ a1 = 201; b1 = 202 } : t1) } : t155) in
  (* .b155.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b155 = #{ r.b155 with a1 = next_r.b155.#a1 } } in
  set_idx_mut r ((.b155.#a1) : (t155, _) idx_mut) next_r.b155.#a1;
  mark_test_run 1769;
  let test = eq r expected in
  if not test then failwithf "test 1769 failed";
  mark_test_run 1770;
  let test = sub_eq (get_idx_mut r ((.b155.#a1) : (t155, _) idx_mut)) next_r.b155.#a1 in
  if not test then failwithf "test 1770 failed";
  (* .b155.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b155 = #{ r.b155 with b1 = next_r.b155.#b1 } } in
  set_idx_mut r ((.b155.#b1) : (t155, _) idx_mut) next_r.b155.#b1;
  mark_test_run 1771;
  let test = eq r expected in
  if not test then failwithf "test 1771 failed";
  mark_test_run 1772;
  let test = sub_eq (get_idx_mut r ((.b155.#b1) : (t155, _) idx_mut)) next_r.b155.#b1 in
  if not test then failwithf "test 1772 failed";
  (*****************************************)
  (*   t156 = { float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun ({ a156 = a1561; b156 = b1561 } : t156) ({ a156 = a1562; b156 = b1562 } : t156) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1561 a1562 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b1561 b1562) in
  let r = ({ a156 = 0.; b156 = (#{ a10 = 1; b10 = 2. } : t10) } : t156) in
  (* Paths of depth 0 *)
  let next_r = ({ a156 = 100.; b156 = (#{ a10 = 101; b10 = 102. } : t10) } : t156) in
  (* .a156 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a156 = next_r.a156 } in
  set_idx_mut r ((.a156) : (t156, _) idx_mut) next_r.a156;
  mark_test_run 1773;
  let test = eq r expected in
  if not test then failwithf "test 1773 failed";
  mark_test_run 1774;
  let test = sub_eq (get_idx_mut r ((.a156) : (t156, _) idx_mut)) next_r.a156 in
  if not test then failwithf "test 1774 failed";
  let r = ({ a156 = 0.; b156 = (#{ a10 = 1; b10 = 2. } : t10) } : t156) in
  (* Paths of depth 0 *)
  let next_r = ({ a156 = 100.; b156 = (#{ a10 = 101; b10 = 102. } : t10) } : t156) in
  (* .b156 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with b156 = next_r.b156 } in
  set_idx_mut r ((.b156) : (t156, _) idx_mut) next_r.b156;
  mark_test_run 1775;
  let test = eq r expected in
  if not test then failwithf "test 1775 failed";
  mark_test_run 1776;
  let test = sub_eq (get_idx_mut r ((.b156) : (t156, _) idx_mut)) next_r.b156 in
  if not test then failwithf "test 1776 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a156 = 200.; b156 = (#{ a10 = 201; b10 = 202. } : t10) } : t156) in
  (* .b156.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b156 = #{ r.b156 with a10 = next_r.b156.#a10 } } in
  set_idx_mut r ((.b156.#a10) : (t156, _) idx_mut) next_r.b156.#a10;
  mark_test_run 1777;
  let test = eq r expected in
  if not test then failwithf "test 1777 failed";
  mark_test_run 1778;
  let test = sub_eq (get_idx_mut r ((.b156.#a10) : (t156, _) idx_mut)) next_r.b156.#a10 in
  if not test then failwithf "test 1778 failed";
  (* .b156.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b156 = #{ r.b156 with b10 = next_r.b156.#b10 } } in
  set_idx_mut r ((.b156.#b10) : (t156, _) idx_mut) next_r.b156.#b10;
  mark_test_run 1779;
  let test = eq r expected in
  if not test then failwithf "test 1779 failed";
  mark_test_run 1780;
  let test = sub_eq (get_idx_mut r ((.b156.#b10) : (t156, _) idx_mut)) next_r.b156.#b10 in
  if not test then failwithf "test 1780 failed";
  (************************************)
  (*   t157 = { float; #{ float } }   *)
  (************************************)
  let eq = (fun ({ a157 = a1571; b157 = b1571 } : t157) ({ a157 = a1572; b157 = b1572 } : t157) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1571 a1572 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b1571 b1572) in
  let r = ({ a157 = 0.; b157 = (#{ a21 = 1. } : t21) } : t157) in
  (* Paths of depth 0 *)
  let next_r = ({ a157 = 100.; b157 = (#{ a21 = 101. } : t21) } : t157) in
  (* .a157 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a157 = next_r.a157 } in
  set_idx_mut r ((.a157) : (t157, _) idx_mut) (Float_u.of_float next_r.a157);
  mark_test_run 1781;
  let test = eq r expected in
  if not test then failwithf "test 1781 failed";
  mark_test_run 1782;
  let test = sub_eq (get_idx_mut r ((.a157) : (t157, _) idx_mut)) (Float_u.of_float next_r.a157) in
  if not test then failwithf "test 1782 failed";
  let r = ({ a157 = 0.; b157 = (#{ a21 = 1. } : t21) } : t157) in
  (* Paths of depth 0 *)
  let next_r = ({ a157 = 100.; b157 = (#{ a21 = 101. } : t21) } : t157) in
  (* .b157 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b157 = next_r.b157 } in
  set_idx_mut r ((.b157) : (t157, _) idx_mut) (Float_u.of_float next_r.b157.#a21);
  mark_test_run 1783;
  let test = eq r expected in
  if not test then failwithf "test 1783 failed";
  mark_test_run 1784;
  let test = sub_eq (get_idx_mut r ((.b157) : (t157, _) idx_mut)) (Float_u.of_float next_r.b157.#a21) in
  if not test then failwithf "test 1784 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a157 = 200.; b157 = (#{ a21 = 201. } : t21) } : t157) in
  (* .b157.#a21 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b157 = #{ r.b157 with a21 = next_r.b157.#a21 } } in
  set_idx_mut r ((.b157.#a21) : (t157, _) idx_mut) (Float_u.of_float next_r.b157.#a21);
  mark_test_run 1785;
  let test = eq r expected in
  if not test then failwithf "test 1785 failed";
  mark_test_run 1786;
  let test = sub_eq (get_idx_mut r ((.b157.#a21) : (t157, _) idx_mut)) (Float_u.of_float next_r.b157.#a21) in
  if not test then failwithf "test 1786 failed";
  (*****************************************)
  (*   t158 = { float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun ({ a158 = a1581; b158 = b1581 } : t158) ({ a158 = a1582; b158 = b1582 } : t158) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1581 a1582 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b1581 b1582) in
  let r = ({ a158 = 0.; b158 = (#{ a23 = 1.; b23 = 2 } : t23) } : t158) in
  (* Paths of depth 0 *)
  let next_r = ({ a158 = 100.; b158 = (#{ a23 = 101.; b23 = 102 } : t23) } : t158) in
  (* .a158 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a158 = next_r.a158 } in
  set_idx_mut r ((.a158) : (t158, _) idx_mut) next_r.a158;
  mark_test_run 1787;
  let test = eq r expected in
  if not test then failwithf "test 1787 failed";
  mark_test_run 1788;
  let test = sub_eq (get_idx_mut r ((.a158) : (t158, _) idx_mut)) next_r.a158 in
  if not test then failwithf "test 1788 failed";
  let r = ({ a158 = 0.; b158 = (#{ a23 = 1.; b23 = 2 } : t23) } : t158) in
  (* Paths of depth 0 *)
  let next_r = ({ a158 = 100.; b158 = (#{ a23 = 101.; b23 = 102 } : t23) } : t158) in
  (* .b158 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with b158 = next_r.b158 } in
  set_idx_mut r ((.b158) : (t158, _) idx_mut) next_r.b158;
  mark_test_run 1789;
  let test = eq r expected in
  if not test then failwithf "test 1789 failed";
  mark_test_run 1790;
  let test = sub_eq (get_idx_mut r ((.b158) : (t158, _) idx_mut)) next_r.b158 in
  if not test then failwithf "test 1790 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a158 = 200.; b158 = (#{ a23 = 201.; b23 = 202 } : t23) } : t158) in
  (* .b158.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b158 = #{ r.b158 with a23 = next_r.b158.#a23 } } in
  set_idx_mut r ((.b158.#a23) : (t158, _) idx_mut) next_r.b158.#a23;
  mark_test_run 1791;
  let test = eq r expected in
  if not test then failwithf "test 1791 failed";
  mark_test_run 1792;
  let test = sub_eq (get_idx_mut r ((.b158.#a23) : (t158, _) idx_mut)) next_r.b158.#a23 in
  if not test then failwithf "test 1792 failed";
  (* .b158.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b158 = #{ r.b158 with b23 = next_r.b158.#b23 } } in
  set_idx_mut r ((.b158.#b23) : (t158, _) idx_mut) next_r.b158.#b23;
  mark_test_run 1793;
  let test = eq r expected in
  if not test then failwithf "test 1793 failed";
  mark_test_run 1794;
  let test = sub_eq (get_idx_mut r ((.b158.#b23) : (t158, _) idx_mut)) next_r.b158.#b23 in
  if not test then failwithf "test 1794 failed";
  (*******************************************)
  (*   t159 = { float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun ({ a159 = a1591; b159 = b1591 } : t159) ({ a159 = a1592; b159 = b1592 } : t159) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1591 a1592 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b1591 b1592) in
  let r = ({ a159 = 0.; b159 = (#{ a25 = 1.; b25 = 2. } : t25) } : t159) in
  (* Paths of depth 0 *)
  let next_r = ({ a159 = 100.; b159 = (#{ a25 = 101.; b25 = 102. } : t25) } : t159) in
  (* .a159 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a159 = next_r.a159 } in
  set_idx_mut r ((.a159) : (t159, _) idx_mut) next_r.a159;
  mark_test_run 1795;
  let test = eq r expected in
  if not test then failwithf "test 1795 failed";
  mark_test_run 1796;
  let test = sub_eq (get_idx_mut r ((.a159) : (t159, _) idx_mut)) next_r.a159 in
  if not test then failwithf "test 1796 failed";
  let r = ({ a159 = 0.; b159 = (#{ a25 = 1.; b25 = 2. } : t25) } : t159) in
  (* Paths of depth 0 *)
  let next_r = ({ a159 = 100.; b159 = (#{ a25 = 101.; b25 = 102. } : t25) } : t159) in
  (* .b159 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with b159 = next_r.b159 } in
  set_idx_mut r ((.b159) : (t159, _) idx_mut) next_r.b159;
  mark_test_run 1797;
  let test = eq r expected in
  if not test then failwithf "test 1797 failed";
  mark_test_run 1798;
  let test = sub_eq (get_idx_mut r ((.b159) : (t159, _) idx_mut)) next_r.b159 in
  if not test then failwithf "test 1798 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a159 = 200.; b159 = (#{ a25 = 201.; b25 = 202. } : t25) } : t159) in
  (* .b159.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b159 = #{ r.b159 with a25 = next_r.b159.#a25 } } in
  set_idx_mut r ((.b159.#a25) : (t159, _) idx_mut) next_r.b159.#a25;
  mark_test_run 1799;
  let test = eq r expected in
  if not test then failwithf "test 1799 failed";
  mark_test_run 1800;
  let test = sub_eq (get_idx_mut r ((.b159.#a25) : (t159, _) idx_mut)) next_r.b159.#a25 in
  if not test then failwithf "test 1800 failed";
  (* .b159.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b159 = #{ r.b159 with b25 = next_r.b159.#b25 } } in
  set_idx_mut r ((.b159.#b25) : (t159, _) idx_mut) next_r.b159.#b25;
  mark_test_run 1801;
  let test = eq r expected in
  if not test then failwithf "test 1801 failed";
  mark_test_run 1802;
  let test = sub_eq (get_idx_mut r ((.b159.#b25) : (t159, _) idx_mut)) next_r.b159.#b25 in
  if not test then failwithf "test 1802 failed";
  (***************************)
  (*   t160 = { #{ int } }   *)
  (***************************)
  let eq = (fun ({ a160 = a1601 } : t160) ({ a160 = a1602 } : t160) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1601 a1602) in
  let r = ({ a160 = (#{ a0 = 0 } : t0) } : t160) in
  (* Paths of depth 0 *)
  let next_r = ({ a160 = (#{ a0 = 100 } : t0) } : t160) in
  (* .a160 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a160 = next_r.a160 } in
  set_idx_mut r ((.a160) : (t160, _) idx_mut) next_r.a160;
  mark_test_run 1803;
  let test = eq r expected in
  if not test then failwithf "test 1803 failed";
  mark_test_run 1804;
  let test = sub_eq (get_idx_mut r ((.a160) : (t160, _) idx_mut)) next_r.a160 in
  if not test then failwithf "test 1804 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a160 = (#{ a0 = 200 } : t0) } : t160) in
  (* .a160.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a160 = #{ r.a160 with a0 = next_r.a160.#a0 } } in
  set_idx_mut r ((.a160.#a0) : (t160, _) idx_mut) next_r.a160.#a0;
  mark_test_run 1805;
  let test = eq r expected in
  if not test then failwithf "test 1805 failed";
  mark_test_run 1806;
  let test = sub_eq (get_idx_mut r ((.a160.#a0) : (t160, _) idx_mut)) next_r.a160.#a0 in
  if not test then failwithf "test 1806 failed";
  (********************************)
  (*   t161 = { #{ int }; int }   *)
  (********************************)
  let eq = (fun ({ a161 = a1611; b161 = b1611 } : t161) ({ a161 = a1612; b161 = b1612 } : t161) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1611 a1612 && (fun a b -> Int.equal a b) b1611 b1612) in
  let r = ({ a161 = (#{ a0 = 0 } : t0); b161 = 1 } : t161) in
  (* Paths of depth 0 *)
  let next_r = ({ a161 = (#{ a0 = 100 } : t0); b161 = 101 } : t161) in
  (* .a161 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a161 = next_r.a161 } in
  set_idx_mut r ((.a161) : (t161, _) idx_mut) next_r.a161;
  mark_test_run 1807;
  let test = eq r expected in
  if not test then failwithf "test 1807 failed";
  mark_test_run 1808;
  let test = sub_eq (get_idx_mut r ((.a161) : (t161, _) idx_mut)) next_r.a161 in
  if not test then failwithf "test 1808 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a161 = (#{ a0 = 200 } : t0); b161 = 201 } : t161) in
  (* .a161.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a161 = #{ r.a161 with a0 = next_r.a161.#a0 } } in
  set_idx_mut r ((.a161.#a0) : (t161, _) idx_mut) next_r.a161.#a0;
  mark_test_run 1809;
  let test = eq r expected in
  if not test then failwithf "test 1809 failed";
  mark_test_run 1810;
  let test = sub_eq (get_idx_mut r ((.a161.#a0) : (t161, _) idx_mut)) next_r.a161.#a0 in
  if not test then failwithf "test 1810 failed";
  let r = ({ a161 = (#{ a0 = 0 } : t0); b161 = 1 } : t161) in
  (* Paths of depth 0 *)
  let next_r = ({ a161 = (#{ a0 = 100 } : t0); b161 = 101 } : t161) in
  (* .b161 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b161 = next_r.b161 } in
  set_idx_mut r ((.b161) : (t161, _) idx_mut) next_r.b161;
  mark_test_run 1811;
  let test = eq r expected in
  if not test then failwithf "test 1811 failed";
  mark_test_run 1812;
  let test = sub_eq (get_idx_mut r ((.b161) : (t161, _) idx_mut)) next_r.b161 in
  if not test then failwithf "test 1812 failed";
  (***********************************)
  (*   t162 = { #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun ({ a162 = a1621; b162 = b1621 } : t162) ({ a162 = a1622; b162 = b1622 } : t162) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1621 a1622 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1621 b1622) in
  let r = ({ a162 = (#{ a0 = 0 } : t0); b162 = #1l } : t162) in
  (* Paths of depth 0 *)
  let next_r = ({ a162 = (#{ a0 = 100 } : t0); b162 = #101l } : t162) in
  (* .a162 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a162 = next_r.a162 } in
  set_idx_mut r ((.a162) : (t162, _) idx_mut) next_r.a162;
  mark_test_run 1813;
  let test = eq r expected in
  if not test then failwithf "test 1813 failed";
  mark_test_run 1814;
  let test = sub_eq (get_idx_mut r ((.a162) : (t162, _) idx_mut)) next_r.a162 in
  if not test then failwithf "test 1814 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a162 = (#{ a0 = 200 } : t0); b162 = #201l } : t162) in
  (* .a162.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a162 = #{ r.a162 with a0 = next_r.a162.#a0 } } in
  set_idx_mut r ((.a162.#a0) : (t162, _) idx_mut) next_r.a162.#a0;
  mark_test_run 1815;
  let test = eq r expected in
  if not test then failwithf "test 1815 failed";
  mark_test_run 1816;
  let test = sub_eq (get_idx_mut r ((.a162.#a0) : (t162, _) idx_mut)) next_r.a162.#a0 in
  if not test then failwithf "test 1816 failed";
  let r = ({ a162 = (#{ a0 = 0 } : t0); b162 = #1l } : t162) in
  (* Paths of depth 0 *)
  let next_r = ({ a162 = (#{ a0 = 100 } : t0); b162 = #101l } : t162) in
  (* .b162 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b162 = next_r.b162 } in
  set_idx_mut r ((.b162) : (t162, _) idx_mut) next_r.b162;
  mark_test_run 1817;
  let test = eq r expected in
  if not test then failwithf "test 1817 failed";
  mark_test_run 1818;
  let test = sub_eq (get_idx_mut r ((.b162) : (t162, _) idx_mut)) next_r.b162 in
  if not test then failwithf "test 1818 failed";
  (**********************************)
  (*   t163 = { #{ int }; float }   *)
  (**********************************)
  let eq = (fun ({ a163 = a1631; b163 = b1631 } : t163) ({ a163 = a1632; b163 = b1632 } : t163) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1631 a1632 && (fun a b -> Float.equal (globalize a) (globalize b)) b1631 b1632) in
  let r = ({ a163 = (#{ a0 = 0 } : t0); b163 = 1. } : t163) in
  (* Paths of depth 0 *)
  let next_r = ({ a163 = (#{ a0 = 100 } : t0); b163 = 101. } : t163) in
  (* .a163 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a163 = next_r.a163 } in
  set_idx_mut r ((.a163) : (t163, _) idx_mut) next_r.a163;
  mark_test_run 1819;
  let test = eq r expected in
  if not test then failwithf "test 1819 failed";
  mark_test_run 1820;
  let test = sub_eq (get_idx_mut r ((.a163) : (t163, _) idx_mut)) next_r.a163 in
  if not test then failwithf "test 1820 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a163 = (#{ a0 = 200 } : t0); b163 = 201. } : t163) in
  (* .a163.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a163 = #{ r.a163 with a0 = next_r.a163.#a0 } } in
  set_idx_mut r ((.a163.#a0) : (t163, _) idx_mut) next_r.a163.#a0;
  mark_test_run 1821;
  let test = eq r expected in
  if not test then failwithf "test 1821 failed";
  mark_test_run 1822;
  let test = sub_eq (get_idx_mut r ((.a163.#a0) : (t163, _) idx_mut)) next_r.a163.#a0 in
  if not test then failwithf "test 1822 failed";
  let r = ({ a163 = (#{ a0 = 0 } : t0); b163 = 1. } : t163) in
  (* Paths of depth 0 *)
  let next_r = ({ a163 = (#{ a0 = 100 } : t0); b163 = 101. } : t163) in
  (* .b163 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b163 = next_r.b163 } in
  set_idx_mut r ((.b163) : (t163, _) idx_mut) next_r.b163;
  mark_test_run 1823;
  let test = eq r expected in
  if not test then failwithf "test 1823 failed";
  mark_test_run 1824;
  let test = sub_eq (get_idx_mut r ((.b163) : (t163, _) idx_mut)) next_r.b163 in
  if not test then failwithf "test 1824 failed";
  (********************************)
  (*   t164 = { #{ int; int } }   *)
  (********************************)
  let eq = (fun ({ a164 = a1641 } : t164) ({ a164 = a1642 } : t164) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1641 a1642) in
  let r = ({ a164 = (#{ a1 = 0; b1 = 1 } : t1) } : t164) in
  (* Paths of depth 0 *)
  let next_r = ({ a164 = (#{ a1 = 100; b1 = 101 } : t1) } : t164) in
  (* .a164 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a164 = next_r.a164 } in
  set_idx_mut r ((.a164) : (t164, _) idx_mut) next_r.a164;
  mark_test_run 1825;
  let test = eq r expected in
  if not test then failwithf "test 1825 failed";
  mark_test_run 1826;
  let test = sub_eq (get_idx_mut r ((.a164) : (t164, _) idx_mut)) next_r.a164 in
  if not test then failwithf "test 1826 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a164 = (#{ a1 = 200; b1 = 201 } : t1) } : t164) in
  (* .a164.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a164 = #{ r.a164 with a1 = next_r.a164.#a1 } } in
  set_idx_mut r ((.a164.#a1) : (t164, _) idx_mut) next_r.a164.#a1;
  mark_test_run 1827;
  let test = eq r expected in
  if not test then failwithf "test 1827 failed";
  mark_test_run 1828;
  let test = sub_eq (get_idx_mut r ((.a164.#a1) : (t164, _) idx_mut)) next_r.a164.#a1 in
  if not test then failwithf "test 1828 failed";
  (* .a164.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a164 = #{ r.a164 with b1 = next_r.a164.#b1 } } in
  set_idx_mut r ((.a164.#b1) : (t164, _) idx_mut) next_r.a164.#b1;
  mark_test_run 1829;
  let test = eq r expected in
  if not test then failwithf "test 1829 failed";
  mark_test_run 1830;
  let test = sub_eq (get_idx_mut r ((.a164.#b1) : (t164, _) idx_mut)) next_r.a164.#b1 in
  if not test then failwithf "test 1830 failed";
  (*************************************)
  (*   t165 = { #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun ({ a165 = a1651; b165 = b1651 } : t165) ({ a165 = a1652; b165 = b1652 } : t165) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1651 a1652 && (fun a b -> Int.equal a b) b1651 b1652) in
  let r = ({ a165 = (#{ a1 = 0; b1 = 1 } : t1); b165 = 2 } : t165) in
  (* Paths of depth 0 *)
  let next_r = ({ a165 = (#{ a1 = 100; b1 = 101 } : t1); b165 = 102 } : t165) in
  (* .a165 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a165 = next_r.a165 } in
  set_idx_mut r ((.a165) : (t165, _) idx_mut) next_r.a165;
  mark_test_run 1831;
  let test = eq r expected in
  if not test then failwithf "test 1831 failed";
  mark_test_run 1832;
  let test = sub_eq (get_idx_mut r ((.a165) : (t165, _) idx_mut)) next_r.a165 in
  if not test then failwithf "test 1832 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a165 = (#{ a1 = 200; b1 = 201 } : t1); b165 = 202 } : t165) in
  (* .a165.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a165 = #{ r.a165 with a1 = next_r.a165.#a1 } } in
  set_idx_mut r ((.a165.#a1) : (t165, _) idx_mut) next_r.a165.#a1;
  mark_test_run 1833;
  let test = eq r expected in
  if not test then failwithf "test 1833 failed";
  mark_test_run 1834;
  let test = sub_eq (get_idx_mut r ((.a165.#a1) : (t165, _) idx_mut)) next_r.a165.#a1 in
  if not test then failwithf "test 1834 failed";
  (* .a165.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a165 = #{ r.a165 with b1 = next_r.a165.#b1 } } in
  set_idx_mut r ((.a165.#b1) : (t165, _) idx_mut) next_r.a165.#b1;
  mark_test_run 1835;
  let test = eq r expected in
  if not test then failwithf "test 1835 failed";
  mark_test_run 1836;
  let test = sub_eq (get_idx_mut r ((.a165.#b1) : (t165, _) idx_mut)) next_r.a165.#b1 in
  if not test then failwithf "test 1836 failed";
  let r = ({ a165 = (#{ a1 = 0; b1 = 1 } : t1); b165 = 2 } : t165) in
  (* Paths of depth 0 *)
  let next_r = ({ a165 = (#{ a1 = 100; b1 = 101 } : t1); b165 = 102 } : t165) in
  (* .b165 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b165 = next_r.b165 } in
  set_idx_mut r ((.b165) : (t165, _) idx_mut) next_r.b165;
  mark_test_run 1837;
  let test = eq r expected in
  if not test then failwithf "test 1837 failed";
  mark_test_run 1838;
  let test = sub_eq (get_idx_mut r ((.b165) : (t165, _) idx_mut)) next_r.b165 in
  if not test then failwithf "test 1838 failed";
  (****************************************)
  (*   t166 = { #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun ({ a166 = a1661; b166 = b1661 } : t166) ({ a166 = a1662; b166 = b1662 } : t166) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1661 a1662 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1661 b1662) in
  let r = ({ a166 = (#{ a1 = 0; b1 = 1 } : t1); b166 = #2l } : t166) in
  (* Paths of depth 0 *)
  let next_r = ({ a166 = (#{ a1 = 100; b1 = 101 } : t1); b166 = #102l } : t166) in
  (* .a166 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a166 = next_r.a166 } in
  set_idx_mut r ((.a166) : (t166, _) idx_mut) next_r.a166;
  mark_test_run 1839;
  let test = eq r expected in
  if not test then failwithf "test 1839 failed";
  mark_test_run 1840;
  let test = sub_eq (get_idx_mut r ((.a166) : (t166, _) idx_mut)) next_r.a166 in
  if not test then failwithf "test 1840 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a166 = (#{ a1 = 200; b1 = 201 } : t1); b166 = #202l } : t166) in
  (* .a166.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a166 = #{ r.a166 with a1 = next_r.a166.#a1 } } in
  set_idx_mut r ((.a166.#a1) : (t166, _) idx_mut) next_r.a166.#a1;
  mark_test_run 1841;
  let test = eq r expected in
  if not test then failwithf "test 1841 failed";
  mark_test_run 1842;
  let test = sub_eq (get_idx_mut r ((.a166.#a1) : (t166, _) idx_mut)) next_r.a166.#a1 in
  if not test then failwithf "test 1842 failed";
  (* .a166.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a166 = #{ r.a166 with b1 = next_r.a166.#b1 } } in
  set_idx_mut r ((.a166.#b1) : (t166, _) idx_mut) next_r.a166.#b1;
  mark_test_run 1843;
  let test = eq r expected in
  if not test then failwithf "test 1843 failed";
  mark_test_run 1844;
  let test = sub_eq (get_idx_mut r ((.a166.#b1) : (t166, _) idx_mut)) next_r.a166.#b1 in
  if not test then failwithf "test 1844 failed";
  let r = ({ a166 = (#{ a1 = 0; b1 = 1 } : t1); b166 = #2l } : t166) in
  (* Paths of depth 0 *)
  let next_r = ({ a166 = (#{ a1 = 100; b1 = 101 } : t1); b166 = #102l } : t166) in
  (* .b166 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b166 = next_r.b166 } in
  set_idx_mut r ((.b166) : (t166, _) idx_mut) next_r.b166;
  mark_test_run 1845;
  let test = eq r expected in
  if not test then failwithf "test 1845 failed";
  mark_test_run 1846;
  let test = sub_eq (get_idx_mut r ((.b166) : (t166, _) idx_mut)) next_r.b166 in
  if not test then failwithf "test 1846 failed";
  (***************************************)
  (*   t167 = { #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun ({ a167 = a1671; b167 = b1671 } : t167) ({ a167 = a1672; b167 = b1672 } : t167) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1671 a1672 && (fun a b -> Float.equal (globalize a) (globalize b)) b1671 b1672) in
  let r = ({ a167 = (#{ a1 = 0; b1 = 1 } : t1); b167 = 2. } : t167) in
  (* Paths of depth 0 *)
  let next_r = ({ a167 = (#{ a1 = 100; b1 = 101 } : t1); b167 = 102. } : t167) in
  (* .a167 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a167 = next_r.a167 } in
  set_idx_mut r ((.a167) : (t167, _) idx_mut) next_r.a167;
  mark_test_run 1847;
  let test = eq r expected in
  if not test then failwithf "test 1847 failed";
  mark_test_run 1848;
  let test = sub_eq (get_idx_mut r ((.a167) : (t167, _) idx_mut)) next_r.a167 in
  if not test then failwithf "test 1848 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a167 = (#{ a1 = 200; b1 = 201 } : t1); b167 = 202. } : t167) in
  (* .a167.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a167 = #{ r.a167 with a1 = next_r.a167.#a1 } } in
  set_idx_mut r ((.a167.#a1) : (t167, _) idx_mut) next_r.a167.#a1;
  mark_test_run 1849;
  let test = eq r expected in
  if not test then failwithf "test 1849 failed";
  mark_test_run 1850;
  let test = sub_eq (get_idx_mut r ((.a167.#a1) : (t167, _) idx_mut)) next_r.a167.#a1 in
  if not test then failwithf "test 1850 failed";
  (* .a167.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a167 = #{ r.a167 with b1 = next_r.a167.#b1 } } in
  set_idx_mut r ((.a167.#b1) : (t167, _) idx_mut) next_r.a167.#b1;
  mark_test_run 1851;
  let test = eq r expected in
  if not test then failwithf "test 1851 failed";
  mark_test_run 1852;
  let test = sub_eq (get_idx_mut r ((.a167.#b1) : (t167, _) idx_mut)) next_r.a167.#b1 in
  if not test then failwithf "test 1852 failed";
  let r = ({ a167 = (#{ a1 = 0; b1 = 1 } : t1); b167 = 2. } : t167) in
  (* Paths of depth 0 *)
  let next_r = ({ a167 = (#{ a1 = 100; b1 = 101 } : t1); b167 = 102. } : t167) in
  (* .b167 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b167 = next_r.b167 } in
  set_idx_mut r ((.b167) : (t167, _) idx_mut) next_r.b167;
  mark_test_run 1853;
  let test = eq r expected in
  if not test then failwithf "test 1853 failed";
  mark_test_run 1854;
  let test = sub_eq (get_idx_mut r ((.b167) : (t167, _) idx_mut)) next_r.b167 in
  if not test then failwithf "test 1854 failed";
  (***********************************)
  (*   t168 = { #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun ({ a168 = a1681 } : t168) ({ a168 = a1682 } : t168) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a1681 a1682) in
  let r = ({ a168 = (#{ a7 = 0; b7 = #1l } : t7) } : t168) in
  (* Paths of depth 0 *)
  let next_r = ({ a168 = (#{ a7 = 100; b7 = #101l } : t7) } : t168) in
  (* .a168 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with a168 = next_r.a168 } in
  set_idx_mut r ((.a168) : (t168, _) idx_mut) next_r.a168;
  mark_test_run 1855;
  let test = eq r expected in
  if not test then failwithf "test 1855 failed";
  mark_test_run 1856;
  let test = sub_eq (get_idx_mut r ((.a168) : (t168, _) idx_mut)) next_r.a168 in
  if not test then failwithf "test 1856 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a168 = (#{ a7 = 200; b7 = #201l } : t7) } : t168) in
  (* .a168.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a168 = #{ r.a168 with a7 = next_r.a168.#a7 } } in
  set_idx_mut r ((.a168.#a7) : (t168, _) idx_mut) next_r.a168.#a7;
  mark_test_run 1857;
  let test = eq r expected in
  if not test then failwithf "test 1857 failed";
  mark_test_run 1858;
  let test = sub_eq (get_idx_mut r ((.a168.#a7) : (t168, _) idx_mut)) next_r.a168.#a7 in
  if not test then failwithf "test 1858 failed";
  (* .a168.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a168 = #{ r.a168 with b7 = next_r.a168.#b7 } } in
  set_idx_mut r ((.a168.#b7) : (t168, _) idx_mut) next_r.a168.#b7;
  mark_test_run 1859;
  let test = eq r expected in
  if not test then failwithf "test 1859 failed";
  mark_test_run 1860;
  let test = sub_eq (get_idx_mut r ((.a168.#b7) : (t168, _) idx_mut)) next_r.a168.#b7 in
  if not test then failwithf "test 1860 failed";
  (****************************************)
  (*   t169 = { #{ int; int32# }; int }   *)
  (****************************************)
  let eq = (fun ({ a169 = a1691; b169 = b1691 } : t169) ({ a169 = a1692; b169 = b1692 } : t169) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a1691 a1692 && (fun a b -> Int.equal a b) b1691 b1692) in
  let r = ({ a169 = (#{ a7 = 0; b7 = #1l } : t7); b169 = 2 } : t169) in
  (* Paths of depth 0 *)
  let next_r = ({ a169 = (#{ a7 = 100; b7 = #101l } : t7); b169 = 102 } : t169) in
  (* .a169 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with a169 = next_r.a169 } in
  set_idx_mut r ((.a169) : (t169, _) idx_mut) next_r.a169;
  mark_test_run 1861;
  let test = eq r expected in
  if not test then failwithf "test 1861 failed";
  mark_test_run 1862;
  let test = sub_eq (get_idx_mut r ((.a169) : (t169, _) idx_mut)) next_r.a169 in
  if not test then failwithf "test 1862 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a169 = (#{ a7 = 200; b7 = #201l } : t7); b169 = 202 } : t169) in
  (* .a169.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a169 = #{ r.a169 with a7 = next_r.a169.#a7 } } in
  set_idx_mut r ((.a169.#a7) : (t169, _) idx_mut) next_r.a169.#a7;
  mark_test_run 1863;
  let test = eq r expected in
  if not test then failwithf "test 1863 failed";
  mark_test_run 1864;
  let test = sub_eq (get_idx_mut r ((.a169.#a7) : (t169, _) idx_mut)) next_r.a169.#a7 in
  if not test then failwithf "test 1864 failed";
  (* .a169.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a169 = #{ r.a169 with b7 = next_r.a169.#b7 } } in
  set_idx_mut r ((.a169.#b7) : (t169, _) idx_mut) next_r.a169.#b7;
  mark_test_run 1865;
  let test = eq r expected in
  if not test then failwithf "test 1865 failed";
  mark_test_run 1866;
  let test = sub_eq (get_idx_mut r ((.a169.#b7) : (t169, _) idx_mut)) next_r.a169.#b7 in
  if not test then failwithf "test 1866 failed";
  let r = ({ a169 = (#{ a7 = 0; b7 = #1l } : t7); b169 = 2 } : t169) in
  (* Paths of depth 0 *)
  let next_r = ({ a169 = (#{ a7 = 100; b7 = #101l } : t7); b169 = 102 } : t169) in
  (* .b169 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b169 = next_r.b169 } in
  set_idx_mut r ((.b169) : (t169, _) idx_mut) next_r.b169;
  mark_test_run 1867;
  let test = eq r expected in
  if not test then failwithf "test 1867 failed";
  mark_test_run 1868;
  let test = sub_eq (get_idx_mut r ((.b169) : (t169, _) idx_mut)) next_r.b169 in
  if not test then failwithf "test 1868 failed";
  (*******************************************)
  (*   t170 = { #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun ({ a170 = a1701; b170 = b1701 } : t170) ({ a170 = a1702; b170 = b1702 } : t170) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a1701 a1702 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1701 b1702) in
  let r = ({ a170 = (#{ a7 = 0; b7 = #1l } : t7); b170 = #2l } : t170) in
  (* Paths of depth 0 *)
  let next_r = ({ a170 = (#{ a7 = 100; b7 = #101l } : t7); b170 = #102l } : t170) in
  (* .a170 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with a170 = next_r.a170 } in
  set_idx_mut r ((.a170) : (t170, _) idx_mut) next_r.a170;
  mark_test_run 1869;
  let test = eq r expected in
  if not test then failwithf "test 1869 failed";
  mark_test_run 1870;
  let test = sub_eq (get_idx_mut r ((.a170) : (t170, _) idx_mut)) next_r.a170 in
  if not test then failwithf "test 1870 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a170 = (#{ a7 = 200; b7 = #201l } : t7); b170 = #202l } : t170) in
  (* .a170.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a170 = #{ r.a170 with a7 = next_r.a170.#a7 } } in
  set_idx_mut r ((.a170.#a7) : (t170, _) idx_mut) next_r.a170.#a7;
  mark_test_run 1871;
  let test = eq r expected in
  if not test then failwithf "test 1871 failed";
  mark_test_run 1872;
  let test = sub_eq (get_idx_mut r ((.a170.#a7) : (t170, _) idx_mut)) next_r.a170.#a7 in
  if not test then failwithf "test 1872 failed";
  (* .a170.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a170 = #{ r.a170 with b7 = next_r.a170.#b7 } } in
  set_idx_mut r ((.a170.#b7) : (t170, _) idx_mut) next_r.a170.#b7;
  mark_test_run 1873;
  let test = eq r expected in
  if not test then failwithf "test 1873 failed";
  mark_test_run 1874;
  let test = sub_eq (get_idx_mut r ((.a170.#b7) : (t170, _) idx_mut)) next_r.a170.#b7 in
  if not test then failwithf "test 1874 failed";
  let r = ({ a170 = (#{ a7 = 0; b7 = #1l } : t7); b170 = #2l } : t170) in
  (* Paths of depth 0 *)
  let next_r = ({ a170 = (#{ a7 = 100; b7 = #101l } : t7); b170 = #102l } : t170) in
  (* .b170 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b170 = next_r.b170 } in
  set_idx_mut r ((.b170) : (t170, _) idx_mut) next_r.b170;
  mark_test_run 1875;
  let test = eq r expected in
  if not test then failwithf "test 1875 failed";
  mark_test_run 1876;
  let test = sub_eq (get_idx_mut r ((.b170) : (t170, _) idx_mut)) next_r.b170 in
  if not test then failwithf "test 1876 failed";
  (**********************************)
  (*   t171 = { #{ int; float } }   *)
  (**********************************)
  let eq = (fun ({ a171 = a1711 } : t171) ({ a171 = a1712 } : t171) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1711 a1712) in
  let r = ({ a171 = (#{ a10 = 0; b10 = 1. } : t10) } : t171) in
  (* Paths of depth 0 *)
  let next_r = ({ a171 = (#{ a10 = 100; b10 = 101. } : t10) } : t171) in
  (* .a171 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with a171 = next_r.a171 } in
  set_idx_mut r ((.a171) : (t171, _) idx_mut) next_r.a171;
  mark_test_run 1877;
  let test = eq r expected in
  if not test then failwithf "test 1877 failed";
  mark_test_run 1878;
  let test = sub_eq (get_idx_mut r ((.a171) : (t171, _) idx_mut)) next_r.a171 in
  if not test then failwithf "test 1878 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a171 = (#{ a10 = 200; b10 = 201. } : t10) } : t171) in
  (* .a171.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a171 = #{ r.a171 with a10 = next_r.a171.#a10 } } in
  set_idx_mut r ((.a171.#a10) : (t171, _) idx_mut) next_r.a171.#a10;
  mark_test_run 1879;
  let test = eq r expected in
  if not test then failwithf "test 1879 failed";
  mark_test_run 1880;
  let test = sub_eq (get_idx_mut r ((.a171.#a10) : (t171, _) idx_mut)) next_r.a171.#a10 in
  if not test then failwithf "test 1880 failed";
  (* .a171.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a171 = #{ r.a171 with b10 = next_r.a171.#b10 } } in
  set_idx_mut r ((.a171.#b10) : (t171, _) idx_mut) next_r.a171.#b10;
  mark_test_run 1881;
  let test = eq r expected in
  if not test then failwithf "test 1881 failed";
  mark_test_run 1882;
  let test = sub_eq (get_idx_mut r ((.a171.#b10) : (t171, _) idx_mut)) next_r.a171.#b10 in
  if not test then failwithf "test 1882 failed";
  (***************************************)
  (*   t172 = { #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun ({ a172 = a1721; b172 = b1721 } : t172) ({ a172 = a1722; b172 = b1722 } : t172) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1721 a1722 && (fun a b -> Int.equal a b) b1721 b1722) in
  let r = ({ a172 = (#{ a10 = 0; b10 = 1. } : t10); b172 = 2 } : t172) in
  (* Paths of depth 0 *)
  let next_r = ({ a172 = (#{ a10 = 100; b10 = 101. } : t10); b172 = 102 } : t172) in
  (* .a172 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with a172 = next_r.a172 } in
  set_idx_mut r ((.a172) : (t172, _) idx_mut) next_r.a172;
  mark_test_run 1883;
  let test = eq r expected in
  if not test then failwithf "test 1883 failed";
  mark_test_run 1884;
  let test = sub_eq (get_idx_mut r ((.a172) : (t172, _) idx_mut)) next_r.a172 in
  if not test then failwithf "test 1884 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a172 = (#{ a10 = 200; b10 = 201. } : t10); b172 = 202 } : t172) in
  (* .a172.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a172 = #{ r.a172 with a10 = next_r.a172.#a10 } } in
  set_idx_mut r ((.a172.#a10) : (t172, _) idx_mut) next_r.a172.#a10;
  mark_test_run 1885;
  let test = eq r expected in
  if not test then failwithf "test 1885 failed";
  mark_test_run 1886;
  let test = sub_eq (get_idx_mut r ((.a172.#a10) : (t172, _) idx_mut)) next_r.a172.#a10 in
  if not test then failwithf "test 1886 failed";
  (* .a172.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a172 = #{ r.a172 with b10 = next_r.a172.#b10 } } in
  set_idx_mut r ((.a172.#b10) : (t172, _) idx_mut) next_r.a172.#b10;
  mark_test_run 1887;
  let test = eq r expected in
  if not test then failwithf "test 1887 failed";
  mark_test_run 1888;
  let test = sub_eq (get_idx_mut r ((.a172.#b10) : (t172, _) idx_mut)) next_r.a172.#b10 in
  if not test then failwithf "test 1888 failed";
  let r = ({ a172 = (#{ a10 = 0; b10 = 1. } : t10); b172 = 2 } : t172) in
  (* Paths of depth 0 *)
  let next_r = ({ a172 = (#{ a10 = 100; b10 = 101. } : t10); b172 = 102 } : t172) in
  (* .b172 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b172 = next_r.b172 } in
  set_idx_mut r ((.b172) : (t172, _) idx_mut) next_r.b172;
  mark_test_run 1889;
  let test = eq r expected in
  if not test then failwithf "test 1889 failed";
  mark_test_run 1890;
  let test = sub_eq (get_idx_mut r ((.b172) : (t172, _) idx_mut)) next_r.b172 in
  if not test then failwithf "test 1890 failed";
  (*****************************************)
  (*   t173 = { #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun ({ a173 = a1731; b173 = b1731 } : t173) ({ a173 = a1732; b173 = b1732 } : t173) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1731 a1732 && (fun a b -> Float.equal (globalize a) (globalize b)) b1731 b1732) in
  let r = ({ a173 = (#{ a10 = 0; b10 = 1. } : t10); b173 = 2. } : t173) in
  (* Paths of depth 0 *)
  let next_r = ({ a173 = (#{ a10 = 100; b10 = 101. } : t10); b173 = 102. } : t173) in
  (* .a173 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with a173 = next_r.a173 } in
  set_idx_mut r ((.a173) : (t173, _) idx_mut) next_r.a173;
  mark_test_run 1891;
  let test = eq r expected in
  if not test then failwithf "test 1891 failed";
  mark_test_run 1892;
  let test = sub_eq (get_idx_mut r ((.a173) : (t173, _) idx_mut)) next_r.a173 in
  if not test then failwithf "test 1892 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a173 = (#{ a10 = 200; b10 = 201. } : t10); b173 = 202. } : t173) in
  (* .a173.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a173 = #{ r.a173 with a10 = next_r.a173.#a10 } } in
  set_idx_mut r ((.a173.#a10) : (t173, _) idx_mut) next_r.a173.#a10;
  mark_test_run 1893;
  let test = eq r expected in
  if not test then failwithf "test 1893 failed";
  mark_test_run 1894;
  let test = sub_eq (get_idx_mut r ((.a173.#a10) : (t173, _) idx_mut)) next_r.a173.#a10 in
  if not test then failwithf "test 1894 failed";
  (* .a173.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a173 = #{ r.a173 with b10 = next_r.a173.#b10 } } in
  set_idx_mut r ((.a173.#b10) : (t173, _) idx_mut) next_r.a173.#b10;
  mark_test_run 1895;
  let test = eq r expected in
  if not test then failwithf "test 1895 failed";
  mark_test_run 1896;
  let test = sub_eq (get_idx_mut r ((.a173.#b10) : (t173, _) idx_mut)) next_r.a173.#b10 in
  if not test then failwithf "test 1896 failed";
  let r = ({ a173 = (#{ a10 = 0; b10 = 1. } : t10); b173 = 2. } : t173) in
  (* Paths of depth 0 *)
  let next_r = ({ a173 = (#{ a10 = 100; b10 = 101. } : t10); b173 = 102. } : t173) in
  (* .b173 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b173 = next_r.b173 } in
  set_idx_mut r ((.b173) : (t173, _) idx_mut) next_r.b173;
  mark_test_run 1897;
  let test = eq r expected in
  if not test then failwithf "test 1897 failed";
  mark_test_run 1898;
  let test = sub_eq (get_idx_mut r ((.b173) : (t173, _) idx_mut)) next_r.b173 in
  if not test then failwithf "test 1898 failed";
  (**********************************************************)
  (*   t176 = { #{ int64; int64# }; #{ int64#; float# } }   *)
  (**********************************************************)
  let eq = (fun ({ a176 = a1761; b176 = b1761 } : t176) ({ a176 = a1762; b176 = b1762 } : t176) -> (fun (#{ a174 = a1741; b174 = b1741 } : t174) (#{ a174 = a1742; b174 = b1742 } : t174) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1741 a1742 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1741 b1742) a1761 a1762 && (fun (#{ a175 = a1751; b175 = b1751 } : t175) (#{ a175 = a1752; b175 = b1752 } : t175) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1751 a1752 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1751 b1752) b1761 b1762) in
  let r = ({ a176 = (#{ a174 = 0L; b174 = #1L } : t174); b176 = (#{ a175 = #2L; b175 = #3. } : t175) } : t176) in
  (* Paths of depth 0 *)
  let next_r = ({ a176 = (#{ a174 = 100L; b174 = #101L } : t174); b176 = (#{ a175 = #102L; b175 = #103. } : t175) } : t176) in
  (* .a176 *)
  let sub_eq = (fun (#{ a174 = a1741; b174 = b1741 } : t174) (#{ a174 = a1742; b174 = b1742 } : t174) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1741 a1742 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1741 b1742) in
  let expected = { r with a176 = next_r.a176 } in
  set_idx_mut r ((.a176) : (t176, _) idx_mut) next_r.a176;
  mark_test_run 1899;
  let test = eq r expected in
  if not test then failwithf "test 1899 failed";
  mark_test_run 1900;
  let test = sub_eq (get_idx_mut r ((.a176) : (t176, _) idx_mut)) next_r.a176 in
  if not test then failwithf "test 1900 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a176 = (#{ a174 = 200L; b174 = #201L } : t174); b176 = (#{ a175 = #202L; b175 = #203. } : t175) } : t176) in
  (* .a176.#a174 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a176 = #{ r.a176 with a174 = next_r.a176.#a174 } } in
  set_idx_mut r ((.a176.#a174) : (t176, _) idx_mut) next_r.a176.#a174;
  mark_test_run 1901;
  let test = eq r expected in
  if not test then failwithf "test 1901 failed";
  mark_test_run 1902;
  let test = sub_eq (get_idx_mut r ((.a176.#a174) : (t176, _) idx_mut)) next_r.a176.#a174 in
  if not test then failwithf "test 1902 failed";
  (* .a176.#b174 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a176 = #{ r.a176 with b174 = next_r.a176.#b174 } } in
  set_idx_mut r ((.a176.#b174) : (t176, _) idx_mut) next_r.a176.#b174;
  mark_test_run 1903;
  let test = eq r expected in
  if not test then failwithf "test 1903 failed";
  mark_test_run 1904;
  let test = sub_eq (get_idx_mut r ((.a176.#b174) : (t176, _) idx_mut)) next_r.a176.#b174 in
  if not test then failwithf "test 1904 failed";
  let r = ({ a176 = (#{ a174 = 0L; b174 = #1L } : t174); b176 = (#{ a175 = #2L; b175 = #3. } : t175) } : t176) in
  (* Paths of depth 0 *)
  let next_r = ({ a176 = (#{ a174 = 100L; b174 = #101L } : t174); b176 = (#{ a175 = #102L; b175 = #103. } : t175) } : t176) in
  (* .b176 *)
  let sub_eq = (fun (#{ a175 = a1751; b175 = b1751 } : t175) (#{ a175 = a1752; b175 = b1752 } : t175) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1751 a1752 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1751 b1752) in
  let expected = { r with b176 = next_r.b176 } in
  set_idx_mut r ((.b176) : (t176, _) idx_mut) next_r.b176;
  mark_test_run 1905;
  let test = eq r expected in
  if not test then failwithf "test 1905 failed";
  mark_test_run 1906;
  let test = sub_eq (get_idx_mut r ((.b176) : (t176, _) idx_mut)) next_r.b176 in
  if not test then failwithf "test 1906 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a176 = (#{ a174 = 200L; b174 = #201L } : t174); b176 = (#{ a175 = #202L; b175 = #203. } : t175) } : t176) in
  (* .b176.#a175 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b176 = #{ r.b176 with a175 = next_r.b176.#a175 } } in
  set_idx_mut r ((.b176.#a175) : (t176, _) idx_mut) next_r.b176.#a175;
  mark_test_run 1907;
  let test = eq r expected in
  if not test then failwithf "test 1907 failed";
  mark_test_run 1908;
  let test = sub_eq (get_idx_mut r ((.b176.#a175) : (t176, _) idx_mut)) next_r.b176.#a175 in
  if not test then failwithf "test 1908 failed";
  (* .b176.#b175 *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b176 = #{ r.b176 with b175 = next_r.b176.#b175 } } in
  set_idx_mut r ((.b176.#b175) : (t176, _) idx_mut) next_r.b176.#b175;
  mark_test_run 1909;
  let test = eq r expected in
  if not test then failwithf "test 1909 failed";
  mark_test_run 1910;
  let test = sub_eq (get_idx_mut r ((.b176.#b175) : (t176, _) idx_mut)) next_r.b176.#b175 in
  if not test then failwithf "test 1910 failed";
  (**********************************************************)
  (*   t179 = { #{ int64; string }; #{ int64#; string } }   *)
  (**********************************************************)
  let eq = (fun ({ a179 = a1791; b179 = b1791 } : t179) ({ a179 = a1792; b179 = b1792 } : t179) -> (fun (#{ a177 = a1771; b177 = b1771 } : t177) (#{ a177 = a1772; b177 = b1772 } : t177) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1771 a1772 && (fun a b -> String.equal (globalize a) (globalize b)) b1771 b1772) a1791 a1792 && (fun (#{ a178 = a1781; b178 = b1781 } : t178) (#{ a178 = a1782; b178 = b1782 } : t178) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1781 a1782 && (fun a b -> String.equal (globalize a) (globalize b)) b1781 b1782) b1791 b1792) in
  let r = ({ a179 = (#{ a177 = 0L; b177 = "1" } : t177); b179 = (#{ a178 = #2L; b178 = "3" } : t178) } : t179) in
  (* Paths of depth 0 *)
  let next_r = ({ a179 = (#{ a177 = 100L; b177 = "101" } : t177); b179 = (#{ a178 = #102L; b178 = "103" } : t178) } : t179) in
  (* .a179 *)
  let sub_eq = (fun (#{ a177 = a1771; b177 = b1771 } : t177) (#{ a177 = a1772; b177 = b1772 } : t177) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1771 a1772 && (fun a b -> String.equal (globalize a) (globalize b)) b1771 b1772) in
  let expected = { r with a179 = next_r.a179 } in
  set_idx_mut r ((.a179) : (t179, _) idx_mut) next_r.a179;
  mark_test_run 1911;
  let test = eq r expected in
  if not test then failwithf "test 1911 failed";
  mark_test_run 1912;
  let test = sub_eq (get_idx_mut r ((.a179) : (t179, _) idx_mut)) next_r.a179 in
  if not test then failwithf "test 1912 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a179 = (#{ a177 = 200L; b177 = "201" } : t177); b179 = (#{ a178 = #202L; b178 = "203" } : t178) } : t179) in
  (* .a179.#a177 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a179 = #{ r.a179 with a177 = next_r.a179.#a177 } } in
  set_idx_mut r ((.a179.#a177) : (t179, _) idx_mut) next_r.a179.#a177;
  mark_test_run 1913;
  let test = eq r expected in
  if not test then failwithf "test 1913 failed";
  mark_test_run 1914;
  let test = sub_eq (get_idx_mut r ((.a179.#a177) : (t179, _) idx_mut)) next_r.a179.#a177 in
  if not test then failwithf "test 1914 failed";
  (* .a179.#b177 *)
  let sub_eq = (fun a b -> String.equal (globalize a) (globalize b)) in
  let expected = { r with a179 = #{ r.a179 with b177 = next_r.a179.#b177 } } in
  set_idx_mut r ((.a179.#b177) : (t179, _) idx_mut) next_r.a179.#b177;
  mark_test_run 1915;
  let test = eq r expected in
  if not test then failwithf "test 1915 failed";
  mark_test_run 1916;
  let test = sub_eq (get_idx_mut r ((.a179.#b177) : (t179, _) idx_mut)) next_r.a179.#b177 in
  if not test then failwithf "test 1916 failed";
  let r = ({ a179 = (#{ a177 = 0L; b177 = "1" } : t177); b179 = (#{ a178 = #2L; b178 = "3" } : t178) } : t179) in
  (* Paths of depth 0 *)
  let next_r = ({ a179 = (#{ a177 = 100L; b177 = "101" } : t177); b179 = (#{ a178 = #102L; b178 = "103" } : t178) } : t179) in
  (* .b179 *)
  let sub_eq = (fun (#{ a178 = a1781; b178 = b1781 } : t178) (#{ a178 = a1782; b178 = b1782 } : t178) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1781 a1782 && (fun a b -> String.equal (globalize a) (globalize b)) b1781 b1782) in
  let expected = { r with b179 = next_r.b179 } in
  set_idx_mut r ((.b179) : (t179, _) idx_mut) next_r.b179;
  mark_test_run 1917;
  let test = eq r expected in
  if not test then failwithf "test 1917 failed";
  mark_test_run 1918;
  let test = sub_eq (get_idx_mut r ((.b179) : (t179, _) idx_mut)) next_r.b179 in
  if not test then failwithf "test 1918 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a179 = (#{ a177 = 200L; b177 = "201" } : t177); b179 = (#{ a178 = #202L; b178 = "203" } : t178) } : t179) in
  (* .b179.#a178 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b179 = #{ r.b179 with a178 = next_r.b179.#a178 } } in
  set_idx_mut r ((.b179.#a178) : (t179, _) idx_mut) next_r.b179.#a178;
  mark_test_run 1919;
  let test = eq r expected in
  if not test then failwithf "test 1919 failed";
  mark_test_run 1920;
  let test = sub_eq (get_idx_mut r ((.b179.#a178) : (t179, _) idx_mut)) next_r.b179.#a178 in
  if not test then failwithf "test 1920 failed";
  (* .b179.#b178 *)
  let sub_eq = (fun a b -> String.equal (globalize a) (globalize b)) in
  let expected = { r with b179 = #{ r.b179 with b178 = next_r.b179.#b178 } } in
  set_idx_mut r ((.b179.#b178) : (t179, _) idx_mut) next_r.b179.#b178;
  mark_test_run 1921;
  let test = eq r expected in
  if not test then failwithf "test 1921 failed";
  mark_test_run 1922;
  let test = sub_eq (get_idx_mut r ((.b179.#b178) : (t179, _) idx_mut)) next_r.b179.#b178 in
  if not test then failwithf "test 1922 failed";
  (********************************************************)
  (*   t181 = { #{ int64#; int64 }; #{ int64; int64 } }   *)
  (********************************************************)
  let eq = (fun ({ a181 = a1811; b181 = b1811 } : t181) ({ a181 = a1812; b181 = b1812 } : t181) -> (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) a1811 a1812 && (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) b1811 b1812) in
  let r = ({ a181 = (#{ a180 = #0L; b180 = 1L } : t180); b181 = (#{ a29 = 2L; b29 = 3L } : t29) } : t181) in
  (* Paths of depth 0 *)
  let next_r = ({ a181 = (#{ a180 = #100L; b180 = 101L } : t180); b181 = (#{ a29 = 102L; b29 = 103L } : t29) } : t181) in
  (* .a181 *)
  let sub_eq = (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) in
  let expected = { r with a181 = next_r.a181 } in
  set_idx_mut r ((.a181) : (t181, _) idx_mut) next_r.a181;
  mark_test_run 1923;
  let test = eq r expected in
  if not test then failwithf "test 1923 failed";
  mark_test_run 1924;
  let test = sub_eq (get_idx_mut r ((.a181) : (t181, _) idx_mut)) next_r.a181 in
  if not test then failwithf "test 1924 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a181 = (#{ a180 = #200L; b180 = 201L } : t180); b181 = (#{ a29 = 202L; b29 = 203L } : t29) } : t181) in
  (* .a181.#a180 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a181 = #{ r.a181 with a180 = next_r.a181.#a180 } } in
  set_idx_mut r ((.a181.#a180) : (t181, _) idx_mut) next_r.a181.#a180;
  mark_test_run 1925;
  let test = eq r expected in
  if not test then failwithf "test 1925 failed";
  mark_test_run 1926;
  let test = sub_eq (get_idx_mut r ((.a181.#a180) : (t181, _) idx_mut)) next_r.a181.#a180 in
  if not test then failwithf "test 1926 failed";
  (* .a181.#b180 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a181 = #{ r.a181 with b180 = next_r.a181.#b180 } } in
  set_idx_mut r ((.a181.#b180) : (t181, _) idx_mut) next_r.a181.#b180;
  mark_test_run 1927;
  let test = eq r expected in
  if not test then failwithf "test 1927 failed";
  mark_test_run 1928;
  let test = sub_eq (get_idx_mut r ((.a181.#b180) : (t181, _) idx_mut)) next_r.a181.#b180 in
  if not test then failwithf "test 1928 failed";
  let r = ({ a181 = (#{ a180 = #0L; b180 = 1L } : t180); b181 = (#{ a29 = 2L; b29 = 3L } : t29) } : t181) in
  (* Paths of depth 0 *)
  let next_r = ({ a181 = (#{ a180 = #100L; b180 = 101L } : t180); b181 = (#{ a29 = 102L; b29 = 103L } : t29) } : t181) in
  (* .b181 *)
  let sub_eq = (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) in
  let expected = { r with b181 = next_r.b181 } in
  set_idx_mut r ((.b181) : (t181, _) idx_mut) next_r.b181;
  mark_test_run 1929;
  let test = eq r expected in
  if not test then failwithf "test 1929 failed";
  mark_test_run 1930;
  let test = sub_eq (get_idx_mut r ((.b181) : (t181, _) idx_mut)) next_r.b181 in
  if not test then failwithf "test 1930 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a181 = (#{ a180 = #200L; b180 = 201L } : t180); b181 = (#{ a29 = 202L; b29 = 203L } : t29) } : t181) in
  (* .b181.#a29 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b181 = #{ r.b181 with a29 = next_r.b181.#a29 } } in
  set_idx_mut r ((.b181.#a29) : (t181, _) idx_mut) next_r.b181.#a29;
  mark_test_run 1931;
  let test = eq r expected in
  if not test then failwithf "test 1931 failed";
  mark_test_run 1932;
  let test = sub_eq (get_idx_mut r ((.b181.#a29) : (t181, _) idx_mut)) next_r.b181.#a29 in
  if not test then failwithf "test 1932 failed";
  (* .b181.#b29 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b181 = #{ r.b181 with b29 = next_r.b181.#b29 } } in
  set_idx_mut r ((.b181.#b29) : (t181, _) idx_mut) next_r.b181.#b29;
  mark_test_run 1933;
  let test = eq r expected in
  if not test then failwithf "test 1933 failed";
  mark_test_run 1934;
  let test = sub_eq (get_idx_mut r ((.b181.#b29) : (t181, _) idx_mut)) next_r.b181.#b29 in
  if not test then failwithf "test 1934 failed";
  (***********************************************************)
  (*   t183 = { #{ int64#; int64 }; #{ float32#; float } }   *)
  (***********************************************************)
  let eq = (fun ({ a183 = a1831; b183 = b1831 } : t183) ({ a183 = a1832; b183 = b1832 } : t183) -> (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) a1831 a1832 && (fun (#{ a182 = a1821; b182 = b1821 } : t182) (#{ a182 = a1822; b182 = b1822 } : t182) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a1821 a1822 && (fun a b -> Float.equal (globalize a) (globalize b)) b1821 b1822) b1831 b1832) in
  let r = ({ a183 = (#{ a180 = #0L; b180 = 1L } : t180); b183 = (#{ a182 = #2.s; b182 = 3. } : t182) } : t183) in
  (* Paths of depth 0 *)
  let next_r = ({ a183 = (#{ a180 = #100L; b180 = 101L } : t180); b183 = (#{ a182 = #102.s; b182 = 103. } : t182) } : t183) in
  (* .a183 *)
  let sub_eq = (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) in
  let expected = { r with a183 = next_r.a183 } in
  set_idx_mut r ((.a183) : (t183, _) idx_mut) next_r.a183;
  mark_test_run 1935;
  let test = eq r expected in
  if not test then failwithf "test 1935 failed";
  mark_test_run 1936;
  let test = sub_eq (get_idx_mut r ((.a183) : (t183, _) idx_mut)) next_r.a183 in
  if not test then failwithf "test 1936 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a183 = (#{ a180 = #200L; b180 = 201L } : t180); b183 = (#{ a182 = #202.s; b182 = 203. } : t182) } : t183) in
  (* .a183.#a180 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a183 = #{ r.a183 with a180 = next_r.a183.#a180 } } in
  set_idx_mut r ((.a183.#a180) : (t183, _) idx_mut) next_r.a183.#a180;
  mark_test_run 1937;
  let test = eq r expected in
  if not test then failwithf "test 1937 failed";
  mark_test_run 1938;
  let test = sub_eq (get_idx_mut r ((.a183.#a180) : (t183, _) idx_mut)) next_r.a183.#a180 in
  if not test then failwithf "test 1938 failed";
  (* .a183.#b180 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a183 = #{ r.a183 with b180 = next_r.a183.#b180 } } in
  set_idx_mut r ((.a183.#b180) : (t183, _) idx_mut) next_r.a183.#b180;
  mark_test_run 1939;
  let test = eq r expected in
  if not test then failwithf "test 1939 failed";
  mark_test_run 1940;
  let test = sub_eq (get_idx_mut r ((.a183.#b180) : (t183, _) idx_mut)) next_r.a183.#b180 in
  if not test then failwithf "test 1940 failed";
  let r = ({ a183 = (#{ a180 = #0L; b180 = 1L } : t180); b183 = (#{ a182 = #2.s; b182 = 3. } : t182) } : t183) in
  (* Paths of depth 0 *)
  let next_r = ({ a183 = (#{ a180 = #100L; b180 = 101L } : t180); b183 = (#{ a182 = #102.s; b182 = 103. } : t182) } : t183) in
  (* .b183 *)
  let sub_eq = (fun (#{ a182 = a1821; b182 = b1821 } : t182) (#{ a182 = a1822; b182 = b1822 } : t182) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a1821 a1822 && (fun a b -> Float.equal (globalize a) (globalize b)) b1821 b1822) in
  let expected = { r with b183 = next_r.b183 } in
  set_idx_mut r ((.b183) : (t183, _) idx_mut) next_r.b183;
  mark_test_run 1941;
  let test = eq r expected in
  if not test then failwithf "test 1941 failed";
  mark_test_run 1942;
  let test = sub_eq (get_idx_mut r ((.b183) : (t183, _) idx_mut)) next_r.b183 in
  if not test then failwithf "test 1942 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a183 = (#{ a180 = #200L; b180 = 201L } : t180); b183 = (#{ a182 = #202.s; b182 = 203. } : t182) } : t183) in
  (* .b183.#a182 *)
  let sub_eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let expected = { r with b183 = #{ r.b183 with a182 = next_r.b183.#a182 } } in
  set_idx_mut r ((.b183.#a182) : (t183, _) idx_mut) next_r.b183.#a182;
  mark_test_run 1943;
  let test = eq r expected in
  if not test then failwithf "test 1943 failed";
  mark_test_run 1944;
  let test = sub_eq (get_idx_mut r ((.b183.#a182) : (t183, _) idx_mut)) next_r.b183.#a182 in
  if not test then failwithf "test 1944 failed";
  (* .b183.#b182 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b183 = #{ r.b183 with b182 = next_r.b183.#b182 } } in
  set_idx_mut r ((.b183.#b182) : (t183, _) idx_mut) next_r.b183.#b182;
  mark_test_run 1945;
  let test = eq r expected in
  if not test then failwithf "test 1945 failed";
  mark_test_run 1946;
  let test = sub_eq (get_idx_mut r ((.b183.#b182) : (t183, _) idx_mut)) next_r.b183.#b182 in
  if not test then failwithf "test 1946 failed";
  (******************************)
  (*   t184 = { #{ int32# } }   *)
  (******************************)
  let eq = (fun ({ a184 = a1841 } : t184) ({ a184 = a1842 } : t184) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a1841 a1842) in
  let r = ({ a184 = (#{ a17 = #0l } : t17) } : t184) in
  (* Paths of depth 0 *)
  let next_r = ({ a184 = (#{ a17 = #100l } : t17) } : t184) in
  (* .a184 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with a184 = next_r.a184 } in
  set_idx_mut r ((.a184) : (t184, _) idx_mut) next_r.a184;
  mark_test_run 1947;
  let test = eq r expected in
  if not test then failwithf "test 1947 failed";
  mark_test_run 1948;
  let test = sub_eq (get_idx_mut r ((.a184) : (t184, _) idx_mut)) next_r.a184 in
  if not test then failwithf "test 1948 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a184 = (#{ a17 = #200l } : t17) } : t184) in
  (* .a184.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a184 = #{ r.a184 with a17 = next_r.a184.#a17 } } in
  set_idx_mut r ((.a184.#a17) : (t184, _) idx_mut) next_r.a184.#a17;
  mark_test_run 1949;
  let test = eq r expected in
  if not test then failwithf "test 1949 failed";
  mark_test_run 1950;
  let test = sub_eq (get_idx_mut r ((.a184.#a17) : (t184, _) idx_mut)) next_r.a184.#a17 in
  if not test then failwithf "test 1950 failed";
  (***********************************)
  (*   t185 = { #{ int32# }; int }   *)
  (***********************************)
  let eq = (fun ({ a185 = a1851; b185 = b1851 } : t185) ({ a185 = a1852; b185 = b1852 } : t185) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a1851 a1852 && (fun a b -> Int.equal a b) b1851 b1852) in
  let r = ({ a185 = (#{ a17 = #0l } : t17); b185 = 1 } : t185) in
  (* Paths of depth 0 *)
  let next_r = ({ a185 = (#{ a17 = #100l } : t17); b185 = 101 } : t185) in
  (* .a185 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with a185 = next_r.a185 } in
  set_idx_mut r ((.a185) : (t185, _) idx_mut) next_r.a185;
  mark_test_run 1951;
  let test = eq r expected in
  if not test then failwithf "test 1951 failed";
  mark_test_run 1952;
  let test = sub_eq (get_idx_mut r ((.a185) : (t185, _) idx_mut)) next_r.a185 in
  if not test then failwithf "test 1952 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a185 = (#{ a17 = #200l } : t17); b185 = 201 } : t185) in
  (* .a185.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a185 = #{ r.a185 with a17 = next_r.a185.#a17 } } in
  set_idx_mut r ((.a185.#a17) : (t185, _) idx_mut) next_r.a185.#a17;
  mark_test_run 1953;
  let test = eq r expected in
  if not test then failwithf "test 1953 failed";
  mark_test_run 1954;
  let test = sub_eq (get_idx_mut r ((.a185.#a17) : (t185, _) idx_mut)) next_r.a185.#a17 in
  if not test then failwithf "test 1954 failed";
  let r = ({ a185 = (#{ a17 = #0l } : t17); b185 = 1 } : t185) in
  (* Paths of depth 0 *)
  let next_r = ({ a185 = (#{ a17 = #100l } : t17); b185 = 101 } : t185) in
  (* .b185 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b185 = next_r.b185 } in
  set_idx_mut r ((.b185) : (t185, _) idx_mut) next_r.b185;
  mark_test_run 1955;
  let test = eq r expected in
  if not test then failwithf "test 1955 failed";
  mark_test_run 1956;
  let test = sub_eq (get_idx_mut r ((.b185) : (t185, _) idx_mut)) next_r.b185 in
  if not test then failwithf "test 1956 failed";
  (**************************************)
  (*   t186 = { #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun ({ a186 = a1861; b186 = b1861 } : t186) ({ a186 = a1862; b186 = b1862 } : t186) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a1861 a1862 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1861 b1862) in
  let r = ({ a186 = (#{ a17 = #0l } : t17); b186 = #1l } : t186) in
  (* Paths of depth 0 *)
  let next_r = ({ a186 = (#{ a17 = #100l } : t17); b186 = #101l } : t186) in
  (* .a186 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with a186 = next_r.a186 } in
  set_idx_mut r ((.a186) : (t186, _) idx_mut) next_r.a186;
  mark_test_run 1957;
  let test = eq r expected in
  if not test then failwithf "test 1957 failed";
  mark_test_run 1958;
  let test = sub_eq (get_idx_mut r ((.a186) : (t186, _) idx_mut)) next_r.a186 in
  if not test then failwithf "test 1958 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a186 = (#{ a17 = #200l } : t17); b186 = #201l } : t186) in
  (* .a186.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a186 = #{ r.a186 with a17 = next_r.a186.#a17 } } in
  set_idx_mut r ((.a186.#a17) : (t186, _) idx_mut) next_r.a186.#a17;
  mark_test_run 1959;
  let test = eq r expected in
  if not test then failwithf "test 1959 failed";
  mark_test_run 1960;
  let test = sub_eq (get_idx_mut r ((.a186.#a17) : (t186, _) idx_mut)) next_r.a186.#a17 in
  if not test then failwithf "test 1960 failed";
  let r = ({ a186 = (#{ a17 = #0l } : t17); b186 = #1l } : t186) in
  (* Paths of depth 0 *)
  let next_r = ({ a186 = (#{ a17 = #100l } : t17); b186 = #101l } : t186) in
  (* .b186 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b186 = next_r.b186 } in
  set_idx_mut r ((.b186) : (t186, _) idx_mut) next_r.b186;
  mark_test_run 1961;
  let test = eq r expected in
  if not test then failwithf "test 1961 failed";
  mark_test_run 1962;
  let test = sub_eq (get_idx_mut r ((.b186) : (t186, _) idx_mut)) next_r.b186 in
  if not test then failwithf "test 1962 failed";
  (***********************************)
  (*   t187 = { #{ int32#; int } }   *)
  (***********************************)
  let eq = (fun ({ a187 = a1871 } : t187) ({ a187 = a1872 } : t187) -> (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1871 a1872) in
  let r = ({ a187 = (#{ a99 = #0l; b99 = 1 } : t99) } : t187) in
  (* Paths of depth 0 *)
  let next_r = ({ a187 = (#{ a99 = #100l; b99 = 101 } : t99) } : t187) in
  (* .a187 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with a187 = next_r.a187 } in
  set_idx_mut r ((.a187) : (t187, _) idx_mut) next_r.a187;
  mark_test_run 1963;
  let test = eq r expected in
  if not test then failwithf "test 1963 failed";
  mark_test_run 1964;
  let test = sub_eq (get_idx_mut r ((.a187) : (t187, _) idx_mut)) next_r.a187 in
  if not test then failwithf "test 1964 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a187 = (#{ a99 = #200l; b99 = 201 } : t99) } : t187) in
  (* .a187.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a187 = #{ r.a187 with a99 = next_r.a187.#a99 } } in
  set_idx_mut r ((.a187.#a99) : (t187, _) idx_mut) next_r.a187.#a99;
  mark_test_run 1965;
  let test = eq r expected in
  if not test then failwithf "test 1965 failed";
  mark_test_run 1966;
  let test = sub_eq (get_idx_mut r ((.a187.#a99) : (t187, _) idx_mut)) next_r.a187.#a99 in
  if not test then failwithf "test 1966 failed";
  (* .a187.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a187 = #{ r.a187 with b99 = next_r.a187.#b99 } } in
  set_idx_mut r ((.a187.#b99) : (t187, _) idx_mut) next_r.a187.#b99;
  mark_test_run 1967;
  let test = eq r expected in
  if not test then failwithf "test 1967 failed";
  mark_test_run 1968;
  let test = sub_eq (get_idx_mut r ((.a187.#b99) : (t187, _) idx_mut)) next_r.a187.#b99 in
  if not test then failwithf "test 1968 failed";
  (****************************************)
  (*   t188 = { #{ int32#; int }; int }   *)
  (****************************************)
  let eq = (fun ({ a188 = a1881; b188 = b1881 } : t188) ({ a188 = a1882; b188 = b1882 } : t188) -> (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1881 a1882 && (fun a b -> Int.equal a b) b1881 b1882) in
  let r = ({ a188 = (#{ a99 = #0l; b99 = 1 } : t99); b188 = 2 } : t188) in
  (* Paths of depth 0 *)
  let next_r = ({ a188 = (#{ a99 = #100l; b99 = 101 } : t99); b188 = 102 } : t188) in
  (* .a188 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with a188 = next_r.a188 } in
  set_idx_mut r ((.a188) : (t188, _) idx_mut) next_r.a188;
  mark_test_run 1969;
  let test = eq r expected in
  if not test then failwithf "test 1969 failed";
  mark_test_run 1970;
  let test = sub_eq (get_idx_mut r ((.a188) : (t188, _) idx_mut)) next_r.a188 in
  if not test then failwithf "test 1970 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a188 = (#{ a99 = #200l; b99 = 201 } : t99); b188 = 202 } : t188) in
  (* .a188.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a188 = #{ r.a188 with a99 = next_r.a188.#a99 } } in
  set_idx_mut r ((.a188.#a99) : (t188, _) idx_mut) next_r.a188.#a99;
  mark_test_run 1971;
  let test = eq r expected in
  if not test then failwithf "test 1971 failed";
  mark_test_run 1972;
  let test = sub_eq (get_idx_mut r ((.a188.#a99) : (t188, _) idx_mut)) next_r.a188.#a99 in
  if not test then failwithf "test 1972 failed";
  (* .a188.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a188 = #{ r.a188 with b99 = next_r.a188.#b99 } } in
  set_idx_mut r ((.a188.#b99) : (t188, _) idx_mut) next_r.a188.#b99;
  mark_test_run 1973;
  let test = eq r expected in
  if not test then failwithf "test 1973 failed";
  mark_test_run 1974;
  let test = sub_eq (get_idx_mut r ((.a188.#b99) : (t188, _) idx_mut)) next_r.a188.#b99 in
  if not test then failwithf "test 1974 failed";
  let r = ({ a188 = (#{ a99 = #0l; b99 = 1 } : t99); b188 = 2 } : t188) in
  (* Paths of depth 0 *)
  let next_r = ({ a188 = (#{ a99 = #100l; b99 = 101 } : t99); b188 = 102 } : t188) in
  (* .b188 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b188 = next_r.b188 } in
  set_idx_mut r ((.b188) : (t188, _) idx_mut) next_r.b188;
  mark_test_run 1975;
  let test = eq r expected in
  if not test then failwithf "test 1975 failed";
  mark_test_run 1976;
  let test = sub_eq (get_idx_mut r ((.b188) : (t188, _) idx_mut)) next_r.b188 in
  if not test then failwithf "test 1976 failed";
  (*******************************************)
  (*   t189 = { #{ int32#; int }; int32# }   *)
  (*******************************************)
  let eq = (fun ({ a189 = a1891; b189 = b1891 } : t189) ({ a189 = a1892; b189 = b1892 } : t189) -> (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1891 a1892 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1891 b1892) in
  let r = ({ a189 = (#{ a99 = #0l; b99 = 1 } : t99); b189 = #2l } : t189) in
  (* Paths of depth 0 *)
  let next_r = ({ a189 = (#{ a99 = #100l; b99 = 101 } : t99); b189 = #102l } : t189) in
  (* .a189 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with a189 = next_r.a189 } in
  set_idx_mut r ((.a189) : (t189, _) idx_mut) next_r.a189;
  mark_test_run 1977;
  let test = eq r expected in
  if not test then failwithf "test 1977 failed";
  mark_test_run 1978;
  let test = sub_eq (get_idx_mut r ((.a189) : (t189, _) idx_mut)) next_r.a189 in
  if not test then failwithf "test 1978 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a189 = (#{ a99 = #200l; b99 = 201 } : t99); b189 = #202l } : t189) in
  (* .a189.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a189 = #{ r.a189 with a99 = next_r.a189.#a99 } } in
  set_idx_mut r ((.a189.#a99) : (t189, _) idx_mut) next_r.a189.#a99;
  mark_test_run 1979;
  let test = eq r expected in
  if not test then failwithf "test 1979 failed";
  mark_test_run 1980;
  let test = sub_eq (get_idx_mut r ((.a189.#a99) : (t189, _) idx_mut)) next_r.a189.#a99 in
  if not test then failwithf "test 1980 failed";
  (* .a189.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a189 = #{ r.a189 with b99 = next_r.a189.#b99 } } in
  set_idx_mut r ((.a189.#b99) : (t189, _) idx_mut) next_r.a189.#b99;
  mark_test_run 1981;
  let test = eq r expected in
  if not test then failwithf "test 1981 failed";
  mark_test_run 1982;
  let test = sub_eq (get_idx_mut r ((.a189.#b99) : (t189, _) idx_mut)) next_r.a189.#b99 in
  if not test then failwithf "test 1982 failed";
  let r = ({ a189 = (#{ a99 = #0l; b99 = 1 } : t99); b189 = #2l } : t189) in
  (* Paths of depth 0 *)
  let next_r = ({ a189 = (#{ a99 = #100l; b99 = 101 } : t99); b189 = #102l } : t189) in
  (* .b189 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b189 = next_r.b189 } in
  set_idx_mut r ((.b189) : (t189, _) idx_mut) next_r.b189;
  mark_test_run 1983;
  let test = eq r expected in
  if not test then failwithf "test 1983 failed";
  mark_test_run 1984;
  let test = sub_eq (get_idx_mut r ((.b189) : (t189, _) idx_mut)) next_r.b189 in
  if not test then failwithf "test 1984 failed";
  (**************************************)
  (*   t190 = { #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun ({ a190 = a1901 } : t190) ({ a190 = a1902 } : t190) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a1901 a1902) in
  let r = ({ a190 = (#{ a19 = #0l; b19 = #1l } : t19) } : t190) in
  (* Paths of depth 0 *)
  let next_r = ({ a190 = (#{ a19 = #100l; b19 = #101l } : t19) } : t190) in
  (* .a190 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with a190 = next_r.a190 } in
  set_idx_mut r ((.a190) : (t190, _) idx_mut) next_r.a190;
  mark_test_run 1985;
  let test = eq r expected in
  if not test then failwithf "test 1985 failed";
  mark_test_run 1986;
  let test = sub_eq (get_idx_mut r ((.a190) : (t190, _) idx_mut)) next_r.a190 in
  if not test then failwithf "test 1986 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a190 = (#{ a19 = #200l; b19 = #201l } : t19) } : t190) in
  (* .a190.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a190 = #{ r.a190 with a19 = next_r.a190.#a19 } } in
  set_idx_mut r ((.a190.#a19) : (t190, _) idx_mut) next_r.a190.#a19;
  mark_test_run 1987;
  let test = eq r expected in
  if not test then failwithf "test 1987 failed";
  mark_test_run 1988;
  let test = sub_eq (get_idx_mut r ((.a190.#a19) : (t190, _) idx_mut)) next_r.a190.#a19 in
  if not test then failwithf "test 1988 failed";
  (* .a190.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a190 = #{ r.a190 with b19 = next_r.a190.#b19 } } in
  set_idx_mut r ((.a190.#b19) : (t190, _) idx_mut) next_r.a190.#b19;
  mark_test_run 1989;
  let test = eq r expected in
  if not test then failwithf "test 1989 failed";
  mark_test_run 1990;
  let test = sub_eq (get_idx_mut r ((.a190.#b19) : (t190, _) idx_mut)) next_r.a190.#b19 in
  if not test then failwithf "test 1990 failed";
  (*******************************************)
  (*   t191 = { #{ int32#; int32# }; int }   *)
  (*******************************************)
  let eq = (fun ({ a191 = a1911; b191 = b1911 } : t191) ({ a191 = a1912; b191 = b1912 } : t191) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a1911 a1912 && (fun a b -> Int.equal a b) b1911 b1912) in
  let r = ({ a191 = (#{ a19 = #0l; b19 = #1l } : t19); b191 = 2 } : t191) in
  (* Paths of depth 0 *)
  let next_r = ({ a191 = (#{ a19 = #100l; b19 = #101l } : t19); b191 = 102 } : t191) in
  (* .a191 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with a191 = next_r.a191 } in
  set_idx_mut r ((.a191) : (t191, _) idx_mut) next_r.a191;
  mark_test_run 1991;
  let test = eq r expected in
  if not test then failwithf "test 1991 failed";
  mark_test_run 1992;
  let test = sub_eq (get_idx_mut r ((.a191) : (t191, _) idx_mut)) next_r.a191 in
  if not test then failwithf "test 1992 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a191 = (#{ a19 = #200l; b19 = #201l } : t19); b191 = 202 } : t191) in
  (* .a191.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a191 = #{ r.a191 with a19 = next_r.a191.#a19 } } in
  set_idx_mut r ((.a191.#a19) : (t191, _) idx_mut) next_r.a191.#a19;
  mark_test_run 1993;
  let test = eq r expected in
  if not test then failwithf "test 1993 failed";
  mark_test_run 1994;
  let test = sub_eq (get_idx_mut r ((.a191.#a19) : (t191, _) idx_mut)) next_r.a191.#a19 in
  if not test then failwithf "test 1994 failed";
  (* .a191.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a191 = #{ r.a191 with b19 = next_r.a191.#b19 } } in
  set_idx_mut r ((.a191.#b19) : (t191, _) idx_mut) next_r.a191.#b19;
  mark_test_run 1995;
  let test = eq r expected in
  if not test then failwithf "test 1995 failed";
  mark_test_run 1996;
  let test = sub_eq (get_idx_mut r ((.a191.#b19) : (t191, _) idx_mut)) next_r.a191.#b19 in
  if not test then failwithf "test 1996 failed";
  let r = ({ a191 = (#{ a19 = #0l; b19 = #1l } : t19); b191 = 2 } : t191) in
  (* Paths of depth 0 *)
  let next_r = ({ a191 = (#{ a19 = #100l; b19 = #101l } : t19); b191 = 102 } : t191) in
  (* .b191 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b191 = next_r.b191 } in
  set_idx_mut r ((.b191) : (t191, _) idx_mut) next_r.b191;
  mark_test_run 1997;
  let test = eq r expected in
  if not test then failwithf "test 1997 failed";
  mark_test_run 1998;
  let test = sub_eq (get_idx_mut r ((.b191) : (t191, _) idx_mut)) next_r.b191 in
  if not test then failwithf "test 1998 failed";
  (**********************************************)
  (*   t192 = { #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun ({ a192 = a1921; b192 = b1921 } : t192) ({ a192 = a1922; b192 = b1922 } : t192) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a1921 a1922 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1921 b1922) in
  let r = ({ a192 = (#{ a19 = #0l; b19 = #1l } : t19); b192 = #2l } : t192) in
  (* Paths of depth 0 *)
  let next_r = ({ a192 = (#{ a19 = #100l; b19 = #101l } : t19); b192 = #102l } : t192) in
  (* .a192 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with a192 = next_r.a192 } in
  set_idx_mut r ((.a192) : (t192, _) idx_mut) next_r.a192;
  mark_test_run 1999;
  let test = eq r expected in
  if not test then failwithf "test 1999 failed";
  mark_test_run 2000;
  let test = sub_eq (get_idx_mut r ((.a192) : (t192, _) idx_mut)) next_r.a192 in
  if not test then failwithf "test 2000 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a192 = (#{ a19 = #200l; b19 = #201l } : t19); b192 = #202l } : t192) in
  (* .a192.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a192 = #{ r.a192 with a19 = next_r.a192.#a19 } } in
  set_idx_mut r ((.a192.#a19) : (t192, _) idx_mut) next_r.a192.#a19;
  mark_test_run 2001;
  let test = eq r expected in
  if not test then failwithf "test 2001 failed";
  mark_test_run 2002;
  let test = sub_eq (get_idx_mut r ((.a192.#a19) : (t192, _) idx_mut)) next_r.a192.#a19 in
  if not test then failwithf "test 2002 failed";
  (* .a192.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a192 = #{ r.a192 with b19 = next_r.a192.#b19 } } in
  set_idx_mut r ((.a192.#b19) : (t192, _) idx_mut) next_r.a192.#b19;
  mark_test_run 2003;
  let test = eq r expected in
  if not test then failwithf "test 2003 failed";
  mark_test_run 2004;
  let test = sub_eq (get_idx_mut r ((.a192.#b19) : (t192, _) idx_mut)) next_r.a192.#b19 in
  if not test then failwithf "test 2004 failed";
  let r = ({ a192 = (#{ a19 = #0l; b19 = #1l } : t19); b192 = #2l } : t192) in
  (* Paths of depth 0 *)
  let next_r = ({ a192 = (#{ a19 = #100l; b19 = #101l } : t19); b192 = #102l } : t192) in
  (* .b192 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b192 = next_r.b192 } in
  set_idx_mut r ((.b192) : (t192, _) idx_mut) next_r.b192;
  mark_test_run 2005;
  let test = eq r expected in
  if not test then failwithf "test 2005 failed";
  mark_test_run 2006;
  let test = sub_eq (get_idx_mut r ((.b192) : (t192, _) idx_mut)) next_r.b192 in
  if not test then failwithf "test 2006 failed";
  (*****************************)
  (*   t193 = { #{ float } }   *)
  (*****************************)
  let eq = (fun ({ a193 = a1931 } : t193) ({ a193 = a1932 } : t193) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1931 a1932) in
  let r = ({ a193 = (#{ a21 = 0. } : t21) } : t193) in
  (* Paths of depth 0 *)
  let next_r = ({ a193 = (#{ a21 = 100. } : t21) } : t193) in
  (* .a193 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a193 = next_r.a193 } in
  set_idx_mut r ((.a193) : (t193, _) idx_mut) (Float_u.of_float next_r.a193.#a21);
  mark_test_run 2007;
  let test = eq r expected in
  if not test then failwithf "test 2007 failed";
  mark_test_run 2008;
  let test = sub_eq (get_idx_mut r ((.a193) : (t193, _) idx_mut)) (Float_u.of_float next_r.a193.#a21) in
  if not test then failwithf "test 2008 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a193 = (#{ a21 = 200. } : t21) } : t193) in
  (* .a193.#a21 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a193 = #{ r.a193 with a21 = next_r.a193.#a21 } } in
  set_idx_mut r ((.a193.#a21) : (t193, _) idx_mut) (Float_u.of_float next_r.a193.#a21);
  mark_test_run 2009;
  let test = eq r expected in
  if not test then failwithf "test 2009 failed";
  mark_test_run 2010;
  let test = sub_eq (get_idx_mut r ((.a193.#a21) : (t193, _) idx_mut)) (Float_u.of_float next_r.a193.#a21) in
  if not test then failwithf "test 2010 failed";
  (**********************************)
  (*   t194 = { #{ float }; int }   *)
  (**********************************)
  let eq = (fun ({ a194 = a1941; b194 = b1941 } : t194) ({ a194 = a1942; b194 = b1942 } : t194) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1941 a1942 && (fun a b -> Int.equal a b) b1941 b1942) in
  let r = ({ a194 = (#{ a21 = 0. } : t21); b194 = 1 } : t194) in
  (* Paths of depth 0 *)
  let next_r = ({ a194 = (#{ a21 = 100. } : t21); b194 = 101 } : t194) in
  (* .a194 *)
  let sub_eq = (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) in
  let expected = { r with a194 = next_r.a194 } in
  set_idx_mut r ((.a194) : (t194, _) idx_mut) next_r.a194;
  mark_test_run 2011;
  let test = eq r expected in
  if not test then failwithf "test 2011 failed";
  mark_test_run 2012;
  let test = sub_eq (get_idx_mut r ((.a194) : (t194, _) idx_mut)) next_r.a194 in
  if not test then failwithf "test 2012 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a194 = (#{ a21 = 200. } : t21); b194 = 201 } : t194) in
  (* .a194.#a21 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a194 = #{ r.a194 with a21 = next_r.a194.#a21 } } in
  set_idx_mut r ((.a194.#a21) : (t194, _) idx_mut) next_r.a194.#a21;
  mark_test_run 2013;
  let test = eq r expected in
  if not test then failwithf "test 2013 failed";
  mark_test_run 2014;
  let test = sub_eq (get_idx_mut r ((.a194.#a21) : (t194, _) idx_mut)) next_r.a194.#a21 in
  if not test then failwithf "test 2014 failed";
  let r = ({ a194 = (#{ a21 = 0. } : t21); b194 = 1 } : t194) in
  (* Paths of depth 0 *)
  let next_r = ({ a194 = (#{ a21 = 100. } : t21); b194 = 101 } : t194) in
  (* .b194 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b194 = next_r.b194 } in
  set_idx_mut r ((.b194) : (t194, _) idx_mut) next_r.b194;
  mark_test_run 2015;
  let test = eq r expected in
  if not test then failwithf "test 2015 failed";
  mark_test_run 2016;
  let test = sub_eq (get_idx_mut r ((.b194) : (t194, _) idx_mut)) next_r.b194 in
  if not test then failwithf "test 2016 failed";
  (************************************)
  (*   t195 = { #{ float }; float }   *)
  (************************************)
  let eq = (fun ({ a195 = a1951; b195 = b1951 } : t195) ({ a195 = a1952; b195 = b1952 } : t195) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1951 a1952 && (fun a b -> Float.equal (globalize a) (globalize b)) b1951 b1952) in
  let r = ({ a195 = (#{ a21 = 0. } : t21); b195 = 1. } : t195) in
  (* Paths of depth 0 *)
  let next_r = ({ a195 = (#{ a21 = 100. } : t21); b195 = 101. } : t195) in
  (* .a195 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a195 = next_r.a195 } in
  set_idx_mut r ((.a195) : (t195, _) idx_mut) (Float_u.of_float next_r.a195.#a21);
  mark_test_run 2017;
  let test = eq r expected in
  if not test then failwithf "test 2017 failed";
  mark_test_run 2018;
  let test = sub_eq (get_idx_mut r ((.a195) : (t195, _) idx_mut)) (Float_u.of_float next_r.a195.#a21) in
  if not test then failwithf "test 2018 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a195 = (#{ a21 = 200. } : t21); b195 = 201. } : t195) in
  (* .a195.#a21 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a195 = #{ r.a195 with a21 = next_r.a195.#a21 } } in
  set_idx_mut r ((.a195.#a21) : (t195, _) idx_mut) (Float_u.of_float next_r.a195.#a21);
  mark_test_run 2019;
  let test = eq r expected in
  if not test then failwithf "test 2019 failed";
  mark_test_run 2020;
  let test = sub_eq (get_idx_mut r ((.a195.#a21) : (t195, _) idx_mut)) (Float_u.of_float next_r.a195.#a21) in
  if not test then failwithf "test 2020 failed";
  let r = ({ a195 = (#{ a21 = 0. } : t21); b195 = 1. } : t195) in
  (* Paths of depth 0 *)
  let next_r = ({ a195 = (#{ a21 = 100. } : t21); b195 = 101. } : t195) in
  (* .b195 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b195 = next_r.b195 } in
  set_idx_mut r ((.b195) : (t195, _) idx_mut) (Float_u.of_float next_r.b195);
  mark_test_run 2021;
  let test = eq r expected in
  if not test then failwithf "test 2021 failed";
  mark_test_run 2022;
  let test = sub_eq (get_idx_mut r ((.b195) : (t195, _) idx_mut)) (Float_u.of_float next_r.b195) in
  if not test then failwithf "test 2022 failed";
  (**********************************)
  (*   t196 = { #{ float; int } }   *)
  (**********************************)
  let eq = (fun ({ a196 = a1961 } : t196) ({ a196 = a1962 } : t196) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a1961 a1962) in
  let r = ({ a196 = (#{ a23 = 0.; b23 = 1 } : t23) } : t196) in
  (* Paths of depth 0 *)
  let next_r = ({ a196 = (#{ a23 = 100.; b23 = 101 } : t23) } : t196) in
  (* .a196 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with a196 = next_r.a196 } in
  set_idx_mut r ((.a196) : (t196, _) idx_mut) next_r.a196;
  mark_test_run 2023;
  let test = eq r expected in
  if not test then failwithf "test 2023 failed";
  mark_test_run 2024;
  let test = sub_eq (get_idx_mut r ((.a196) : (t196, _) idx_mut)) next_r.a196 in
  if not test then failwithf "test 2024 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a196 = (#{ a23 = 200.; b23 = 201 } : t23) } : t196) in
  (* .a196.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a196 = #{ r.a196 with a23 = next_r.a196.#a23 } } in
  set_idx_mut r ((.a196.#a23) : (t196, _) idx_mut) next_r.a196.#a23;
  mark_test_run 2025;
  let test = eq r expected in
  if not test then failwithf "test 2025 failed";
  mark_test_run 2026;
  let test = sub_eq (get_idx_mut r ((.a196.#a23) : (t196, _) idx_mut)) next_r.a196.#a23 in
  if not test then failwithf "test 2026 failed";
  (* .a196.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a196 = #{ r.a196 with b23 = next_r.a196.#b23 } } in
  set_idx_mut r ((.a196.#b23) : (t196, _) idx_mut) next_r.a196.#b23;
  mark_test_run 2027;
  let test = eq r expected in
  if not test then failwithf "test 2027 failed";
  mark_test_run 2028;
  let test = sub_eq (get_idx_mut r ((.a196.#b23) : (t196, _) idx_mut)) next_r.a196.#b23 in
  if not test then failwithf "test 2028 failed";
  (***************************************)
  (*   t197 = { #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun ({ a197 = a1971; b197 = b1971 } : t197) ({ a197 = a1972; b197 = b1972 } : t197) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a1971 a1972 && (fun a b -> Int.equal a b) b1971 b1972) in
  let r = ({ a197 = (#{ a23 = 0.; b23 = 1 } : t23); b197 = 2 } : t197) in
  (* Paths of depth 0 *)
  let next_r = ({ a197 = (#{ a23 = 100.; b23 = 101 } : t23); b197 = 102 } : t197) in
  (* .a197 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with a197 = next_r.a197 } in
  set_idx_mut r ((.a197) : (t197, _) idx_mut) next_r.a197;
  mark_test_run 2029;
  let test = eq r expected in
  if not test then failwithf "test 2029 failed";
  mark_test_run 2030;
  let test = sub_eq (get_idx_mut r ((.a197) : (t197, _) idx_mut)) next_r.a197 in
  if not test then failwithf "test 2030 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a197 = (#{ a23 = 200.; b23 = 201 } : t23); b197 = 202 } : t197) in
  (* .a197.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a197 = #{ r.a197 with a23 = next_r.a197.#a23 } } in
  set_idx_mut r ((.a197.#a23) : (t197, _) idx_mut) next_r.a197.#a23;
  mark_test_run 2031;
  let test = eq r expected in
  if not test then failwithf "test 2031 failed";
  mark_test_run 2032;
  let test = sub_eq (get_idx_mut r ((.a197.#a23) : (t197, _) idx_mut)) next_r.a197.#a23 in
  if not test then failwithf "test 2032 failed";
  (* .a197.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a197 = #{ r.a197 with b23 = next_r.a197.#b23 } } in
  set_idx_mut r ((.a197.#b23) : (t197, _) idx_mut) next_r.a197.#b23;
  mark_test_run 2033;
  let test = eq r expected in
  if not test then failwithf "test 2033 failed";
  mark_test_run 2034;
  let test = sub_eq (get_idx_mut r ((.a197.#b23) : (t197, _) idx_mut)) next_r.a197.#b23 in
  if not test then failwithf "test 2034 failed";
  let r = ({ a197 = (#{ a23 = 0.; b23 = 1 } : t23); b197 = 2 } : t197) in
  (* Paths of depth 0 *)
  let next_r = ({ a197 = (#{ a23 = 100.; b23 = 101 } : t23); b197 = 102 } : t197) in
  (* .b197 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b197 = next_r.b197 } in
  set_idx_mut r ((.b197) : (t197, _) idx_mut) next_r.b197;
  mark_test_run 2035;
  let test = eq r expected in
  if not test then failwithf "test 2035 failed";
  mark_test_run 2036;
  let test = sub_eq (get_idx_mut r ((.b197) : (t197, _) idx_mut)) next_r.b197 in
  if not test then failwithf "test 2036 failed";
  (*****************************************)
  (*   t198 = { #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun ({ a198 = a1981; b198 = b1981 } : t198) ({ a198 = a1982; b198 = b1982 } : t198) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a1981 a1982 && (fun a b -> Float.equal (globalize a) (globalize b)) b1981 b1982) in
  let r = ({ a198 = (#{ a23 = 0.; b23 = 1 } : t23); b198 = 2. } : t198) in
  (* Paths of depth 0 *)
  let next_r = ({ a198 = (#{ a23 = 100.; b23 = 101 } : t23); b198 = 102. } : t198) in
  (* .a198 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with a198 = next_r.a198 } in
  set_idx_mut r ((.a198) : (t198, _) idx_mut) next_r.a198;
  mark_test_run 2037;
  let test = eq r expected in
  if not test then failwithf "test 2037 failed";
  mark_test_run 2038;
  let test = sub_eq (get_idx_mut r ((.a198) : (t198, _) idx_mut)) next_r.a198 in
  if not test then failwithf "test 2038 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a198 = (#{ a23 = 200.; b23 = 201 } : t23); b198 = 202. } : t198) in
  (* .a198.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a198 = #{ r.a198 with a23 = next_r.a198.#a23 } } in
  set_idx_mut r ((.a198.#a23) : (t198, _) idx_mut) next_r.a198.#a23;
  mark_test_run 2039;
  let test = eq r expected in
  if not test then failwithf "test 2039 failed";
  mark_test_run 2040;
  let test = sub_eq (get_idx_mut r ((.a198.#a23) : (t198, _) idx_mut)) next_r.a198.#a23 in
  if not test then failwithf "test 2040 failed";
  (* .a198.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a198 = #{ r.a198 with b23 = next_r.a198.#b23 } } in
  set_idx_mut r ((.a198.#b23) : (t198, _) idx_mut) next_r.a198.#b23;
  mark_test_run 2041;
  let test = eq r expected in
  if not test then failwithf "test 2041 failed";
  mark_test_run 2042;
  let test = sub_eq (get_idx_mut r ((.a198.#b23) : (t198, _) idx_mut)) next_r.a198.#b23 in
  if not test then failwithf "test 2042 failed";
  let r = ({ a198 = (#{ a23 = 0.; b23 = 1 } : t23); b198 = 2. } : t198) in
  (* Paths of depth 0 *)
  let next_r = ({ a198 = (#{ a23 = 100.; b23 = 101 } : t23); b198 = 102. } : t198) in
  (* .b198 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b198 = next_r.b198 } in
  set_idx_mut r ((.b198) : (t198, _) idx_mut) next_r.b198;
  mark_test_run 2043;
  let test = eq r expected in
  if not test then failwithf "test 2043 failed";
  mark_test_run 2044;
  let test = sub_eq (get_idx_mut r ((.b198) : (t198, _) idx_mut)) next_r.b198 in
  if not test then failwithf "test 2044 failed";
  (************************************)
  (*   t199 = { #{ float; float } }   *)
  (************************************)
  let eq = (fun ({ a199 = a1991 } : t199) ({ a199 = a1992 } : t199) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a1991 a1992) in
  let r = ({ a199 = (#{ a25 = 0.; b25 = 1. } : t25) } : t199) in
  (* Paths of depth 0 *)
  let next_r = ({ a199 = (#{ a25 = 100.; b25 = 101. } : t25) } : t199) in
  (* .a199 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with a199 = next_r.a199 } in
  set_idx_mut r ((.a199) : (t199, _) idx_mut) next_r.a199;
  mark_test_run 2045;
  let test = eq r expected in
  if not test then failwithf "test 2045 failed";
  mark_test_run 2046;
  let test = sub_eq (get_idx_mut r ((.a199) : (t199, _) idx_mut)) next_r.a199 in
  if not test then failwithf "test 2046 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a199 = (#{ a25 = 200.; b25 = 201. } : t25) } : t199) in
  (* .a199.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a199 = #{ r.a199 with a25 = next_r.a199.#a25 } } in
  set_idx_mut r ((.a199.#a25) : (t199, _) idx_mut) next_r.a199.#a25;
  mark_test_run 2047;
  let test = eq r expected in
  if not test then failwithf "test 2047 failed";
  mark_test_run 2048;
  let test = sub_eq (get_idx_mut r ((.a199.#a25) : (t199, _) idx_mut)) next_r.a199.#a25 in
  if not test then failwithf "test 2048 failed";
  (* .a199.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a199 = #{ r.a199 with b25 = next_r.a199.#b25 } } in
  set_idx_mut r ((.a199.#b25) : (t199, _) idx_mut) next_r.a199.#b25;
  mark_test_run 2049;
  let test = eq r expected in
  if not test then failwithf "test 2049 failed";
  mark_test_run 2050;
  let test = sub_eq (get_idx_mut r ((.a199.#b25) : (t199, _) idx_mut)) next_r.a199.#b25 in
  if not test then failwithf "test 2050 failed";
  (*****************************************)
  (*   t200 = { #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun ({ a200 = a2001; b200 = b2001 } : t200) ({ a200 = a2002; b200 = b2002 } : t200) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a2001 a2002 && (fun a b -> Int.equal a b) b2001 b2002) in
  let r = ({ a200 = (#{ a25 = 0.; b25 = 1. } : t25); b200 = 2 } : t200) in
  (* Paths of depth 0 *)
  let next_r = ({ a200 = (#{ a25 = 100.; b25 = 101. } : t25); b200 = 102 } : t200) in
  (* .a200 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with a200 = next_r.a200 } in
  set_idx_mut r ((.a200) : (t200, _) idx_mut) next_r.a200;
  mark_test_run 2051;
  let test = eq r expected in
  if not test then failwithf "test 2051 failed";
  mark_test_run 2052;
  let test = sub_eq (get_idx_mut r ((.a200) : (t200, _) idx_mut)) next_r.a200 in
  if not test then failwithf "test 2052 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a200 = (#{ a25 = 200.; b25 = 201. } : t25); b200 = 202 } : t200) in
  (* .a200.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a200 = #{ r.a200 with a25 = next_r.a200.#a25 } } in
  set_idx_mut r ((.a200.#a25) : (t200, _) idx_mut) next_r.a200.#a25;
  mark_test_run 2053;
  let test = eq r expected in
  if not test then failwithf "test 2053 failed";
  mark_test_run 2054;
  let test = sub_eq (get_idx_mut r ((.a200.#a25) : (t200, _) idx_mut)) next_r.a200.#a25 in
  if not test then failwithf "test 2054 failed";
  (* .a200.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a200 = #{ r.a200 with b25 = next_r.a200.#b25 } } in
  set_idx_mut r ((.a200.#b25) : (t200, _) idx_mut) next_r.a200.#b25;
  mark_test_run 2055;
  let test = eq r expected in
  if not test then failwithf "test 2055 failed";
  mark_test_run 2056;
  let test = sub_eq (get_idx_mut r ((.a200.#b25) : (t200, _) idx_mut)) next_r.a200.#b25 in
  if not test then failwithf "test 2056 failed";
  let r = ({ a200 = (#{ a25 = 0.; b25 = 1. } : t25); b200 = 2 } : t200) in
  (* Paths of depth 0 *)
  let next_r = ({ a200 = (#{ a25 = 100.; b25 = 101. } : t25); b200 = 102 } : t200) in
  (* .b200 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b200 = next_r.b200 } in
  set_idx_mut r ((.b200) : (t200, _) idx_mut) next_r.b200;
  mark_test_run 2057;
  let test = eq r expected in
  if not test then failwithf "test 2057 failed";
  mark_test_run 2058;
  let test = sub_eq (get_idx_mut r ((.b200) : (t200, _) idx_mut)) next_r.b200 in
  if not test then failwithf "test 2058 failed";
  (*******************************************)
  (*   t201 = { #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun ({ a201 = a2011; b201 = b2011 } : t201) ({ a201 = a2012; b201 = b2012 } : t201) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a2011 a2012 && (fun a b -> Float.equal (globalize a) (globalize b)) b2011 b2012) in
  let r = ({ a201 = (#{ a25 = 0.; b25 = 1. } : t25); b201 = 2. } : t201) in
  (* Paths of depth 0 *)
  let next_r = ({ a201 = (#{ a25 = 100.; b25 = 101. } : t25); b201 = 102. } : t201) in
  (* .a201 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with a201 = next_r.a201 } in
  set_idx_mut r ((.a201) : (t201, _) idx_mut) next_r.a201;
  mark_test_run 2059;
  let test = eq r expected in
  if not test then failwithf "test 2059 failed";
  mark_test_run 2060;
  let test = sub_eq (get_idx_mut r ((.a201) : (t201, _) idx_mut)) next_r.a201 in
  if not test then failwithf "test 2060 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a201 = (#{ a25 = 200.; b25 = 201. } : t25); b201 = 202. } : t201) in
  (* .a201.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a201 = #{ r.a201 with a25 = next_r.a201.#a25 } } in
  set_idx_mut r ((.a201.#a25) : (t201, _) idx_mut) next_r.a201.#a25;
  mark_test_run 2061;
  let test = eq r expected in
  if not test then failwithf "test 2061 failed";
  mark_test_run 2062;
  let test = sub_eq (get_idx_mut r ((.a201.#a25) : (t201, _) idx_mut)) next_r.a201.#a25 in
  if not test then failwithf "test 2062 failed";
  (* .a201.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a201 = #{ r.a201 with b25 = next_r.a201.#b25 } } in
  set_idx_mut r ((.a201.#b25) : (t201, _) idx_mut) next_r.a201.#b25;
  mark_test_run 2063;
  let test = eq r expected in
  if not test then failwithf "test 2063 failed";
  mark_test_run 2064;
  let test = sub_eq (get_idx_mut r ((.a201.#b25) : (t201, _) idx_mut)) next_r.a201.#b25 in
  if not test then failwithf "test 2064 failed";
  let r = ({ a201 = (#{ a25 = 0.; b25 = 1. } : t25); b201 = 2. } : t201) in
  (* Paths of depth 0 *)
  let next_r = ({ a201 = (#{ a25 = 100.; b25 = 101. } : t25); b201 = 102. } : t201) in
  (* .b201 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b201 = next_r.b201 } in
  set_idx_mut r ((.b201) : (t201, _) idx_mut) next_r.b201;
  mark_test_run 2065;
  let test = eq r expected in
  if not test then failwithf "test 2065 failed";
  mark_test_run 2066;
  let test = sub_eq (get_idx_mut r ((.b201) : (t201, _) idx_mut)) next_r.b201 in
  if not test then failwithf "test 2066 failed";
  (*************************************************************)
  (*   t204 = { #{ float32#; int64# }; #{ string; int64# } }   *)
  (*************************************************************)
  let eq = (fun ({ a204 = a2041; b204 = b2041 } : t204) ({ a204 = a2042; b204 = b2042 } : t204) -> (fun (#{ a202 = a2021; b202 = b2021 } : t202) (#{ a202 = a2022; b202 = b2022 } : t202) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2021 a2022 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2021 b2022) a2041 a2042 && (fun (#{ a203 = a2031; b203 = b2031 } : t203) (#{ a203 = a2032; b203 = b2032 } : t203) -> (fun a b -> String.equal (globalize a) (globalize b)) a2031 a2032 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2031 b2032) b2041 b2042) in
  let r = ({ a204 = (#{ a202 = #0.s; b202 = #1L } : t202); b204 = (#{ a203 = "2"; b203 = #3L } : t203) } : t204) in
  (* Paths of depth 0 *)
  let next_r = ({ a204 = (#{ a202 = #100.s; b202 = #101L } : t202); b204 = (#{ a203 = "102"; b203 = #103L } : t203) } : t204) in
  (* .a204 *)
  let sub_eq = (fun (#{ a202 = a2021; b202 = b2021 } : t202) (#{ a202 = a2022; b202 = b2022 } : t202) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2021 a2022 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2021 b2022) in
  let expected = { r with a204 = next_r.a204 } in
  set_idx_mut r ((.a204) : (t204, _) idx_mut) next_r.a204;
  mark_test_run 2067;
  let test = eq r expected in
  if not test then failwithf "test 2067 failed";
  mark_test_run 2068;
  let test = sub_eq (get_idx_mut r ((.a204) : (t204, _) idx_mut)) next_r.a204 in
  if not test then failwithf "test 2068 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a204 = (#{ a202 = #200.s; b202 = #201L } : t202); b204 = (#{ a203 = "202"; b203 = #203L } : t203) } : t204) in
  (* .a204.#a202 *)
  let sub_eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let expected = { r with a204 = #{ r.a204 with a202 = next_r.a204.#a202 } } in
  set_idx_mut r ((.a204.#a202) : (t204, _) idx_mut) next_r.a204.#a202;
  mark_test_run 2069;
  let test = eq r expected in
  if not test then failwithf "test 2069 failed";
  mark_test_run 2070;
  let test = sub_eq (get_idx_mut r ((.a204.#a202) : (t204, _) idx_mut)) next_r.a204.#a202 in
  if not test then failwithf "test 2070 failed";
  (* .a204.#b202 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a204 = #{ r.a204 with b202 = next_r.a204.#b202 } } in
  set_idx_mut r ((.a204.#b202) : (t204, _) idx_mut) next_r.a204.#b202;
  mark_test_run 2071;
  let test = eq r expected in
  if not test then failwithf "test 2071 failed";
  mark_test_run 2072;
  let test = sub_eq (get_idx_mut r ((.a204.#b202) : (t204, _) idx_mut)) next_r.a204.#b202 in
  if not test then failwithf "test 2072 failed";
  let r = ({ a204 = (#{ a202 = #0.s; b202 = #1L } : t202); b204 = (#{ a203 = "2"; b203 = #3L } : t203) } : t204) in
  (* Paths of depth 0 *)
  let next_r = ({ a204 = (#{ a202 = #100.s; b202 = #101L } : t202); b204 = (#{ a203 = "102"; b203 = #103L } : t203) } : t204) in
  (* .b204 *)
  let sub_eq = (fun (#{ a203 = a2031; b203 = b2031 } : t203) (#{ a203 = a2032; b203 = b2032 } : t203) -> (fun a b -> String.equal (globalize a) (globalize b)) a2031 a2032 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2031 b2032) in
  let expected = { r with b204 = next_r.b204 } in
  set_idx_mut r ((.b204) : (t204, _) idx_mut) next_r.b204;
  mark_test_run 2073;
  let test = eq r expected in
  if not test then failwithf "test 2073 failed";
  mark_test_run 2074;
  let test = sub_eq (get_idx_mut r ((.b204) : (t204, _) idx_mut)) next_r.b204 in
  if not test then failwithf "test 2074 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a204 = (#{ a202 = #200.s; b202 = #201L } : t202); b204 = (#{ a203 = "202"; b203 = #203L } : t203) } : t204) in
  (* .b204.#a203 *)
  let sub_eq = (fun a b -> String.equal (globalize a) (globalize b)) in
  let expected = { r with b204 = #{ r.b204 with a203 = next_r.b204.#a203 } } in
  set_idx_mut r ((.b204.#a203) : (t204, _) idx_mut) next_r.b204.#a203;
  mark_test_run 2075;
  let test = eq r expected in
  if not test then failwithf "test 2075 failed";
  mark_test_run 2076;
  let test = sub_eq (get_idx_mut r ((.b204.#a203) : (t204, _) idx_mut)) next_r.b204.#a203 in
  if not test then failwithf "test 2076 failed";
  (* .b204.#b203 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b204 = #{ r.b204 with b203 = next_r.b204.#b203 } } in
  set_idx_mut r ((.b204.#b203) : (t204, _) idx_mut) next_r.b204.#b203;
  mark_test_run 2077;
  let test = eq r expected in
  if not test then failwithf "test 2077 failed";
  mark_test_run 2078;
  let test = sub_eq (get_idx_mut r ((.b204.#b203) : (t204, _) idx_mut)) next_r.b204.#b203 in
  if not test then failwithf "test 2078 failed";
  ()

(* Test record idx get and set (local) *)
let () =
  (*********************)
  (*   t80 = { int }   *)
  (*********************)
  let eq = (fun ({ a80 = a801 } : t80) ({ a80 = a802 } : t80) -> (fun a b -> Int.equal a b) a801 a802) in
  let r = ({ a80 = 0 } : t80) in
  (* Paths of depth 0 *)
  let next_r = ({ a80 = 100 } : t80) in
  (* .a80 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a80 = next_r.a80 } in
  set_idx_mut r ((.a80) : (t80, _) idx_mut) next_r.a80;
  mark_test_run 2079;
  let test = eq r expected in
  if not test then failwithf "test 2079 failed";
  mark_test_run 2080;
  let test = sub_eq (get_idx_mut r ((.a80) : (t80, _) idx_mut)) next_r.a80 in
  if not test then failwithf "test 2080 failed";
  (**************************)
  (*   t81 = { int; int }   *)
  (**************************)
  let eq = (fun ({ a81 = a811; b81 = b811 } : t81) ({ a81 = a812; b81 = b812 } : t81) -> (fun a b -> Int.equal a b) a811 a812 && (fun a b -> Int.equal a b) b811 b812) in
  let r = ({ a81 = 0; b81 = 1 } : t81) in
  (* Paths of depth 0 *)
  let next_r = ({ a81 = 100; b81 = 101 } : t81) in
  (* .a81 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a81 = next_r.a81 } in
  set_idx_mut r ((.a81) : (t81, _) idx_mut) next_r.a81;
  mark_test_run 2081;
  let test = eq r expected in
  if not test then failwithf "test 2081 failed";
  mark_test_run 2082;
  let test = sub_eq (get_idx_mut r ((.a81) : (t81, _) idx_mut)) next_r.a81 in
  if not test then failwithf "test 2082 failed";
  let r = ({ a81 = 0; b81 = 1 } : t81) in
  (* Paths of depth 0 *)
  let next_r = ({ a81 = 100; b81 = 101 } : t81) in
  (* .b81 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b81 = next_r.b81 } in
  set_idx_mut r ((.b81) : (t81, _) idx_mut) next_r.b81;
  mark_test_run 2083;
  let test = eq r expected in
  if not test then failwithf "test 2083 failed";
  mark_test_run 2084;
  let test = sub_eq (get_idx_mut r ((.b81) : (t81, _) idx_mut)) next_r.b81 in
  if not test then failwithf "test 2084 failed";
  (*******************************)
  (*   t82 = { int; int; int }   *)
  (*******************************)
  let eq = (fun ({ a82 = a821; b82 = b821; c82 = c821 } : t82) ({ a82 = a822; b82 = b822; c82 = c822 } : t82) -> (fun a b -> Int.equal a b) a821 a822 && (fun a b -> Int.equal a b) b821 b822 && (fun a b -> Int.equal a b) c821 c822) in
  let r = ({ a82 = 0; b82 = 1; c82 = 2 } : t82) in
  (* Paths of depth 0 *)
  let next_r = ({ a82 = 100; b82 = 101; c82 = 102 } : t82) in
  (* .a82 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a82 = next_r.a82 } in
  set_idx_mut r ((.a82) : (t82, _) idx_mut) next_r.a82;
  mark_test_run 2085;
  let test = eq r expected in
  if not test then failwithf "test 2085 failed";
  mark_test_run 2086;
  let test = sub_eq (get_idx_mut r ((.a82) : (t82, _) idx_mut)) next_r.a82 in
  if not test then failwithf "test 2086 failed";
  let r = ({ a82 = 0; b82 = 1; c82 = 2 } : t82) in
  (* Paths of depth 0 *)
  let next_r = ({ a82 = 100; b82 = 101; c82 = 102 } : t82) in
  (* .b82 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b82 = next_r.b82 } in
  set_idx_mut r ((.b82) : (t82, _) idx_mut) next_r.b82;
  mark_test_run 2087;
  let test = eq r expected in
  if not test then failwithf "test 2087 failed";
  mark_test_run 2088;
  let test = sub_eq (get_idx_mut r ((.b82) : (t82, _) idx_mut)) next_r.b82 in
  if not test then failwithf "test 2088 failed";
  let r = ({ a82 = 0; b82 = 1; c82 = 2 } : t82) in
  (* Paths of depth 0 *)
  let next_r = ({ a82 = 100; b82 = 101; c82 = 102 } : t82) in
  (* .c82 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c82 = next_r.c82 } in
  set_idx_mut r ((.c82) : (t82, _) idx_mut) next_r.c82;
  mark_test_run 2089;
  let test = eq r expected in
  if not test then failwithf "test 2089 failed";
  mark_test_run 2090;
  let test = sub_eq (get_idx_mut r ((.c82) : (t82, _) idx_mut)) next_r.c82 in
  if not test then failwithf "test 2090 failed";
  (**********************************)
  (*   t83 = { int; int; int32# }   *)
  (**********************************)
  let eq = (fun ({ a83 = a831; b83 = b831; c83 = c831 } : t83) ({ a83 = a832; b83 = b832; c83 = c832 } : t83) -> (fun a b -> Int.equal a b) a831 a832 && (fun a b -> Int.equal a b) b831 b832 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c831 c832) in
  let r = ({ a83 = 0; b83 = 1; c83 = #2l } : t83) in
  (* Paths of depth 0 *)
  let next_r = ({ a83 = 100; b83 = 101; c83 = #102l } : t83) in
  (* .a83 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a83 = next_r.a83 } in
  set_idx_mut r ((.a83) : (t83, _) idx_mut) next_r.a83;
  mark_test_run 2091;
  let test = eq r expected in
  if not test then failwithf "test 2091 failed";
  mark_test_run 2092;
  let test = sub_eq (get_idx_mut r ((.a83) : (t83, _) idx_mut)) next_r.a83 in
  if not test then failwithf "test 2092 failed";
  let r = ({ a83 = 0; b83 = 1; c83 = #2l } : t83) in
  (* Paths of depth 0 *)
  let next_r = ({ a83 = 100; b83 = 101; c83 = #102l } : t83) in
  (* .b83 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b83 = next_r.b83 } in
  set_idx_mut r ((.b83) : (t83, _) idx_mut) next_r.b83;
  mark_test_run 2093;
  let test = eq r expected in
  if not test then failwithf "test 2093 failed";
  mark_test_run 2094;
  let test = sub_eq (get_idx_mut r ((.b83) : (t83, _) idx_mut)) next_r.b83 in
  if not test then failwithf "test 2094 failed";
  let r = ({ a83 = 0; b83 = 1; c83 = #2l } : t83) in
  (* Paths of depth 0 *)
  let next_r = ({ a83 = 100; b83 = 101; c83 = #102l } : t83) in
  (* .c83 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c83 = next_r.c83 } in
  set_idx_mut r ((.c83) : (t83, _) idx_mut) next_r.c83;
  mark_test_run 2095;
  let test = eq r expected in
  if not test then failwithf "test 2095 failed";
  mark_test_run 2096;
  let test = sub_eq (get_idx_mut r ((.c83) : (t83, _) idx_mut)) next_r.c83 in
  if not test then failwithf "test 2096 failed";
  (*********************************)
  (*   t84 = { int; int; float }   *)
  (*********************************)
  let eq = (fun ({ a84 = a841; b84 = b841; c84 = c841 } : t84) ({ a84 = a842; b84 = b842; c84 = c842 } : t84) -> (fun a b -> Int.equal a b) a841 a842 && (fun a b -> Int.equal a b) b841 b842 && (fun a b -> Float.equal (globalize a) (globalize b)) c841 c842) in
  let r = ({ a84 = 0; b84 = 1; c84 = 2. } : t84) in
  (* Paths of depth 0 *)
  let next_r = ({ a84 = 100; b84 = 101; c84 = 102. } : t84) in
  (* .a84 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a84 = next_r.a84 } in
  set_idx_mut r ((.a84) : (t84, _) idx_mut) next_r.a84;
  mark_test_run 2097;
  let test = eq r expected in
  if not test then failwithf "test 2097 failed";
  mark_test_run 2098;
  let test = sub_eq (get_idx_mut r ((.a84) : (t84, _) idx_mut)) next_r.a84 in
  if not test then failwithf "test 2098 failed";
  let r = ({ a84 = 0; b84 = 1; c84 = 2. } : t84) in
  (* Paths of depth 0 *)
  let next_r = ({ a84 = 100; b84 = 101; c84 = 102. } : t84) in
  (* .b84 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b84 = next_r.b84 } in
  set_idx_mut r ((.b84) : (t84, _) idx_mut) next_r.b84;
  mark_test_run 2099;
  let test = eq r expected in
  if not test then failwithf "test 2099 failed";
  mark_test_run 2100;
  let test = sub_eq (get_idx_mut r ((.b84) : (t84, _) idx_mut)) next_r.b84 in
  if not test then failwithf "test 2100 failed";
  let r = ({ a84 = 0; b84 = 1; c84 = 2. } : t84) in
  (* Paths of depth 0 *)
  let next_r = ({ a84 = 100; b84 = 101; c84 = 102. } : t84) in
  (* .c84 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with c84 = next_r.c84 } in
  set_idx_mut r ((.c84) : (t84, _) idx_mut) next_r.c84;
  mark_test_run 2101;
  let test = eq r expected in
  if not test then failwithf "test 2101 failed";
  mark_test_run 2102;
  let test = sub_eq (get_idx_mut r ((.c84) : (t84, _) idx_mut)) next_r.c84 in
  if not test then failwithf "test 2102 failed";
  (****************************)
  (*   t85 = { int; int64 }   *)
  (****************************)
  let eq = (fun ({ a85 = a851; b85 = b851 } : t85) ({ a85 = a852; b85 = b852 } : t85) -> (fun a b -> Int.equal a b) a851 a852 && (fun a b -> Int64.equal (globalize a) (globalize b)) b851 b852) in
  let r = ({ a85 = 0; b85 = 1L } : t85) in
  (* Paths of depth 0 *)
  let next_r = ({ a85 = 100; b85 = 101L } : t85) in
  (* .a85 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a85 = next_r.a85 } in
  set_idx_mut r ((.a85) : (t85, _) idx_mut) next_r.a85;
  mark_test_run 2103;
  let test = eq r expected in
  if not test then failwithf "test 2103 failed";
  mark_test_run 2104;
  let test = sub_eq (get_idx_mut r ((.a85) : (t85, _) idx_mut)) next_r.a85 in
  if not test then failwithf "test 2104 failed";
  let r = ({ a85 = 0; b85 = 1L } : t85) in
  (* Paths of depth 0 *)
  let next_r = ({ a85 = 100; b85 = 101L } : t85) in
  (* .b85 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b85 = next_r.b85 } in
  set_idx_mut r ((.b85) : (t85, _) idx_mut) next_r.b85;
  mark_test_run 2105;
  let test = eq r expected in
  if not test then failwithf "test 2105 failed";
  mark_test_run 2106;
  let test = sub_eq (get_idx_mut r ((.b85) : (t85, _) idx_mut)) next_r.b85 in
  if not test then failwithf "test 2106 failed";
  (*****************************)
  (*   t86 = { int; int64# }   *)
  (*****************************)
  let eq = (fun ({ a86 = a861; b86 = b861 } : t86) ({ a86 = a862; b86 = b862 } : t86) -> (fun a b -> Int.equal a b) a861 a862 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b861 b862) in
  let r = ({ a86 = 0; b86 = #1L } : t86) in
  (* Paths of depth 0 *)
  let next_r = ({ a86 = 100; b86 = #101L } : t86) in
  (* .a86 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a86 = next_r.a86 } in
  set_idx_mut r ((.a86) : (t86, _) idx_mut) next_r.a86;
  mark_test_run 2107;
  let test = eq r expected in
  if not test then failwithf "test 2107 failed";
  mark_test_run 2108;
  let test = sub_eq (get_idx_mut r ((.a86) : (t86, _) idx_mut)) next_r.a86 in
  if not test then failwithf "test 2108 failed";
  let r = ({ a86 = 0; b86 = #1L } : t86) in
  (* Paths of depth 0 *)
  let next_r = ({ a86 = 100; b86 = #101L } : t86) in
  (* .b86 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b86 = next_r.b86 } in
  set_idx_mut r ((.b86) : (t86, _) idx_mut) next_r.b86;
  mark_test_run 2109;
  let test = eq r expected in
  if not test then failwithf "test 2109 failed";
  mark_test_run 2110;
  let test = sub_eq (get_idx_mut r ((.b86) : (t86, _) idx_mut)) next_r.b86 in
  if not test then failwithf "test 2110 failed";
  (*****************************)
  (*   t87 = { int; int32# }   *)
  (*****************************)
  let eq = (fun ({ a87 = a871; b87 = b871 } : t87) ({ a87 = a872; b87 = b872 } : t87) -> (fun a b -> Int.equal a b) a871 a872 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b871 b872) in
  let r = ({ a87 = 0; b87 = #1l } : t87) in
  (* Paths of depth 0 *)
  let next_r = ({ a87 = 100; b87 = #101l } : t87) in
  (* .a87 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a87 = next_r.a87 } in
  set_idx_mut r ((.a87) : (t87, _) idx_mut) next_r.a87;
  mark_test_run 2111;
  let test = eq r expected in
  if not test then failwithf "test 2111 failed";
  mark_test_run 2112;
  let test = sub_eq (get_idx_mut r ((.a87) : (t87, _) idx_mut)) next_r.a87 in
  if not test then failwithf "test 2112 failed";
  let r = ({ a87 = 0; b87 = #1l } : t87) in
  (* Paths of depth 0 *)
  let next_r = ({ a87 = 100; b87 = #101l } : t87) in
  (* .b87 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b87 = next_r.b87 } in
  set_idx_mut r ((.b87) : (t87, _) idx_mut) next_r.b87;
  mark_test_run 2113;
  let test = eq r expected in
  if not test then failwithf "test 2113 failed";
  mark_test_run 2114;
  let test = sub_eq (get_idx_mut r ((.b87) : (t87, _) idx_mut)) next_r.b87 in
  if not test then failwithf "test 2114 failed";
  (**********************************)
  (*   t88 = { int; int32#; int }   *)
  (**********************************)
  let eq = (fun ({ a88 = a881; b88 = b881; c88 = c881 } : t88) ({ a88 = a882; b88 = b882; c88 = c882 } : t88) -> (fun a b -> Int.equal a b) a881 a882 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b881 b882 && (fun a b -> Int.equal a b) c881 c882) in
  let r = ({ a88 = 0; b88 = #1l; c88 = 2 } : t88) in
  (* Paths of depth 0 *)
  let next_r = ({ a88 = 100; b88 = #101l; c88 = 102 } : t88) in
  (* .a88 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a88 = next_r.a88 } in
  set_idx_mut r ((.a88) : (t88, _) idx_mut) next_r.a88;
  mark_test_run 2115;
  let test = eq r expected in
  if not test then failwithf "test 2115 failed";
  mark_test_run 2116;
  let test = sub_eq (get_idx_mut r ((.a88) : (t88, _) idx_mut)) next_r.a88 in
  if not test then failwithf "test 2116 failed";
  let r = ({ a88 = 0; b88 = #1l; c88 = 2 } : t88) in
  (* Paths of depth 0 *)
  let next_r = ({ a88 = 100; b88 = #101l; c88 = 102 } : t88) in
  (* .b88 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b88 = next_r.b88 } in
  set_idx_mut r ((.b88) : (t88, _) idx_mut) next_r.b88;
  mark_test_run 2117;
  let test = eq r expected in
  if not test then failwithf "test 2117 failed";
  mark_test_run 2118;
  let test = sub_eq (get_idx_mut r ((.b88) : (t88, _) idx_mut)) next_r.b88 in
  if not test then failwithf "test 2118 failed";
  let r = ({ a88 = 0; b88 = #1l; c88 = 2 } : t88) in
  (* Paths of depth 0 *)
  let next_r = ({ a88 = 100; b88 = #101l; c88 = 102 } : t88) in
  (* .c88 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c88 = next_r.c88 } in
  set_idx_mut r ((.c88) : (t88, _) idx_mut) next_r.c88;
  mark_test_run 2119;
  let test = eq r expected in
  if not test then failwithf "test 2119 failed";
  mark_test_run 2120;
  let test = sub_eq (get_idx_mut r ((.c88) : (t88, _) idx_mut)) next_r.c88 in
  if not test then failwithf "test 2120 failed";
  (*************************************)
  (*   t89 = { int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun ({ a89 = a891; b89 = b891; c89 = c891 } : t89) ({ a89 = a892; b89 = b892; c89 = c892 } : t89) -> (fun a b -> Int.equal a b) a891 a892 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b891 b892 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c891 c892) in
  let r = ({ a89 = 0; b89 = #1l; c89 = #2l } : t89) in
  (* Paths of depth 0 *)
  let next_r = ({ a89 = 100; b89 = #101l; c89 = #102l } : t89) in
  (* .a89 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a89 = next_r.a89 } in
  set_idx_mut r ((.a89) : (t89, _) idx_mut) next_r.a89;
  mark_test_run 2121;
  let test = eq r expected in
  if not test then failwithf "test 2121 failed";
  mark_test_run 2122;
  let test = sub_eq (get_idx_mut r ((.a89) : (t89, _) idx_mut)) next_r.a89 in
  if not test then failwithf "test 2122 failed";
  let r = ({ a89 = 0; b89 = #1l; c89 = #2l } : t89) in
  (* Paths of depth 0 *)
  let next_r = ({ a89 = 100; b89 = #101l; c89 = #102l } : t89) in
  (* .b89 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b89 = next_r.b89 } in
  set_idx_mut r ((.b89) : (t89, _) idx_mut) next_r.b89;
  mark_test_run 2123;
  let test = eq r expected in
  if not test then failwithf "test 2123 failed";
  mark_test_run 2124;
  let test = sub_eq (get_idx_mut r ((.b89) : (t89, _) idx_mut)) next_r.b89 in
  if not test then failwithf "test 2124 failed";
  let r = ({ a89 = 0; b89 = #1l; c89 = #2l } : t89) in
  (* Paths of depth 0 *)
  let next_r = ({ a89 = 100; b89 = #101l; c89 = #102l } : t89) in
  (* .c89 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c89 = next_r.c89 } in
  set_idx_mut r ((.c89) : (t89, _) idx_mut) next_r.c89;
  mark_test_run 2125;
  let test = eq r expected in
  if not test then failwithf "test 2125 failed";
  mark_test_run 2126;
  let test = sub_eq (get_idx_mut r ((.c89) : (t89, _) idx_mut)) next_r.c89 in
  if not test then failwithf "test 2126 failed";
  (*********************************)
  (*   t90 = { int; nativeint# }   *)
  (*********************************)
  let eq = (fun ({ a90 = a901; b90 = b901 } : t90) ({ a90 = a902; b90 = b902 } : t90) -> (fun a b -> Int.equal a b) a901 a902 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b901 b902) in
  let r = ({ a90 = 0; b90 = #1n } : t90) in
  (* Paths of depth 0 *)
  let next_r = ({ a90 = 100; b90 = #101n } : t90) in
  (* .a90 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a90 = next_r.a90 } in
  set_idx_mut r ((.a90) : (t90, _) idx_mut) next_r.a90;
  mark_test_run 2127;
  let test = eq r expected in
  if not test then failwithf "test 2127 failed";
  mark_test_run 2128;
  let test = sub_eq (get_idx_mut r ((.a90) : (t90, _) idx_mut)) next_r.a90 in
  if not test then failwithf "test 2128 failed";
  let r = ({ a90 = 0; b90 = #1n } : t90) in
  (* Paths of depth 0 *)
  let next_r = ({ a90 = 100; b90 = #101n } : t90) in
  (* .b90 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b90 = next_r.b90 } in
  set_idx_mut r ((.b90) : (t90, _) idx_mut) next_r.b90;
  mark_test_run 2129;
  let test = eq r expected in
  if not test then failwithf "test 2129 failed";
  mark_test_run 2130;
  let test = sub_eq (get_idx_mut r ((.b90) : (t90, _) idx_mut)) next_r.b90 in
  if not test then failwithf "test 2130 failed";
  (****************************)
  (*   t91 = { int; float }   *)
  (****************************)
  let eq = (fun ({ a91 = a911; b91 = b911 } : t91) ({ a91 = a912; b91 = b912 } : t91) -> (fun a b -> Int.equal a b) a911 a912 && (fun a b -> Float.equal (globalize a) (globalize b)) b911 b912) in
  let r = ({ a91 = 0; b91 = 1. } : t91) in
  (* Paths of depth 0 *)
  let next_r = ({ a91 = 100; b91 = 101. } : t91) in
  (* .a91 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a91 = next_r.a91 } in
  set_idx_mut r ((.a91) : (t91, _) idx_mut) next_r.a91;
  mark_test_run 2131;
  let test = eq r expected in
  if not test then failwithf "test 2131 failed";
  mark_test_run 2132;
  let test = sub_eq (get_idx_mut r ((.a91) : (t91, _) idx_mut)) next_r.a91 in
  if not test then failwithf "test 2132 failed";
  let r = ({ a91 = 0; b91 = 1. } : t91) in
  (* Paths of depth 0 *)
  let next_r = ({ a91 = 100; b91 = 101. } : t91) in
  (* .b91 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b91 = next_r.b91 } in
  set_idx_mut r ((.b91) : (t91, _) idx_mut) next_r.b91;
  mark_test_run 2133;
  let test = eq r expected in
  if not test then failwithf "test 2133 failed";
  mark_test_run 2134;
  let test = sub_eq (get_idx_mut r ((.b91) : (t91, _) idx_mut)) next_r.b91 in
  if not test then failwithf "test 2134 failed";
  (*********************************)
  (*   t92 = { int; float; int }   *)
  (*********************************)
  let eq = (fun ({ a92 = a921; b92 = b921; c92 = c921 } : t92) ({ a92 = a922; b92 = b922; c92 = c922 } : t92) -> (fun a b -> Int.equal a b) a921 a922 && (fun a b -> Float.equal (globalize a) (globalize b)) b921 b922 && (fun a b -> Int.equal a b) c921 c922) in
  let r = ({ a92 = 0; b92 = 1.; c92 = 2 } : t92) in
  (* Paths of depth 0 *)
  let next_r = ({ a92 = 100; b92 = 101.; c92 = 102 } : t92) in
  (* .a92 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a92 = next_r.a92 } in
  set_idx_mut r ((.a92) : (t92, _) idx_mut) next_r.a92;
  mark_test_run 2135;
  let test = eq r expected in
  if not test then failwithf "test 2135 failed";
  mark_test_run 2136;
  let test = sub_eq (get_idx_mut r ((.a92) : (t92, _) idx_mut)) next_r.a92 in
  if not test then failwithf "test 2136 failed";
  let r = ({ a92 = 0; b92 = 1.; c92 = 2 } : t92) in
  (* Paths of depth 0 *)
  let next_r = ({ a92 = 100; b92 = 101.; c92 = 102 } : t92) in
  (* .b92 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b92 = next_r.b92 } in
  set_idx_mut r ((.b92) : (t92, _) idx_mut) next_r.b92;
  mark_test_run 2137;
  let test = eq r expected in
  if not test then failwithf "test 2137 failed";
  mark_test_run 2138;
  let test = sub_eq (get_idx_mut r ((.b92) : (t92, _) idx_mut)) next_r.b92 in
  if not test then failwithf "test 2138 failed";
  let r = ({ a92 = 0; b92 = 1.; c92 = 2 } : t92) in
  (* Paths of depth 0 *)
  let next_r = ({ a92 = 100; b92 = 101.; c92 = 102 } : t92) in
  (* .c92 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c92 = next_r.c92 } in
  set_idx_mut r ((.c92) : (t92, _) idx_mut) next_r.c92;
  mark_test_run 2139;
  let test = eq r expected in
  if not test then failwithf "test 2139 failed";
  mark_test_run 2140;
  let test = sub_eq (get_idx_mut r ((.c92) : (t92, _) idx_mut)) next_r.c92 in
  if not test then failwithf "test 2140 failed";
  (***********************************)
  (*   t93 = { int; float; float }   *)
  (***********************************)
  let eq = (fun ({ a93 = a931; b93 = b931; c93 = c931 } : t93) ({ a93 = a932; b93 = b932; c93 = c932 } : t93) -> (fun a b -> Int.equal a b) a931 a932 && (fun a b -> Float.equal (globalize a) (globalize b)) b931 b932 && (fun a b -> Float.equal (globalize a) (globalize b)) c931 c932) in
  let r = ({ a93 = 0; b93 = 1.; c93 = 2. } : t93) in
  (* Paths of depth 0 *)
  let next_r = ({ a93 = 100; b93 = 101.; c93 = 102. } : t93) in
  (* .a93 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a93 = next_r.a93 } in
  set_idx_mut r ((.a93) : (t93, _) idx_mut) next_r.a93;
  mark_test_run 2141;
  let test = eq r expected in
  if not test then failwithf "test 2141 failed";
  mark_test_run 2142;
  let test = sub_eq (get_idx_mut r ((.a93) : (t93, _) idx_mut)) next_r.a93 in
  if not test then failwithf "test 2142 failed";
  let r = ({ a93 = 0; b93 = 1.; c93 = 2. } : t93) in
  (* Paths of depth 0 *)
  let next_r = ({ a93 = 100; b93 = 101.; c93 = 102. } : t93) in
  (* .b93 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b93 = next_r.b93 } in
  set_idx_mut r ((.b93) : (t93, _) idx_mut) next_r.b93;
  mark_test_run 2143;
  let test = eq r expected in
  if not test then failwithf "test 2143 failed";
  mark_test_run 2144;
  let test = sub_eq (get_idx_mut r ((.b93) : (t93, _) idx_mut)) next_r.b93 in
  if not test then failwithf "test 2144 failed";
  let r = ({ a93 = 0; b93 = 1.; c93 = 2. } : t93) in
  (* Paths of depth 0 *)
  let next_r = ({ a93 = 100; b93 = 101.; c93 = 102. } : t93) in
  (* .c93 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with c93 = next_r.c93 } in
  set_idx_mut r ((.c93) : (t93, _) idx_mut) next_r.c93;
  mark_test_run 2145;
  let test = eq r expected in
  if not test then failwithf "test 2145 failed";
  mark_test_run 2146;
  let test = sub_eq (get_idx_mut r ((.c93) : (t93, _) idx_mut)) next_r.c93 in
  if not test then failwithf "test 2146 failed";
  (*******************************)
  (*   t94 = { int; #{ int } }   *)
  (*******************************)
  let eq = (fun ({ a94 = a941; b94 = b941 } : t94) ({ a94 = a942; b94 = b942 } : t94) -> (fun a b -> Int.equal a b) a941 a942 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b941 b942) in
  let r = ({ a94 = 0; b94 = (#{ a0 = 1 } : t0) } : t94) in
  (* Paths of depth 0 *)
  let next_r = ({ a94 = 100; b94 = (#{ a0 = 101 } : t0) } : t94) in
  (* .a94 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a94 = next_r.a94 } in
  set_idx_mut r ((.a94) : (t94, _) idx_mut) next_r.a94;
  mark_test_run 2147;
  let test = eq r expected in
  if not test then failwithf "test 2147 failed";
  mark_test_run 2148;
  let test = sub_eq (get_idx_mut r ((.a94) : (t94, _) idx_mut)) next_r.a94 in
  if not test then failwithf "test 2148 failed";
  let r = ({ a94 = 0; b94 = (#{ a0 = 1 } : t0) } : t94) in
  (* Paths of depth 0 *)
  let next_r = ({ a94 = 100; b94 = (#{ a0 = 101 } : t0) } : t94) in
  (* .b94 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with b94 = next_r.b94 } in
  set_idx_mut r ((.b94) : (t94, _) idx_mut) next_r.b94;
  mark_test_run 2149;
  let test = eq r expected in
  if not test then failwithf "test 2149 failed";
  mark_test_run 2150;
  let test = sub_eq (get_idx_mut r ((.b94) : (t94, _) idx_mut)) next_r.b94 in
  if not test then failwithf "test 2150 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a94 = 200; b94 = (#{ a0 = 201 } : t0) } : t94) in
  (* .b94.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b94 = #{ r.b94 with a0 = next_r.b94.#a0 } } in
  set_idx_mut r ((.b94.#a0) : (t94, _) idx_mut) next_r.b94.#a0;
  mark_test_run 2151;
  let test = eq r expected in
  if not test then failwithf "test 2151 failed";
  mark_test_run 2152;
  let test = sub_eq (get_idx_mut r ((.b94.#a0) : (t94, _) idx_mut)) next_r.b94.#a0 in
  if not test then failwithf "test 2152 failed";
  (************************************)
  (*   t95 = { int; #{ int; int } }   *)
  (************************************)
  let eq = (fun ({ a95 = a951; b95 = b951 } : t95) ({ a95 = a952; b95 = b952 } : t95) -> (fun a b -> Int.equal a b) a951 a952 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b951 b952) in
  let r = ({ a95 = 0; b95 = (#{ a1 = 1; b1 = 2 } : t1) } : t95) in
  (* Paths of depth 0 *)
  let next_r = ({ a95 = 100; b95 = (#{ a1 = 101; b1 = 102 } : t1) } : t95) in
  (* .a95 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a95 = next_r.a95 } in
  set_idx_mut r ((.a95) : (t95, _) idx_mut) next_r.a95;
  mark_test_run 2153;
  let test = eq r expected in
  if not test then failwithf "test 2153 failed";
  mark_test_run 2154;
  let test = sub_eq (get_idx_mut r ((.a95) : (t95, _) idx_mut)) next_r.a95 in
  if not test then failwithf "test 2154 failed";
  let r = ({ a95 = 0; b95 = (#{ a1 = 1; b1 = 2 } : t1) } : t95) in
  (* Paths of depth 0 *)
  let next_r = ({ a95 = 100; b95 = (#{ a1 = 101; b1 = 102 } : t1) } : t95) in
  (* .b95 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with b95 = next_r.b95 } in
  set_idx_mut r ((.b95) : (t95, _) idx_mut) next_r.b95;
  mark_test_run 2155;
  let test = eq r expected in
  if not test then failwithf "test 2155 failed";
  mark_test_run 2156;
  let test = sub_eq (get_idx_mut r ((.b95) : (t95, _) idx_mut)) next_r.b95 in
  if not test then failwithf "test 2156 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a95 = 200; b95 = (#{ a1 = 201; b1 = 202 } : t1) } : t95) in
  (* .b95.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b95 = #{ r.b95 with a1 = next_r.b95.#a1 } } in
  set_idx_mut r ((.b95.#a1) : (t95, _) idx_mut) next_r.b95.#a1;
  mark_test_run 2157;
  let test = eq r expected in
  if not test then failwithf "test 2157 failed";
  mark_test_run 2158;
  let test = sub_eq (get_idx_mut r ((.b95.#a1) : (t95, _) idx_mut)) next_r.b95.#a1 in
  if not test then failwithf "test 2158 failed";
  (* .b95.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b95 = #{ r.b95 with b1 = next_r.b95.#b1 } } in
  set_idx_mut r ((.b95.#b1) : (t95, _) idx_mut) next_r.b95.#b1;
  mark_test_run 2159;
  let test = eq r expected in
  if not test then failwithf "test 2159 failed";
  mark_test_run 2160;
  let test = sub_eq (get_idx_mut r ((.b95.#b1) : (t95, _) idx_mut)) next_r.b95.#b1 in
  if not test then failwithf "test 2160 failed";
  (***************************************)
  (*   t96 = { int; #{ int; int32# } }   *)
  (***************************************)
  let eq = (fun ({ a96 = a961; b96 = b961 } : t96) ({ a96 = a962; b96 = b962 } : t96) -> (fun a b -> Int.equal a b) a961 a962 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b961 b962) in
  let r = ({ a96 = 0; b96 = (#{ a7 = 1; b7 = #2l } : t7) } : t96) in
  (* Paths of depth 0 *)
  let next_r = ({ a96 = 100; b96 = (#{ a7 = 101; b7 = #102l } : t7) } : t96) in
  (* .a96 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a96 = next_r.a96 } in
  set_idx_mut r ((.a96) : (t96, _) idx_mut) next_r.a96;
  mark_test_run 2161;
  let test = eq r expected in
  if not test then failwithf "test 2161 failed";
  mark_test_run 2162;
  let test = sub_eq (get_idx_mut r ((.a96) : (t96, _) idx_mut)) next_r.a96 in
  if not test then failwithf "test 2162 failed";
  let r = ({ a96 = 0; b96 = (#{ a7 = 1; b7 = #2l } : t7) } : t96) in
  (* Paths of depth 0 *)
  let next_r = ({ a96 = 100; b96 = (#{ a7 = 101; b7 = #102l } : t7) } : t96) in
  (* .b96 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with b96 = next_r.b96 } in
  set_idx_mut r ((.b96) : (t96, _) idx_mut) next_r.b96;
  mark_test_run 2163;
  let test = eq r expected in
  if not test then failwithf "test 2163 failed";
  mark_test_run 2164;
  let test = sub_eq (get_idx_mut r ((.b96) : (t96, _) idx_mut)) next_r.b96 in
  if not test then failwithf "test 2164 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a96 = 200; b96 = (#{ a7 = 201; b7 = #202l } : t7) } : t96) in
  (* .b96.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b96 = #{ r.b96 with a7 = next_r.b96.#a7 } } in
  set_idx_mut r ((.b96.#a7) : (t96, _) idx_mut) next_r.b96.#a7;
  mark_test_run 2165;
  let test = eq r expected in
  if not test then failwithf "test 2165 failed";
  mark_test_run 2166;
  let test = sub_eq (get_idx_mut r ((.b96.#a7) : (t96, _) idx_mut)) next_r.b96.#a7 in
  if not test then failwithf "test 2166 failed";
  (* .b96.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b96 = #{ r.b96 with b7 = next_r.b96.#b7 } } in
  set_idx_mut r ((.b96.#b7) : (t96, _) idx_mut) next_r.b96.#b7;
  mark_test_run 2167;
  let test = eq r expected in
  if not test then failwithf "test 2167 failed";
  mark_test_run 2168;
  let test = sub_eq (get_idx_mut r ((.b96.#b7) : (t96, _) idx_mut)) next_r.b96.#b7 in
  if not test then failwithf "test 2168 failed";
  (**************************************)
  (*   t97 = { int; #{ int; float } }   *)
  (**************************************)
  let eq = (fun ({ a97 = a971; b97 = b971 } : t97) ({ a97 = a972; b97 = b972 } : t97) -> (fun a b -> Int.equal a b) a971 a972 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b971 b972) in
  let r = ({ a97 = 0; b97 = (#{ a10 = 1; b10 = 2. } : t10) } : t97) in
  (* Paths of depth 0 *)
  let next_r = ({ a97 = 100; b97 = (#{ a10 = 101; b10 = 102. } : t10) } : t97) in
  (* .a97 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a97 = next_r.a97 } in
  set_idx_mut r ((.a97) : (t97, _) idx_mut) next_r.a97;
  mark_test_run 2169;
  let test = eq r expected in
  if not test then failwithf "test 2169 failed";
  mark_test_run 2170;
  let test = sub_eq (get_idx_mut r ((.a97) : (t97, _) idx_mut)) next_r.a97 in
  if not test then failwithf "test 2170 failed";
  let r = ({ a97 = 0; b97 = (#{ a10 = 1; b10 = 2. } : t10) } : t97) in
  (* Paths of depth 0 *)
  let next_r = ({ a97 = 100; b97 = (#{ a10 = 101; b10 = 102. } : t10) } : t97) in
  (* .b97 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with b97 = next_r.b97 } in
  set_idx_mut r ((.b97) : (t97, _) idx_mut) next_r.b97;
  mark_test_run 2171;
  let test = eq r expected in
  if not test then failwithf "test 2171 failed";
  mark_test_run 2172;
  let test = sub_eq (get_idx_mut r ((.b97) : (t97, _) idx_mut)) next_r.b97 in
  if not test then failwithf "test 2172 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a97 = 200; b97 = (#{ a10 = 201; b10 = 202. } : t10) } : t97) in
  (* .b97.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b97 = #{ r.b97 with a10 = next_r.b97.#a10 } } in
  set_idx_mut r ((.b97.#a10) : (t97, _) idx_mut) next_r.b97.#a10;
  mark_test_run 2173;
  let test = eq r expected in
  if not test then failwithf "test 2173 failed";
  mark_test_run 2174;
  let test = sub_eq (get_idx_mut r ((.b97.#a10) : (t97, _) idx_mut)) next_r.b97.#a10 in
  if not test then failwithf "test 2174 failed";
  (* .b97.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b97 = #{ r.b97 with b10 = next_r.b97.#b10 } } in
  set_idx_mut r ((.b97.#b10) : (t97, _) idx_mut) next_r.b97.#b10;
  mark_test_run 2175;
  let test = eq r expected in
  if not test then failwithf "test 2175 failed";
  mark_test_run 2176;
  let test = sub_eq (get_idx_mut r ((.b97.#b10) : (t97, _) idx_mut)) next_r.b97.#b10 in
  if not test then failwithf "test 2176 failed";
  (**********************************)
  (*   t98 = { int; #{ int32# } }   *)
  (**********************************)
  let eq = (fun ({ a98 = a981; b98 = b981 } : t98) ({ a98 = a982; b98 = b982 } : t98) -> (fun a b -> Int.equal a b) a981 a982 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b981 b982) in
  let r = ({ a98 = 0; b98 = (#{ a17 = #1l } : t17) } : t98) in
  (* Paths of depth 0 *)
  let next_r = ({ a98 = 100; b98 = (#{ a17 = #101l } : t17) } : t98) in
  (* .a98 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a98 = next_r.a98 } in
  set_idx_mut r ((.a98) : (t98, _) idx_mut) next_r.a98;
  mark_test_run 2177;
  let test = eq r expected in
  if not test then failwithf "test 2177 failed";
  mark_test_run 2178;
  let test = sub_eq (get_idx_mut r ((.a98) : (t98, _) idx_mut)) next_r.a98 in
  if not test then failwithf "test 2178 failed";
  let r = ({ a98 = 0; b98 = (#{ a17 = #1l } : t17) } : t98) in
  (* Paths of depth 0 *)
  let next_r = ({ a98 = 100; b98 = (#{ a17 = #101l } : t17) } : t98) in
  (* .b98 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with b98 = next_r.b98 } in
  set_idx_mut r ((.b98) : (t98, _) idx_mut) next_r.b98;
  mark_test_run 2179;
  let test = eq r expected in
  if not test then failwithf "test 2179 failed";
  mark_test_run 2180;
  let test = sub_eq (get_idx_mut r ((.b98) : (t98, _) idx_mut)) next_r.b98 in
  if not test then failwithf "test 2180 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a98 = 200; b98 = (#{ a17 = #201l } : t17) } : t98) in
  (* .b98.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b98 = #{ r.b98 with a17 = next_r.b98.#a17 } } in
  set_idx_mut r ((.b98.#a17) : (t98, _) idx_mut) next_r.b98.#a17;
  mark_test_run 2181;
  let test = eq r expected in
  if not test then failwithf "test 2181 failed";
  mark_test_run 2182;
  let test = sub_eq (get_idx_mut r ((.b98.#a17) : (t98, _) idx_mut)) next_r.b98.#a17 in
  if not test then failwithf "test 2182 failed";
  (****************************************)
  (*   t100 = { int; #{ int32#; int } }   *)
  (****************************************)
  let eq = (fun ({ a100 = a1001; b100 = b1001 } : t100) ({ a100 = a1002; b100 = b1002 } : t100) -> (fun a b -> Int.equal a b) a1001 a1002 && (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) b1001 b1002) in
  let r = ({ a100 = 0; b100 = (#{ a99 = #1l; b99 = 2 } : t99) } : t100) in
  (* Paths of depth 0 *)
  let next_r = ({ a100 = 100; b100 = (#{ a99 = #101l; b99 = 102 } : t99) } : t100) in
  (* .a100 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a100 = next_r.a100 } in
  set_idx_mut r ((.a100) : (t100, _) idx_mut) next_r.a100;
  mark_test_run 2183;
  let test = eq r expected in
  if not test then failwithf "test 2183 failed";
  mark_test_run 2184;
  let test = sub_eq (get_idx_mut r ((.a100) : (t100, _) idx_mut)) next_r.a100 in
  if not test then failwithf "test 2184 failed";
  let r = ({ a100 = 0; b100 = (#{ a99 = #1l; b99 = 2 } : t99) } : t100) in
  (* Paths of depth 0 *)
  let next_r = ({ a100 = 100; b100 = (#{ a99 = #101l; b99 = 102 } : t99) } : t100) in
  (* .b100 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with b100 = next_r.b100 } in
  set_idx_mut r ((.b100) : (t100, _) idx_mut) next_r.b100;
  mark_test_run 2185;
  let test = eq r expected in
  if not test then failwithf "test 2185 failed";
  mark_test_run 2186;
  let test = sub_eq (get_idx_mut r ((.b100) : (t100, _) idx_mut)) next_r.b100 in
  if not test then failwithf "test 2186 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a100 = 200; b100 = (#{ a99 = #201l; b99 = 202 } : t99) } : t100) in
  (* .b100.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b100 = #{ r.b100 with a99 = next_r.b100.#a99 } } in
  set_idx_mut r ((.b100.#a99) : (t100, _) idx_mut) next_r.b100.#a99;
  mark_test_run 2187;
  let test = eq r expected in
  if not test then failwithf "test 2187 failed";
  mark_test_run 2188;
  let test = sub_eq (get_idx_mut r ((.b100.#a99) : (t100, _) idx_mut)) next_r.b100.#a99 in
  if not test then failwithf "test 2188 failed";
  (* .b100.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b100 = #{ r.b100 with b99 = next_r.b100.#b99 } } in
  set_idx_mut r ((.b100.#b99) : (t100, _) idx_mut) next_r.b100.#b99;
  mark_test_run 2189;
  let test = eq r expected in
  if not test then failwithf "test 2189 failed";
  mark_test_run 2190;
  let test = sub_eq (get_idx_mut r ((.b100.#b99) : (t100, _) idx_mut)) next_r.b100.#b99 in
  if not test then failwithf "test 2190 failed";
  (*******************************************)
  (*   t101 = { int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun ({ a101 = a1011; b101 = b1011 } : t101) ({ a101 = a1012; b101 = b1012 } : t101) -> (fun a b -> Int.equal a b) a1011 a1012 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b1011 b1012) in
  let r = ({ a101 = 0; b101 = (#{ a19 = #1l; b19 = #2l } : t19) } : t101) in
  (* Paths of depth 0 *)
  let next_r = ({ a101 = 100; b101 = (#{ a19 = #101l; b19 = #102l } : t19) } : t101) in
  (* .a101 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a101 = next_r.a101 } in
  set_idx_mut r ((.a101) : (t101, _) idx_mut) next_r.a101;
  mark_test_run 2191;
  let test = eq r expected in
  if not test then failwithf "test 2191 failed";
  mark_test_run 2192;
  let test = sub_eq (get_idx_mut r ((.a101) : (t101, _) idx_mut)) next_r.a101 in
  if not test then failwithf "test 2192 failed";
  let r = ({ a101 = 0; b101 = (#{ a19 = #1l; b19 = #2l } : t19) } : t101) in
  (* Paths of depth 0 *)
  let next_r = ({ a101 = 100; b101 = (#{ a19 = #101l; b19 = #102l } : t19) } : t101) in
  (* .b101 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with b101 = next_r.b101 } in
  set_idx_mut r ((.b101) : (t101, _) idx_mut) next_r.b101;
  mark_test_run 2193;
  let test = eq r expected in
  if not test then failwithf "test 2193 failed";
  mark_test_run 2194;
  let test = sub_eq (get_idx_mut r ((.b101) : (t101, _) idx_mut)) next_r.b101 in
  if not test then failwithf "test 2194 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a101 = 200; b101 = (#{ a19 = #201l; b19 = #202l } : t19) } : t101) in
  (* .b101.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b101 = #{ r.b101 with a19 = next_r.b101.#a19 } } in
  set_idx_mut r ((.b101.#a19) : (t101, _) idx_mut) next_r.b101.#a19;
  mark_test_run 2195;
  let test = eq r expected in
  if not test then failwithf "test 2195 failed";
  mark_test_run 2196;
  let test = sub_eq (get_idx_mut r ((.b101.#a19) : (t101, _) idx_mut)) next_r.b101.#a19 in
  if not test then failwithf "test 2196 failed";
  (* .b101.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b101 = #{ r.b101 with b19 = next_r.b101.#b19 } } in
  set_idx_mut r ((.b101.#b19) : (t101, _) idx_mut) next_r.b101.#b19;
  mark_test_run 2197;
  let test = eq r expected in
  if not test then failwithf "test 2197 failed";
  mark_test_run 2198;
  let test = sub_eq (get_idx_mut r ((.b101.#b19) : (t101, _) idx_mut)) next_r.b101.#b19 in
  if not test then failwithf "test 2198 failed";
  (**********************************)
  (*   t102 = { int; #{ float } }   *)
  (**********************************)
  let eq = (fun ({ a102 = a1021; b102 = b1021 } : t102) ({ a102 = a1022; b102 = b1022 } : t102) -> (fun a b -> Int.equal a b) a1021 a1022 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b1021 b1022) in
  let r = ({ a102 = 0; b102 = (#{ a21 = 1. } : t21) } : t102) in
  (* Paths of depth 0 *)
  let next_r = ({ a102 = 100; b102 = (#{ a21 = 101. } : t21) } : t102) in
  (* .a102 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a102 = next_r.a102 } in
  set_idx_mut r ((.a102) : (t102, _) idx_mut) next_r.a102;
  mark_test_run 2199;
  let test = eq r expected in
  if not test then failwithf "test 2199 failed";
  mark_test_run 2200;
  let test = sub_eq (get_idx_mut r ((.a102) : (t102, _) idx_mut)) next_r.a102 in
  if not test then failwithf "test 2200 failed";
  let r = ({ a102 = 0; b102 = (#{ a21 = 1. } : t21) } : t102) in
  (* Paths of depth 0 *)
  let next_r = ({ a102 = 100; b102 = (#{ a21 = 101. } : t21) } : t102) in
  (* .b102 *)
  let sub_eq = (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) in
  let expected = { r with b102 = next_r.b102 } in
  set_idx_mut r ((.b102) : (t102, _) idx_mut) next_r.b102;
  mark_test_run 2201;
  let test = eq r expected in
  if not test then failwithf "test 2201 failed";
  mark_test_run 2202;
  let test = sub_eq (get_idx_mut r ((.b102) : (t102, _) idx_mut)) next_r.b102 in
  if not test then failwithf "test 2202 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a102 = 200; b102 = (#{ a21 = 201. } : t21) } : t102) in
  (* .b102.#a21 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b102 = #{ r.b102 with a21 = next_r.b102.#a21 } } in
  set_idx_mut r ((.b102.#a21) : (t102, _) idx_mut) next_r.b102.#a21;
  mark_test_run 2203;
  let test = eq r expected in
  if not test then failwithf "test 2203 failed";
  mark_test_run 2204;
  let test = sub_eq (get_idx_mut r ((.b102.#a21) : (t102, _) idx_mut)) next_r.b102.#a21 in
  if not test then failwithf "test 2204 failed";
  (***************************************)
  (*   t103 = { int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun ({ a103 = a1031; b103 = b1031 } : t103) ({ a103 = a1032; b103 = b1032 } : t103) -> (fun a b -> Int.equal a b) a1031 a1032 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b1031 b1032) in
  let r = ({ a103 = 0; b103 = (#{ a23 = 1.; b23 = 2 } : t23) } : t103) in
  (* Paths of depth 0 *)
  let next_r = ({ a103 = 100; b103 = (#{ a23 = 101.; b23 = 102 } : t23) } : t103) in
  (* .a103 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a103 = next_r.a103 } in
  set_idx_mut r ((.a103) : (t103, _) idx_mut) next_r.a103;
  mark_test_run 2205;
  let test = eq r expected in
  if not test then failwithf "test 2205 failed";
  mark_test_run 2206;
  let test = sub_eq (get_idx_mut r ((.a103) : (t103, _) idx_mut)) next_r.a103 in
  if not test then failwithf "test 2206 failed";
  let r = ({ a103 = 0; b103 = (#{ a23 = 1.; b23 = 2 } : t23) } : t103) in
  (* Paths of depth 0 *)
  let next_r = ({ a103 = 100; b103 = (#{ a23 = 101.; b23 = 102 } : t23) } : t103) in
  (* .b103 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with b103 = next_r.b103 } in
  set_idx_mut r ((.b103) : (t103, _) idx_mut) next_r.b103;
  mark_test_run 2207;
  let test = eq r expected in
  if not test then failwithf "test 2207 failed";
  mark_test_run 2208;
  let test = sub_eq (get_idx_mut r ((.b103) : (t103, _) idx_mut)) next_r.b103 in
  if not test then failwithf "test 2208 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a103 = 200; b103 = (#{ a23 = 201.; b23 = 202 } : t23) } : t103) in
  (* .b103.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b103 = #{ r.b103 with a23 = next_r.b103.#a23 } } in
  set_idx_mut r ((.b103.#a23) : (t103, _) idx_mut) next_r.b103.#a23;
  mark_test_run 2209;
  let test = eq r expected in
  if not test then failwithf "test 2209 failed";
  mark_test_run 2210;
  let test = sub_eq (get_idx_mut r ((.b103.#a23) : (t103, _) idx_mut)) next_r.b103.#a23 in
  if not test then failwithf "test 2210 failed";
  (* .b103.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b103 = #{ r.b103 with b23 = next_r.b103.#b23 } } in
  set_idx_mut r ((.b103.#b23) : (t103, _) idx_mut) next_r.b103.#b23;
  mark_test_run 2211;
  let test = eq r expected in
  if not test then failwithf "test 2211 failed";
  mark_test_run 2212;
  let test = sub_eq (get_idx_mut r ((.b103.#b23) : (t103, _) idx_mut)) next_r.b103.#b23 in
  if not test then failwithf "test 2212 failed";
  (*****************************************)
  (*   t104 = { int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun ({ a104 = a1041; b104 = b1041 } : t104) ({ a104 = a1042; b104 = b1042 } : t104) -> (fun a b -> Int.equal a b) a1041 a1042 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b1041 b1042) in
  let r = ({ a104 = 0; b104 = (#{ a25 = 1.; b25 = 2. } : t25) } : t104) in
  (* Paths of depth 0 *)
  let next_r = ({ a104 = 100; b104 = (#{ a25 = 101.; b25 = 102. } : t25) } : t104) in
  (* .a104 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a104 = next_r.a104 } in
  set_idx_mut r ((.a104) : (t104, _) idx_mut) next_r.a104;
  mark_test_run 2213;
  let test = eq r expected in
  if not test then failwithf "test 2213 failed";
  mark_test_run 2214;
  let test = sub_eq (get_idx_mut r ((.a104) : (t104, _) idx_mut)) next_r.a104 in
  if not test then failwithf "test 2214 failed";
  let r = ({ a104 = 0; b104 = (#{ a25 = 1.; b25 = 2. } : t25) } : t104) in
  (* Paths of depth 0 *)
  let next_r = ({ a104 = 100; b104 = (#{ a25 = 101.; b25 = 102. } : t25) } : t104) in
  (* .b104 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with b104 = next_r.b104 } in
  set_idx_mut r ((.b104) : (t104, _) idx_mut) next_r.b104;
  mark_test_run 2215;
  let test = eq r expected in
  if not test then failwithf "test 2215 failed";
  mark_test_run 2216;
  let test = sub_eq (get_idx_mut r ((.b104) : (t104, _) idx_mut)) next_r.b104 in
  if not test then failwithf "test 2216 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a104 = 200; b104 = (#{ a25 = 201.; b25 = 202. } : t25) } : t104) in
  (* .b104.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b104 = #{ r.b104 with a25 = next_r.b104.#a25 } } in
  set_idx_mut r ((.b104.#a25) : (t104, _) idx_mut) next_r.b104.#a25;
  mark_test_run 2217;
  let test = eq r expected in
  if not test then failwithf "test 2217 failed";
  mark_test_run 2218;
  let test = sub_eq (get_idx_mut r ((.b104.#a25) : (t104, _) idx_mut)) next_r.b104.#a25 in
  if not test then failwithf "test 2218 failed";
  (* .b104.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b104 = #{ r.b104 with b25 = next_r.b104.#b25 } } in
  set_idx_mut r ((.b104.#b25) : (t104, _) idx_mut) next_r.b104.#b25;
  mark_test_run 2219;
  let test = eq r expected in
  if not test then failwithf "test 2219 failed";
  mark_test_run 2220;
  let test = sub_eq (get_idx_mut r ((.b104.#b25) : (t104, _) idx_mut)) next_r.b104.#b25 in
  if not test then failwithf "test 2220 failed";
  (************************)
  (*   t105 = { int64 }   *)
  (************************)
  let eq = (fun ({ a105 = a1051 } : t105) ({ a105 = a1052 } : t105) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1051 a1052) in
  let r = ({ a105 = 0L } : t105) in
  (* Paths of depth 0 *)
  let next_r = ({ a105 = 100L } : t105) in
  (* .a105 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a105 = next_r.a105 } in
  set_idx_mut r ((.a105) : (t105, _) idx_mut) next_r.a105;
  mark_test_run 2221;
  let test = eq r expected in
  if not test then failwithf "test 2221 failed";
  mark_test_run 2222;
  let test = sub_eq (get_idx_mut r ((.a105) : (t105, _) idx_mut)) next_r.a105 in
  if not test then failwithf "test 2222 failed";
  (*****************************)
  (*   t106 = { int64; int }   *)
  (*****************************)
  let eq = (fun ({ a106 = a1061; b106 = b1061 } : t106) ({ a106 = a1062; b106 = b1062 } : t106) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1061 a1062 && (fun a b -> Int.equal a b) b1061 b1062) in
  let r = ({ a106 = 0L; b106 = 1 } : t106) in
  (* Paths of depth 0 *)
  let next_r = ({ a106 = 100L; b106 = 101 } : t106) in
  (* .a106 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a106 = next_r.a106 } in
  set_idx_mut r ((.a106) : (t106, _) idx_mut) next_r.a106;
  mark_test_run 2223;
  let test = eq r expected in
  if not test then failwithf "test 2223 failed";
  mark_test_run 2224;
  let test = sub_eq (get_idx_mut r ((.a106) : (t106, _) idx_mut)) next_r.a106 in
  if not test then failwithf "test 2224 failed";
  let r = ({ a106 = 0L; b106 = 1 } : t106) in
  (* Paths of depth 0 *)
  let next_r = ({ a106 = 100L; b106 = 101 } : t106) in
  (* .b106 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b106 = next_r.b106 } in
  set_idx_mut r ((.b106) : (t106, _) idx_mut) next_r.b106;
  mark_test_run 2225;
  let test = eq r expected in
  if not test then failwithf "test 2225 failed";
  mark_test_run 2226;
  let test = sub_eq (get_idx_mut r ((.b106) : (t106, _) idx_mut)) next_r.b106 in
  if not test then failwithf "test 2226 failed";
  (*******************************)
  (*   t107 = { int64; int64 }   *)
  (*******************************)
  let eq = (fun ({ a107 = a1071; b107 = b1071 } : t107) ({ a107 = a1072; b107 = b1072 } : t107) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1071 a1072 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1071 b1072) in
  let r = ({ a107 = 0L; b107 = 1L } : t107) in
  (* Paths of depth 0 *)
  let next_r = ({ a107 = 100L; b107 = 101L } : t107) in
  (* .a107 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a107 = next_r.a107 } in
  set_idx_mut r ((.a107) : (t107, _) idx_mut) next_r.a107;
  mark_test_run 2227;
  let test = eq r expected in
  if not test then failwithf "test 2227 failed";
  mark_test_run 2228;
  let test = sub_eq (get_idx_mut r ((.a107) : (t107, _) idx_mut)) next_r.a107 in
  if not test then failwithf "test 2228 failed";
  let r = ({ a107 = 0L; b107 = 1L } : t107) in
  (* Paths of depth 0 *)
  let next_r = ({ a107 = 100L; b107 = 101L } : t107) in
  (* .b107 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b107 = next_r.b107 } in
  set_idx_mut r ((.b107) : (t107, _) idx_mut) next_r.b107;
  mark_test_run 2229;
  let test = eq r expected in
  if not test then failwithf "test 2229 failed";
  mark_test_run 2230;
  let test = sub_eq (get_idx_mut r ((.b107) : (t107, _) idx_mut)) next_r.b107 in
  if not test then failwithf "test 2230 failed";
  (********************************)
  (*   t108 = { int64; int64# }   *)
  (********************************)
  let eq = (fun ({ a108 = a1081; b108 = b1081 } : t108) ({ a108 = a1082; b108 = b1082 } : t108) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1081 a1082 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1081 b1082) in
  let r = ({ a108 = 0L; b108 = #1L } : t108) in
  (* Paths of depth 0 *)
  let next_r = ({ a108 = 100L; b108 = #101L } : t108) in
  (* .a108 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a108 = next_r.a108 } in
  set_idx_mut r ((.a108) : (t108, _) idx_mut) next_r.a108;
  mark_test_run 2231;
  let test = eq r expected in
  if not test then failwithf "test 2231 failed";
  mark_test_run 2232;
  let test = sub_eq (get_idx_mut r ((.a108) : (t108, _) idx_mut)) next_r.a108 in
  if not test then failwithf "test 2232 failed";
  let r = ({ a108 = 0L; b108 = #1L } : t108) in
  (* Paths of depth 0 *)
  let next_r = ({ a108 = 100L; b108 = #101L } : t108) in
  (* .b108 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b108 = next_r.b108 } in
  set_idx_mut r ((.b108) : (t108, _) idx_mut) next_r.b108;
  mark_test_run 2233;
  let test = eq r expected in
  if not test then failwithf "test 2233 failed";
  mark_test_run 2234;
  let test = sub_eq (get_idx_mut r ((.b108) : (t108, _) idx_mut)) next_r.b108 in
  if not test then failwithf "test 2234 failed";
  (********************************)
  (*   t109 = { int64; int32# }   *)
  (********************************)
  let eq = (fun ({ a109 = a1091; b109 = b1091 } : t109) ({ a109 = a1092; b109 = b1092 } : t109) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1091 a1092 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1091 b1092) in
  let r = ({ a109 = 0L; b109 = #1l } : t109) in
  (* Paths of depth 0 *)
  let next_r = ({ a109 = 100L; b109 = #101l } : t109) in
  (* .a109 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a109 = next_r.a109 } in
  set_idx_mut r ((.a109) : (t109, _) idx_mut) next_r.a109;
  mark_test_run 2235;
  let test = eq r expected in
  if not test then failwithf "test 2235 failed";
  mark_test_run 2236;
  let test = sub_eq (get_idx_mut r ((.a109) : (t109, _) idx_mut)) next_r.a109 in
  if not test then failwithf "test 2236 failed";
  let r = ({ a109 = 0L; b109 = #1l } : t109) in
  (* Paths of depth 0 *)
  let next_r = ({ a109 = 100L; b109 = #101l } : t109) in
  (* .b109 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b109 = next_r.b109 } in
  set_idx_mut r ((.b109) : (t109, _) idx_mut) next_r.b109;
  mark_test_run 2237;
  let test = eq r expected in
  if not test then failwithf "test 2237 failed";
  mark_test_run 2238;
  let test = sub_eq (get_idx_mut r ((.b109) : (t109, _) idx_mut)) next_r.b109 in
  if not test then failwithf "test 2238 failed";
  (************************************)
  (*   t110 = { int64; nativeint# }   *)
  (************************************)
  let eq = (fun ({ a110 = a1101; b110 = b1101 } : t110) ({ a110 = a1102; b110 = b1102 } : t110) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1101 a1102 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1101 b1102) in
  let r = ({ a110 = 0L; b110 = #1n } : t110) in
  (* Paths of depth 0 *)
  let next_r = ({ a110 = 100L; b110 = #101n } : t110) in
  (* .a110 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a110 = next_r.a110 } in
  set_idx_mut r ((.a110) : (t110, _) idx_mut) next_r.a110;
  mark_test_run 2239;
  let test = eq r expected in
  if not test then failwithf "test 2239 failed";
  mark_test_run 2240;
  let test = sub_eq (get_idx_mut r ((.a110) : (t110, _) idx_mut)) next_r.a110 in
  if not test then failwithf "test 2240 failed";
  let r = ({ a110 = 0L; b110 = #1n } : t110) in
  (* Paths of depth 0 *)
  let next_r = ({ a110 = 100L; b110 = #101n } : t110) in
  (* .b110 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b110 = next_r.b110 } in
  set_idx_mut r ((.b110) : (t110, _) idx_mut) next_r.b110;
  mark_test_run 2241;
  let test = eq r expected in
  if not test then failwithf "test 2241 failed";
  mark_test_run 2242;
  let test = sub_eq (get_idx_mut r ((.b110) : (t110, _) idx_mut)) next_r.b110 in
  if not test then failwithf "test 2242 failed";
  (*******************************)
  (*   t111 = { int64; float }   *)
  (*******************************)
  let eq = (fun ({ a111 = a1111; b111 = b1111 } : t111) ({ a111 = a1112; b111 = b1112 } : t111) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1111 a1112 && (fun a b -> Float.equal (globalize a) (globalize b)) b1111 b1112) in
  let r = ({ a111 = 0L; b111 = 1. } : t111) in
  (* Paths of depth 0 *)
  let next_r = ({ a111 = 100L; b111 = 101. } : t111) in
  (* .a111 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a111 = next_r.a111 } in
  set_idx_mut r ((.a111) : (t111, _) idx_mut) next_r.a111;
  mark_test_run 2243;
  let test = eq r expected in
  if not test then failwithf "test 2243 failed";
  mark_test_run 2244;
  let test = sub_eq (get_idx_mut r ((.a111) : (t111, _) idx_mut)) next_r.a111 in
  if not test then failwithf "test 2244 failed";
  let r = ({ a111 = 0L; b111 = 1. } : t111) in
  (* Paths of depth 0 *)
  let next_r = ({ a111 = 100L; b111 = 101. } : t111) in
  (* .b111 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b111 = next_r.b111 } in
  set_idx_mut r ((.b111) : (t111, _) idx_mut) next_r.b111;
  mark_test_run 2245;
  let test = eq r expected in
  if not test then failwithf "test 2245 failed";
  mark_test_run 2246;
  let test = sub_eq (get_idx_mut r ((.b111) : (t111, _) idx_mut)) next_r.b111 in
  if not test then failwithf "test 2246 failed";
  (*************************)
  (*   t112 = { int64# }   *)
  (*************************)
  let eq = (fun ({ a112 = a1121 } : t112) ({ a112 = a1122 } : t112) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1121 a1122) in
  let r = ({ a112 = #0L } : t112) in
  (* Paths of depth 0 *)
  let next_r = ({ a112 = #100L } : t112) in
  (* .a112 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a112 = next_r.a112 } in
  set_idx_mut r ((.a112) : (t112, _) idx_mut) next_r.a112;
  mark_test_run 2247;
  let test = eq r expected in
  if not test then failwithf "test 2247 failed";
  mark_test_run 2248;
  let test = sub_eq (get_idx_mut r ((.a112) : (t112, _) idx_mut)) next_r.a112 in
  if not test then failwithf "test 2248 failed";
  (******************************)
  (*   t113 = { int64#; int }   *)
  (******************************)
  let eq = (fun ({ a113 = a1131; b113 = b1131 } : t113) ({ a113 = a1132; b113 = b1132 } : t113) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1131 a1132 && (fun a b -> Int.equal a b) b1131 b1132) in
  let r = ({ a113 = #0L; b113 = 1 } : t113) in
  (* Paths of depth 0 *)
  let next_r = ({ a113 = #100L; b113 = 101 } : t113) in
  (* .a113 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a113 = next_r.a113 } in
  set_idx_mut r ((.a113) : (t113, _) idx_mut) next_r.a113;
  mark_test_run 2249;
  let test = eq r expected in
  if not test then failwithf "test 2249 failed";
  mark_test_run 2250;
  let test = sub_eq (get_idx_mut r ((.a113) : (t113, _) idx_mut)) next_r.a113 in
  if not test then failwithf "test 2250 failed";
  let r = ({ a113 = #0L; b113 = 1 } : t113) in
  (* Paths of depth 0 *)
  let next_r = ({ a113 = #100L; b113 = 101 } : t113) in
  (* .b113 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b113 = next_r.b113 } in
  set_idx_mut r ((.b113) : (t113, _) idx_mut) next_r.b113;
  mark_test_run 2251;
  let test = eq r expected in
  if not test then failwithf "test 2251 failed";
  mark_test_run 2252;
  let test = sub_eq (get_idx_mut r ((.b113) : (t113, _) idx_mut)) next_r.b113 in
  if not test then failwithf "test 2252 failed";
  (********************************)
  (*   t114 = { int64#; int64 }   *)
  (********************************)
  let eq = (fun ({ a114 = a1141; b114 = b1141 } : t114) ({ a114 = a1142; b114 = b1142 } : t114) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1141 a1142 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1141 b1142) in
  let r = ({ a114 = #0L; b114 = 1L } : t114) in
  (* Paths of depth 0 *)
  let next_r = ({ a114 = #100L; b114 = 101L } : t114) in
  (* .a114 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a114 = next_r.a114 } in
  set_idx_mut r ((.a114) : (t114, _) idx_mut) next_r.a114;
  mark_test_run 2253;
  let test = eq r expected in
  if not test then failwithf "test 2253 failed";
  mark_test_run 2254;
  let test = sub_eq (get_idx_mut r ((.a114) : (t114, _) idx_mut)) next_r.a114 in
  if not test then failwithf "test 2254 failed";
  let r = ({ a114 = #0L; b114 = 1L } : t114) in
  (* Paths of depth 0 *)
  let next_r = ({ a114 = #100L; b114 = 101L } : t114) in
  (* .b114 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b114 = next_r.b114 } in
  set_idx_mut r ((.b114) : (t114, _) idx_mut) next_r.b114;
  mark_test_run 2255;
  let test = eq r expected in
  if not test then failwithf "test 2255 failed";
  mark_test_run 2256;
  let test = sub_eq (get_idx_mut r ((.b114) : (t114, _) idx_mut)) next_r.b114 in
  if not test then failwithf "test 2256 failed";
  (*********************************)
  (*   t115 = { int64#; int64# }   *)
  (*********************************)
  let eq = (fun ({ a115 = a1151; b115 = b1151 } : t115) ({ a115 = a1152; b115 = b1152 } : t115) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1151 a1152 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1151 b1152) in
  let r = ({ a115 = #0L; b115 = #1L } : t115) in
  (* Paths of depth 0 *)
  let next_r = ({ a115 = #100L; b115 = #101L } : t115) in
  (* .a115 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a115 = next_r.a115 } in
  set_idx_mut r ((.a115) : (t115, _) idx_mut) next_r.a115;
  mark_test_run 2257;
  let test = eq r expected in
  if not test then failwithf "test 2257 failed";
  mark_test_run 2258;
  let test = sub_eq (get_idx_mut r ((.a115) : (t115, _) idx_mut)) next_r.a115 in
  if not test then failwithf "test 2258 failed";
  let r = ({ a115 = #0L; b115 = #1L } : t115) in
  (* Paths of depth 0 *)
  let next_r = ({ a115 = #100L; b115 = #101L } : t115) in
  (* .b115 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b115 = next_r.b115 } in
  set_idx_mut r ((.b115) : (t115, _) idx_mut) next_r.b115;
  mark_test_run 2259;
  let test = eq r expected in
  if not test then failwithf "test 2259 failed";
  mark_test_run 2260;
  let test = sub_eq (get_idx_mut r ((.b115) : (t115, _) idx_mut)) next_r.b115 in
  if not test then failwithf "test 2260 failed";
  (*********************************)
  (*   t116 = { int64#; int32# }   *)
  (*********************************)
  let eq = (fun ({ a116 = a1161; b116 = b1161 } : t116) ({ a116 = a1162; b116 = b1162 } : t116) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1161 a1162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1161 b1162) in
  let r = ({ a116 = #0L; b116 = #1l } : t116) in
  (* Paths of depth 0 *)
  let next_r = ({ a116 = #100L; b116 = #101l } : t116) in
  (* .a116 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a116 = next_r.a116 } in
  set_idx_mut r ((.a116) : (t116, _) idx_mut) next_r.a116;
  mark_test_run 2261;
  let test = eq r expected in
  if not test then failwithf "test 2261 failed";
  mark_test_run 2262;
  let test = sub_eq (get_idx_mut r ((.a116) : (t116, _) idx_mut)) next_r.a116 in
  if not test then failwithf "test 2262 failed";
  let r = ({ a116 = #0L; b116 = #1l } : t116) in
  (* Paths of depth 0 *)
  let next_r = ({ a116 = #100L; b116 = #101l } : t116) in
  (* .b116 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b116 = next_r.b116 } in
  set_idx_mut r ((.b116) : (t116, _) idx_mut) next_r.b116;
  mark_test_run 2263;
  let test = eq r expected in
  if not test then failwithf "test 2263 failed";
  mark_test_run 2264;
  let test = sub_eq (get_idx_mut r ((.b116) : (t116, _) idx_mut)) next_r.b116 in
  if not test then failwithf "test 2264 failed";
  (*************************************)
  (*   t117 = { int64#; nativeint# }   *)
  (*************************************)
  let eq = (fun ({ a117 = a1171; b117 = b1171 } : t117) ({ a117 = a1172; b117 = b1172 } : t117) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1171 a1172 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1171 b1172) in
  let r = ({ a117 = #0L; b117 = #1n } : t117) in
  (* Paths of depth 0 *)
  let next_r = ({ a117 = #100L; b117 = #101n } : t117) in
  (* .a117 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a117 = next_r.a117 } in
  set_idx_mut r ((.a117) : (t117, _) idx_mut) next_r.a117;
  mark_test_run 2265;
  let test = eq r expected in
  if not test then failwithf "test 2265 failed";
  mark_test_run 2266;
  let test = sub_eq (get_idx_mut r ((.a117) : (t117, _) idx_mut)) next_r.a117 in
  if not test then failwithf "test 2266 failed";
  let r = ({ a117 = #0L; b117 = #1n } : t117) in
  (* Paths of depth 0 *)
  let next_r = ({ a117 = #100L; b117 = #101n } : t117) in
  (* .b117 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b117 = next_r.b117 } in
  set_idx_mut r ((.b117) : (t117, _) idx_mut) next_r.b117;
  mark_test_run 2267;
  let test = eq r expected in
  if not test then failwithf "test 2267 failed";
  mark_test_run 2268;
  let test = sub_eq (get_idx_mut r ((.b117) : (t117, _) idx_mut)) next_r.b117 in
  if not test then failwithf "test 2268 failed";
  (********************************)
  (*   t118 = { int64#; float }   *)
  (********************************)
  let eq = (fun ({ a118 = a1181; b118 = b1181 } : t118) ({ a118 = a1182; b118 = b1182 } : t118) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1181 a1182 && (fun a b -> Float.equal (globalize a) (globalize b)) b1181 b1182) in
  let r = ({ a118 = #0L; b118 = 1. } : t118) in
  (* Paths of depth 0 *)
  let next_r = ({ a118 = #100L; b118 = 101. } : t118) in
  (* .a118 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a118 = next_r.a118 } in
  set_idx_mut r ((.a118) : (t118, _) idx_mut) next_r.a118;
  mark_test_run 2269;
  let test = eq r expected in
  if not test then failwithf "test 2269 failed";
  mark_test_run 2270;
  let test = sub_eq (get_idx_mut r ((.a118) : (t118, _) idx_mut)) next_r.a118 in
  if not test then failwithf "test 2270 failed";
  let r = ({ a118 = #0L; b118 = 1. } : t118) in
  (* Paths of depth 0 *)
  let next_r = ({ a118 = #100L; b118 = 101. } : t118) in
  (* .b118 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b118 = next_r.b118 } in
  set_idx_mut r ((.b118) : (t118, _) idx_mut) next_r.b118;
  mark_test_run 2271;
  let test = eq r expected in
  if not test then failwithf "test 2271 failed";
  mark_test_run 2272;
  let test = sub_eq (get_idx_mut r ((.b118) : (t118, _) idx_mut)) next_r.b118 in
  if not test then failwithf "test 2272 failed";
  (*************************)
  (*   t119 = { int32# }   *)
  (*************************)
  let eq = (fun ({ a119 = a1191 } : t119) ({ a119 = a1192 } : t119) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1191 a1192) in
  let r = ({ a119 = #0l } : t119) in
  (* Paths of depth 0 *)
  let next_r = ({ a119 = #100l } : t119) in
  (* .a119 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a119 = next_r.a119 } in
  set_idx_mut r ((.a119) : (t119, _) idx_mut) next_r.a119;
  mark_test_run 2273;
  let test = eq r expected in
  if not test then failwithf "test 2273 failed";
  mark_test_run 2274;
  let test = sub_eq (get_idx_mut r ((.a119) : (t119, _) idx_mut)) next_r.a119 in
  if not test then failwithf "test 2274 failed";
  (******************************)
  (*   t120 = { int32#; int }   *)
  (******************************)
  let eq = (fun ({ a120 = a1201; b120 = b1201 } : t120) ({ a120 = a1202; b120 = b1202 } : t120) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1201 a1202 && (fun a b -> Int.equal a b) b1201 b1202) in
  let r = ({ a120 = #0l; b120 = 1 } : t120) in
  (* Paths of depth 0 *)
  let next_r = ({ a120 = #100l; b120 = 101 } : t120) in
  (* .a120 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a120 = next_r.a120 } in
  set_idx_mut r ((.a120) : (t120, _) idx_mut) next_r.a120;
  mark_test_run 2275;
  let test = eq r expected in
  if not test then failwithf "test 2275 failed";
  mark_test_run 2276;
  let test = sub_eq (get_idx_mut r ((.a120) : (t120, _) idx_mut)) next_r.a120 in
  if not test then failwithf "test 2276 failed";
  let r = ({ a120 = #0l; b120 = 1 } : t120) in
  (* Paths of depth 0 *)
  let next_r = ({ a120 = #100l; b120 = 101 } : t120) in
  (* .b120 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b120 = next_r.b120 } in
  set_idx_mut r ((.b120) : (t120, _) idx_mut) next_r.b120;
  mark_test_run 2277;
  let test = eq r expected in
  if not test then failwithf "test 2277 failed";
  mark_test_run 2278;
  let test = sub_eq (get_idx_mut r ((.b120) : (t120, _) idx_mut)) next_r.b120 in
  if not test then failwithf "test 2278 failed";
  (***********************************)
  (*   t121 = { int32#; int; int }   *)
  (***********************************)
  let eq = (fun ({ a121 = a1211; b121 = b1211; c121 = c1211 } : t121) ({ a121 = a1212; b121 = b1212; c121 = c1212 } : t121) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1211 a1212 && (fun a b -> Int.equal a b) b1211 b1212 && (fun a b -> Int.equal a b) c1211 c1212) in
  let r = ({ a121 = #0l; b121 = 1; c121 = 2 } : t121) in
  (* Paths of depth 0 *)
  let next_r = ({ a121 = #100l; b121 = 101; c121 = 102 } : t121) in
  (* .a121 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a121 = next_r.a121 } in
  set_idx_mut r ((.a121) : (t121, _) idx_mut) next_r.a121;
  mark_test_run 2279;
  let test = eq r expected in
  if not test then failwithf "test 2279 failed";
  mark_test_run 2280;
  let test = sub_eq (get_idx_mut r ((.a121) : (t121, _) idx_mut)) next_r.a121 in
  if not test then failwithf "test 2280 failed";
  let r = ({ a121 = #0l; b121 = 1; c121 = 2 } : t121) in
  (* Paths of depth 0 *)
  let next_r = ({ a121 = #100l; b121 = 101; c121 = 102 } : t121) in
  (* .b121 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b121 = next_r.b121 } in
  set_idx_mut r ((.b121) : (t121, _) idx_mut) next_r.b121;
  mark_test_run 2281;
  let test = eq r expected in
  if not test then failwithf "test 2281 failed";
  mark_test_run 2282;
  let test = sub_eq (get_idx_mut r ((.b121) : (t121, _) idx_mut)) next_r.b121 in
  if not test then failwithf "test 2282 failed";
  let r = ({ a121 = #0l; b121 = 1; c121 = 2 } : t121) in
  (* Paths of depth 0 *)
  let next_r = ({ a121 = #100l; b121 = 101; c121 = 102 } : t121) in
  (* .c121 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c121 = next_r.c121 } in
  set_idx_mut r ((.c121) : (t121, _) idx_mut) next_r.c121;
  mark_test_run 2283;
  let test = eq r expected in
  if not test then failwithf "test 2283 failed";
  mark_test_run 2284;
  let test = sub_eq (get_idx_mut r ((.c121) : (t121, _) idx_mut)) next_r.c121 in
  if not test then failwithf "test 2284 failed";
  (**************************************)
  (*   t122 = { int32#; int; int32# }   *)
  (**************************************)
  let eq = (fun ({ a122 = a1221; b122 = b1221; c122 = c1221 } : t122) ({ a122 = a1222; b122 = b1222; c122 = c1222 } : t122) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1221 a1222 && (fun a b -> Int.equal a b) b1221 b1222 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c1221 c1222) in
  let r = ({ a122 = #0l; b122 = 1; c122 = #2l } : t122) in
  (* Paths of depth 0 *)
  let next_r = ({ a122 = #100l; b122 = 101; c122 = #102l } : t122) in
  (* .a122 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a122 = next_r.a122 } in
  set_idx_mut r ((.a122) : (t122, _) idx_mut) next_r.a122;
  mark_test_run 2285;
  let test = eq r expected in
  if not test then failwithf "test 2285 failed";
  mark_test_run 2286;
  let test = sub_eq (get_idx_mut r ((.a122) : (t122, _) idx_mut)) next_r.a122 in
  if not test then failwithf "test 2286 failed";
  let r = ({ a122 = #0l; b122 = 1; c122 = #2l } : t122) in
  (* Paths of depth 0 *)
  let next_r = ({ a122 = #100l; b122 = 101; c122 = #102l } : t122) in
  (* .b122 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b122 = next_r.b122 } in
  set_idx_mut r ((.b122) : (t122, _) idx_mut) next_r.b122;
  mark_test_run 2287;
  let test = eq r expected in
  if not test then failwithf "test 2287 failed";
  mark_test_run 2288;
  let test = sub_eq (get_idx_mut r ((.b122) : (t122, _) idx_mut)) next_r.b122 in
  if not test then failwithf "test 2288 failed";
  let r = ({ a122 = #0l; b122 = 1; c122 = #2l } : t122) in
  (* Paths of depth 0 *)
  let next_r = ({ a122 = #100l; b122 = 101; c122 = #102l } : t122) in
  (* .c122 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c122 = next_r.c122 } in
  set_idx_mut r ((.c122) : (t122, _) idx_mut) next_r.c122;
  mark_test_run 2289;
  let test = eq r expected in
  if not test then failwithf "test 2289 failed";
  mark_test_run 2290;
  let test = sub_eq (get_idx_mut r ((.c122) : (t122, _) idx_mut)) next_r.c122 in
  if not test then failwithf "test 2290 failed";
  (********************************)
  (*   t123 = { int32#; int64 }   *)
  (********************************)
  let eq = (fun ({ a123 = a1231; b123 = b1231 } : t123) ({ a123 = a1232; b123 = b1232 } : t123) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1231 a1232 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1231 b1232) in
  let r = ({ a123 = #0l; b123 = 1L } : t123) in
  (* Paths of depth 0 *)
  let next_r = ({ a123 = #100l; b123 = 101L } : t123) in
  (* .a123 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a123 = next_r.a123 } in
  set_idx_mut r ((.a123) : (t123, _) idx_mut) next_r.a123;
  mark_test_run 2291;
  let test = eq r expected in
  if not test then failwithf "test 2291 failed";
  mark_test_run 2292;
  let test = sub_eq (get_idx_mut r ((.a123) : (t123, _) idx_mut)) next_r.a123 in
  if not test then failwithf "test 2292 failed";
  let r = ({ a123 = #0l; b123 = 1L } : t123) in
  (* Paths of depth 0 *)
  let next_r = ({ a123 = #100l; b123 = 101L } : t123) in
  (* .b123 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b123 = next_r.b123 } in
  set_idx_mut r ((.b123) : (t123, _) idx_mut) next_r.b123;
  mark_test_run 2293;
  let test = eq r expected in
  if not test then failwithf "test 2293 failed";
  mark_test_run 2294;
  let test = sub_eq (get_idx_mut r ((.b123) : (t123, _) idx_mut)) next_r.b123 in
  if not test then failwithf "test 2294 failed";
  (*********************************)
  (*   t124 = { int32#; int64# }   *)
  (*********************************)
  let eq = (fun ({ a124 = a1241; b124 = b1241 } : t124) ({ a124 = a1242; b124 = b1242 } : t124) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1241 a1242 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1241 b1242) in
  let r = ({ a124 = #0l; b124 = #1L } : t124) in
  (* Paths of depth 0 *)
  let next_r = ({ a124 = #100l; b124 = #101L } : t124) in
  (* .a124 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a124 = next_r.a124 } in
  set_idx_mut r ((.a124) : (t124, _) idx_mut) next_r.a124;
  mark_test_run 2295;
  let test = eq r expected in
  if not test then failwithf "test 2295 failed";
  mark_test_run 2296;
  let test = sub_eq (get_idx_mut r ((.a124) : (t124, _) idx_mut)) next_r.a124 in
  if not test then failwithf "test 2296 failed";
  let r = ({ a124 = #0l; b124 = #1L } : t124) in
  (* Paths of depth 0 *)
  let next_r = ({ a124 = #100l; b124 = #101L } : t124) in
  (* .b124 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b124 = next_r.b124 } in
  set_idx_mut r ((.b124) : (t124, _) idx_mut) next_r.b124;
  mark_test_run 2297;
  let test = eq r expected in
  if not test then failwithf "test 2297 failed";
  mark_test_run 2298;
  let test = sub_eq (get_idx_mut r ((.b124) : (t124, _) idx_mut)) next_r.b124 in
  if not test then failwithf "test 2298 failed";
  (*********************************)
  (*   t125 = { int32#; int32# }   *)
  (*********************************)
  let eq = (fun ({ a125 = a1251; b125 = b1251 } : t125) ({ a125 = a1252; b125 = b1252 } : t125) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1251 a1252 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1251 b1252) in
  let r = ({ a125 = #0l; b125 = #1l } : t125) in
  (* Paths of depth 0 *)
  let next_r = ({ a125 = #100l; b125 = #101l } : t125) in
  (* .a125 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a125 = next_r.a125 } in
  set_idx_mut r ((.a125) : (t125, _) idx_mut) next_r.a125;
  mark_test_run 2299;
  let test = eq r expected in
  if not test then failwithf "test 2299 failed";
  mark_test_run 2300;
  let test = sub_eq (get_idx_mut r ((.a125) : (t125, _) idx_mut)) next_r.a125 in
  if not test then failwithf "test 2300 failed";
  let r = ({ a125 = #0l; b125 = #1l } : t125) in
  (* Paths of depth 0 *)
  let next_r = ({ a125 = #100l; b125 = #101l } : t125) in
  (* .b125 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b125 = next_r.b125 } in
  set_idx_mut r ((.b125) : (t125, _) idx_mut) next_r.b125;
  mark_test_run 2301;
  let test = eq r expected in
  if not test then failwithf "test 2301 failed";
  mark_test_run 2302;
  let test = sub_eq (get_idx_mut r ((.b125) : (t125, _) idx_mut)) next_r.b125 in
  if not test then failwithf "test 2302 failed";
  (**************************************)
  (*   t126 = { int32#; int32#; int }   *)
  (**************************************)
  let eq = (fun ({ a126 = a1261; b126 = b1261; c126 = c1261 } : t126) ({ a126 = a1262; b126 = b1262; c126 = c1262 } : t126) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1261 a1262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1261 b1262 && (fun a b -> Int.equal a b) c1261 c1262) in
  let r = ({ a126 = #0l; b126 = #1l; c126 = 2 } : t126) in
  (* Paths of depth 0 *)
  let next_r = ({ a126 = #100l; b126 = #101l; c126 = 102 } : t126) in
  (* .a126 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a126 = next_r.a126 } in
  set_idx_mut r ((.a126) : (t126, _) idx_mut) next_r.a126;
  mark_test_run 2303;
  let test = eq r expected in
  if not test then failwithf "test 2303 failed";
  mark_test_run 2304;
  let test = sub_eq (get_idx_mut r ((.a126) : (t126, _) idx_mut)) next_r.a126 in
  if not test then failwithf "test 2304 failed";
  let r = ({ a126 = #0l; b126 = #1l; c126 = 2 } : t126) in
  (* Paths of depth 0 *)
  let next_r = ({ a126 = #100l; b126 = #101l; c126 = 102 } : t126) in
  (* .b126 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b126 = next_r.b126 } in
  set_idx_mut r ((.b126) : (t126, _) idx_mut) next_r.b126;
  mark_test_run 2305;
  let test = eq r expected in
  if not test then failwithf "test 2305 failed";
  mark_test_run 2306;
  let test = sub_eq (get_idx_mut r ((.b126) : (t126, _) idx_mut)) next_r.b126 in
  if not test then failwithf "test 2306 failed";
  let r = ({ a126 = #0l; b126 = #1l; c126 = 2 } : t126) in
  (* Paths of depth 0 *)
  let next_r = ({ a126 = #100l; b126 = #101l; c126 = 102 } : t126) in
  (* .c126 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c126 = next_r.c126 } in
  set_idx_mut r ((.c126) : (t126, _) idx_mut) next_r.c126;
  mark_test_run 2307;
  let test = eq r expected in
  if not test then failwithf "test 2307 failed";
  mark_test_run 2308;
  let test = sub_eq (get_idx_mut r ((.c126) : (t126, _) idx_mut)) next_r.c126 in
  if not test then failwithf "test 2308 failed";
  (*****************************************)
  (*   t127 = { int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun ({ a127 = a1271; b127 = b1271; c127 = c1271 } : t127) ({ a127 = a1272; b127 = b1272; c127 = c1272 } : t127) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1271 a1272 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1271 b1272 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c1271 c1272) in
  let r = ({ a127 = #0l; b127 = #1l; c127 = #2l } : t127) in
  (* Paths of depth 0 *)
  let next_r = ({ a127 = #100l; b127 = #101l; c127 = #102l } : t127) in
  (* .a127 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a127 = next_r.a127 } in
  set_idx_mut r ((.a127) : (t127, _) idx_mut) next_r.a127;
  mark_test_run 2309;
  let test = eq r expected in
  if not test then failwithf "test 2309 failed";
  mark_test_run 2310;
  let test = sub_eq (get_idx_mut r ((.a127) : (t127, _) idx_mut)) next_r.a127 in
  if not test then failwithf "test 2310 failed";
  let r = ({ a127 = #0l; b127 = #1l; c127 = #2l } : t127) in
  (* Paths of depth 0 *)
  let next_r = ({ a127 = #100l; b127 = #101l; c127 = #102l } : t127) in
  (* .b127 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b127 = next_r.b127 } in
  set_idx_mut r ((.b127) : (t127, _) idx_mut) next_r.b127;
  mark_test_run 2311;
  let test = eq r expected in
  if not test then failwithf "test 2311 failed";
  mark_test_run 2312;
  let test = sub_eq (get_idx_mut r ((.b127) : (t127, _) idx_mut)) next_r.b127 in
  if not test then failwithf "test 2312 failed";
  let r = ({ a127 = #0l; b127 = #1l; c127 = #2l } : t127) in
  (* Paths of depth 0 *)
  let next_r = ({ a127 = #100l; b127 = #101l; c127 = #102l } : t127) in
  (* .c127 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with c127 = next_r.c127 } in
  set_idx_mut r ((.c127) : (t127, _) idx_mut) next_r.c127;
  mark_test_run 2313;
  let test = eq r expected in
  if not test then failwithf "test 2313 failed";
  mark_test_run 2314;
  let test = sub_eq (get_idx_mut r ((.c127) : (t127, _) idx_mut)) next_r.c127 in
  if not test then failwithf "test 2314 failed";
  (*************************************)
  (*   t128 = { int32#; nativeint# }   *)
  (*************************************)
  let eq = (fun ({ a128 = a1281; b128 = b1281 } : t128) ({ a128 = a1282; b128 = b1282 } : t128) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1281 a1282 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1281 b1282) in
  let r = ({ a128 = #0l; b128 = #1n } : t128) in
  (* Paths of depth 0 *)
  let next_r = ({ a128 = #100l; b128 = #101n } : t128) in
  (* .a128 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a128 = next_r.a128 } in
  set_idx_mut r ((.a128) : (t128, _) idx_mut) next_r.a128;
  mark_test_run 2315;
  let test = eq r expected in
  if not test then failwithf "test 2315 failed";
  mark_test_run 2316;
  let test = sub_eq (get_idx_mut r ((.a128) : (t128, _) idx_mut)) next_r.a128 in
  if not test then failwithf "test 2316 failed";
  let r = ({ a128 = #0l; b128 = #1n } : t128) in
  (* Paths of depth 0 *)
  let next_r = ({ a128 = #100l; b128 = #101n } : t128) in
  (* .b128 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b128 = next_r.b128 } in
  set_idx_mut r ((.b128) : (t128, _) idx_mut) next_r.b128;
  mark_test_run 2317;
  let test = eq r expected in
  if not test then failwithf "test 2317 failed";
  mark_test_run 2318;
  let test = sub_eq (get_idx_mut r ((.b128) : (t128, _) idx_mut)) next_r.b128 in
  if not test then failwithf "test 2318 failed";
  (********************************)
  (*   t129 = { int32#; float }   *)
  (********************************)
  let eq = (fun ({ a129 = a1291; b129 = b1291 } : t129) ({ a129 = a1292; b129 = b1292 } : t129) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1291 a1292 && (fun a b -> Float.equal (globalize a) (globalize b)) b1291 b1292) in
  let r = ({ a129 = #0l; b129 = 1. } : t129) in
  (* Paths of depth 0 *)
  let next_r = ({ a129 = #100l; b129 = 101. } : t129) in
  (* .a129 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a129 = next_r.a129 } in
  set_idx_mut r ((.a129) : (t129, _) idx_mut) next_r.a129;
  mark_test_run 2319;
  let test = eq r expected in
  if not test then failwithf "test 2319 failed";
  mark_test_run 2320;
  let test = sub_eq (get_idx_mut r ((.a129) : (t129, _) idx_mut)) next_r.a129 in
  if not test then failwithf "test 2320 failed";
  let r = ({ a129 = #0l; b129 = 1. } : t129) in
  (* Paths of depth 0 *)
  let next_r = ({ a129 = #100l; b129 = 101. } : t129) in
  (* .b129 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b129 = next_r.b129 } in
  set_idx_mut r ((.b129) : (t129, _) idx_mut) next_r.b129;
  mark_test_run 2321;
  let test = eq r expected in
  if not test then failwithf "test 2321 failed";
  mark_test_run 2322;
  let test = sub_eq (get_idx_mut r ((.b129) : (t129, _) idx_mut)) next_r.b129 in
  if not test then failwithf "test 2322 failed";
  (***********************************)
  (*   t130 = { int32#; #{ int } }   *)
  (***********************************)
  let eq = (fun ({ a130 = a1301; b130 = b1301 } : t130) ({ a130 = a1302; b130 = b1302 } : t130) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1301 a1302 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b1301 b1302) in
  let r = ({ a130 = #0l; b130 = (#{ a0 = 1 } : t0) } : t130) in
  (* Paths of depth 0 *)
  let next_r = ({ a130 = #100l; b130 = (#{ a0 = 101 } : t0) } : t130) in
  (* .a130 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a130 = next_r.a130 } in
  set_idx_mut r ((.a130) : (t130, _) idx_mut) next_r.a130;
  mark_test_run 2323;
  let test = eq r expected in
  if not test then failwithf "test 2323 failed";
  mark_test_run 2324;
  let test = sub_eq (get_idx_mut r ((.a130) : (t130, _) idx_mut)) next_r.a130 in
  if not test then failwithf "test 2324 failed";
  let r = ({ a130 = #0l; b130 = (#{ a0 = 1 } : t0) } : t130) in
  (* Paths of depth 0 *)
  let next_r = ({ a130 = #100l; b130 = (#{ a0 = 101 } : t0) } : t130) in
  (* .b130 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with b130 = next_r.b130 } in
  set_idx_mut r ((.b130) : (t130, _) idx_mut) next_r.b130;
  mark_test_run 2325;
  let test = eq r expected in
  if not test then failwithf "test 2325 failed";
  mark_test_run 2326;
  let test = sub_eq (get_idx_mut r ((.b130) : (t130, _) idx_mut)) next_r.b130 in
  if not test then failwithf "test 2326 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a130 = #200l; b130 = (#{ a0 = 201 } : t0) } : t130) in
  (* .b130.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b130 = #{ r.b130 with a0 = next_r.b130.#a0 } } in
  set_idx_mut r ((.b130.#a0) : (t130, _) idx_mut) next_r.b130.#a0;
  mark_test_run 2327;
  let test = eq r expected in
  if not test then failwithf "test 2327 failed";
  mark_test_run 2328;
  let test = sub_eq (get_idx_mut r ((.b130.#a0) : (t130, _) idx_mut)) next_r.b130.#a0 in
  if not test then failwithf "test 2328 failed";
  (****************************************)
  (*   t131 = { int32#; #{ int; int } }   *)
  (****************************************)
  let eq = (fun ({ a131 = a1311; b131 = b1311 } : t131) ({ a131 = a1312; b131 = b1312 } : t131) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1311 a1312 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b1311 b1312) in
  let r = ({ a131 = #0l; b131 = (#{ a1 = 1; b1 = 2 } : t1) } : t131) in
  (* Paths of depth 0 *)
  let next_r = ({ a131 = #100l; b131 = (#{ a1 = 101; b1 = 102 } : t1) } : t131) in
  (* .a131 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a131 = next_r.a131 } in
  set_idx_mut r ((.a131) : (t131, _) idx_mut) next_r.a131;
  mark_test_run 2329;
  let test = eq r expected in
  if not test then failwithf "test 2329 failed";
  mark_test_run 2330;
  let test = sub_eq (get_idx_mut r ((.a131) : (t131, _) idx_mut)) next_r.a131 in
  if not test then failwithf "test 2330 failed";
  let r = ({ a131 = #0l; b131 = (#{ a1 = 1; b1 = 2 } : t1) } : t131) in
  (* Paths of depth 0 *)
  let next_r = ({ a131 = #100l; b131 = (#{ a1 = 101; b1 = 102 } : t1) } : t131) in
  (* .b131 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with b131 = next_r.b131 } in
  set_idx_mut r ((.b131) : (t131, _) idx_mut) next_r.b131;
  mark_test_run 2331;
  let test = eq r expected in
  if not test then failwithf "test 2331 failed";
  mark_test_run 2332;
  let test = sub_eq (get_idx_mut r ((.b131) : (t131, _) idx_mut)) next_r.b131 in
  if not test then failwithf "test 2332 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a131 = #200l; b131 = (#{ a1 = 201; b1 = 202 } : t1) } : t131) in
  (* .b131.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b131 = #{ r.b131 with a1 = next_r.b131.#a1 } } in
  set_idx_mut r ((.b131.#a1) : (t131, _) idx_mut) next_r.b131.#a1;
  mark_test_run 2333;
  let test = eq r expected in
  if not test then failwithf "test 2333 failed";
  mark_test_run 2334;
  let test = sub_eq (get_idx_mut r ((.b131.#a1) : (t131, _) idx_mut)) next_r.b131.#a1 in
  if not test then failwithf "test 2334 failed";
  (* .b131.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b131 = #{ r.b131 with b1 = next_r.b131.#b1 } } in
  set_idx_mut r ((.b131.#b1) : (t131, _) idx_mut) next_r.b131.#b1;
  mark_test_run 2335;
  let test = eq r expected in
  if not test then failwithf "test 2335 failed";
  mark_test_run 2336;
  let test = sub_eq (get_idx_mut r ((.b131.#b1) : (t131, _) idx_mut)) next_r.b131.#b1 in
  if not test then failwithf "test 2336 failed";
  (*******************************************)
  (*   t132 = { int32#; #{ int; int32# } }   *)
  (*******************************************)
  let eq = (fun ({ a132 = a1321; b132 = b1321 } : t132) ({ a132 = a1322; b132 = b1322 } : t132) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1321 a1322 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) b1321 b1322) in
  let r = ({ a132 = #0l; b132 = (#{ a7 = 1; b7 = #2l } : t7) } : t132) in
  (* Paths of depth 0 *)
  let next_r = ({ a132 = #100l; b132 = (#{ a7 = 101; b7 = #102l } : t7) } : t132) in
  (* .a132 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a132 = next_r.a132 } in
  set_idx_mut r ((.a132) : (t132, _) idx_mut) next_r.a132;
  mark_test_run 2337;
  let test = eq r expected in
  if not test then failwithf "test 2337 failed";
  mark_test_run 2338;
  let test = sub_eq (get_idx_mut r ((.a132) : (t132, _) idx_mut)) next_r.a132 in
  if not test then failwithf "test 2338 failed";
  let r = ({ a132 = #0l; b132 = (#{ a7 = 1; b7 = #2l } : t7) } : t132) in
  (* Paths of depth 0 *)
  let next_r = ({ a132 = #100l; b132 = (#{ a7 = 101; b7 = #102l } : t7) } : t132) in
  (* .b132 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with b132 = next_r.b132 } in
  set_idx_mut r ((.b132) : (t132, _) idx_mut) next_r.b132;
  mark_test_run 2339;
  let test = eq r expected in
  if not test then failwithf "test 2339 failed";
  mark_test_run 2340;
  let test = sub_eq (get_idx_mut r ((.b132) : (t132, _) idx_mut)) next_r.b132 in
  if not test then failwithf "test 2340 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a132 = #200l; b132 = (#{ a7 = 201; b7 = #202l } : t7) } : t132) in
  (* .b132.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b132 = #{ r.b132 with a7 = next_r.b132.#a7 } } in
  set_idx_mut r ((.b132.#a7) : (t132, _) idx_mut) next_r.b132.#a7;
  mark_test_run 2341;
  let test = eq r expected in
  if not test then failwithf "test 2341 failed";
  mark_test_run 2342;
  let test = sub_eq (get_idx_mut r ((.b132.#a7) : (t132, _) idx_mut)) next_r.b132.#a7 in
  if not test then failwithf "test 2342 failed";
  (* .b132.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b132 = #{ r.b132 with b7 = next_r.b132.#b7 } } in
  set_idx_mut r ((.b132.#b7) : (t132, _) idx_mut) next_r.b132.#b7;
  mark_test_run 2343;
  let test = eq r expected in
  if not test then failwithf "test 2343 failed";
  mark_test_run 2344;
  let test = sub_eq (get_idx_mut r ((.b132.#b7) : (t132, _) idx_mut)) next_r.b132.#b7 in
  if not test then failwithf "test 2344 failed";
  (**************************************)
  (*   t133 = { int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun ({ a133 = a1331; b133 = b1331 } : t133) ({ a133 = a1332; b133 = b1332 } : t133) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1331 a1332 && (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) b1331 b1332) in
  let r = ({ a133 = #0l; b133 = (#{ a17 = #1l } : t17) } : t133) in
  (* Paths of depth 0 *)
  let next_r = ({ a133 = #100l; b133 = (#{ a17 = #101l } : t17) } : t133) in
  (* .a133 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a133 = next_r.a133 } in
  set_idx_mut r ((.a133) : (t133, _) idx_mut) next_r.a133;
  mark_test_run 2345;
  let test = eq r expected in
  if not test then failwithf "test 2345 failed";
  mark_test_run 2346;
  let test = sub_eq (get_idx_mut r ((.a133) : (t133, _) idx_mut)) next_r.a133 in
  if not test then failwithf "test 2346 failed";
  let r = ({ a133 = #0l; b133 = (#{ a17 = #1l } : t17) } : t133) in
  (* Paths of depth 0 *)
  let next_r = ({ a133 = #100l; b133 = (#{ a17 = #101l } : t17) } : t133) in
  (* .b133 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with b133 = next_r.b133 } in
  set_idx_mut r ((.b133) : (t133, _) idx_mut) next_r.b133;
  mark_test_run 2347;
  let test = eq r expected in
  if not test then failwithf "test 2347 failed";
  mark_test_run 2348;
  let test = sub_eq (get_idx_mut r ((.b133) : (t133, _) idx_mut)) next_r.b133 in
  if not test then failwithf "test 2348 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a133 = #200l; b133 = (#{ a17 = #201l } : t17) } : t133) in
  (* .b133.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b133 = #{ r.b133 with a17 = next_r.b133.#a17 } } in
  set_idx_mut r ((.b133.#a17) : (t133, _) idx_mut) next_r.b133.#a17;
  mark_test_run 2349;
  let test = eq r expected in
  if not test then failwithf "test 2349 failed";
  mark_test_run 2350;
  let test = sub_eq (get_idx_mut r ((.b133.#a17) : (t133, _) idx_mut)) next_r.b133.#a17 in
  if not test then failwithf "test 2350 failed";
  (*******************************************)
  (*   t134 = { int32#; #{ int32#; int } }   *)
  (*******************************************)
  let eq = (fun ({ a134 = a1341; b134 = b1341 } : t134) ({ a134 = a1342; b134 = b1342 } : t134) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1341 a1342 && (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) b1341 b1342) in
  let r = ({ a134 = #0l; b134 = (#{ a99 = #1l; b99 = 2 } : t99) } : t134) in
  (* Paths of depth 0 *)
  let next_r = ({ a134 = #100l; b134 = (#{ a99 = #101l; b99 = 102 } : t99) } : t134) in
  (* .a134 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a134 = next_r.a134 } in
  set_idx_mut r ((.a134) : (t134, _) idx_mut) next_r.a134;
  mark_test_run 2351;
  let test = eq r expected in
  if not test then failwithf "test 2351 failed";
  mark_test_run 2352;
  let test = sub_eq (get_idx_mut r ((.a134) : (t134, _) idx_mut)) next_r.a134 in
  if not test then failwithf "test 2352 failed";
  let r = ({ a134 = #0l; b134 = (#{ a99 = #1l; b99 = 2 } : t99) } : t134) in
  (* Paths of depth 0 *)
  let next_r = ({ a134 = #100l; b134 = (#{ a99 = #101l; b99 = 102 } : t99) } : t134) in
  (* .b134 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with b134 = next_r.b134 } in
  set_idx_mut r ((.b134) : (t134, _) idx_mut) next_r.b134;
  mark_test_run 2353;
  let test = eq r expected in
  if not test then failwithf "test 2353 failed";
  mark_test_run 2354;
  let test = sub_eq (get_idx_mut r ((.b134) : (t134, _) idx_mut)) next_r.b134 in
  if not test then failwithf "test 2354 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a134 = #200l; b134 = (#{ a99 = #201l; b99 = 202 } : t99) } : t134) in
  (* .b134.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b134 = #{ r.b134 with a99 = next_r.b134.#a99 } } in
  set_idx_mut r ((.b134.#a99) : (t134, _) idx_mut) next_r.b134.#a99;
  mark_test_run 2355;
  let test = eq r expected in
  if not test then failwithf "test 2355 failed";
  mark_test_run 2356;
  let test = sub_eq (get_idx_mut r ((.b134.#a99) : (t134, _) idx_mut)) next_r.b134.#a99 in
  if not test then failwithf "test 2356 failed";
  (* .b134.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b134 = #{ r.b134 with b99 = next_r.b134.#b99 } } in
  set_idx_mut r ((.b134.#b99) : (t134, _) idx_mut) next_r.b134.#b99;
  mark_test_run 2357;
  let test = eq r expected in
  if not test then failwithf "test 2357 failed";
  mark_test_run 2358;
  let test = sub_eq (get_idx_mut r ((.b134.#b99) : (t134, _) idx_mut)) next_r.b134.#b99 in
  if not test then failwithf "test 2358 failed";
  (**********************************************)
  (*   t135 = { int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun ({ a135 = a1351; b135 = b1351 } : t135) ({ a135 = a1352; b135 = b1352 } : t135) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1351 a1352 && (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) b1351 b1352) in
  let r = ({ a135 = #0l; b135 = (#{ a19 = #1l; b19 = #2l } : t19) } : t135) in
  (* Paths of depth 0 *)
  let next_r = ({ a135 = #100l; b135 = (#{ a19 = #101l; b19 = #102l } : t19) } : t135) in
  (* .a135 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a135 = next_r.a135 } in
  set_idx_mut r ((.a135) : (t135, _) idx_mut) next_r.a135;
  mark_test_run 2359;
  let test = eq r expected in
  if not test then failwithf "test 2359 failed";
  mark_test_run 2360;
  let test = sub_eq (get_idx_mut r ((.a135) : (t135, _) idx_mut)) next_r.a135 in
  if not test then failwithf "test 2360 failed";
  let r = ({ a135 = #0l; b135 = (#{ a19 = #1l; b19 = #2l } : t19) } : t135) in
  (* Paths of depth 0 *)
  let next_r = ({ a135 = #100l; b135 = (#{ a19 = #101l; b19 = #102l } : t19) } : t135) in
  (* .b135 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with b135 = next_r.b135 } in
  set_idx_mut r ((.b135) : (t135, _) idx_mut) next_r.b135;
  mark_test_run 2361;
  let test = eq r expected in
  if not test then failwithf "test 2361 failed";
  mark_test_run 2362;
  let test = sub_eq (get_idx_mut r ((.b135) : (t135, _) idx_mut)) next_r.b135 in
  if not test then failwithf "test 2362 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a135 = #200l; b135 = (#{ a19 = #201l; b19 = #202l } : t19) } : t135) in
  (* .b135.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b135 = #{ r.b135 with a19 = next_r.b135.#a19 } } in
  set_idx_mut r ((.b135.#a19) : (t135, _) idx_mut) next_r.b135.#a19;
  mark_test_run 2363;
  let test = eq r expected in
  if not test then failwithf "test 2363 failed";
  mark_test_run 2364;
  let test = sub_eq (get_idx_mut r ((.b135.#a19) : (t135, _) idx_mut)) next_r.b135.#a19 in
  if not test then failwithf "test 2364 failed";
  (* .b135.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b135 = #{ r.b135 with b19 = next_r.b135.#b19 } } in
  set_idx_mut r ((.b135.#b19) : (t135, _) idx_mut) next_r.b135.#b19;
  mark_test_run 2365;
  let test = eq r expected in
  if not test then failwithf "test 2365 failed";
  mark_test_run 2366;
  let test = sub_eq (get_idx_mut r ((.b135.#b19) : (t135, _) idx_mut)) next_r.b135.#b19 in
  if not test then failwithf "test 2366 failed";
  (*****************************)
  (*   t136 = { nativeint# }   *)
  (*****************************)
  let eq = (fun ({ a136 = a1361 } : t136) ({ a136 = a1362 } : t136) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1361 a1362) in
  let r = ({ a136 = #0n } : t136) in
  (* Paths of depth 0 *)
  let next_r = ({ a136 = #100n } : t136) in
  (* .a136 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a136 = next_r.a136 } in
  set_idx_mut r ((.a136) : (t136, _) idx_mut) next_r.a136;
  mark_test_run 2367;
  let test = eq r expected in
  if not test then failwithf "test 2367 failed";
  mark_test_run 2368;
  let test = sub_eq (get_idx_mut r ((.a136) : (t136, _) idx_mut)) next_r.a136 in
  if not test then failwithf "test 2368 failed";
  (**********************************)
  (*   t137 = { nativeint#; int }   *)
  (**********************************)
  let eq = (fun ({ a137 = a1371; b137 = b1371 } : t137) ({ a137 = a1372; b137 = b1372 } : t137) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1371 a1372 && (fun a b -> Int.equal a b) b1371 b1372) in
  let r = ({ a137 = #0n; b137 = 1 } : t137) in
  (* Paths of depth 0 *)
  let next_r = ({ a137 = #100n; b137 = 101 } : t137) in
  (* .a137 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a137 = next_r.a137 } in
  set_idx_mut r ((.a137) : (t137, _) idx_mut) next_r.a137;
  mark_test_run 2369;
  let test = eq r expected in
  if not test then failwithf "test 2369 failed";
  mark_test_run 2370;
  let test = sub_eq (get_idx_mut r ((.a137) : (t137, _) idx_mut)) next_r.a137 in
  if not test then failwithf "test 2370 failed";
  let r = ({ a137 = #0n; b137 = 1 } : t137) in
  (* Paths of depth 0 *)
  let next_r = ({ a137 = #100n; b137 = 101 } : t137) in
  (* .b137 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b137 = next_r.b137 } in
  set_idx_mut r ((.b137) : (t137, _) idx_mut) next_r.b137;
  mark_test_run 2371;
  let test = eq r expected in
  if not test then failwithf "test 2371 failed";
  mark_test_run 2372;
  let test = sub_eq (get_idx_mut r ((.b137) : (t137, _) idx_mut)) next_r.b137 in
  if not test then failwithf "test 2372 failed";
  (************************************)
  (*   t138 = { nativeint#; int64 }   *)
  (************************************)
  let eq = (fun ({ a138 = a1381; b138 = b1381 } : t138) ({ a138 = a1382; b138 = b1382 } : t138) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1381 a1382 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1381 b1382) in
  let r = ({ a138 = #0n; b138 = 1L } : t138) in
  (* Paths of depth 0 *)
  let next_r = ({ a138 = #100n; b138 = 101L } : t138) in
  (* .a138 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a138 = next_r.a138 } in
  set_idx_mut r ((.a138) : (t138, _) idx_mut) next_r.a138;
  mark_test_run 2373;
  let test = eq r expected in
  if not test then failwithf "test 2373 failed";
  mark_test_run 2374;
  let test = sub_eq (get_idx_mut r ((.a138) : (t138, _) idx_mut)) next_r.a138 in
  if not test then failwithf "test 2374 failed";
  let r = ({ a138 = #0n; b138 = 1L } : t138) in
  (* Paths of depth 0 *)
  let next_r = ({ a138 = #100n; b138 = 101L } : t138) in
  (* .b138 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b138 = next_r.b138 } in
  set_idx_mut r ((.b138) : (t138, _) idx_mut) next_r.b138;
  mark_test_run 2375;
  let test = eq r expected in
  if not test then failwithf "test 2375 failed";
  mark_test_run 2376;
  let test = sub_eq (get_idx_mut r ((.b138) : (t138, _) idx_mut)) next_r.b138 in
  if not test then failwithf "test 2376 failed";
  (*************************************)
  (*   t139 = { nativeint#; int64# }   *)
  (*************************************)
  let eq = (fun ({ a139 = a1391; b139 = b1391 } : t139) ({ a139 = a1392; b139 = b1392 } : t139) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1391 a1392 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1391 b1392) in
  let r = ({ a139 = #0n; b139 = #1L } : t139) in
  (* Paths of depth 0 *)
  let next_r = ({ a139 = #100n; b139 = #101L } : t139) in
  (* .a139 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a139 = next_r.a139 } in
  set_idx_mut r ((.a139) : (t139, _) idx_mut) next_r.a139;
  mark_test_run 2377;
  let test = eq r expected in
  if not test then failwithf "test 2377 failed";
  mark_test_run 2378;
  let test = sub_eq (get_idx_mut r ((.a139) : (t139, _) idx_mut)) next_r.a139 in
  if not test then failwithf "test 2378 failed";
  let r = ({ a139 = #0n; b139 = #1L } : t139) in
  (* Paths of depth 0 *)
  let next_r = ({ a139 = #100n; b139 = #101L } : t139) in
  (* .b139 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b139 = next_r.b139 } in
  set_idx_mut r ((.b139) : (t139, _) idx_mut) next_r.b139;
  mark_test_run 2379;
  let test = eq r expected in
  if not test then failwithf "test 2379 failed";
  mark_test_run 2380;
  let test = sub_eq (get_idx_mut r ((.b139) : (t139, _) idx_mut)) next_r.b139 in
  if not test then failwithf "test 2380 failed";
  (*************************************)
  (*   t140 = { nativeint#; int32# }   *)
  (*************************************)
  let eq = (fun ({ a140 = a1401; b140 = b1401 } : t140) ({ a140 = a1402; b140 = b1402 } : t140) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1401 a1402 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1401 b1402) in
  let r = ({ a140 = #0n; b140 = #1l } : t140) in
  (* Paths of depth 0 *)
  let next_r = ({ a140 = #100n; b140 = #101l } : t140) in
  (* .a140 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a140 = next_r.a140 } in
  set_idx_mut r ((.a140) : (t140, _) idx_mut) next_r.a140;
  mark_test_run 2381;
  let test = eq r expected in
  if not test then failwithf "test 2381 failed";
  mark_test_run 2382;
  let test = sub_eq (get_idx_mut r ((.a140) : (t140, _) idx_mut)) next_r.a140 in
  if not test then failwithf "test 2382 failed";
  let r = ({ a140 = #0n; b140 = #1l } : t140) in
  (* Paths of depth 0 *)
  let next_r = ({ a140 = #100n; b140 = #101l } : t140) in
  (* .b140 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b140 = next_r.b140 } in
  set_idx_mut r ((.b140) : (t140, _) idx_mut) next_r.b140;
  mark_test_run 2383;
  let test = eq r expected in
  if not test then failwithf "test 2383 failed";
  mark_test_run 2384;
  let test = sub_eq (get_idx_mut r ((.b140) : (t140, _) idx_mut)) next_r.b140 in
  if not test then failwithf "test 2384 failed";
  (*****************************************)
  (*   t141 = { nativeint#; nativeint# }   *)
  (*****************************************)
  let eq = (fun ({ a141 = a1411; b141 = b1411 } : t141) ({ a141 = a1412; b141 = b1412 } : t141) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1411 a1412 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1411 b1412) in
  let r = ({ a141 = #0n; b141 = #1n } : t141) in
  (* Paths of depth 0 *)
  let next_r = ({ a141 = #100n; b141 = #101n } : t141) in
  (* .a141 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a141 = next_r.a141 } in
  set_idx_mut r ((.a141) : (t141, _) idx_mut) next_r.a141;
  mark_test_run 2385;
  let test = eq r expected in
  if not test then failwithf "test 2385 failed";
  mark_test_run 2386;
  let test = sub_eq (get_idx_mut r ((.a141) : (t141, _) idx_mut)) next_r.a141 in
  if not test then failwithf "test 2386 failed";
  let r = ({ a141 = #0n; b141 = #1n } : t141) in
  (* Paths of depth 0 *)
  let next_r = ({ a141 = #100n; b141 = #101n } : t141) in
  (* .b141 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b141 = next_r.b141 } in
  set_idx_mut r ((.b141) : (t141, _) idx_mut) next_r.b141;
  mark_test_run 2387;
  let test = eq r expected in
  if not test then failwithf "test 2387 failed";
  mark_test_run 2388;
  let test = sub_eq (get_idx_mut r ((.b141) : (t141, _) idx_mut)) next_r.b141 in
  if not test then failwithf "test 2388 failed";
  (************************************)
  (*   t142 = { nativeint#; float }   *)
  (************************************)
  let eq = (fun ({ a142 = a1421; b142 = b1421 } : t142) ({ a142 = a1422; b142 = b1422 } : t142) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a1421 a1422 && (fun a b -> Float.equal (globalize a) (globalize b)) b1421 b1422) in
  let r = ({ a142 = #0n; b142 = 1. } : t142) in
  (* Paths of depth 0 *)
  let next_r = ({ a142 = #100n; b142 = 101. } : t142) in
  (* .a142 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with a142 = next_r.a142 } in
  set_idx_mut r ((.a142) : (t142, _) idx_mut) next_r.a142;
  mark_test_run 2389;
  let test = eq r expected in
  if not test then failwithf "test 2389 failed";
  mark_test_run 2390;
  let test = sub_eq (get_idx_mut r ((.a142) : (t142, _) idx_mut)) next_r.a142 in
  if not test then failwithf "test 2390 failed";
  let r = ({ a142 = #0n; b142 = 1. } : t142) in
  (* Paths of depth 0 *)
  let next_r = ({ a142 = #100n; b142 = 101. } : t142) in
  (* .b142 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b142 = next_r.b142 } in
  set_idx_mut r ((.b142) : (t142, _) idx_mut) next_r.b142;
  mark_test_run 2391;
  let test = eq r expected in
  if not test then failwithf "test 2391 failed";
  mark_test_run 2392;
  let test = sub_eq (get_idx_mut r ((.b142) : (t142, _) idx_mut)) next_r.b142 in
  if not test then failwithf "test 2392 failed";
  (************************)
  (*   t143 = { float }   *)
  (************************)
  let eq = (fun ({ a143 = a1431 } : t143) ({ a143 = a1432 } : t143) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1431 a1432) in
  let r = ({ a143 = 0. } : t143) in
  (* Paths of depth 0 *)
  let next_r = ({ a143 = 100. } : t143) in
  (* .a143 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a143 = next_r.a143 } in
  set_idx_mut r ((.a143) : (t143, _) idx_mut) (Float_u.of_float next_r.a143);
  mark_test_run 2393;
  let test = eq r expected in
  if not test then failwithf "test 2393 failed";
  mark_test_run 2394;
  let test = sub_eq (get_idx_mut r ((.a143) : (t143, _) idx_mut)) (Float_u.of_float next_r.a143) in
  if not test then failwithf "test 2394 failed";
  (*****************************)
  (*   t144 = { float; int }   *)
  (*****************************)
  let eq = (fun ({ a144 = a1441; b144 = b1441 } : t144) ({ a144 = a1442; b144 = b1442 } : t144) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1441 a1442 && (fun a b -> Int.equal a b) b1441 b1442) in
  let r = ({ a144 = 0.; b144 = 1 } : t144) in
  (* Paths of depth 0 *)
  let next_r = ({ a144 = 100.; b144 = 101 } : t144) in
  (* .a144 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a144 = next_r.a144 } in
  set_idx_mut r ((.a144) : (t144, _) idx_mut) next_r.a144;
  mark_test_run 2395;
  let test = eq r expected in
  if not test then failwithf "test 2395 failed";
  mark_test_run 2396;
  let test = sub_eq (get_idx_mut r ((.a144) : (t144, _) idx_mut)) next_r.a144 in
  if not test then failwithf "test 2396 failed";
  let r = ({ a144 = 0.; b144 = 1 } : t144) in
  (* Paths of depth 0 *)
  let next_r = ({ a144 = 100.; b144 = 101 } : t144) in
  (* .b144 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b144 = next_r.b144 } in
  set_idx_mut r ((.b144) : (t144, _) idx_mut) next_r.b144;
  mark_test_run 2397;
  let test = eq r expected in
  if not test then failwithf "test 2397 failed";
  mark_test_run 2398;
  let test = sub_eq (get_idx_mut r ((.b144) : (t144, _) idx_mut)) next_r.b144 in
  if not test then failwithf "test 2398 failed";
  (**********************************)
  (*   t145 = { float; int; int }   *)
  (**********************************)
  let eq = (fun ({ a145 = a1451; b145 = b1451; c145 = c1451 } : t145) ({ a145 = a1452; b145 = b1452; c145 = c1452 } : t145) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1451 a1452 && (fun a b -> Int.equal a b) b1451 b1452 && (fun a b -> Int.equal a b) c1451 c1452) in
  let r = ({ a145 = 0.; b145 = 1; c145 = 2 } : t145) in
  (* Paths of depth 0 *)
  let next_r = ({ a145 = 100.; b145 = 101; c145 = 102 } : t145) in
  (* .a145 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a145 = next_r.a145 } in
  set_idx_mut r ((.a145) : (t145, _) idx_mut) next_r.a145;
  mark_test_run 2399;
  let test = eq r expected in
  if not test then failwithf "test 2399 failed";
  mark_test_run 2400;
  let test = sub_eq (get_idx_mut r ((.a145) : (t145, _) idx_mut)) next_r.a145 in
  if not test then failwithf "test 2400 failed";
  let r = ({ a145 = 0.; b145 = 1; c145 = 2 } : t145) in
  (* Paths of depth 0 *)
  let next_r = ({ a145 = 100.; b145 = 101; c145 = 102 } : t145) in
  (* .b145 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b145 = next_r.b145 } in
  set_idx_mut r ((.b145) : (t145, _) idx_mut) next_r.b145;
  mark_test_run 2401;
  let test = eq r expected in
  if not test then failwithf "test 2401 failed";
  mark_test_run 2402;
  let test = sub_eq (get_idx_mut r ((.b145) : (t145, _) idx_mut)) next_r.b145 in
  if not test then failwithf "test 2402 failed";
  let r = ({ a145 = 0.; b145 = 1; c145 = 2 } : t145) in
  (* Paths of depth 0 *)
  let next_r = ({ a145 = 100.; b145 = 101; c145 = 102 } : t145) in
  (* .c145 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c145 = next_r.c145 } in
  set_idx_mut r ((.c145) : (t145, _) idx_mut) next_r.c145;
  mark_test_run 2403;
  let test = eq r expected in
  if not test then failwithf "test 2403 failed";
  mark_test_run 2404;
  let test = sub_eq (get_idx_mut r ((.c145) : (t145, _) idx_mut)) next_r.c145 in
  if not test then failwithf "test 2404 failed";
  (************************************)
  (*   t146 = { float; int; float }   *)
  (************************************)
  let eq = (fun ({ a146 = a1461; b146 = b1461; c146 = c1461 } : t146) ({ a146 = a1462; b146 = b1462; c146 = c1462 } : t146) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1461 a1462 && (fun a b -> Int.equal a b) b1461 b1462 && (fun a b -> Float.equal (globalize a) (globalize b)) c1461 c1462) in
  let r = ({ a146 = 0.; b146 = 1; c146 = 2. } : t146) in
  (* Paths of depth 0 *)
  let next_r = ({ a146 = 100.; b146 = 101; c146 = 102. } : t146) in
  (* .a146 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a146 = next_r.a146 } in
  set_idx_mut r ((.a146) : (t146, _) idx_mut) next_r.a146;
  mark_test_run 2405;
  let test = eq r expected in
  if not test then failwithf "test 2405 failed";
  mark_test_run 2406;
  let test = sub_eq (get_idx_mut r ((.a146) : (t146, _) idx_mut)) next_r.a146 in
  if not test then failwithf "test 2406 failed";
  let r = ({ a146 = 0.; b146 = 1; c146 = 2. } : t146) in
  (* Paths of depth 0 *)
  let next_r = ({ a146 = 100.; b146 = 101; c146 = 102. } : t146) in
  (* .b146 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b146 = next_r.b146 } in
  set_idx_mut r ((.b146) : (t146, _) idx_mut) next_r.b146;
  mark_test_run 2407;
  let test = eq r expected in
  if not test then failwithf "test 2407 failed";
  mark_test_run 2408;
  let test = sub_eq (get_idx_mut r ((.b146) : (t146, _) idx_mut)) next_r.b146 in
  if not test then failwithf "test 2408 failed";
  let r = ({ a146 = 0.; b146 = 1; c146 = 2. } : t146) in
  (* Paths of depth 0 *)
  let next_r = ({ a146 = 100.; b146 = 101; c146 = 102. } : t146) in
  (* .c146 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with c146 = next_r.c146 } in
  set_idx_mut r ((.c146) : (t146, _) idx_mut) next_r.c146;
  mark_test_run 2409;
  let test = eq r expected in
  if not test then failwithf "test 2409 failed";
  mark_test_run 2410;
  let test = sub_eq (get_idx_mut r ((.c146) : (t146, _) idx_mut)) next_r.c146 in
  if not test then failwithf "test 2410 failed";
  (*******************************)
  (*   t147 = { float; int64 }   *)
  (*******************************)
  let eq = (fun ({ a147 = a1471; b147 = b1471 } : t147) ({ a147 = a1472; b147 = b1472 } : t147) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1471 a1472 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1471 b1472) in
  let r = ({ a147 = 0.; b147 = 1L } : t147) in
  (* Paths of depth 0 *)
  let next_r = ({ a147 = 100.; b147 = 101L } : t147) in
  (* .a147 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a147 = next_r.a147 } in
  set_idx_mut r ((.a147) : (t147, _) idx_mut) next_r.a147;
  mark_test_run 2411;
  let test = eq r expected in
  if not test then failwithf "test 2411 failed";
  mark_test_run 2412;
  let test = sub_eq (get_idx_mut r ((.a147) : (t147, _) idx_mut)) next_r.a147 in
  if not test then failwithf "test 2412 failed";
  let r = ({ a147 = 0.; b147 = 1L } : t147) in
  (* Paths of depth 0 *)
  let next_r = ({ a147 = 100.; b147 = 101L } : t147) in
  (* .b147 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b147 = next_r.b147 } in
  set_idx_mut r ((.b147) : (t147, _) idx_mut) next_r.b147;
  mark_test_run 2413;
  let test = eq r expected in
  if not test then failwithf "test 2413 failed";
  mark_test_run 2414;
  let test = sub_eq (get_idx_mut r ((.b147) : (t147, _) idx_mut)) next_r.b147 in
  if not test then failwithf "test 2414 failed";
  (********************************)
  (*   t148 = { float; int64# }   *)
  (********************************)
  let eq = (fun ({ a148 = a1481; b148 = b1481 } : t148) ({ a148 = a1482; b148 = b1482 } : t148) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1481 a1482 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1481 b1482) in
  let r = ({ a148 = 0.; b148 = #1L } : t148) in
  (* Paths of depth 0 *)
  let next_r = ({ a148 = 100.; b148 = #101L } : t148) in
  (* .a148 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a148 = next_r.a148 } in
  set_idx_mut r ((.a148) : (t148, _) idx_mut) next_r.a148;
  mark_test_run 2415;
  let test = eq r expected in
  if not test then failwithf "test 2415 failed";
  mark_test_run 2416;
  let test = sub_eq (get_idx_mut r ((.a148) : (t148, _) idx_mut)) next_r.a148 in
  if not test then failwithf "test 2416 failed";
  let r = ({ a148 = 0.; b148 = #1L } : t148) in
  (* Paths of depth 0 *)
  let next_r = ({ a148 = 100.; b148 = #101L } : t148) in
  (* .b148 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b148 = next_r.b148 } in
  set_idx_mut r ((.b148) : (t148, _) idx_mut) next_r.b148;
  mark_test_run 2417;
  let test = eq r expected in
  if not test then failwithf "test 2417 failed";
  mark_test_run 2418;
  let test = sub_eq (get_idx_mut r ((.b148) : (t148, _) idx_mut)) next_r.b148 in
  if not test then failwithf "test 2418 failed";
  (********************************)
  (*   t149 = { float; int32# }   *)
  (********************************)
  let eq = (fun ({ a149 = a1491; b149 = b1491 } : t149) ({ a149 = a1492; b149 = b1492 } : t149) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1491 a1492 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1491 b1492) in
  let r = ({ a149 = 0.; b149 = #1l } : t149) in
  (* Paths of depth 0 *)
  let next_r = ({ a149 = 100.; b149 = #101l } : t149) in
  (* .a149 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a149 = next_r.a149 } in
  set_idx_mut r ((.a149) : (t149, _) idx_mut) next_r.a149;
  mark_test_run 2419;
  let test = eq r expected in
  if not test then failwithf "test 2419 failed";
  mark_test_run 2420;
  let test = sub_eq (get_idx_mut r ((.a149) : (t149, _) idx_mut)) next_r.a149 in
  if not test then failwithf "test 2420 failed";
  let r = ({ a149 = 0.; b149 = #1l } : t149) in
  (* Paths of depth 0 *)
  let next_r = ({ a149 = 100.; b149 = #101l } : t149) in
  (* .b149 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b149 = next_r.b149 } in
  set_idx_mut r ((.b149) : (t149, _) idx_mut) next_r.b149;
  mark_test_run 2421;
  let test = eq r expected in
  if not test then failwithf "test 2421 failed";
  mark_test_run 2422;
  let test = sub_eq (get_idx_mut r ((.b149) : (t149, _) idx_mut)) next_r.b149 in
  if not test then failwithf "test 2422 failed";
  (************************************)
  (*   t150 = { float; nativeint# }   *)
  (************************************)
  let eq = (fun ({ a150 = a1501; b150 = b1501 } : t150) ({ a150 = a1502; b150 = b1502 } : t150) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1501 a1502 && (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) b1501 b1502) in
  let r = ({ a150 = 0.; b150 = #1n } : t150) in
  (* Paths of depth 0 *)
  let next_r = ({ a150 = 100.; b150 = #101n } : t150) in
  (* .a150 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a150 = next_r.a150 } in
  set_idx_mut r ((.a150) : (t150, _) idx_mut) next_r.a150;
  mark_test_run 2423;
  let test = eq r expected in
  if not test then failwithf "test 2423 failed";
  mark_test_run 2424;
  let test = sub_eq (get_idx_mut r ((.a150) : (t150, _) idx_mut)) next_r.a150 in
  if not test then failwithf "test 2424 failed";
  let r = ({ a150 = 0.; b150 = #1n } : t150) in
  (* Paths of depth 0 *)
  let next_r = ({ a150 = 100.; b150 = #101n } : t150) in
  (* .b150 *)
  let sub_eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let expected = { r with b150 = next_r.b150 } in
  set_idx_mut r ((.b150) : (t150, _) idx_mut) next_r.b150;
  mark_test_run 2425;
  let test = eq r expected in
  if not test then failwithf "test 2425 failed";
  mark_test_run 2426;
  let test = sub_eq (get_idx_mut r ((.b150) : (t150, _) idx_mut)) next_r.b150 in
  if not test then failwithf "test 2426 failed";
  (*******************************)
  (*   t151 = { float; float }   *)
  (*******************************)
  let eq = (fun ({ a151 = a1511; b151 = b1511 } : t151) ({ a151 = a1512; b151 = b1512 } : t151) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1511 a1512 && (fun a b -> Float.equal (globalize a) (globalize b)) b1511 b1512) in
  let r = ({ a151 = 0.; b151 = 1. } : t151) in
  (* Paths of depth 0 *)
  let next_r = ({ a151 = 100.; b151 = 101. } : t151) in
  (* .a151 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a151 = next_r.a151 } in
  set_idx_mut r ((.a151) : (t151, _) idx_mut) (Float_u.of_float next_r.a151);
  mark_test_run 2427;
  let test = eq r expected in
  if not test then failwithf "test 2427 failed";
  mark_test_run 2428;
  let test = sub_eq (get_idx_mut r ((.a151) : (t151, _) idx_mut)) (Float_u.of_float next_r.a151) in
  if not test then failwithf "test 2428 failed";
  let r = ({ a151 = 0.; b151 = 1. } : t151) in
  (* Paths of depth 0 *)
  let next_r = ({ a151 = 100.; b151 = 101. } : t151) in
  (* .b151 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b151 = next_r.b151 } in
  set_idx_mut r ((.b151) : (t151, _) idx_mut) (Float_u.of_float next_r.b151);
  mark_test_run 2429;
  let test = eq r expected in
  if not test then failwithf "test 2429 failed";
  mark_test_run 2430;
  let test = sub_eq (get_idx_mut r ((.b151) : (t151, _) idx_mut)) (Float_u.of_float next_r.b151) in
  if not test then failwithf "test 2430 failed";
  (************************************)
  (*   t152 = { float; float; int }   *)
  (************************************)
  let eq = (fun ({ a152 = a1521; b152 = b1521; c152 = c1521 } : t152) ({ a152 = a1522; b152 = b1522; c152 = c1522 } : t152) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1521 a1522 && (fun a b -> Float.equal (globalize a) (globalize b)) b1521 b1522 && (fun a b -> Int.equal a b) c1521 c1522) in
  let r = ({ a152 = 0.; b152 = 1.; c152 = 2 } : t152) in
  (* Paths of depth 0 *)
  let next_r = ({ a152 = 100.; b152 = 101.; c152 = 102 } : t152) in
  (* .a152 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a152 = next_r.a152 } in
  set_idx_mut r ((.a152) : (t152, _) idx_mut) next_r.a152;
  mark_test_run 2431;
  let test = eq r expected in
  if not test then failwithf "test 2431 failed";
  mark_test_run 2432;
  let test = sub_eq (get_idx_mut r ((.a152) : (t152, _) idx_mut)) next_r.a152 in
  if not test then failwithf "test 2432 failed";
  let r = ({ a152 = 0.; b152 = 1.; c152 = 2 } : t152) in
  (* Paths of depth 0 *)
  let next_r = ({ a152 = 100.; b152 = 101.; c152 = 102 } : t152) in
  (* .b152 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b152 = next_r.b152 } in
  set_idx_mut r ((.b152) : (t152, _) idx_mut) next_r.b152;
  mark_test_run 2433;
  let test = eq r expected in
  if not test then failwithf "test 2433 failed";
  mark_test_run 2434;
  let test = sub_eq (get_idx_mut r ((.b152) : (t152, _) idx_mut)) next_r.b152 in
  if not test then failwithf "test 2434 failed";
  let r = ({ a152 = 0.; b152 = 1.; c152 = 2 } : t152) in
  (* Paths of depth 0 *)
  let next_r = ({ a152 = 100.; b152 = 101.; c152 = 102 } : t152) in
  (* .c152 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with c152 = next_r.c152 } in
  set_idx_mut r ((.c152) : (t152, _) idx_mut) next_r.c152;
  mark_test_run 2435;
  let test = eq r expected in
  if not test then failwithf "test 2435 failed";
  mark_test_run 2436;
  let test = sub_eq (get_idx_mut r ((.c152) : (t152, _) idx_mut)) next_r.c152 in
  if not test then failwithf "test 2436 failed";
  (**************************************)
  (*   t153 = { float; float; float }   *)
  (**************************************)
  let eq = (fun ({ a153 = a1531; b153 = b1531; c153 = c1531 } : t153) ({ a153 = a1532; b153 = b1532; c153 = c1532 } : t153) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1531 a1532 && (fun a b -> Float.equal (globalize a) (globalize b)) b1531 b1532 && (fun a b -> Float.equal (globalize a) (globalize b)) c1531 c1532) in
  let r = ({ a153 = 0.; b153 = 1.; c153 = 2. } : t153) in
  (* Paths of depth 0 *)
  let next_r = ({ a153 = 100.; b153 = 101.; c153 = 102. } : t153) in
  (* .a153 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a153 = next_r.a153 } in
  set_idx_mut r ((.a153) : (t153, _) idx_mut) (Float_u.of_float next_r.a153);
  mark_test_run 2437;
  let test = eq r expected in
  if not test then failwithf "test 2437 failed";
  mark_test_run 2438;
  let test = sub_eq (get_idx_mut r ((.a153) : (t153, _) idx_mut)) (Float_u.of_float next_r.a153) in
  if not test then failwithf "test 2438 failed";
  let r = ({ a153 = 0.; b153 = 1.; c153 = 2. } : t153) in
  (* Paths of depth 0 *)
  let next_r = ({ a153 = 100.; b153 = 101.; c153 = 102. } : t153) in
  (* .b153 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b153 = next_r.b153 } in
  set_idx_mut r ((.b153) : (t153, _) idx_mut) (Float_u.of_float next_r.b153);
  mark_test_run 2439;
  let test = eq r expected in
  if not test then failwithf "test 2439 failed";
  mark_test_run 2440;
  let test = sub_eq (get_idx_mut r ((.b153) : (t153, _) idx_mut)) (Float_u.of_float next_r.b153) in
  if not test then failwithf "test 2440 failed";
  let r = ({ a153 = 0.; b153 = 1.; c153 = 2. } : t153) in
  (* Paths of depth 0 *)
  let next_r = ({ a153 = 100.; b153 = 101.; c153 = 102. } : t153) in
  (* .c153 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with c153 = next_r.c153 } in
  set_idx_mut r ((.c153) : (t153, _) idx_mut) (Float_u.of_float next_r.c153);
  mark_test_run 2441;
  let test = eq r expected in
  if not test then failwithf "test 2441 failed";
  mark_test_run 2442;
  let test = sub_eq (get_idx_mut r ((.c153) : (t153, _) idx_mut)) (Float_u.of_float next_r.c153) in
  if not test then failwithf "test 2442 failed";
  (**********************************)
  (*   t154 = { float; #{ int } }   *)
  (**********************************)
  let eq = (fun ({ a154 = a1541; b154 = b1541 } : t154) ({ a154 = a1542; b154 = b1542 } : t154) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1541 a1542 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b1541 b1542) in
  let r = ({ a154 = 0.; b154 = (#{ a0 = 1 } : t0) } : t154) in
  (* Paths of depth 0 *)
  let next_r = ({ a154 = 100.; b154 = (#{ a0 = 101 } : t0) } : t154) in
  (* .a154 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a154 = next_r.a154 } in
  set_idx_mut r ((.a154) : (t154, _) idx_mut) next_r.a154;
  mark_test_run 2443;
  let test = eq r expected in
  if not test then failwithf "test 2443 failed";
  mark_test_run 2444;
  let test = sub_eq (get_idx_mut r ((.a154) : (t154, _) idx_mut)) next_r.a154 in
  if not test then failwithf "test 2444 failed";
  let r = ({ a154 = 0.; b154 = (#{ a0 = 1 } : t0) } : t154) in
  (* Paths of depth 0 *)
  let next_r = ({ a154 = 100.; b154 = (#{ a0 = 101 } : t0) } : t154) in
  (* .b154 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with b154 = next_r.b154 } in
  set_idx_mut r ((.b154) : (t154, _) idx_mut) next_r.b154;
  mark_test_run 2445;
  let test = eq r expected in
  if not test then failwithf "test 2445 failed";
  mark_test_run 2446;
  let test = sub_eq (get_idx_mut r ((.b154) : (t154, _) idx_mut)) next_r.b154 in
  if not test then failwithf "test 2446 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a154 = 200.; b154 = (#{ a0 = 201 } : t0) } : t154) in
  (* .b154.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b154 = #{ r.b154 with a0 = next_r.b154.#a0 } } in
  set_idx_mut r ((.b154.#a0) : (t154, _) idx_mut) next_r.b154.#a0;
  mark_test_run 2447;
  let test = eq r expected in
  if not test then failwithf "test 2447 failed";
  mark_test_run 2448;
  let test = sub_eq (get_idx_mut r ((.b154.#a0) : (t154, _) idx_mut)) next_r.b154.#a0 in
  if not test then failwithf "test 2448 failed";
  (***************************************)
  (*   t155 = { float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun ({ a155 = a1551; b155 = b1551 } : t155) ({ a155 = a1552; b155 = b1552 } : t155) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1551 a1552 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b1551 b1552) in
  let r = ({ a155 = 0.; b155 = (#{ a1 = 1; b1 = 2 } : t1) } : t155) in
  (* Paths of depth 0 *)
  let next_r = ({ a155 = 100.; b155 = (#{ a1 = 101; b1 = 102 } : t1) } : t155) in
  (* .a155 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a155 = next_r.a155 } in
  set_idx_mut r ((.a155) : (t155, _) idx_mut) next_r.a155;
  mark_test_run 2449;
  let test = eq r expected in
  if not test then failwithf "test 2449 failed";
  mark_test_run 2450;
  let test = sub_eq (get_idx_mut r ((.a155) : (t155, _) idx_mut)) next_r.a155 in
  if not test then failwithf "test 2450 failed";
  let r = ({ a155 = 0.; b155 = (#{ a1 = 1; b1 = 2 } : t1) } : t155) in
  (* Paths of depth 0 *)
  let next_r = ({ a155 = 100.; b155 = (#{ a1 = 101; b1 = 102 } : t1) } : t155) in
  (* .b155 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with b155 = next_r.b155 } in
  set_idx_mut r ((.b155) : (t155, _) idx_mut) next_r.b155;
  mark_test_run 2451;
  let test = eq r expected in
  if not test then failwithf "test 2451 failed";
  mark_test_run 2452;
  let test = sub_eq (get_idx_mut r ((.b155) : (t155, _) idx_mut)) next_r.b155 in
  if not test then failwithf "test 2452 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a155 = 200.; b155 = (#{ a1 = 201; b1 = 202 } : t1) } : t155) in
  (* .b155.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b155 = #{ r.b155 with a1 = next_r.b155.#a1 } } in
  set_idx_mut r ((.b155.#a1) : (t155, _) idx_mut) next_r.b155.#a1;
  mark_test_run 2453;
  let test = eq r expected in
  if not test then failwithf "test 2453 failed";
  mark_test_run 2454;
  let test = sub_eq (get_idx_mut r ((.b155.#a1) : (t155, _) idx_mut)) next_r.b155.#a1 in
  if not test then failwithf "test 2454 failed";
  (* .b155.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b155 = #{ r.b155 with b1 = next_r.b155.#b1 } } in
  set_idx_mut r ((.b155.#b1) : (t155, _) idx_mut) next_r.b155.#b1;
  mark_test_run 2455;
  let test = eq r expected in
  if not test then failwithf "test 2455 failed";
  mark_test_run 2456;
  let test = sub_eq (get_idx_mut r ((.b155.#b1) : (t155, _) idx_mut)) next_r.b155.#b1 in
  if not test then failwithf "test 2456 failed";
  (*****************************************)
  (*   t156 = { float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun ({ a156 = a1561; b156 = b1561 } : t156) ({ a156 = a1562; b156 = b1562 } : t156) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1561 a1562 && (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) b1561 b1562) in
  let r = ({ a156 = 0.; b156 = (#{ a10 = 1; b10 = 2. } : t10) } : t156) in
  (* Paths of depth 0 *)
  let next_r = ({ a156 = 100.; b156 = (#{ a10 = 101; b10 = 102. } : t10) } : t156) in
  (* .a156 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a156 = next_r.a156 } in
  set_idx_mut r ((.a156) : (t156, _) idx_mut) next_r.a156;
  mark_test_run 2457;
  let test = eq r expected in
  if not test then failwithf "test 2457 failed";
  mark_test_run 2458;
  let test = sub_eq (get_idx_mut r ((.a156) : (t156, _) idx_mut)) next_r.a156 in
  if not test then failwithf "test 2458 failed";
  let r = ({ a156 = 0.; b156 = (#{ a10 = 1; b10 = 2. } : t10) } : t156) in
  (* Paths of depth 0 *)
  let next_r = ({ a156 = 100.; b156 = (#{ a10 = 101; b10 = 102. } : t10) } : t156) in
  (* .b156 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with b156 = next_r.b156 } in
  set_idx_mut r ((.b156) : (t156, _) idx_mut) next_r.b156;
  mark_test_run 2459;
  let test = eq r expected in
  if not test then failwithf "test 2459 failed";
  mark_test_run 2460;
  let test = sub_eq (get_idx_mut r ((.b156) : (t156, _) idx_mut)) next_r.b156 in
  if not test then failwithf "test 2460 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a156 = 200.; b156 = (#{ a10 = 201; b10 = 202. } : t10) } : t156) in
  (* .b156.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b156 = #{ r.b156 with a10 = next_r.b156.#a10 } } in
  set_idx_mut r ((.b156.#a10) : (t156, _) idx_mut) next_r.b156.#a10;
  mark_test_run 2461;
  let test = eq r expected in
  if not test then failwithf "test 2461 failed";
  mark_test_run 2462;
  let test = sub_eq (get_idx_mut r ((.b156.#a10) : (t156, _) idx_mut)) next_r.b156.#a10 in
  if not test then failwithf "test 2462 failed";
  (* .b156.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b156 = #{ r.b156 with b10 = next_r.b156.#b10 } } in
  set_idx_mut r ((.b156.#b10) : (t156, _) idx_mut) next_r.b156.#b10;
  mark_test_run 2463;
  let test = eq r expected in
  if not test then failwithf "test 2463 failed";
  mark_test_run 2464;
  let test = sub_eq (get_idx_mut r ((.b156.#b10) : (t156, _) idx_mut)) next_r.b156.#b10 in
  if not test then failwithf "test 2464 failed";
  (************************************)
  (*   t157 = { float; #{ float } }   *)
  (************************************)
  let eq = (fun ({ a157 = a1571; b157 = b1571 } : t157) ({ a157 = a1572; b157 = b1572 } : t157) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1571 a1572 && (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) b1571 b1572) in
  let r = ({ a157 = 0.; b157 = (#{ a21 = 1. } : t21) } : t157) in
  (* Paths of depth 0 *)
  let next_r = ({ a157 = 100.; b157 = (#{ a21 = 101. } : t21) } : t157) in
  (* .a157 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a157 = next_r.a157 } in
  set_idx_mut r ((.a157) : (t157, _) idx_mut) (Float_u.of_float next_r.a157);
  mark_test_run 2465;
  let test = eq r expected in
  if not test then failwithf "test 2465 failed";
  mark_test_run 2466;
  let test = sub_eq (get_idx_mut r ((.a157) : (t157, _) idx_mut)) (Float_u.of_float next_r.a157) in
  if not test then failwithf "test 2466 failed";
  let r = ({ a157 = 0.; b157 = (#{ a21 = 1. } : t21) } : t157) in
  (* Paths of depth 0 *)
  let next_r = ({ a157 = 100.; b157 = (#{ a21 = 101. } : t21) } : t157) in
  (* .b157 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b157 = next_r.b157 } in
  set_idx_mut r ((.b157) : (t157, _) idx_mut) (Float_u.of_float next_r.b157.#a21);
  mark_test_run 2467;
  let test = eq r expected in
  if not test then failwithf "test 2467 failed";
  mark_test_run 2468;
  let test = sub_eq (get_idx_mut r ((.b157) : (t157, _) idx_mut)) (Float_u.of_float next_r.b157.#a21) in
  if not test then failwithf "test 2468 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a157 = 200.; b157 = (#{ a21 = 201. } : t21) } : t157) in
  (* .b157.#a21 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b157 = #{ r.b157 with a21 = next_r.b157.#a21 } } in
  set_idx_mut r ((.b157.#a21) : (t157, _) idx_mut) (Float_u.of_float next_r.b157.#a21);
  mark_test_run 2469;
  let test = eq r expected in
  if not test then failwithf "test 2469 failed";
  mark_test_run 2470;
  let test = sub_eq (get_idx_mut r ((.b157.#a21) : (t157, _) idx_mut)) (Float_u.of_float next_r.b157.#a21) in
  if not test then failwithf "test 2470 failed";
  (*****************************************)
  (*   t158 = { float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun ({ a158 = a1581; b158 = b1581 } : t158) ({ a158 = a1582; b158 = b1582 } : t158) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1581 a1582 && (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) b1581 b1582) in
  let r = ({ a158 = 0.; b158 = (#{ a23 = 1.; b23 = 2 } : t23) } : t158) in
  (* Paths of depth 0 *)
  let next_r = ({ a158 = 100.; b158 = (#{ a23 = 101.; b23 = 102 } : t23) } : t158) in
  (* .a158 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a158 = next_r.a158 } in
  set_idx_mut r ((.a158) : (t158, _) idx_mut) next_r.a158;
  mark_test_run 2471;
  let test = eq r expected in
  if not test then failwithf "test 2471 failed";
  mark_test_run 2472;
  let test = sub_eq (get_idx_mut r ((.a158) : (t158, _) idx_mut)) next_r.a158 in
  if not test then failwithf "test 2472 failed";
  let r = ({ a158 = 0.; b158 = (#{ a23 = 1.; b23 = 2 } : t23) } : t158) in
  (* Paths of depth 0 *)
  let next_r = ({ a158 = 100.; b158 = (#{ a23 = 101.; b23 = 102 } : t23) } : t158) in
  (* .b158 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with b158 = next_r.b158 } in
  set_idx_mut r ((.b158) : (t158, _) idx_mut) next_r.b158;
  mark_test_run 2473;
  let test = eq r expected in
  if not test then failwithf "test 2473 failed";
  mark_test_run 2474;
  let test = sub_eq (get_idx_mut r ((.b158) : (t158, _) idx_mut)) next_r.b158 in
  if not test then failwithf "test 2474 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a158 = 200.; b158 = (#{ a23 = 201.; b23 = 202 } : t23) } : t158) in
  (* .b158.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b158 = #{ r.b158 with a23 = next_r.b158.#a23 } } in
  set_idx_mut r ((.b158.#a23) : (t158, _) idx_mut) next_r.b158.#a23;
  mark_test_run 2475;
  let test = eq r expected in
  if not test then failwithf "test 2475 failed";
  mark_test_run 2476;
  let test = sub_eq (get_idx_mut r ((.b158.#a23) : (t158, _) idx_mut)) next_r.b158.#a23 in
  if not test then failwithf "test 2476 failed";
  (* .b158.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b158 = #{ r.b158 with b23 = next_r.b158.#b23 } } in
  set_idx_mut r ((.b158.#b23) : (t158, _) idx_mut) next_r.b158.#b23;
  mark_test_run 2477;
  let test = eq r expected in
  if not test then failwithf "test 2477 failed";
  mark_test_run 2478;
  let test = sub_eq (get_idx_mut r ((.b158.#b23) : (t158, _) idx_mut)) next_r.b158.#b23 in
  if not test then failwithf "test 2478 failed";
  (*******************************************)
  (*   t159 = { float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun ({ a159 = a1591; b159 = b1591 } : t159) ({ a159 = a1592; b159 = b1592 } : t159) -> (fun a b -> Float.equal (globalize a) (globalize b)) a1591 a1592 && (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) b1591 b1592) in
  let r = ({ a159 = 0.; b159 = (#{ a25 = 1.; b25 = 2. } : t25) } : t159) in
  (* Paths of depth 0 *)
  let next_r = ({ a159 = 100.; b159 = (#{ a25 = 101.; b25 = 102. } : t25) } : t159) in
  (* .a159 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a159 = next_r.a159 } in
  set_idx_mut r ((.a159) : (t159, _) idx_mut) next_r.a159;
  mark_test_run 2479;
  let test = eq r expected in
  if not test then failwithf "test 2479 failed";
  mark_test_run 2480;
  let test = sub_eq (get_idx_mut r ((.a159) : (t159, _) idx_mut)) next_r.a159 in
  if not test then failwithf "test 2480 failed";
  let r = ({ a159 = 0.; b159 = (#{ a25 = 1.; b25 = 2. } : t25) } : t159) in
  (* Paths of depth 0 *)
  let next_r = ({ a159 = 100.; b159 = (#{ a25 = 101.; b25 = 102. } : t25) } : t159) in
  (* .b159 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with b159 = next_r.b159 } in
  set_idx_mut r ((.b159) : (t159, _) idx_mut) next_r.b159;
  mark_test_run 2481;
  let test = eq r expected in
  if not test then failwithf "test 2481 failed";
  mark_test_run 2482;
  let test = sub_eq (get_idx_mut r ((.b159) : (t159, _) idx_mut)) next_r.b159 in
  if not test then failwithf "test 2482 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a159 = 200.; b159 = (#{ a25 = 201.; b25 = 202. } : t25) } : t159) in
  (* .b159.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b159 = #{ r.b159 with a25 = next_r.b159.#a25 } } in
  set_idx_mut r ((.b159.#a25) : (t159, _) idx_mut) next_r.b159.#a25;
  mark_test_run 2483;
  let test = eq r expected in
  if not test then failwithf "test 2483 failed";
  mark_test_run 2484;
  let test = sub_eq (get_idx_mut r ((.b159.#a25) : (t159, _) idx_mut)) next_r.b159.#a25 in
  if not test then failwithf "test 2484 failed";
  (* .b159.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b159 = #{ r.b159 with b25 = next_r.b159.#b25 } } in
  set_idx_mut r ((.b159.#b25) : (t159, _) idx_mut) next_r.b159.#b25;
  mark_test_run 2485;
  let test = eq r expected in
  if not test then failwithf "test 2485 failed";
  mark_test_run 2486;
  let test = sub_eq (get_idx_mut r ((.b159.#b25) : (t159, _) idx_mut)) next_r.b159.#b25 in
  if not test then failwithf "test 2486 failed";
  (***************************)
  (*   t160 = { #{ int } }   *)
  (***************************)
  let eq = (fun ({ a160 = a1601 } : t160) ({ a160 = a1602 } : t160) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1601 a1602) in
  let r = ({ a160 = (#{ a0 = 0 } : t0) } : t160) in
  (* Paths of depth 0 *)
  let next_r = ({ a160 = (#{ a0 = 100 } : t0) } : t160) in
  (* .a160 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a160 = next_r.a160 } in
  set_idx_mut r ((.a160) : (t160, _) idx_mut) next_r.a160;
  mark_test_run 2487;
  let test = eq r expected in
  if not test then failwithf "test 2487 failed";
  mark_test_run 2488;
  let test = sub_eq (get_idx_mut r ((.a160) : (t160, _) idx_mut)) next_r.a160 in
  if not test then failwithf "test 2488 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a160 = (#{ a0 = 200 } : t0) } : t160) in
  (* .a160.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a160 = #{ r.a160 with a0 = next_r.a160.#a0 } } in
  set_idx_mut r ((.a160.#a0) : (t160, _) idx_mut) next_r.a160.#a0;
  mark_test_run 2489;
  let test = eq r expected in
  if not test then failwithf "test 2489 failed";
  mark_test_run 2490;
  let test = sub_eq (get_idx_mut r ((.a160.#a0) : (t160, _) idx_mut)) next_r.a160.#a0 in
  if not test then failwithf "test 2490 failed";
  (********************************)
  (*   t161 = { #{ int }; int }   *)
  (********************************)
  let eq = (fun ({ a161 = a1611; b161 = b1611 } : t161) ({ a161 = a1612; b161 = b1612 } : t161) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1611 a1612 && (fun a b -> Int.equal a b) b1611 b1612) in
  let r = ({ a161 = (#{ a0 = 0 } : t0); b161 = 1 } : t161) in
  (* Paths of depth 0 *)
  let next_r = ({ a161 = (#{ a0 = 100 } : t0); b161 = 101 } : t161) in
  (* .a161 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a161 = next_r.a161 } in
  set_idx_mut r ((.a161) : (t161, _) idx_mut) next_r.a161;
  mark_test_run 2491;
  let test = eq r expected in
  if not test then failwithf "test 2491 failed";
  mark_test_run 2492;
  let test = sub_eq (get_idx_mut r ((.a161) : (t161, _) idx_mut)) next_r.a161 in
  if not test then failwithf "test 2492 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a161 = (#{ a0 = 200 } : t0); b161 = 201 } : t161) in
  (* .a161.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a161 = #{ r.a161 with a0 = next_r.a161.#a0 } } in
  set_idx_mut r ((.a161.#a0) : (t161, _) idx_mut) next_r.a161.#a0;
  mark_test_run 2493;
  let test = eq r expected in
  if not test then failwithf "test 2493 failed";
  mark_test_run 2494;
  let test = sub_eq (get_idx_mut r ((.a161.#a0) : (t161, _) idx_mut)) next_r.a161.#a0 in
  if not test then failwithf "test 2494 failed";
  let r = ({ a161 = (#{ a0 = 0 } : t0); b161 = 1 } : t161) in
  (* Paths of depth 0 *)
  let next_r = ({ a161 = (#{ a0 = 100 } : t0); b161 = 101 } : t161) in
  (* .b161 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b161 = next_r.b161 } in
  set_idx_mut r ((.b161) : (t161, _) idx_mut) next_r.b161;
  mark_test_run 2495;
  let test = eq r expected in
  if not test then failwithf "test 2495 failed";
  mark_test_run 2496;
  let test = sub_eq (get_idx_mut r ((.b161) : (t161, _) idx_mut)) next_r.b161 in
  if not test then failwithf "test 2496 failed";
  (***********************************)
  (*   t162 = { #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun ({ a162 = a1621; b162 = b1621 } : t162) ({ a162 = a1622; b162 = b1622 } : t162) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1621 a1622 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1621 b1622) in
  let r = ({ a162 = (#{ a0 = 0 } : t0); b162 = #1l } : t162) in
  (* Paths of depth 0 *)
  let next_r = ({ a162 = (#{ a0 = 100 } : t0); b162 = #101l } : t162) in
  (* .a162 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a162 = next_r.a162 } in
  set_idx_mut r ((.a162) : (t162, _) idx_mut) next_r.a162;
  mark_test_run 2497;
  let test = eq r expected in
  if not test then failwithf "test 2497 failed";
  mark_test_run 2498;
  let test = sub_eq (get_idx_mut r ((.a162) : (t162, _) idx_mut)) next_r.a162 in
  if not test then failwithf "test 2498 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a162 = (#{ a0 = 200 } : t0); b162 = #201l } : t162) in
  (* .a162.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a162 = #{ r.a162 with a0 = next_r.a162.#a0 } } in
  set_idx_mut r ((.a162.#a0) : (t162, _) idx_mut) next_r.a162.#a0;
  mark_test_run 2499;
  let test = eq r expected in
  if not test then failwithf "test 2499 failed";
  mark_test_run 2500;
  let test = sub_eq (get_idx_mut r ((.a162.#a0) : (t162, _) idx_mut)) next_r.a162.#a0 in
  if not test then failwithf "test 2500 failed";
  let r = ({ a162 = (#{ a0 = 0 } : t0); b162 = #1l } : t162) in
  (* Paths of depth 0 *)
  let next_r = ({ a162 = (#{ a0 = 100 } : t0); b162 = #101l } : t162) in
  (* .b162 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b162 = next_r.b162 } in
  set_idx_mut r ((.b162) : (t162, _) idx_mut) next_r.b162;
  mark_test_run 2501;
  let test = eq r expected in
  if not test then failwithf "test 2501 failed";
  mark_test_run 2502;
  let test = sub_eq (get_idx_mut r ((.b162) : (t162, _) idx_mut)) next_r.b162 in
  if not test then failwithf "test 2502 failed";
  (**********************************)
  (*   t163 = { #{ int }; float }   *)
  (**********************************)
  let eq = (fun ({ a163 = a1631; b163 = b1631 } : t163) ({ a163 = a1632; b163 = b1632 } : t163) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a1631 a1632 && (fun a b -> Float.equal (globalize a) (globalize b)) b1631 b1632) in
  let r = ({ a163 = (#{ a0 = 0 } : t0); b163 = 1. } : t163) in
  (* Paths of depth 0 *)
  let next_r = ({ a163 = (#{ a0 = 100 } : t0); b163 = 101. } : t163) in
  (* .a163 *)
  let sub_eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let expected = { r with a163 = next_r.a163 } in
  set_idx_mut r ((.a163) : (t163, _) idx_mut) next_r.a163;
  mark_test_run 2503;
  let test = eq r expected in
  if not test then failwithf "test 2503 failed";
  mark_test_run 2504;
  let test = sub_eq (get_idx_mut r ((.a163) : (t163, _) idx_mut)) next_r.a163 in
  if not test then failwithf "test 2504 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a163 = (#{ a0 = 200 } : t0); b163 = 201. } : t163) in
  (* .a163.#a0 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a163 = #{ r.a163 with a0 = next_r.a163.#a0 } } in
  set_idx_mut r ((.a163.#a0) : (t163, _) idx_mut) next_r.a163.#a0;
  mark_test_run 2505;
  let test = eq r expected in
  if not test then failwithf "test 2505 failed";
  mark_test_run 2506;
  let test = sub_eq (get_idx_mut r ((.a163.#a0) : (t163, _) idx_mut)) next_r.a163.#a0 in
  if not test then failwithf "test 2506 failed";
  let r = ({ a163 = (#{ a0 = 0 } : t0); b163 = 1. } : t163) in
  (* Paths of depth 0 *)
  let next_r = ({ a163 = (#{ a0 = 100 } : t0); b163 = 101. } : t163) in
  (* .b163 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b163 = next_r.b163 } in
  set_idx_mut r ((.b163) : (t163, _) idx_mut) next_r.b163;
  mark_test_run 2507;
  let test = eq r expected in
  if not test then failwithf "test 2507 failed";
  mark_test_run 2508;
  let test = sub_eq (get_idx_mut r ((.b163) : (t163, _) idx_mut)) next_r.b163 in
  if not test then failwithf "test 2508 failed";
  (********************************)
  (*   t164 = { #{ int; int } }   *)
  (********************************)
  let eq = (fun ({ a164 = a1641 } : t164) ({ a164 = a1642 } : t164) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1641 a1642) in
  let r = ({ a164 = (#{ a1 = 0; b1 = 1 } : t1) } : t164) in
  (* Paths of depth 0 *)
  let next_r = ({ a164 = (#{ a1 = 100; b1 = 101 } : t1) } : t164) in
  (* .a164 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a164 = next_r.a164 } in
  set_idx_mut r ((.a164) : (t164, _) idx_mut) next_r.a164;
  mark_test_run 2509;
  let test = eq r expected in
  if not test then failwithf "test 2509 failed";
  mark_test_run 2510;
  let test = sub_eq (get_idx_mut r ((.a164) : (t164, _) idx_mut)) next_r.a164 in
  if not test then failwithf "test 2510 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a164 = (#{ a1 = 200; b1 = 201 } : t1) } : t164) in
  (* .a164.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a164 = #{ r.a164 with a1 = next_r.a164.#a1 } } in
  set_idx_mut r ((.a164.#a1) : (t164, _) idx_mut) next_r.a164.#a1;
  mark_test_run 2511;
  let test = eq r expected in
  if not test then failwithf "test 2511 failed";
  mark_test_run 2512;
  let test = sub_eq (get_idx_mut r ((.a164.#a1) : (t164, _) idx_mut)) next_r.a164.#a1 in
  if not test then failwithf "test 2512 failed";
  (* .a164.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a164 = #{ r.a164 with b1 = next_r.a164.#b1 } } in
  set_idx_mut r ((.a164.#b1) : (t164, _) idx_mut) next_r.a164.#b1;
  mark_test_run 2513;
  let test = eq r expected in
  if not test then failwithf "test 2513 failed";
  mark_test_run 2514;
  let test = sub_eq (get_idx_mut r ((.a164.#b1) : (t164, _) idx_mut)) next_r.a164.#b1 in
  if not test then failwithf "test 2514 failed";
  (*************************************)
  (*   t165 = { #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun ({ a165 = a1651; b165 = b1651 } : t165) ({ a165 = a1652; b165 = b1652 } : t165) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1651 a1652 && (fun a b -> Int.equal a b) b1651 b1652) in
  let r = ({ a165 = (#{ a1 = 0; b1 = 1 } : t1); b165 = 2 } : t165) in
  (* Paths of depth 0 *)
  let next_r = ({ a165 = (#{ a1 = 100; b1 = 101 } : t1); b165 = 102 } : t165) in
  (* .a165 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a165 = next_r.a165 } in
  set_idx_mut r ((.a165) : (t165, _) idx_mut) next_r.a165;
  mark_test_run 2515;
  let test = eq r expected in
  if not test then failwithf "test 2515 failed";
  mark_test_run 2516;
  let test = sub_eq (get_idx_mut r ((.a165) : (t165, _) idx_mut)) next_r.a165 in
  if not test then failwithf "test 2516 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a165 = (#{ a1 = 200; b1 = 201 } : t1); b165 = 202 } : t165) in
  (* .a165.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a165 = #{ r.a165 with a1 = next_r.a165.#a1 } } in
  set_idx_mut r ((.a165.#a1) : (t165, _) idx_mut) next_r.a165.#a1;
  mark_test_run 2517;
  let test = eq r expected in
  if not test then failwithf "test 2517 failed";
  mark_test_run 2518;
  let test = sub_eq (get_idx_mut r ((.a165.#a1) : (t165, _) idx_mut)) next_r.a165.#a1 in
  if not test then failwithf "test 2518 failed";
  (* .a165.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a165 = #{ r.a165 with b1 = next_r.a165.#b1 } } in
  set_idx_mut r ((.a165.#b1) : (t165, _) idx_mut) next_r.a165.#b1;
  mark_test_run 2519;
  let test = eq r expected in
  if not test then failwithf "test 2519 failed";
  mark_test_run 2520;
  let test = sub_eq (get_idx_mut r ((.a165.#b1) : (t165, _) idx_mut)) next_r.a165.#b1 in
  if not test then failwithf "test 2520 failed";
  let r = ({ a165 = (#{ a1 = 0; b1 = 1 } : t1); b165 = 2 } : t165) in
  (* Paths of depth 0 *)
  let next_r = ({ a165 = (#{ a1 = 100; b1 = 101 } : t1); b165 = 102 } : t165) in
  (* .b165 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b165 = next_r.b165 } in
  set_idx_mut r ((.b165) : (t165, _) idx_mut) next_r.b165;
  mark_test_run 2521;
  let test = eq r expected in
  if not test then failwithf "test 2521 failed";
  mark_test_run 2522;
  let test = sub_eq (get_idx_mut r ((.b165) : (t165, _) idx_mut)) next_r.b165 in
  if not test then failwithf "test 2522 failed";
  (****************************************)
  (*   t166 = { #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun ({ a166 = a1661; b166 = b1661 } : t166) ({ a166 = a1662; b166 = b1662 } : t166) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1661 a1662 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1661 b1662) in
  let r = ({ a166 = (#{ a1 = 0; b1 = 1 } : t1); b166 = #2l } : t166) in
  (* Paths of depth 0 *)
  let next_r = ({ a166 = (#{ a1 = 100; b1 = 101 } : t1); b166 = #102l } : t166) in
  (* .a166 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a166 = next_r.a166 } in
  set_idx_mut r ((.a166) : (t166, _) idx_mut) next_r.a166;
  mark_test_run 2523;
  let test = eq r expected in
  if not test then failwithf "test 2523 failed";
  mark_test_run 2524;
  let test = sub_eq (get_idx_mut r ((.a166) : (t166, _) idx_mut)) next_r.a166 in
  if not test then failwithf "test 2524 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a166 = (#{ a1 = 200; b1 = 201 } : t1); b166 = #202l } : t166) in
  (* .a166.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a166 = #{ r.a166 with a1 = next_r.a166.#a1 } } in
  set_idx_mut r ((.a166.#a1) : (t166, _) idx_mut) next_r.a166.#a1;
  mark_test_run 2525;
  let test = eq r expected in
  if not test then failwithf "test 2525 failed";
  mark_test_run 2526;
  let test = sub_eq (get_idx_mut r ((.a166.#a1) : (t166, _) idx_mut)) next_r.a166.#a1 in
  if not test then failwithf "test 2526 failed";
  (* .a166.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a166 = #{ r.a166 with b1 = next_r.a166.#b1 } } in
  set_idx_mut r ((.a166.#b1) : (t166, _) idx_mut) next_r.a166.#b1;
  mark_test_run 2527;
  let test = eq r expected in
  if not test then failwithf "test 2527 failed";
  mark_test_run 2528;
  let test = sub_eq (get_idx_mut r ((.a166.#b1) : (t166, _) idx_mut)) next_r.a166.#b1 in
  if not test then failwithf "test 2528 failed";
  let r = ({ a166 = (#{ a1 = 0; b1 = 1 } : t1); b166 = #2l } : t166) in
  (* Paths of depth 0 *)
  let next_r = ({ a166 = (#{ a1 = 100; b1 = 101 } : t1); b166 = #102l } : t166) in
  (* .b166 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b166 = next_r.b166 } in
  set_idx_mut r ((.b166) : (t166, _) idx_mut) next_r.b166;
  mark_test_run 2529;
  let test = eq r expected in
  if not test then failwithf "test 2529 failed";
  mark_test_run 2530;
  let test = sub_eq (get_idx_mut r ((.b166) : (t166, _) idx_mut)) next_r.b166 in
  if not test then failwithf "test 2530 failed";
  (***************************************)
  (*   t167 = { #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun ({ a167 = a1671; b167 = b1671 } : t167) ({ a167 = a1672; b167 = b1672 } : t167) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a1671 a1672 && (fun a b -> Float.equal (globalize a) (globalize b)) b1671 b1672) in
  let r = ({ a167 = (#{ a1 = 0; b1 = 1 } : t1); b167 = 2. } : t167) in
  (* Paths of depth 0 *)
  let next_r = ({ a167 = (#{ a1 = 100; b1 = 101 } : t1); b167 = 102. } : t167) in
  (* .a167 *)
  let sub_eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let expected = { r with a167 = next_r.a167 } in
  set_idx_mut r ((.a167) : (t167, _) idx_mut) next_r.a167;
  mark_test_run 2531;
  let test = eq r expected in
  if not test then failwithf "test 2531 failed";
  mark_test_run 2532;
  let test = sub_eq (get_idx_mut r ((.a167) : (t167, _) idx_mut)) next_r.a167 in
  if not test then failwithf "test 2532 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a167 = (#{ a1 = 200; b1 = 201 } : t1); b167 = 202. } : t167) in
  (* .a167.#a1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a167 = #{ r.a167 with a1 = next_r.a167.#a1 } } in
  set_idx_mut r ((.a167.#a1) : (t167, _) idx_mut) next_r.a167.#a1;
  mark_test_run 2533;
  let test = eq r expected in
  if not test then failwithf "test 2533 failed";
  mark_test_run 2534;
  let test = sub_eq (get_idx_mut r ((.a167.#a1) : (t167, _) idx_mut)) next_r.a167.#a1 in
  if not test then failwithf "test 2534 failed";
  (* .a167.#b1 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a167 = #{ r.a167 with b1 = next_r.a167.#b1 } } in
  set_idx_mut r ((.a167.#b1) : (t167, _) idx_mut) next_r.a167.#b1;
  mark_test_run 2535;
  let test = eq r expected in
  if not test then failwithf "test 2535 failed";
  mark_test_run 2536;
  let test = sub_eq (get_idx_mut r ((.a167.#b1) : (t167, _) idx_mut)) next_r.a167.#b1 in
  if not test then failwithf "test 2536 failed";
  let r = ({ a167 = (#{ a1 = 0; b1 = 1 } : t1); b167 = 2. } : t167) in
  (* Paths of depth 0 *)
  let next_r = ({ a167 = (#{ a1 = 100; b1 = 101 } : t1); b167 = 102. } : t167) in
  (* .b167 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b167 = next_r.b167 } in
  set_idx_mut r ((.b167) : (t167, _) idx_mut) next_r.b167;
  mark_test_run 2537;
  let test = eq r expected in
  if not test then failwithf "test 2537 failed";
  mark_test_run 2538;
  let test = sub_eq (get_idx_mut r ((.b167) : (t167, _) idx_mut)) next_r.b167 in
  if not test then failwithf "test 2538 failed";
  (***********************************)
  (*   t168 = { #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun ({ a168 = a1681 } : t168) ({ a168 = a1682 } : t168) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a1681 a1682) in
  let r = ({ a168 = (#{ a7 = 0; b7 = #1l } : t7) } : t168) in
  (* Paths of depth 0 *)
  let next_r = ({ a168 = (#{ a7 = 100; b7 = #101l } : t7) } : t168) in
  (* .a168 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with a168 = next_r.a168 } in
  set_idx_mut r ((.a168) : (t168, _) idx_mut) next_r.a168;
  mark_test_run 2539;
  let test = eq r expected in
  if not test then failwithf "test 2539 failed";
  mark_test_run 2540;
  let test = sub_eq (get_idx_mut r ((.a168) : (t168, _) idx_mut)) next_r.a168 in
  if not test then failwithf "test 2540 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a168 = (#{ a7 = 200; b7 = #201l } : t7) } : t168) in
  (* .a168.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a168 = #{ r.a168 with a7 = next_r.a168.#a7 } } in
  set_idx_mut r ((.a168.#a7) : (t168, _) idx_mut) next_r.a168.#a7;
  mark_test_run 2541;
  let test = eq r expected in
  if not test then failwithf "test 2541 failed";
  mark_test_run 2542;
  let test = sub_eq (get_idx_mut r ((.a168.#a7) : (t168, _) idx_mut)) next_r.a168.#a7 in
  if not test then failwithf "test 2542 failed";
  (* .a168.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a168 = #{ r.a168 with b7 = next_r.a168.#b7 } } in
  set_idx_mut r ((.a168.#b7) : (t168, _) idx_mut) next_r.a168.#b7;
  mark_test_run 2543;
  let test = eq r expected in
  if not test then failwithf "test 2543 failed";
  mark_test_run 2544;
  let test = sub_eq (get_idx_mut r ((.a168.#b7) : (t168, _) idx_mut)) next_r.a168.#b7 in
  if not test then failwithf "test 2544 failed";
  (****************************************)
  (*   t169 = { #{ int; int32# }; int }   *)
  (****************************************)
  let eq = (fun ({ a169 = a1691; b169 = b1691 } : t169) ({ a169 = a1692; b169 = b1692 } : t169) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a1691 a1692 && (fun a b -> Int.equal a b) b1691 b1692) in
  let r = ({ a169 = (#{ a7 = 0; b7 = #1l } : t7); b169 = 2 } : t169) in
  (* Paths of depth 0 *)
  let next_r = ({ a169 = (#{ a7 = 100; b7 = #101l } : t7); b169 = 102 } : t169) in
  (* .a169 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with a169 = next_r.a169 } in
  set_idx_mut r ((.a169) : (t169, _) idx_mut) next_r.a169;
  mark_test_run 2545;
  let test = eq r expected in
  if not test then failwithf "test 2545 failed";
  mark_test_run 2546;
  let test = sub_eq (get_idx_mut r ((.a169) : (t169, _) idx_mut)) next_r.a169 in
  if not test then failwithf "test 2546 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a169 = (#{ a7 = 200; b7 = #201l } : t7); b169 = 202 } : t169) in
  (* .a169.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a169 = #{ r.a169 with a7 = next_r.a169.#a7 } } in
  set_idx_mut r ((.a169.#a7) : (t169, _) idx_mut) next_r.a169.#a7;
  mark_test_run 2547;
  let test = eq r expected in
  if not test then failwithf "test 2547 failed";
  mark_test_run 2548;
  let test = sub_eq (get_idx_mut r ((.a169.#a7) : (t169, _) idx_mut)) next_r.a169.#a7 in
  if not test then failwithf "test 2548 failed";
  (* .a169.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a169 = #{ r.a169 with b7 = next_r.a169.#b7 } } in
  set_idx_mut r ((.a169.#b7) : (t169, _) idx_mut) next_r.a169.#b7;
  mark_test_run 2549;
  let test = eq r expected in
  if not test then failwithf "test 2549 failed";
  mark_test_run 2550;
  let test = sub_eq (get_idx_mut r ((.a169.#b7) : (t169, _) idx_mut)) next_r.a169.#b7 in
  if not test then failwithf "test 2550 failed";
  let r = ({ a169 = (#{ a7 = 0; b7 = #1l } : t7); b169 = 2 } : t169) in
  (* Paths of depth 0 *)
  let next_r = ({ a169 = (#{ a7 = 100; b7 = #101l } : t7); b169 = 102 } : t169) in
  (* .b169 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b169 = next_r.b169 } in
  set_idx_mut r ((.b169) : (t169, _) idx_mut) next_r.b169;
  mark_test_run 2551;
  let test = eq r expected in
  if not test then failwithf "test 2551 failed";
  mark_test_run 2552;
  let test = sub_eq (get_idx_mut r ((.b169) : (t169, _) idx_mut)) next_r.b169 in
  if not test then failwithf "test 2552 failed";
  (*******************************************)
  (*   t170 = { #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun ({ a170 = a1701; b170 = b1701 } : t170) ({ a170 = a1702; b170 = b1702 } : t170) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) a1701 a1702 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1701 b1702) in
  let r = ({ a170 = (#{ a7 = 0; b7 = #1l } : t7); b170 = #2l } : t170) in
  (* Paths of depth 0 *)
  let next_r = ({ a170 = (#{ a7 = 100; b7 = #101l } : t7); b170 = #102l } : t170) in
  (* .a170 *)
  let sub_eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b71 b72) in
  let expected = { r with a170 = next_r.a170 } in
  set_idx_mut r ((.a170) : (t170, _) idx_mut) next_r.a170;
  mark_test_run 2553;
  let test = eq r expected in
  if not test then failwithf "test 2553 failed";
  mark_test_run 2554;
  let test = sub_eq (get_idx_mut r ((.a170) : (t170, _) idx_mut)) next_r.a170 in
  if not test then failwithf "test 2554 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a170 = (#{ a7 = 200; b7 = #201l } : t7); b170 = #202l } : t170) in
  (* .a170.#a7 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a170 = #{ r.a170 with a7 = next_r.a170.#a7 } } in
  set_idx_mut r ((.a170.#a7) : (t170, _) idx_mut) next_r.a170.#a7;
  mark_test_run 2555;
  let test = eq r expected in
  if not test then failwithf "test 2555 failed";
  mark_test_run 2556;
  let test = sub_eq (get_idx_mut r ((.a170.#a7) : (t170, _) idx_mut)) next_r.a170.#a7 in
  if not test then failwithf "test 2556 failed";
  (* .a170.#b7 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a170 = #{ r.a170 with b7 = next_r.a170.#b7 } } in
  set_idx_mut r ((.a170.#b7) : (t170, _) idx_mut) next_r.a170.#b7;
  mark_test_run 2557;
  let test = eq r expected in
  if not test then failwithf "test 2557 failed";
  mark_test_run 2558;
  let test = sub_eq (get_idx_mut r ((.a170.#b7) : (t170, _) idx_mut)) next_r.a170.#b7 in
  if not test then failwithf "test 2558 failed";
  let r = ({ a170 = (#{ a7 = 0; b7 = #1l } : t7); b170 = #2l } : t170) in
  (* Paths of depth 0 *)
  let next_r = ({ a170 = (#{ a7 = 100; b7 = #101l } : t7); b170 = #102l } : t170) in
  (* .b170 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b170 = next_r.b170 } in
  set_idx_mut r ((.b170) : (t170, _) idx_mut) next_r.b170;
  mark_test_run 2559;
  let test = eq r expected in
  if not test then failwithf "test 2559 failed";
  mark_test_run 2560;
  let test = sub_eq (get_idx_mut r ((.b170) : (t170, _) idx_mut)) next_r.b170 in
  if not test then failwithf "test 2560 failed";
  (**********************************)
  (*   t171 = { #{ int; float } }   *)
  (**********************************)
  let eq = (fun ({ a171 = a1711 } : t171) ({ a171 = a1712 } : t171) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1711 a1712) in
  let r = ({ a171 = (#{ a10 = 0; b10 = 1. } : t10) } : t171) in
  (* Paths of depth 0 *)
  let next_r = ({ a171 = (#{ a10 = 100; b10 = 101. } : t10) } : t171) in
  (* .a171 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with a171 = next_r.a171 } in
  set_idx_mut r ((.a171) : (t171, _) idx_mut) next_r.a171;
  mark_test_run 2561;
  let test = eq r expected in
  if not test then failwithf "test 2561 failed";
  mark_test_run 2562;
  let test = sub_eq (get_idx_mut r ((.a171) : (t171, _) idx_mut)) next_r.a171 in
  if not test then failwithf "test 2562 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a171 = (#{ a10 = 200; b10 = 201. } : t10) } : t171) in
  (* .a171.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a171 = #{ r.a171 with a10 = next_r.a171.#a10 } } in
  set_idx_mut r ((.a171.#a10) : (t171, _) idx_mut) next_r.a171.#a10;
  mark_test_run 2563;
  let test = eq r expected in
  if not test then failwithf "test 2563 failed";
  mark_test_run 2564;
  let test = sub_eq (get_idx_mut r ((.a171.#a10) : (t171, _) idx_mut)) next_r.a171.#a10 in
  if not test then failwithf "test 2564 failed";
  (* .a171.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a171 = #{ r.a171 with b10 = next_r.a171.#b10 } } in
  set_idx_mut r ((.a171.#b10) : (t171, _) idx_mut) next_r.a171.#b10;
  mark_test_run 2565;
  let test = eq r expected in
  if not test then failwithf "test 2565 failed";
  mark_test_run 2566;
  let test = sub_eq (get_idx_mut r ((.a171.#b10) : (t171, _) idx_mut)) next_r.a171.#b10 in
  if not test then failwithf "test 2566 failed";
  (***************************************)
  (*   t172 = { #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun ({ a172 = a1721; b172 = b1721 } : t172) ({ a172 = a1722; b172 = b1722 } : t172) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1721 a1722 && (fun a b -> Int.equal a b) b1721 b1722) in
  let r = ({ a172 = (#{ a10 = 0; b10 = 1. } : t10); b172 = 2 } : t172) in
  (* Paths of depth 0 *)
  let next_r = ({ a172 = (#{ a10 = 100; b10 = 101. } : t10); b172 = 102 } : t172) in
  (* .a172 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with a172 = next_r.a172 } in
  set_idx_mut r ((.a172) : (t172, _) idx_mut) next_r.a172;
  mark_test_run 2567;
  let test = eq r expected in
  if not test then failwithf "test 2567 failed";
  mark_test_run 2568;
  let test = sub_eq (get_idx_mut r ((.a172) : (t172, _) idx_mut)) next_r.a172 in
  if not test then failwithf "test 2568 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a172 = (#{ a10 = 200; b10 = 201. } : t10); b172 = 202 } : t172) in
  (* .a172.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a172 = #{ r.a172 with a10 = next_r.a172.#a10 } } in
  set_idx_mut r ((.a172.#a10) : (t172, _) idx_mut) next_r.a172.#a10;
  mark_test_run 2569;
  let test = eq r expected in
  if not test then failwithf "test 2569 failed";
  mark_test_run 2570;
  let test = sub_eq (get_idx_mut r ((.a172.#a10) : (t172, _) idx_mut)) next_r.a172.#a10 in
  if not test then failwithf "test 2570 failed";
  (* .a172.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a172 = #{ r.a172 with b10 = next_r.a172.#b10 } } in
  set_idx_mut r ((.a172.#b10) : (t172, _) idx_mut) next_r.a172.#b10;
  mark_test_run 2571;
  let test = eq r expected in
  if not test then failwithf "test 2571 failed";
  mark_test_run 2572;
  let test = sub_eq (get_idx_mut r ((.a172.#b10) : (t172, _) idx_mut)) next_r.a172.#b10 in
  if not test then failwithf "test 2572 failed";
  let r = ({ a172 = (#{ a10 = 0; b10 = 1. } : t10); b172 = 2 } : t172) in
  (* Paths of depth 0 *)
  let next_r = ({ a172 = (#{ a10 = 100; b10 = 101. } : t10); b172 = 102 } : t172) in
  (* .b172 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b172 = next_r.b172 } in
  set_idx_mut r ((.b172) : (t172, _) idx_mut) next_r.b172;
  mark_test_run 2573;
  let test = eq r expected in
  if not test then failwithf "test 2573 failed";
  mark_test_run 2574;
  let test = sub_eq (get_idx_mut r ((.b172) : (t172, _) idx_mut)) next_r.b172 in
  if not test then failwithf "test 2574 failed";
  (*****************************************)
  (*   t173 = { #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun ({ a173 = a1731; b173 = b1731 } : t173) ({ a173 = a1732; b173 = b1732 } : t173) -> (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) a1731 a1732 && (fun a b -> Float.equal (globalize a) (globalize b)) b1731 b1732) in
  let r = ({ a173 = (#{ a10 = 0; b10 = 1. } : t10); b173 = 2. } : t173) in
  (* Paths of depth 0 *)
  let next_r = ({ a173 = (#{ a10 = 100; b10 = 101. } : t10); b173 = 102. } : t173) in
  (* .a173 *)
  let sub_eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun a b -> Float.equal (globalize a) (globalize b)) b101 b102) in
  let expected = { r with a173 = next_r.a173 } in
  set_idx_mut r ((.a173) : (t173, _) idx_mut) next_r.a173;
  mark_test_run 2575;
  let test = eq r expected in
  if not test then failwithf "test 2575 failed";
  mark_test_run 2576;
  let test = sub_eq (get_idx_mut r ((.a173) : (t173, _) idx_mut)) next_r.a173 in
  if not test then failwithf "test 2576 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a173 = (#{ a10 = 200; b10 = 201. } : t10); b173 = 202. } : t173) in
  (* .a173.#a10 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a173 = #{ r.a173 with a10 = next_r.a173.#a10 } } in
  set_idx_mut r ((.a173.#a10) : (t173, _) idx_mut) next_r.a173.#a10;
  mark_test_run 2577;
  let test = eq r expected in
  if not test then failwithf "test 2577 failed";
  mark_test_run 2578;
  let test = sub_eq (get_idx_mut r ((.a173.#a10) : (t173, _) idx_mut)) next_r.a173.#a10 in
  if not test then failwithf "test 2578 failed";
  (* .a173.#b10 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a173 = #{ r.a173 with b10 = next_r.a173.#b10 } } in
  set_idx_mut r ((.a173.#b10) : (t173, _) idx_mut) next_r.a173.#b10;
  mark_test_run 2579;
  let test = eq r expected in
  if not test then failwithf "test 2579 failed";
  mark_test_run 2580;
  let test = sub_eq (get_idx_mut r ((.a173.#b10) : (t173, _) idx_mut)) next_r.a173.#b10 in
  if not test then failwithf "test 2580 failed";
  let r = ({ a173 = (#{ a10 = 0; b10 = 1. } : t10); b173 = 2. } : t173) in
  (* Paths of depth 0 *)
  let next_r = ({ a173 = (#{ a10 = 100; b10 = 101. } : t10); b173 = 102. } : t173) in
  (* .b173 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b173 = next_r.b173 } in
  set_idx_mut r ((.b173) : (t173, _) idx_mut) next_r.b173;
  mark_test_run 2581;
  let test = eq r expected in
  if not test then failwithf "test 2581 failed";
  mark_test_run 2582;
  let test = sub_eq (get_idx_mut r ((.b173) : (t173, _) idx_mut)) next_r.b173 in
  if not test then failwithf "test 2582 failed";
  (**********************************************************)
  (*   t176 = { #{ int64; int64# }; #{ int64#; float# } }   *)
  (**********************************************************)
  let eq = (fun ({ a176 = a1761; b176 = b1761 } : t176) ({ a176 = a1762; b176 = b1762 } : t176) -> (fun (#{ a174 = a1741; b174 = b1741 } : t174) (#{ a174 = a1742; b174 = b1742 } : t174) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1741 a1742 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1741 b1742) a1761 a1762 && (fun (#{ a175 = a1751; b175 = b1751 } : t175) (#{ a175 = a1752; b175 = b1752 } : t175) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1751 a1752 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1751 b1752) b1761 b1762) in
  let r = ({ a176 = (#{ a174 = 0L; b174 = #1L } : t174); b176 = (#{ a175 = #2L; b175 = #3. } : t175) } : t176) in
  (* Paths of depth 0 *)
  let next_r = ({ a176 = (#{ a174 = 100L; b174 = #101L } : t174); b176 = (#{ a175 = #102L; b175 = #103. } : t175) } : t176) in
  (* .a176 *)
  let sub_eq = (fun (#{ a174 = a1741; b174 = b1741 } : t174) (#{ a174 = a1742; b174 = b1742 } : t174) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1741 a1742 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b1741 b1742) in
  let expected = { r with a176 = next_r.a176 } in
  set_idx_mut r ((.a176) : (t176, _) idx_mut) next_r.a176;
  mark_test_run 2583;
  let test = eq r expected in
  if not test then failwithf "test 2583 failed";
  mark_test_run 2584;
  let test = sub_eq (get_idx_mut r ((.a176) : (t176, _) idx_mut)) next_r.a176 in
  if not test then failwithf "test 2584 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a176 = (#{ a174 = 200L; b174 = #201L } : t174); b176 = (#{ a175 = #202L; b175 = #203. } : t175) } : t176) in
  (* .a176.#a174 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a176 = #{ r.a176 with a174 = next_r.a176.#a174 } } in
  set_idx_mut r ((.a176.#a174) : (t176, _) idx_mut) next_r.a176.#a174;
  mark_test_run 2585;
  let test = eq r expected in
  if not test then failwithf "test 2585 failed";
  mark_test_run 2586;
  let test = sub_eq (get_idx_mut r ((.a176.#a174) : (t176, _) idx_mut)) next_r.a176.#a174 in
  if not test then failwithf "test 2586 failed";
  (* .a176.#b174 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a176 = #{ r.a176 with b174 = next_r.a176.#b174 } } in
  set_idx_mut r ((.a176.#b174) : (t176, _) idx_mut) next_r.a176.#b174;
  mark_test_run 2587;
  let test = eq r expected in
  if not test then failwithf "test 2587 failed";
  mark_test_run 2588;
  let test = sub_eq (get_idx_mut r ((.a176.#b174) : (t176, _) idx_mut)) next_r.a176.#b174 in
  if not test then failwithf "test 2588 failed";
  let r = ({ a176 = (#{ a174 = 0L; b174 = #1L } : t174); b176 = (#{ a175 = #2L; b175 = #3. } : t175) } : t176) in
  (* Paths of depth 0 *)
  let next_r = ({ a176 = (#{ a174 = 100L; b174 = #101L } : t174); b176 = (#{ a175 = #102L; b175 = #103. } : t175) } : t176) in
  (* .b176 *)
  let sub_eq = (fun (#{ a175 = a1751; b175 = b1751 } : t175) (#{ a175 = a1752; b175 = b1752 } : t175) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1751 a1752 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1751 b1752) in
  let expected = { r with b176 = next_r.b176 } in
  set_idx_mut r ((.b176) : (t176, _) idx_mut) next_r.b176;
  mark_test_run 2589;
  let test = eq r expected in
  if not test then failwithf "test 2589 failed";
  mark_test_run 2590;
  let test = sub_eq (get_idx_mut r ((.b176) : (t176, _) idx_mut)) next_r.b176 in
  if not test then failwithf "test 2590 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a176 = (#{ a174 = 200L; b174 = #201L } : t174); b176 = (#{ a175 = #202L; b175 = #203. } : t175) } : t176) in
  (* .b176.#a175 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b176 = #{ r.b176 with a175 = next_r.b176.#a175 } } in
  set_idx_mut r ((.b176.#a175) : (t176, _) idx_mut) next_r.b176.#a175;
  mark_test_run 2591;
  let test = eq r expected in
  if not test then failwithf "test 2591 failed";
  mark_test_run 2592;
  let test = sub_eq (get_idx_mut r ((.b176.#a175) : (t176, _) idx_mut)) next_r.b176.#a175 in
  if not test then failwithf "test 2592 failed";
  (* .b176.#b175 *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b176 = #{ r.b176 with b175 = next_r.b176.#b175 } } in
  set_idx_mut r ((.b176.#b175) : (t176, _) idx_mut) next_r.b176.#b175;
  mark_test_run 2593;
  let test = eq r expected in
  if not test then failwithf "test 2593 failed";
  mark_test_run 2594;
  let test = sub_eq (get_idx_mut r ((.b176.#b175) : (t176, _) idx_mut)) next_r.b176.#b175 in
  if not test then failwithf "test 2594 failed";
  (**********************************************************)
  (*   t179 = { #{ int64; string }; #{ int64#; string } }   *)
  (**********************************************************)
  let eq = (fun ({ a179 = a1791; b179 = b1791 } : t179) ({ a179 = a1792; b179 = b1792 } : t179) -> (fun (#{ a177 = a1771; b177 = b1771 } : t177) (#{ a177 = a1772; b177 = b1772 } : t177) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1771 a1772 && (fun a b -> String.equal (globalize a) (globalize b)) b1771 b1772) a1791 a1792 && (fun (#{ a178 = a1781; b178 = b1781 } : t178) (#{ a178 = a1782; b178 = b1782 } : t178) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1781 a1782 && (fun a b -> String.equal (globalize a) (globalize b)) b1781 b1782) b1791 b1792) in
  let r = ({ a179 = (#{ a177 = 0L; b177 = "1" } : t177); b179 = (#{ a178 = #2L; b178 = "3" } : t178) } : t179) in
  (* Paths of depth 0 *)
  let next_r = ({ a179 = (#{ a177 = 100L; b177 = "101" } : t177); b179 = (#{ a178 = #102L; b178 = "103" } : t178) } : t179) in
  (* .a179 *)
  let sub_eq = (fun (#{ a177 = a1771; b177 = b1771 } : t177) (#{ a177 = a1772; b177 = b1772 } : t177) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a1771 a1772 && (fun a b -> String.equal (globalize a) (globalize b)) b1771 b1772) in
  let expected = { r with a179 = next_r.a179 } in
  set_idx_mut r ((.a179) : (t179, _) idx_mut) next_r.a179;
  mark_test_run 2595;
  let test = eq r expected in
  if not test then failwithf "test 2595 failed";
  mark_test_run 2596;
  let test = sub_eq (get_idx_mut r ((.a179) : (t179, _) idx_mut)) next_r.a179 in
  if not test then failwithf "test 2596 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a179 = (#{ a177 = 200L; b177 = "201" } : t177); b179 = (#{ a178 = #202L; b178 = "203" } : t178) } : t179) in
  (* .a179.#a177 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a179 = #{ r.a179 with a177 = next_r.a179.#a177 } } in
  set_idx_mut r ((.a179.#a177) : (t179, _) idx_mut) next_r.a179.#a177;
  mark_test_run 2597;
  let test = eq r expected in
  if not test then failwithf "test 2597 failed";
  mark_test_run 2598;
  let test = sub_eq (get_idx_mut r ((.a179.#a177) : (t179, _) idx_mut)) next_r.a179.#a177 in
  if not test then failwithf "test 2598 failed";
  (* .a179.#b177 *)
  let sub_eq = (fun a b -> String.equal (globalize a) (globalize b)) in
  let expected = { r with a179 = #{ r.a179 with b177 = next_r.a179.#b177 } } in
  set_idx_mut r ((.a179.#b177) : (t179, _) idx_mut) next_r.a179.#b177;
  mark_test_run 2599;
  let test = eq r expected in
  if not test then failwithf "test 2599 failed";
  mark_test_run 2600;
  let test = sub_eq (get_idx_mut r ((.a179.#b177) : (t179, _) idx_mut)) next_r.a179.#b177 in
  if not test then failwithf "test 2600 failed";
  let r = ({ a179 = (#{ a177 = 0L; b177 = "1" } : t177); b179 = (#{ a178 = #2L; b178 = "3" } : t178) } : t179) in
  (* Paths of depth 0 *)
  let next_r = ({ a179 = (#{ a177 = 100L; b177 = "101" } : t177); b179 = (#{ a178 = #102L; b178 = "103" } : t178) } : t179) in
  (* .b179 *)
  let sub_eq = (fun (#{ a178 = a1781; b178 = b1781 } : t178) (#{ a178 = a1782; b178 = b1782 } : t178) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1781 a1782 && (fun a b -> String.equal (globalize a) (globalize b)) b1781 b1782) in
  let expected = { r with b179 = next_r.b179 } in
  set_idx_mut r ((.b179) : (t179, _) idx_mut) next_r.b179;
  mark_test_run 2601;
  let test = eq r expected in
  if not test then failwithf "test 2601 failed";
  mark_test_run 2602;
  let test = sub_eq (get_idx_mut r ((.b179) : (t179, _) idx_mut)) next_r.b179 in
  if not test then failwithf "test 2602 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a179 = (#{ a177 = 200L; b177 = "201" } : t177); b179 = (#{ a178 = #202L; b178 = "203" } : t178) } : t179) in
  (* .b179.#a178 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b179 = #{ r.b179 with a178 = next_r.b179.#a178 } } in
  set_idx_mut r ((.b179.#a178) : (t179, _) idx_mut) next_r.b179.#a178;
  mark_test_run 2603;
  let test = eq r expected in
  if not test then failwithf "test 2603 failed";
  mark_test_run 2604;
  let test = sub_eq (get_idx_mut r ((.b179.#a178) : (t179, _) idx_mut)) next_r.b179.#a178 in
  if not test then failwithf "test 2604 failed";
  (* .b179.#b178 *)
  let sub_eq = (fun a b -> String.equal (globalize a) (globalize b)) in
  let expected = { r with b179 = #{ r.b179 with b178 = next_r.b179.#b178 } } in
  set_idx_mut r ((.b179.#b178) : (t179, _) idx_mut) next_r.b179.#b178;
  mark_test_run 2605;
  let test = eq r expected in
  if not test then failwithf "test 2605 failed";
  mark_test_run 2606;
  let test = sub_eq (get_idx_mut r ((.b179.#b178) : (t179, _) idx_mut)) next_r.b179.#b178 in
  if not test then failwithf "test 2606 failed";
  (********************************************************)
  (*   t181 = { #{ int64#; int64 }; #{ int64; int64 } }   *)
  (********************************************************)
  let eq = (fun ({ a181 = a1811; b181 = b1811 } : t181) ({ a181 = a1812; b181 = b1812 } : t181) -> (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) a1811 a1812 && (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) b1811 b1812) in
  let r = ({ a181 = (#{ a180 = #0L; b180 = 1L } : t180); b181 = (#{ a29 = 2L; b29 = 3L } : t29) } : t181) in
  (* Paths of depth 0 *)
  let next_r = ({ a181 = (#{ a180 = #100L; b180 = 101L } : t180); b181 = (#{ a29 = 102L; b29 = 103L } : t29) } : t181) in
  (* .a181 *)
  let sub_eq = (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) in
  let expected = { r with a181 = next_r.a181 } in
  set_idx_mut r ((.a181) : (t181, _) idx_mut) next_r.a181;
  mark_test_run 2607;
  let test = eq r expected in
  if not test then failwithf "test 2607 failed";
  mark_test_run 2608;
  let test = sub_eq (get_idx_mut r ((.a181) : (t181, _) idx_mut)) next_r.a181 in
  if not test then failwithf "test 2608 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a181 = (#{ a180 = #200L; b180 = 201L } : t180); b181 = (#{ a29 = 202L; b29 = 203L } : t29) } : t181) in
  (* .a181.#a180 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a181 = #{ r.a181 with a180 = next_r.a181.#a180 } } in
  set_idx_mut r ((.a181.#a180) : (t181, _) idx_mut) next_r.a181.#a180;
  mark_test_run 2609;
  let test = eq r expected in
  if not test then failwithf "test 2609 failed";
  mark_test_run 2610;
  let test = sub_eq (get_idx_mut r ((.a181.#a180) : (t181, _) idx_mut)) next_r.a181.#a180 in
  if not test then failwithf "test 2610 failed";
  (* .a181.#b180 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a181 = #{ r.a181 with b180 = next_r.a181.#b180 } } in
  set_idx_mut r ((.a181.#b180) : (t181, _) idx_mut) next_r.a181.#b180;
  mark_test_run 2611;
  let test = eq r expected in
  if not test then failwithf "test 2611 failed";
  mark_test_run 2612;
  let test = sub_eq (get_idx_mut r ((.a181.#b180) : (t181, _) idx_mut)) next_r.a181.#b180 in
  if not test then failwithf "test 2612 failed";
  let r = ({ a181 = (#{ a180 = #0L; b180 = 1L } : t180); b181 = (#{ a29 = 2L; b29 = 3L } : t29) } : t181) in
  (* Paths of depth 0 *)
  let next_r = ({ a181 = (#{ a180 = #100L; b180 = 101L } : t180); b181 = (#{ a29 = 102L; b29 = 103L } : t29) } : t181) in
  (* .b181 *)
  let sub_eq = (fun (#{ a29 = a291; b29 = b291 } : t29) (#{ a29 = a292; b29 = b292 } : t29) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a291 a292 && (fun a b -> Int64.equal (globalize a) (globalize b)) b291 b292) in
  let expected = { r with b181 = next_r.b181 } in
  set_idx_mut r ((.b181) : (t181, _) idx_mut) next_r.b181;
  mark_test_run 2613;
  let test = eq r expected in
  if not test then failwithf "test 2613 failed";
  mark_test_run 2614;
  let test = sub_eq (get_idx_mut r ((.b181) : (t181, _) idx_mut)) next_r.b181 in
  if not test then failwithf "test 2614 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a181 = (#{ a180 = #200L; b180 = 201L } : t180); b181 = (#{ a29 = 202L; b29 = 203L } : t29) } : t181) in
  (* .b181.#a29 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b181 = #{ r.b181 with a29 = next_r.b181.#a29 } } in
  set_idx_mut r ((.b181.#a29) : (t181, _) idx_mut) next_r.b181.#a29;
  mark_test_run 2615;
  let test = eq r expected in
  if not test then failwithf "test 2615 failed";
  mark_test_run 2616;
  let test = sub_eq (get_idx_mut r ((.b181.#a29) : (t181, _) idx_mut)) next_r.b181.#a29 in
  if not test then failwithf "test 2616 failed";
  (* .b181.#b29 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with b181 = #{ r.b181 with b29 = next_r.b181.#b29 } } in
  set_idx_mut r ((.b181.#b29) : (t181, _) idx_mut) next_r.b181.#b29;
  mark_test_run 2617;
  let test = eq r expected in
  if not test then failwithf "test 2617 failed";
  mark_test_run 2618;
  let test = sub_eq (get_idx_mut r ((.b181.#b29) : (t181, _) idx_mut)) next_r.b181.#b29 in
  if not test then failwithf "test 2618 failed";
  (***********************************************************)
  (*   t183 = { #{ int64#; int64 }; #{ float32#; float } }   *)
  (***********************************************************)
  let eq = (fun ({ a183 = a1831; b183 = b1831 } : t183) ({ a183 = a1832; b183 = b1832 } : t183) -> (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) a1831 a1832 && (fun (#{ a182 = a1821; b182 = b1821 } : t182) (#{ a182 = a1822; b182 = b1822 } : t182) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a1821 a1822 && (fun a b -> Float.equal (globalize a) (globalize b)) b1821 b1822) b1831 b1832) in
  let r = ({ a183 = (#{ a180 = #0L; b180 = 1L } : t180); b183 = (#{ a182 = #2.s; b182 = 3. } : t182) } : t183) in
  (* Paths of depth 0 *)
  let next_r = ({ a183 = (#{ a180 = #100L; b180 = 101L } : t180); b183 = (#{ a182 = #102.s; b182 = 103. } : t182) } : t183) in
  (* .a183 *)
  let sub_eq = (fun (#{ a180 = a1801; b180 = b1801 } : t180) (#{ a180 = a1802; b180 = b1802 } : t180) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1801 a1802 && (fun a b -> Int64.equal (globalize a) (globalize b)) b1801 b1802) in
  let expected = { r with a183 = next_r.a183 } in
  set_idx_mut r ((.a183) : (t183, _) idx_mut) next_r.a183;
  mark_test_run 2619;
  let test = eq r expected in
  if not test then failwithf "test 2619 failed";
  mark_test_run 2620;
  let test = sub_eq (get_idx_mut r ((.a183) : (t183, _) idx_mut)) next_r.a183 in
  if not test then failwithf "test 2620 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a183 = (#{ a180 = #200L; b180 = 201L } : t180); b183 = (#{ a182 = #202.s; b182 = 203. } : t182) } : t183) in
  (* .a183.#a180 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a183 = #{ r.a183 with a180 = next_r.a183.#a180 } } in
  set_idx_mut r ((.a183.#a180) : (t183, _) idx_mut) next_r.a183.#a180;
  mark_test_run 2621;
  let test = eq r expected in
  if not test then failwithf "test 2621 failed";
  mark_test_run 2622;
  let test = sub_eq (get_idx_mut r ((.a183.#a180) : (t183, _) idx_mut)) next_r.a183.#a180 in
  if not test then failwithf "test 2622 failed";
  (* .a183.#b180 *)
  let sub_eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let expected = { r with a183 = #{ r.a183 with b180 = next_r.a183.#b180 } } in
  set_idx_mut r ((.a183.#b180) : (t183, _) idx_mut) next_r.a183.#b180;
  mark_test_run 2623;
  let test = eq r expected in
  if not test then failwithf "test 2623 failed";
  mark_test_run 2624;
  let test = sub_eq (get_idx_mut r ((.a183.#b180) : (t183, _) idx_mut)) next_r.a183.#b180 in
  if not test then failwithf "test 2624 failed";
  let r = ({ a183 = (#{ a180 = #0L; b180 = 1L } : t180); b183 = (#{ a182 = #2.s; b182 = 3. } : t182) } : t183) in
  (* Paths of depth 0 *)
  let next_r = ({ a183 = (#{ a180 = #100L; b180 = 101L } : t180); b183 = (#{ a182 = #102.s; b182 = 103. } : t182) } : t183) in
  (* .b183 *)
  let sub_eq = (fun (#{ a182 = a1821; b182 = b1821 } : t182) (#{ a182 = a1822; b182 = b1822 } : t182) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a1821 a1822 && (fun a b -> Float.equal (globalize a) (globalize b)) b1821 b1822) in
  let expected = { r with b183 = next_r.b183 } in
  set_idx_mut r ((.b183) : (t183, _) idx_mut) next_r.b183;
  mark_test_run 2625;
  let test = eq r expected in
  if not test then failwithf "test 2625 failed";
  mark_test_run 2626;
  let test = sub_eq (get_idx_mut r ((.b183) : (t183, _) idx_mut)) next_r.b183 in
  if not test then failwithf "test 2626 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a183 = (#{ a180 = #200L; b180 = 201L } : t180); b183 = (#{ a182 = #202.s; b182 = 203. } : t182) } : t183) in
  (* .b183.#a182 *)
  let sub_eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let expected = { r with b183 = #{ r.b183 with a182 = next_r.b183.#a182 } } in
  set_idx_mut r ((.b183.#a182) : (t183, _) idx_mut) next_r.b183.#a182;
  mark_test_run 2627;
  let test = eq r expected in
  if not test then failwithf "test 2627 failed";
  mark_test_run 2628;
  let test = sub_eq (get_idx_mut r ((.b183.#a182) : (t183, _) idx_mut)) next_r.b183.#a182 in
  if not test then failwithf "test 2628 failed";
  (* .b183.#b182 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b183 = #{ r.b183 with b182 = next_r.b183.#b182 } } in
  set_idx_mut r ((.b183.#b182) : (t183, _) idx_mut) next_r.b183.#b182;
  mark_test_run 2629;
  let test = eq r expected in
  if not test then failwithf "test 2629 failed";
  mark_test_run 2630;
  let test = sub_eq (get_idx_mut r ((.b183.#b182) : (t183, _) idx_mut)) next_r.b183.#b182 in
  if not test then failwithf "test 2630 failed";
  (******************************)
  (*   t184 = { #{ int32# } }   *)
  (******************************)
  let eq = (fun ({ a184 = a1841 } : t184) ({ a184 = a1842 } : t184) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a1841 a1842) in
  let r = ({ a184 = (#{ a17 = #0l } : t17) } : t184) in
  (* Paths of depth 0 *)
  let next_r = ({ a184 = (#{ a17 = #100l } : t17) } : t184) in
  (* .a184 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with a184 = next_r.a184 } in
  set_idx_mut r ((.a184) : (t184, _) idx_mut) next_r.a184;
  mark_test_run 2631;
  let test = eq r expected in
  if not test then failwithf "test 2631 failed";
  mark_test_run 2632;
  let test = sub_eq (get_idx_mut r ((.a184) : (t184, _) idx_mut)) next_r.a184 in
  if not test then failwithf "test 2632 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a184 = (#{ a17 = #200l } : t17) } : t184) in
  (* .a184.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a184 = #{ r.a184 with a17 = next_r.a184.#a17 } } in
  set_idx_mut r ((.a184.#a17) : (t184, _) idx_mut) next_r.a184.#a17;
  mark_test_run 2633;
  let test = eq r expected in
  if not test then failwithf "test 2633 failed";
  mark_test_run 2634;
  let test = sub_eq (get_idx_mut r ((.a184.#a17) : (t184, _) idx_mut)) next_r.a184.#a17 in
  if not test then failwithf "test 2634 failed";
  (***********************************)
  (*   t185 = { #{ int32# }; int }   *)
  (***********************************)
  let eq = (fun ({ a185 = a1851; b185 = b1851 } : t185) ({ a185 = a1852; b185 = b1852 } : t185) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a1851 a1852 && (fun a b -> Int.equal a b) b1851 b1852) in
  let r = ({ a185 = (#{ a17 = #0l } : t17); b185 = 1 } : t185) in
  (* Paths of depth 0 *)
  let next_r = ({ a185 = (#{ a17 = #100l } : t17); b185 = 101 } : t185) in
  (* .a185 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with a185 = next_r.a185 } in
  set_idx_mut r ((.a185) : (t185, _) idx_mut) next_r.a185;
  mark_test_run 2635;
  let test = eq r expected in
  if not test then failwithf "test 2635 failed";
  mark_test_run 2636;
  let test = sub_eq (get_idx_mut r ((.a185) : (t185, _) idx_mut)) next_r.a185 in
  if not test then failwithf "test 2636 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a185 = (#{ a17 = #200l } : t17); b185 = 201 } : t185) in
  (* .a185.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a185 = #{ r.a185 with a17 = next_r.a185.#a17 } } in
  set_idx_mut r ((.a185.#a17) : (t185, _) idx_mut) next_r.a185.#a17;
  mark_test_run 2637;
  let test = eq r expected in
  if not test then failwithf "test 2637 failed";
  mark_test_run 2638;
  let test = sub_eq (get_idx_mut r ((.a185.#a17) : (t185, _) idx_mut)) next_r.a185.#a17 in
  if not test then failwithf "test 2638 failed";
  let r = ({ a185 = (#{ a17 = #0l } : t17); b185 = 1 } : t185) in
  (* Paths of depth 0 *)
  let next_r = ({ a185 = (#{ a17 = #100l } : t17); b185 = 101 } : t185) in
  (* .b185 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b185 = next_r.b185 } in
  set_idx_mut r ((.b185) : (t185, _) idx_mut) next_r.b185;
  mark_test_run 2639;
  let test = eq r expected in
  if not test then failwithf "test 2639 failed";
  mark_test_run 2640;
  let test = sub_eq (get_idx_mut r ((.b185) : (t185, _) idx_mut)) next_r.b185 in
  if not test then failwithf "test 2640 failed";
  (**************************************)
  (*   t186 = { #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun ({ a186 = a1861; b186 = b1861 } : t186) ({ a186 = a1862; b186 = b1862 } : t186) -> (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) a1861 a1862 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1861 b1862) in
  let r = ({ a186 = (#{ a17 = #0l } : t17); b186 = #1l } : t186) in
  (* Paths of depth 0 *)
  let next_r = ({ a186 = (#{ a17 = #100l } : t17); b186 = #101l } : t186) in
  (* .a186 *)
  let sub_eq = (fun (#{ a17 = a171 } : t17) (#{ a17 = a172 } : t17) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a171 a172) in
  let expected = { r with a186 = next_r.a186 } in
  set_idx_mut r ((.a186) : (t186, _) idx_mut) next_r.a186;
  mark_test_run 2641;
  let test = eq r expected in
  if not test then failwithf "test 2641 failed";
  mark_test_run 2642;
  let test = sub_eq (get_idx_mut r ((.a186) : (t186, _) idx_mut)) next_r.a186 in
  if not test then failwithf "test 2642 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a186 = (#{ a17 = #200l } : t17); b186 = #201l } : t186) in
  (* .a186.#a17 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a186 = #{ r.a186 with a17 = next_r.a186.#a17 } } in
  set_idx_mut r ((.a186.#a17) : (t186, _) idx_mut) next_r.a186.#a17;
  mark_test_run 2643;
  let test = eq r expected in
  if not test then failwithf "test 2643 failed";
  mark_test_run 2644;
  let test = sub_eq (get_idx_mut r ((.a186.#a17) : (t186, _) idx_mut)) next_r.a186.#a17 in
  if not test then failwithf "test 2644 failed";
  let r = ({ a186 = (#{ a17 = #0l } : t17); b186 = #1l } : t186) in
  (* Paths of depth 0 *)
  let next_r = ({ a186 = (#{ a17 = #100l } : t17); b186 = #101l } : t186) in
  (* .b186 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b186 = next_r.b186 } in
  set_idx_mut r ((.b186) : (t186, _) idx_mut) next_r.b186;
  mark_test_run 2645;
  let test = eq r expected in
  if not test then failwithf "test 2645 failed";
  mark_test_run 2646;
  let test = sub_eq (get_idx_mut r ((.b186) : (t186, _) idx_mut)) next_r.b186 in
  if not test then failwithf "test 2646 failed";
  (***********************************)
  (*   t187 = { #{ int32#; int } }   *)
  (***********************************)
  let eq = (fun ({ a187 = a1871 } : t187) ({ a187 = a1872 } : t187) -> (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1871 a1872) in
  let r = ({ a187 = (#{ a99 = #0l; b99 = 1 } : t99) } : t187) in
  (* Paths of depth 0 *)
  let next_r = ({ a187 = (#{ a99 = #100l; b99 = 101 } : t99) } : t187) in
  (* .a187 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with a187 = next_r.a187 } in
  set_idx_mut r ((.a187) : (t187, _) idx_mut) next_r.a187;
  mark_test_run 2647;
  let test = eq r expected in
  if not test then failwithf "test 2647 failed";
  mark_test_run 2648;
  let test = sub_eq (get_idx_mut r ((.a187) : (t187, _) idx_mut)) next_r.a187 in
  if not test then failwithf "test 2648 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a187 = (#{ a99 = #200l; b99 = 201 } : t99) } : t187) in
  (* .a187.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a187 = #{ r.a187 with a99 = next_r.a187.#a99 } } in
  set_idx_mut r ((.a187.#a99) : (t187, _) idx_mut) next_r.a187.#a99;
  mark_test_run 2649;
  let test = eq r expected in
  if not test then failwithf "test 2649 failed";
  mark_test_run 2650;
  let test = sub_eq (get_idx_mut r ((.a187.#a99) : (t187, _) idx_mut)) next_r.a187.#a99 in
  if not test then failwithf "test 2650 failed";
  (* .a187.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a187 = #{ r.a187 with b99 = next_r.a187.#b99 } } in
  set_idx_mut r ((.a187.#b99) : (t187, _) idx_mut) next_r.a187.#b99;
  mark_test_run 2651;
  let test = eq r expected in
  if not test then failwithf "test 2651 failed";
  mark_test_run 2652;
  let test = sub_eq (get_idx_mut r ((.a187.#b99) : (t187, _) idx_mut)) next_r.a187.#b99 in
  if not test then failwithf "test 2652 failed";
  (****************************************)
  (*   t188 = { #{ int32#; int }; int }   *)
  (****************************************)
  let eq = (fun ({ a188 = a1881; b188 = b1881 } : t188) ({ a188 = a1882; b188 = b1882 } : t188) -> (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1881 a1882 && (fun a b -> Int.equal a b) b1881 b1882) in
  let r = ({ a188 = (#{ a99 = #0l; b99 = 1 } : t99); b188 = 2 } : t188) in
  (* Paths of depth 0 *)
  let next_r = ({ a188 = (#{ a99 = #100l; b99 = 101 } : t99); b188 = 102 } : t188) in
  (* .a188 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with a188 = next_r.a188 } in
  set_idx_mut r ((.a188) : (t188, _) idx_mut) next_r.a188;
  mark_test_run 2653;
  let test = eq r expected in
  if not test then failwithf "test 2653 failed";
  mark_test_run 2654;
  let test = sub_eq (get_idx_mut r ((.a188) : (t188, _) idx_mut)) next_r.a188 in
  if not test then failwithf "test 2654 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a188 = (#{ a99 = #200l; b99 = 201 } : t99); b188 = 202 } : t188) in
  (* .a188.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a188 = #{ r.a188 with a99 = next_r.a188.#a99 } } in
  set_idx_mut r ((.a188.#a99) : (t188, _) idx_mut) next_r.a188.#a99;
  mark_test_run 2655;
  let test = eq r expected in
  if not test then failwithf "test 2655 failed";
  mark_test_run 2656;
  let test = sub_eq (get_idx_mut r ((.a188.#a99) : (t188, _) idx_mut)) next_r.a188.#a99 in
  if not test then failwithf "test 2656 failed";
  (* .a188.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a188 = #{ r.a188 with b99 = next_r.a188.#b99 } } in
  set_idx_mut r ((.a188.#b99) : (t188, _) idx_mut) next_r.a188.#b99;
  mark_test_run 2657;
  let test = eq r expected in
  if not test then failwithf "test 2657 failed";
  mark_test_run 2658;
  let test = sub_eq (get_idx_mut r ((.a188.#b99) : (t188, _) idx_mut)) next_r.a188.#b99 in
  if not test then failwithf "test 2658 failed";
  let r = ({ a188 = (#{ a99 = #0l; b99 = 1 } : t99); b188 = 2 } : t188) in
  (* Paths of depth 0 *)
  let next_r = ({ a188 = (#{ a99 = #100l; b99 = 101 } : t99); b188 = 102 } : t188) in
  (* .b188 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b188 = next_r.b188 } in
  set_idx_mut r ((.b188) : (t188, _) idx_mut) next_r.b188;
  mark_test_run 2659;
  let test = eq r expected in
  if not test then failwithf "test 2659 failed";
  mark_test_run 2660;
  let test = sub_eq (get_idx_mut r ((.b188) : (t188, _) idx_mut)) next_r.b188 in
  if not test then failwithf "test 2660 failed";
  (*******************************************)
  (*   t189 = { #{ int32#; int }; int32# }   *)
  (*******************************************)
  let eq = (fun ({ a189 = a1891; b189 = b1891 } : t189) ({ a189 = a1892; b189 = b1892 } : t189) -> (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) a1891 a1892 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1891 b1892) in
  let r = ({ a189 = (#{ a99 = #0l; b99 = 1 } : t99); b189 = #2l } : t189) in
  (* Paths of depth 0 *)
  let next_r = ({ a189 = (#{ a99 = #100l; b99 = 101 } : t99); b189 = #102l } : t189) in
  (* .a189 *)
  let sub_eq = (fun (#{ a99 = a991; b99 = b991 } : t99) (#{ a99 = a992; b99 = b992 } : t99) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a991 a992 && (fun a b -> Int.equal a b) b991 b992) in
  let expected = { r with a189 = next_r.a189 } in
  set_idx_mut r ((.a189) : (t189, _) idx_mut) next_r.a189;
  mark_test_run 2661;
  let test = eq r expected in
  if not test then failwithf "test 2661 failed";
  mark_test_run 2662;
  let test = sub_eq (get_idx_mut r ((.a189) : (t189, _) idx_mut)) next_r.a189 in
  if not test then failwithf "test 2662 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a189 = (#{ a99 = #200l; b99 = 201 } : t99); b189 = #202l } : t189) in
  (* .a189.#a99 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a189 = #{ r.a189 with a99 = next_r.a189.#a99 } } in
  set_idx_mut r ((.a189.#a99) : (t189, _) idx_mut) next_r.a189.#a99;
  mark_test_run 2663;
  let test = eq r expected in
  if not test then failwithf "test 2663 failed";
  mark_test_run 2664;
  let test = sub_eq (get_idx_mut r ((.a189.#a99) : (t189, _) idx_mut)) next_r.a189.#a99 in
  if not test then failwithf "test 2664 failed";
  (* .a189.#b99 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a189 = #{ r.a189 with b99 = next_r.a189.#b99 } } in
  set_idx_mut r ((.a189.#b99) : (t189, _) idx_mut) next_r.a189.#b99;
  mark_test_run 2665;
  let test = eq r expected in
  if not test then failwithf "test 2665 failed";
  mark_test_run 2666;
  let test = sub_eq (get_idx_mut r ((.a189.#b99) : (t189, _) idx_mut)) next_r.a189.#b99 in
  if not test then failwithf "test 2666 failed";
  let r = ({ a189 = (#{ a99 = #0l; b99 = 1 } : t99); b189 = #2l } : t189) in
  (* Paths of depth 0 *)
  let next_r = ({ a189 = (#{ a99 = #100l; b99 = 101 } : t99); b189 = #102l } : t189) in
  (* .b189 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b189 = next_r.b189 } in
  set_idx_mut r ((.b189) : (t189, _) idx_mut) next_r.b189;
  mark_test_run 2667;
  let test = eq r expected in
  if not test then failwithf "test 2667 failed";
  mark_test_run 2668;
  let test = sub_eq (get_idx_mut r ((.b189) : (t189, _) idx_mut)) next_r.b189 in
  if not test then failwithf "test 2668 failed";
  (**************************************)
  (*   t190 = { #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun ({ a190 = a1901 } : t190) ({ a190 = a1902 } : t190) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a1901 a1902) in
  let r = ({ a190 = (#{ a19 = #0l; b19 = #1l } : t19) } : t190) in
  (* Paths of depth 0 *)
  let next_r = ({ a190 = (#{ a19 = #100l; b19 = #101l } : t19) } : t190) in
  (* .a190 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with a190 = next_r.a190 } in
  set_idx_mut r ((.a190) : (t190, _) idx_mut) next_r.a190;
  mark_test_run 2669;
  let test = eq r expected in
  if not test then failwithf "test 2669 failed";
  mark_test_run 2670;
  let test = sub_eq (get_idx_mut r ((.a190) : (t190, _) idx_mut)) next_r.a190 in
  if not test then failwithf "test 2670 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a190 = (#{ a19 = #200l; b19 = #201l } : t19) } : t190) in
  (* .a190.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a190 = #{ r.a190 with a19 = next_r.a190.#a19 } } in
  set_idx_mut r ((.a190.#a19) : (t190, _) idx_mut) next_r.a190.#a19;
  mark_test_run 2671;
  let test = eq r expected in
  if not test then failwithf "test 2671 failed";
  mark_test_run 2672;
  let test = sub_eq (get_idx_mut r ((.a190.#a19) : (t190, _) idx_mut)) next_r.a190.#a19 in
  if not test then failwithf "test 2672 failed";
  (* .a190.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a190 = #{ r.a190 with b19 = next_r.a190.#b19 } } in
  set_idx_mut r ((.a190.#b19) : (t190, _) idx_mut) next_r.a190.#b19;
  mark_test_run 2673;
  let test = eq r expected in
  if not test then failwithf "test 2673 failed";
  mark_test_run 2674;
  let test = sub_eq (get_idx_mut r ((.a190.#b19) : (t190, _) idx_mut)) next_r.a190.#b19 in
  if not test then failwithf "test 2674 failed";
  (*******************************************)
  (*   t191 = { #{ int32#; int32# }; int }   *)
  (*******************************************)
  let eq = (fun ({ a191 = a1911; b191 = b1911 } : t191) ({ a191 = a1912; b191 = b1912 } : t191) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a1911 a1912 && (fun a b -> Int.equal a b) b1911 b1912) in
  let r = ({ a191 = (#{ a19 = #0l; b19 = #1l } : t19); b191 = 2 } : t191) in
  (* Paths of depth 0 *)
  let next_r = ({ a191 = (#{ a19 = #100l; b19 = #101l } : t19); b191 = 102 } : t191) in
  (* .a191 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with a191 = next_r.a191 } in
  set_idx_mut r ((.a191) : (t191, _) idx_mut) next_r.a191;
  mark_test_run 2675;
  let test = eq r expected in
  if not test then failwithf "test 2675 failed";
  mark_test_run 2676;
  let test = sub_eq (get_idx_mut r ((.a191) : (t191, _) idx_mut)) next_r.a191 in
  if not test then failwithf "test 2676 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a191 = (#{ a19 = #200l; b19 = #201l } : t19); b191 = 202 } : t191) in
  (* .a191.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a191 = #{ r.a191 with a19 = next_r.a191.#a19 } } in
  set_idx_mut r ((.a191.#a19) : (t191, _) idx_mut) next_r.a191.#a19;
  mark_test_run 2677;
  let test = eq r expected in
  if not test then failwithf "test 2677 failed";
  mark_test_run 2678;
  let test = sub_eq (get_idx_mut r ((.a191.#a19) : (t191, _) idx_mut)) next_r.a191.#a19 in
  if not test then failwithf "test 2678 failed";
  (* .a191.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a191 = #{ r.a191 with b19 = next_r.a191.#b19 } } in
  set_idx_mut r ((.a191.#b19) : (t191, _) idx_mut) next_r.a191.#b19;
  mark_test_run 2679;
  let test = eq r expected in
  if not test then failwithf "test 2679 failed";
  mark_test_run 2680;
  let test = sub_eq (get_idx_mut r ((.a191.#b19) : (t191, _) idx_mut)) next_r.a191.#b19 in
  if not test then failwithf "test 2680 failed";
  let r = ({ a191 = (#{ a19 = #0l; b19 = #1l } : t19); b191 = 2 } : t191) in
  (* Paths of depth 0 *)
  let next_r = ({ a191 = (#{ a19 = #100l; b19 = #101l } : t19); b191 = 102 } : t191) in
  (* .b191 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b191 = next_r.b191 } in
  set_idx_mut r ((.b191) : (t191, _) idx_mut) next_r.b191;
  mark_test_run 2681;
  let test = eq r expected in
  if not test then failwithf "test 2681 failed";
  mark_test_run 2682;
  let test = sub_eq (get_idx_mut r ((.b191) : (t191, _) idx_mut)) next_r.b191 in
  if not test then failwithf "test 2682 failed";
  (**********************************************)
  (*   t192 = { #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun ({ a192 = a1921; b192 = b1921 } : t192) ({ a192 = a1922; b192 = b1922 } : t192) -> (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) a1921 a1922 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b1921 b1922) in
  let r = ({ a192 = (#{ a19 = #0l; b19 = #1l } : t19); b192 = #2l } : t192) in
  (* Paths of depth 0 *)
  let next_r = ({ a192 = (#{ a19 = #100l; b19 = #101l } : t19); b192 = #102l } : t192) in
  (* .a192 *)
  let sub_eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a191 a192 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b191 b192) in
  let expected = { r with a192 = next_r.a192 } in
  set_idx_mut r ((.a192) : (t192, _) idx_mut) next_r.a192;
  mark_test_run 2683;
  let test = eq r expected in
  if not test then failwithf "test 2683 failed";
  mark_test_run 2684;
  let test = sub_eq (get_idx_mut r ((.a192) : (t192, _) idx_mut)) next_r.a192 in
  if not test then failwithf "test 2684 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a192 = (#{ a19 = #200l; b19 = #201l } : t19); b192 = #202l } : t192) in
  (* .a192.#a19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a192 = #{ r.a192 with a19 = next_r.a192.#a19 } } in
  set_idx_mut r ((.a192.#a19) : (t192, _) idx_mut) next_r.a192.#a19;
  mark_test_run 2685;
  let test = eq r expected in
  if not test then failwithf "test 2685 failed";
  mark_test_run 2686;
  let test = sub_eq (get_idx_mut r ((.a192.#a19) : (t192, _) idx_mut)) next_r.a192.#a19 in
  if not test then failwithf "test 2686 failed";
  (* .a192.#b19 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with a192 = #{ r.a192 with b19 = next_r.a192.#b19 } } in
  set_idx_mut r ((.a192.#b19) : (t192, _) idx_mut) next_r.a192.#b19;
  mark_test_run 2687;
  let test = eq r expected in
  if not test then failwithf "test 2687 failed";
  mark_test_run 2688;
  let test = sub_eq (get_idx_mut r ((.a192.#b19) : (t192, _) idx_mut)) next_r.a192.#b19 in
  if not test then failwithf "test 2688 failed";
  let r = ({ a192 = (#{ a19 = #0l; b19 = #1l } : t19); b192 = #2l } : t192) in
  (* Paths of depth 0 *)
  let next_r = ({ a192 = (#{ a19 = #100l; b19 = #101l } : t19); b192 = #102l } : t192) in
  (* .b192 *)
  let sub_eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let expected = { r with b192 = next_r.b192 } in
  set_idx_mut r ((.b192) : (t192, _) idx_mut) next_r.b192;
  mark_test_run 2689;
  let test = eq r expected in
  if not test then failwithf "test 2689 failed";
  mark_test_run 2690;
  let test = sub_eq (get_idx_mut r ((.b192) : (t192, _) idx_mut)) next_r.b192 in
  if not test then failwithf "test 2690 failed";
  (*****************************)
  (*   t193 = { #{ float } }   *)
  (*****************************)
  let eq = (fun ({ a193 = a1931 } : t193) ({ a193 = a1932 } : t193) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1931 a1932) in
  let r = ({ a193 = (#{ a21 = 0. } : t21) } : t193) in
  (* Paths of depth 0 *)
  let next_r = ({ a193 = (#{ a21 = 100. } : t21) } : t193) in
  (* .a193 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a193 = next_r.a193 } in
  set_idx_mut r ((.a193) : (t193, _) idx_mut) (Float_u.of_float next_r.a193.#a21);
  mark_test_run 2691;
  let test = eq r expected in
  if not test then failwithf "test 2691 failed";
  mark_test_run 2692;
  let test = sub_eq (get_idx_mut r ((.a193) : (t193, _) idx_mut)) (Float_u.of_float next_r.a193.#a21) in
  if not test then failwithf "test 2692 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a193 = (#{ a21 = 200. } : t21) } : t193) in
  (* .a193.#a21 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a193 = #{ r.a193 with a21 = next_r.a193.#a21 } } in
  set_idx_mut r ((.a193.#a21) : (t193, _) idx_mut) (Float_u.of_float next_r.a193.#a21);
  mark_test_run 2693;
  let test = eq r expected in
  if not test then failwithf "test 2693 failed";
  mark_test_run 2694;
  let test = sub_eq (get_idx_mut r ((.a193.#a21) : (t193, _) idx_mut)) (Float_u.of_float next_r.a193.#a21) in
  if not test then failwithf "test 2694 failed";
  (**********************************)
  (*   t194 = { #{ float }; int }   *)
  (**********************************)
  let eq = (fun ({ a194 = a1941; b194 = b1941 } : t194) ({ a194 = a1942; b194 = b1942 } : t194) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1941 a1942 && (fun a b -> Int.equal a b) b1941 b1942) in
  let r = ({ a194 = (#{ a21 = 0. } : t21); b194 = 1 } : t194) in
  (* Paths of depth 0 *)
  let next_r = ({ a194 = (#{ a21 = 100. } : t21); b194 = 101 } : t194) in
  (* .a194 *)
  let sub_eq = (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) in
  let expected = { r with a194 = next_r.a194 } in
  set_idx_mut r ((.a194) : (t194, _) idx_mut) next_r.a194;
  mark_test_run 2695;
  let test = eq r expected in
  if not test then failwithf "test 2695 failed";
  mark_test_run 2696;
  let test = sub_eq (get_idx_mut r ((.a194) : (t194, _) idx_mut)) next_r.a194 in
  if not test then failwithf "test 2696 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a194 = (#{ a21 = 200. } : t21); b194 = 201 } : t194) in
  (* .a194.#a21 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a194 = #{ r.a194 with a21 = next_r.a194.#a21 } } in
  set_idx_mut r ((.a194.#a21) : (t194, _) idx_mut) next_r.a194.#a21;
  mark_test_run 2697;
  let test = eq r expected in
  if not test then failwithf "test 2697 failed";
  mark_test_run 2698;
  let test = sub_eq (get_idx_mut r ((.a194.#a21) : (t194, _) idx_mut)) next_r.a194.#a21 in
  if not test then failwithf "test 2698 failed";
  let r = ({ a194 = (#{ a21 = 0. } : t21); b194 = 1 } : t194) in
  (* Paths of depth 0 *)
  let next_r = ({ a194 = (#{ a21 = 100. } : t21); b194 = 101 } : t194) in
  (* .b194 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b194 = next_r.b194 } in
  set_idx_mut r ((.b194) : (t194, _) idx_mut) next_r.b194;
  mark_test_run 2699;
  let test = eq r expected in
  if not test then failwithf "test 2699 failed";
  mark_test_run 2700;
  let test = sub_eq (get_idx_mut r ((.b194) : (t194, _) idx_mut)) next_r.b194 in
  if not test then failwithf "test 2700 failed";
  (************************************)
  (*   t195 = { #{ float }; float }   *)
  (************************************)
  let eq = (fun ({ a195 = a1951; b195 = b1951 } : t195) ({ a195 = a1952; b195 = b1952 } : t195) -> (fun (#{ a21 = a211 } : t21) (#{ a21 = a212 } : t21) -> (fun a b -> Float.equal (globalize a) (globalize b)) a211 a212) a1951 a1952 && (fun a b -> Float.equal (globalize a) (globalize b)) b1951 b1952) in
  let r = ({ a195 = (#{ a21 = 0. } : t21); b195 = 1. } : t195) in
  (* Paths of depth 0 *)
  let next_r = ({ a195 = (#{ a21 = 100. } : t21); b195 = 101. } : t195) in
  (* .a195 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a195 = next_r.a195 } in
  set_idx_mut r ((.a195) : (t195, _) idx_mut) (Float_u.of_float next_r.a195.#a21);
  mark_test_run 2701;
  let test = eq r expected in
  if not test then failwithf "test 2701 failed";
  mark_test_run 2702;
  let test = sub_eq (get_idx_mut r ((.a195) : (t195, _) idx_mut)) (Float_u.of_float next_r.a195.#a21) in
  if not test then failwithf "test 2702 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a195 = (#{ a21 = 200. } : t21); b195 = 201. } : t195) in
  (* .a195.#a21 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with a195 = #{ r.a195 with a21 = next_r.a195.#a21 } } in
  set_idx_mut r ((.a195.#a21) : (t195, _) idx_mut) (Float_u.of_float next_r.a195.#a21);
  mark_test_run 2703;
  let test = eq r expected in
  if not test then failwithf "test 2703 failed";
  mark_test_run 2704;
  let test = sub_eq (get_idx_mut r ((.a195.#a21) : (t195, _) idx_mut)) (Float_u.of_float next_r.a195.#a21) in
  if not test then failwithf "test 2704 failed";
  let r = ({ a195 = (#{ a21 = 0. } : t21); b195 = 1. } : t195) in
  (* Paths of depth 0 *)
  let next_r = ({ a195 = (#{ a21 = 100. } : t21); b195 = 101. } : t195) in
  (* .b195 *)
  (* ff *)
  let sub_eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let expected = { r with b195 = next_r.b195 } in
  set_idx_mut r ((.b195) : (t195, _) idx_mut) (Float_u.of_float next_r.b195);
  mark_test_run 2705;
  let test = eq r expected in
  if not test then failwithf "test 2705 failed";
  mark_test_run 2706;
  let test = sub_eq (get_idx_mut r ((.b195) : (t195, _) idx_mut)) (Float_u.of_float next_r.b195) in
  if not test then failwithf "test 2706 failed";
  (**********************************)
  (*   t196 = { #{ float; int } }   *)
  (**********************************)
  let eq = (fun ({ a196 = a1961 } : t196) ({ a196 = a1962 } : t196) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a1961 a1962) in
  let r = ({ a196 = (#{ a23 = 0.; b23 = 1 } : t23) } : t196) in
  (* Paths of depth 0 *)
  let next_r = ({ a196 = (#{ a23 = 100.; b23 = 101 } : t23) } : t196) in
  (* .a196 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with a196 = next_r.a196 } in
  set_idx_mut r ((.a196) : (t196, _) idx_mut) next_r.a196;
  mark_test_run 2707;
  let test = eq r expected in
  if not test then failwithf "test 2707 failed";
  mark_test_run 2708;
  let test = sub_eq (get_idx_mut r ((.a196) : (t196, _) idx_mut)) next_r.a196 in
  if not test then failwithf "test 2708 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a196 = (#{ a23 = 200.; b23 = 201 } : t23) } : t196) in
  (* .a196.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a196 = #{ r.a196 with a23 = next_r.a196.#a23 } } in
  set_idx_mut r ((.a196.#a23) : (t196, _) idx_mut) next_r.a196.#a23;
  mark_test_run 2709;
  let test = eq r expected in
  if not test then failwithf "test 2709 failed";
  mark_test_run 2710;
  let test = sub_eq (get_idx_mut r ((.a196.#a23) : (t196, _) idx_mut)) next_r.a196.#a23 in
  if not test then failwithf "test 2710 failed";
  (* .a196.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a196 = #{ r.a196 with b23 = next_r.a196.#b23 } } in
  set_idx_mut r ((.a196.#b23) : (t196, _) idx_mut) next_r.a196.#b23;
  mark_test_run 2711;
  let test = eq r expected in
  if not test then failwithf "test 2711 failed";
  mark_test_run 2712;
  let test = sub_eq (get_idx_mut r ((.a196.#b23) : (t196, _) idx_mut)) next_r.a196.#b23 in
  if not test then failwithf "test 2712 failed";
  (***************************************)
  (*   t197 = { #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun ({ a197 = a1971; b197 = b1971 } : t197) ({ a197 = a1972; b197 = b1972 } : t197) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a1971 a1972 && (fun a b -> Int.equal a b) b1971 b1972) in
  let r = ({ a197 = (#{ a23 = 0.; b23 = 1 } : t23); b197 = 2 } : t197) in
  (* Paths of depth 0 *)
  let next_r = ({ a197 = (#{ a23 = 100.; b23 = 101 } : t23); b197 = 102 } : t197) in
  (* .a197 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with a197 = next_r.a197 } in
  set_idx_mut r ((.a197) : (t197, _) idx_mut) next_r.a197;
  mark_test_run 2713;
  let test = eq r expected in
  if not test then failwithf "test 2713 failed";
  mark_test_run 2714;
  let test = sub_eq (get_idx_mut r ((.a197) : (t197, _) idx_mut)) next_r.a197 in
  if not test then failwithf "test 2714 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a197 = (#{ a23 = 200.; b23 = 201 } : t23); b197 = 202 } : t197) in
  (* .a197.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a197 = #{ r.a197 with a23 = next_r.a197.#a23 } } in
  set_idx_mut r ((.a197.#a23) : (t197, _) idx_mut) next_r.a197.#a23;
  mark_test_run 2715;
  let test = eq r expected in
  if not test then failwithf "test 2715 failed";
  mark_test_run 2716;
  let test = sub_eq (get_idx_mut r ((.a197.#a23) : (t197, _) idx_mut)) next_r.a197.#a23 in
  if not test then failwithf "test 2716 failed";
  (* .a197.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a197 = #{ r.a197 with b23 = next_r.a197.#b23 } } in
  set_idx_mut r ((.a197.#b23) : (t197, _) idx_mut) next_r.a197.#b23;
  mark_test_run 2717;
  let test = eq r expected in
  if not test then failwithf "test 2717 failed";
  mark_test_run 2718;
  let test = sub_eq (get_idx_mut r ((.a197.#b23) : (t197, _) idx_mut)) next_r.a197.#b23 in
  if not test then failwithf "test 2718 failed";
  let r = ({ a197 = (#{ a23 = 0.; b23 = 1 } : t23); b197 = 2 } : t197) in
  (* Paths of depth 0 *)
  let next_r = ({ a197 = (#{ a23 = 100.; b23 = 101 } : t23); b197 = 102 } : t197) in
  (* .b197 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b197 = next_r.b197 } in
  set_idx_mut r ((.b197) : (t197, _) idx_mut) next_r.b197;
  mark_test_run 2719;
  let test = eq r expected in
  if not test then failwithf "test 2719 failed";
  mark_test_run 2720;
  let test = sub_eq (get_idx_mut r ((.b197) : (t197, _) idx_mut)) next_r.b197 in
  if not test then failwithf "test 2720 failed";
  (*****************************************)
  (*   t198 = { #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun ({ a198 = a1981; b198 = b1981 } : t198) ({ a198 = a1982; b198 = b1982 } : t198) -> (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) a1981 a1982 && (fun a b -> Float.equal (globalize a) (globalize b)) b1981 b1982) in
  let r = ({ a198 = (#{ a23 = 0.; b23 = 1 } : t23); b198 = 2. } : t198) in
  (* Paths of depth 0 *)
  let next_r = ({ a198 = (#{ a23 = 100.; b23 = 101 } : t23); b198 = 102. } : t198) in
  (* .a198 *)
  let sub_eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Float.equal (globalize a) (globalize b)) a231 a232 && (fun a b -> Int.equal a b) b231 b232) in
  let expected = { r with a198 = next_r.a198 } in
  set_idx_mut r ((.a198) : (t198, _) idx_mut) next_r.a198;
  mark_test_run 2721;
  let test = eq r expected in
  if not test then failwithf "test 2721 failed";
  mark_test_run 2722;
  let test = sub_eq (get_idx_mut r ((.a198) : (t198, _) idx_mut)) next_r.a198 in
  if not test then failwithf "test 2722 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a198 = (#{ a23 = 200.; b23 = 201 } : t23); b198 = 202. } : t198) in
  (* .a198.#a23 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a198 = #{ r.a198 with a23 = next_r.a198.#a23 } } in
  set_idx_mut r ((.a198.#a23) : (t198, _) idx_mut) next_r.a198.#a23;
  mark_test_run 2723;
  let test = eq r expected in
  if not test then failwithf "test 2723 failed";
  mark_test_run 2724;
  let test = sub_eq (get_idx_mut r ((.a198.#a23) : (t198, _) idx_mut)) next_r.a198.#a23 in
  if not test then failwithf "test 2724 failed";
  (* .a198.#b23 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with a198 = #{ r.a198 with b23 = next_r.a198.#b23 } } in
  set_idx_mut r ((.a198.#b23) : (t198, _) idx_mut) next_r.a198.#b23;
  mark_test_run 2725;
  let test = eq r expected in
  if not test then failwithf "test 2725 failed";
  mark_test_run 2726;
  let test = sub_eq (get_idx_mut r ((.a198.#b23) : (t198, _) idx_mut)) next_r.a198.#b23 in
  if not test then failwithf "test 2726 failed";
  let r = ({ a198 = (#{ a23 = 0.; b23 = 1 } : t23); b198 = 2. } : t198) in
  (* Paths of depth 0 *)
  let next_r = ({ a198 = (#{ a23 = 100.; b23 = 101 } : t23); b198 = 102. } : t198) in
  (* .b198 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b198 = next_r.b198 } in
  set_idx_mut r ((.b198) : (t198, _) idx_mut) next_r.b198;
  mark_test_run 2727;
  let test = eq r expected in
  if not test then failwithf "test 2727 failed";
  mark_test_run 2728;
  let test = sub_eq (get_idx_mut r ((.b198) : (t198, _) idx_mut)) next_r.b198 in
  if not test then failwithf "test 2728 failed";
  (************************************)
  (*   t199 = { #{ float; float } }   *)
  (************************************)
  let eq = (fun ({ a199 = a1991 } : t199) ({ a199 = a1992 } : t199) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a1991 a1992) in
  let r = ({ a199 = (#{ a25 = 0.; b25 = 1. } : t25) } : t199) in
  (* Paths of depth 0 *)
  let next_r = ({ a199 = (#{ a25 = 100.; b25 = 101. } : t25) } : t199) in
  (* .a199 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with a199 = next_r.a199 } in
  set_idx_mut r ((.a199) : (t199, _) idx_mut) next_r.a199;
  mark_test_run 2729;
  let test = eq r expected in
  if not test then failwithf "test 2729 failed";
  mark_test_run 2730;
  let test = sub_eq (get_idx_mut r ((.a199) : (t199, _) idx_mut)) next_r.a199 in
  if not test then failwithf "test 2730 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a199 = (#{ a25 = 200.; b25 = 201. } : t25) } : t199) in
  (* .a199.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a199 = #{ r.a199 with a25 = next_r.a199.#a25 } } in
  set_idx_mut r ((.a199.#a25) : (t199, _) idx_mut) next_r.a199.#a25;
  mark_test_run 2731;
  let test = eq r expected in
  if not test then failwithf "test 2731 failed";
  mark_test_run 2732;
  let test = sub_eq (get_idx_mut r ((.a199.#a25) : (t199, _) idx_mut)) next_r.a199.#a25 in
  if not test then failwithf "test 2732 failed";
  (* .a199.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a199 = #{ r.a199 with b25 = next_r.a199.#b25 } } in
  set_idx_mut r ((.a199.#b25) : (t199, _) idx_mut) next_r.a199.#b25;
  mark_test_run 2733;
  let test = eq r expected in
  if not test then failwithf "test 2733 failed";
  mark_test_run 2734;
  let test = sub_eq (get_idx_mut r ((.a199.#b25) : (t199, _) idx_mut)) next_r.a199.#b25 in
  if not test then failwithf "test 2734 failed";
  (*****************************************)
  (*   t200 = { #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun ({ a200 = a2001; b200 = b2001 } : t200) ({ a200 = a2002; b200 = b2002 } : t200) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a2001 a2002 && (fun a b -> Int.equal a b) b2001 b2002) in
  let r = ({ a200 = (#{ a25 = 0.; b25 = 1. } : t25); b200 = 2 } : t200) in
  (* Paths of depth 0 *)
  let next_r = ({ a200 = (#{ a25 = 100.; b25 = 101. } : t25); b200 = 102 } : t200) in
  (* .a200 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with a200 = next_r.a200 } in
  set_idx_mut r ((.a200) : (t200, _) idx_mut) next_r.a200;
  mark_test_run 2735;
  let test = eq r expected in
  if not test then failwithf "test 2735 failed";
  mark_test_run 2736;
  let test = sub_eq (get_idx_mut r ((.a200) : (t200, _) idx_mut)) next_r.a200 in
  if not test then failwithf "test 2736 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a200 = (#{ a25 = 200.; b25 = 201. } : t25); b200 = 202 } : t200) in
  (* .a200.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a200 = #{ r.a200 with a25 = next_r.a200.#a25 } } in
  set_idx_mut r ((.a200.#a25) : (t200, _) idx_mut) next_r.a200.#a25;
  mark_test_run 2737;
  let test = eq r expected in
  if not test then failwithf "test 2737 failed";
  mark_test_run 2738;
  let test = sub_eq (get_idx_mut r ((.a200.#a25) : (t200, _) idx_mut)) next_r.a200.#a25 in
  if not test then failwithf "test 2738 failed";
  (* .a200.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a200 = #{ r.a200 with b25 = next_r.a200.#b25 } } in
  set_idx_mut r ((.a200.#b25) : (t200, _) idx_mut) next_r.a200.#b25;
  mark_test_run 2739;
  let test = eq r expected in
  if not test then failwithf "test 2739 failed";
  mark_test_run 2740;
  let test = sub_eq (get_idx_mut r ((.a200.#b25) : (t200, _) idx_mut)) next_r.a200.#b25 in
  if not test then failwithf "test 2740 failed";
  let r = ({ a200 = (#{ a25 = 0.; b25 = 1. } : t25); b200 = 2 } : t200) in
  (* Paths of depth 0 *)
  let next_r = ({ a200 = (#{ a25 = 100.; b25 = 101. } : t25); b200 = 102 } : t200) in
  (* .b200 *)
  let sub_eq = (fun a b -> Int.equal a b) in
  let expected = { r with b200 = next_r.b200 } in
  set_idx_mut r ((.b200) : (t200, _) idx_mut) next_r.b200;
  mark_test_run 2741;
  let test = eq r expected in
  if not test then failwithf "test 2741 failed";
  mark_test_run 2742;
  let test = sub_eq (get_idx_mut r ((.b200) : (t200, _) idx_mut)) next_r.b200 in
  if not test then failwithf "test 2742 failed";
  (*******************************************)
  (*   t201 = { #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun ({ a201 = a2011; b201 = b2011 } : t201) ({ a201 = a2012; b201 = b2012 } : t201) -> (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) a2011 a2012 && (fun a b -> Float.equal (globalize a) (globalize b)) b2011 b2012) in
  let r = ({ a201 = (#{ a25 = 0.; b25 = 1. } : t25); b201 = 2. } : t201) in
  (* Paths of depth 0 *)
  let next_r = ({ a201 = (#{ a25 = 100.; b25 = 101. } : t25); b201 = 102. } : t201) in
  (* .a201 *)
  let sub_eq = (fun (#{ a25 = a251; b25 = b251 } : t25) (#{ a25 = a252; b25 = b252 } : t25) -> (fun a b -> Float.equal (globalize a) (globalize b)) a251 a252 && (fun a b -> Float.equal (globalize a) (globalize b)) b251 b252) in
  let expected = { r with a201 = next_r.a201 } in
  set_idx_mut r ((.a201) : (t201, _) idx_mut) next_r.a201;
  mark_test_run 2743;
  let test = eq r expected in
  if not test then failwithf "test 2743 failed";
  mark_test_run 2744;
  let test = sub_eq (get_idx_mut r ((.a201) : (t201, _) idx_mut)) next_r.a201 in
  if not test then failwithf "test 2744 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a201 = (#{ a25 = 200.; b25 = 201. } : t25); b201 = 202. } : t201) in
  (* .a201.#a25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a201 = #{ r.a201 with a25 = next_r.a201.#a25 } } in
  set_idx_mut r ((.a201.#a25) : (t201, _) idx_mut) next_r.a201.#a25;
  mark_test_run 2745;
  let test = eq r expected in
  if not test then failwithf "test 2745 failed";
  mark_test_run 2746;
  let test = sub_eq (get_idx_mut r ((.a201.#a25) : (t201, _) idx_mut)) next_r.a201.#a25 in
  if not test then failwithf "test 2746 failed";
  (* .a201.#b25 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with a201 = #{ r.a201 with b25 = next_r.a201.#b25 } } in
  set_idx_mut r ((.a201.#b25) : (t201, _) idx_mut) next_r.a201.#b25;
  mark_test_run 2747;
  let test = eq r expected in
  if not test then failwithf "test 2747 failed";
  mark_test_run 2748;
  let test = sub_eq (get_idx_mut r ((.a201.#b25) : (t201, _) idx_mut)) next_r.a201.#b25 in
  if not test then failwithf "test 2748 failed";
  let r = ({ a201 = (#{ a25 = 0.; b25 = 1. } : t25); b201 = 2. } : t201) in
  (* Paths of depth 0 *)
  let next_r = ({ a201 = (#{ a25 = 100.; b25 = 101. } : t25); b201 = 102. } : t201) in
  (* .b201 *)
  let sub_eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let expected = { r with b201 = next_r.b201 } in
  set_idx_mut r ((.b201) : (t201, _) idx_mut) next_r.b201;
  mark_test_run 2749;
  let test = eq r expected in
  if not test then failwithf "test 2749 failed";
  mark_test_run 2750;
  let test = sub_eq (get_idx_mut r ((.b201) : (t201, _) idx_mut)) next_r.b201 in
  if not test then failwithf "test 2750 failed";
  (*************************************************************)
  (*   t204 = { #{ float32#; int64# }; #{ string; int64# } }   *)
  (*************************************************************)
  let eq = (fun ({ a204 = a2041; b204 = b2041 } : t204) ({ a204 = a2042; b204 = b2042 } : t204) -> (fun (#{ a202 = a2021; b202 = b2021 } : t202) (#{ a202 = a2022; b202 = b2022 } : t202) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2021 a2022 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2021 b2022) a2041 a2042 && (fun (#{ a203 = a2031; b203 = b2031 } : t203) (#{ a203 = a2032; b203 = b2032 } : t203) -> (fun a b -> String.equal (globalize a) (globalize b)) a2031 a2032 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2031 b2032) b2041 b2042) in
  let r = ({ a204 = (#{ a202 = #0.s; b202 = #1L } : t202); b204 = (#{ a203 = "2"; b203 = #3L } : t203) } : t204) in
  (* Paths of depth 0 *)
  let next_r = ({ a204 = (#{ a202 = #100.s; b202 = #101L } : t202); b204 = (#{ a203 = "102"; b203 = #103L } : t203) } : t204) in
  (* .a204 *)
  let sub_eq = (fun (#{ a202 = a2021; b202 = b2021 } : t202) (#{ a202 = a2022; b202 = b2022 } : t202) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2021 a2022 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2021 b2022) in
  let expected = { r with a204 = next_r.a204 } in
  set_idx_mut r ((.a204) : (t204, _) idx_mut) next_r.a204;
  mark_test_run 2751;
  let test = eq r expected in
  if not test then failwithf "test 2751 failed";
  mark_test_run 2752;
  let test = sub_eq (get_idx_mut r ((.a204) : (t204, _) idx_mut)) next_r.a204 in
  if not test then failwithf "test 2752 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a204 = (#{ a202 = #200.s; b202 = #201L } : t202); b204 = (#{ a203 = "202"; b203 = #203L } : t203) } : t204) in
  (* .a204.#a202 *)
  let sub_eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let expected = { r with a204 = #{ r.a204 with a202 = next_r.a204.#a202 } } in
  set_idx_mut r ((.a204.#a202) : (t204, _) idx_mut) next_r.a204.#a202;
  mark_test_run 2753;
  let test = eq r expected in
  if not test then failwithf "test 2753 failed";
  mark_test_run 2754;
  let test = sub_eq (get_idx_mut r ((.a204.#a202) : (t204, _) idx_mut)) next_r.a204.#a202 in
  if not test then failwithf "test 2754 failed";
  (* .a204.#b202 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with a204 = #{ r.a204 with b202 = next_r.a204.#b202 } } in
  set_idx_mut r ((.a204.#b202) : (t204, _) idx_mut) next_r.a204.#b202;
  mark_test_run 2755;
  let test = eq r expected in
  if not test then failwithf "test 2755 failed";
  mark_test_run 2756;
  let test = sub_eq (get_idx_mut r ((.a204.#b202) : (t204, _) idx_mut)) next_r.a204.#b202 in
  if not test then failwithf "test 2756 failed";
  let r = ({ a204 = (#{ a202 = #0.s; b202 = #1L } : t202); b204 = (#{ a203 = "2"; b203 = #3L } : t203) } : t204) in
  (* Paths of depth 0 *)
  let next_r = ({ a204 = (#{ a202 = #100.s; b202 = #101L } : t202); b204 = (#{ a203 = "102"; b203 = #103L } : t203) } : t204) in
  (* .b204 *)
  let sub_eq = (fun (#{ a203 = a2031; b203 = b2031 } : t203) (#{ a203 = a2032; b203 = b2032 } : t203) -> (fun a b -> String.equal (globalize a) (globalize b)) a2031 a2032 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b2031 b2032) in
  let expected = { r with b204 = next_r.b204 } in
  set_idx_mut r ((.b204) : (t204, _) idx_mut) next_r.b204;
  mark_test_run 2757;
  let test = eq r expected in
  if not test then failwithf "test 2757 failed";
  mark_test_run 2758;
  let test = sub_eq (get_idx_mut r ((.b204) : (t204, _) idx_mut)) next_r.b204 in
  if not test then failwithf "test 2758 failed";
  (* Paths of depth 1 *)
  let next_r = ({ a204 = (#{ a202 = #200.s; b202 = #201L } : t202); b204 = (#{ a203 = "202"; b203 = #203L } : t203) } : t204) in
  (* .b204.#a203 *)
  let sub_eq = (fun a b -> String.equal (globalize a) (globalize b)) in
  let expected = { r with b204 = #{ r.b204 with a203 = next_r.b204.#a203 } } in
  set_idx_mut r ((.b204.#a203) : (t204, _) idx_mut) next_r.b204.#a203;
  mark_test_run 2759;
  let test = eq r expected in
  if not test then failwithf "test 2759 failed";
  mark_test_run 2760;
  let test = sub_eq (get_idx_mut r ((.b204.#a203) : (t204, _) idx_mut)) next_r.b204.#a203 in
  if not test then failwithf "test 2760 failed";
  (* .b204.#b203 *)
  let sub_eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let expected = { r with b204 = #{ r.b204 with b203 = next_r.b204.#b203 } } in
  set_idx_mut r ((.b204.#b203) : (t204, _) idx_mut) next_r.b204.#b203;
  mark_test_run 2761;
  let test = eq r expected in
  if not test then failwithf "test 2761 failed";
  mark_test_run 2762;
  let test = sub_eq (get_idx_mut r ((.b204.#b203) : (t204, _) idx_mut)) next_r.b204.#b203 in
  if not test then failwithf "test 2762 failed";
  ()

(* Test record idx deepening *)
let () =
  (*********************)
  (*   t80 = { int }   *)
  (*********************)
  (**************************)
  (*   t81 = { int; int }   *)
  (**************************)
  (*******************************)
  (*   t82 = { int; int; int }   *)
  (*******************************)
  (**********************************)
  (*   t83 = { int; int; int32# }   *)
  (**********************************)
  (*********************************)
  (*   t84 = { int; int; float }   *)
  (*********************************)
  (****************************)
  (*   t85 = { int; int64 }   *)
  (****************************)
  (*****************************)
  (*   t86 = { int; int64# }   *)
  (*****************************)
  (*****************************)
  (*   t87 = { int; int32# }   *)
  (*****************************)
  (**********************************)
  (*   t88 = { int; int32#; int }   *)
  (**********************************)
  (*************************************)
  (*   t89 = { int; int32#; int32# }   *)
  (*************************************)
  (*********************************)
  (*   t90 = { int; nativeint# }   *)
  (*********************************)
  (****************************)
  (*   t91 = { int; float }   *)
  (****************************)
  (*********************************)
  (*   t92 = { int; float; int }   *)
  (*********************************)
  (***********************************)
  (*   t93 = { int; float; float }   *)
  (***********************************)
  (*******************************)
  (*   t94 = { int; #{ int } }   *)
  (*******************************)
  (************************************)
  (*   t95 = { int; #{ int; int } }   *)
  (************************************)
  (***************************************)
  (*   t96 = { int; #{ int; int32# } }   *)
  (***************************************)
  (**************************************)
  (*   t97 = { int; #{ int; float } }   *)
  (**************************************)
  (**********************************)
  (*   t98 = { int; #{ int32# } }   *)
  (**********************************)
  (****************************************)
  (*   t100 = { int; #{ int32#; int } }   *)
  (****************************************)
  (*******************************************)
  (*   t101 = { int; #{ int32#; int32# } }   *)
  (*******************************************)
  (**********************************)
  (*   t102 = { int; #{ float } }   *)
  (**********************************)
  (***************************************)
  (*   t103 = { int; #{ float; int } }   *)
  (***************************************)
  (*****************************************)
  (*   t104 = { int; #{ float; float } }   *)
  (*****************************************)
  (************************)
  (*   t105 = { int64 }   *)
  (************************)
  (*****************************)
  (*   t106 = { int64; int }   *)
  (*****************************)
  (*******************************)
  (*   t107 = { int64; int64 }   *)
  (*******************************)
  (********************************)
  (*   t108 = { int64; int64# }   *)
  (********************************)
  (********************************)
  (*   t109 = { int64; int32# }   *)
  (********************************)
  (************************************)
  (*   t110 = { int64; nativeint# }   *)
  (************************************)
  (*******************************)
  (*   t111 = { int64; float }   *)
  (*******************************)
  (*************************)
  (*   t112 = { int64# }   *)
  (*************************)
  (******************************)
  (*   t113 = { int64#; int }   *)
  (******************************)
  (********************************)
  (*   t114 = { int64#; int64 }   *)
  (********************************)
  (*********************************)
  (*   t115 = { int64#; int64# }   *)
  (*********************************)
  (*********************************)
  (*   t116 = { int64#; int32# }   *)
  (*********************************)
  (*************************************)
  (*   t117 = { int64#; nativeint# }   *)
  (*************************************)
  (********************************)
  (*   t118 = { int64#; float }   *)
  (********************************)
  (*************************)
  (*   t119 = { int32# }   *)
  (*************************)
  (******************************)
  (*   t120 = { int32#; int }   *)
  (******************************)
  (***********************************)
  (*   t121 = { int32#; int; int }   *)
  (***********************************)
  (**************************************)
  (*   t122 = { int32#; int; int32# }   *)
  (**************************************)
  (********************************)
  (*   t123 = { int32#; int64 }   *)
  (********************************)
  (*********************************)
  (*   t124 = { int32#; int64# }   *)
  (*********************************)
  (*********************************)
  (*   t125 = { int32#; int32# }   *)
  (*********************************)
  (**************************************)
  (*   t126 = { int32#; int32#; int }   *)
  (**************************************)
  (*****************************************)
  (*   t127 = { int32#; int32#; int32# }   *)
  (*****************************************)
  (*************************************)
  (*   t128 = { int32#; nativeint# }   *)
  (*************************************)
  (********************************)
  (*   t129 = { int32#; float }   *)
  (********************************)
  (***********************************)
  (*   t130 = { int32#; #{ int } }   *)
  (***********************************)
  (****************************************)
  (*   t131 = { int32#; #{ int; int } }   *)
  (****************************************)
  (*******************************************)
  (*   t132 = { int32#; #{ int; int32# } }   *)
  (*******************************************)
  (**************************************)
  (*   t133 = { int32#; #{ int32# } }   *)
  (**************************************)
  (*******************************************)
  (*   t134 = { int32#; #{ int32#; int } }   *)
  (*******************************************)
  (**********************************************)
  (*   t135 = { int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  (*****************************)
  (*   t136 = { nativeint# }   *)
  (*****************************)
  (**********************************)
  (*   t137 = { nativeint#; int }   *)
  (**********************************)
  (************************************)
  (*   t138 = { nativeint#; int64 }   *)
  (************************************)
  (*************************************)
  (*   t139 = { nativeint#; int64# }   *)
  (*************************************)
  (*************************************)
  (*   t140 = { nativeint#; int32# }   *)
  (*************************************)
  (*****************************************)
  (*   t141 = { nativeint#; nativeint# }   *)
  (*****************************************)
  (************************************)
  (*   t142 = { nativeint#; float }   *)
  (************************************)
  (************************)
  (*   t143 = { float }   *)
  (************************)
  (*****************************)
  (*   t144 = { float; int }   *)
  (*****************************)
  (**********************************)
  (*   t145 = { float; int; int }   *)
  (**********************************)
  (************************************)
  (*   t146 = { float; int; float }   *)
  (************************************)
  (*******************************)
  (*   t147 = { float; int64 }   *)
  (*******************************)
  (********************************)
  (*   t148 = { float; int64# }   *)
  (********************************)
  (********************************)
  (*   t149 = { float; int32# }   *)
  (********************************)
  (************************************)
  (*   t150 = { float; nativeint# }   *)
  (************************************)
  (*******************************)
  (*   t151 = { float; float }   *)
  (*******************************)
  (************************************)
  (*   t152 = { float; float; int }   *)
  (************************************)
  (**************************************)
  (*   t153 = { float; float; float }   *)
  (**************************************)
  (**********************************)
  (*   t154 = { float; #{ int } }   *)
  (**********************************)
  (***************************************)
  (*   t155 = { float; #{ int; int } }   *)
  (***************************************)
  (*****************************************)
  (*   t156 = { float; #{ int; float } }   *)
  (*****************************************)
  (************************************)
  (*   t157 = { float; #{ float } }   *)
  (************************************)
  (*****************************************)
  (*   t158 = { float; #{ float; int } }   *)
  (*****************************************)
  (*******************************************)
  (*   t159 = { float; #{ float; float } }   *)
  (*******************************************)
  (***************************)
  (*   t160 = { #{ int } }   *)
  (***************************)
  (********************************)
  (*   t161 = { #{ int }; int }   *)
  (********************************)
  (***********************************)
  (*   t162 = { #{ int }; int32# }   *)
  (***********************************)
  (**********************************)
  (*   t163 = { #{ int }; float }   *)
  (**********************************)
  (********************************)
  (*   t164 = { #{ int; int } }   *)
  (********************************)
  (*************************************)
  (*   t165 = { #{ int; int }; int }   *)
  (*************************************)
  (****************************************)
  (*   t166 = { #{ int; int }; int32# }   *)
  (****************************************)
  (***************************************)
  (*   t167 = { #{ int; int }; float }   *)
  (***************************************)
  (***********************************)
  (*   t168 = { #{ int; int32# } }   *)
  (***********************************)
  (****************************************)
  (*   t169 = { #{ int; int32# }; int }   *)
  (****************************************)
  (*******************************************)
  (*   t170 = { #{ int; int32# }; int32# }   *)
  (*******************************************)
  (**********************************)
  (*   t171 = { #{ int; float } }   *)
  (**********************************)
  (***************************************)
  (*   t172 = { #{ int; float }; int }   *)
  (***************************************)
  (*****************************************)
  (*   t173 = { #{ int; float }; float }   *)
  (*****************************************)
  (**********************************************************)
  (*   t176 = { #{ int64; int64# }; #{ int64#; float# } }   *)
  (**********************************************************)
  (**********************************************************)
  (*   t179 = { #{ int64; string }; #{ int64#; string } }   *)
  (**********************************************************)
  (********************************************************)
  (*   t181 = { #{ int64#; int64 }; #{ int64; int64 } }   *)
  (********************************************************)
  (***********************************************************)
  (*   t183 = { #{ int64#; int64 }; #{ float32#; float } }   *)
  (***********************************************************)
  (******************************)
  (*   t184 = { #{ int32# } }   *)
  (******************************)
  (***********************************)
  (*   t185 = { #{ int32# }; int }   *)
  (***********************************)
  (**************************************)
  (*   t186 = { #{ int32# }; int32# }   *)
  (**************************************)
  (***********************************)
  (*   t187 = { #{ int32#; int } }   *)
  (***********************************)
  (****************************************)
  (*   t188 = { #{ int32#; int }; int }   *)
  (****************************************)
  (*******************************************)
  (*   t189 = { #{ int32#; int }; int32# }   *)
  (*******************************************)
  (**************************************)
  (*   t190 = { #{ int32#; int32# } }   *)
  (**************************************)
  (*******************************************)
  (*   t191 = { #{ int32#; int32# }; int }   *)
  (*******************************************)
  (**********************************************)
  (*   t192 = { #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  (*****************************)
  (*   t193 = { #{ float } }   *)
  (*****************************)
  (**********************************)
  (*   t194 = { #{ float }; int }   *)
  (**********************************)
  (************************************)
  (*   t195 = { #{ float }; float }   *)
  (************************************)
  (**********************************)
  (*   t196 = { #{ float; int } }   *)
  (**********************************)
  (***************************************)
  (*   t197 = { #{ float; int }; int }   *)
  (***************************************)
  (*****************************************)
  (*   t198 = { #{ float; int }; float }   *)
  (*****************************************)
  (************************************)
  (*   t199 = { #{ float; float } }   *)
  (************************************)
  (*****************************************)
  (*   t200 = { #{ float; float }; int }   *)
  (*****************************************)
  (*******************************************)
  (*   t201 = { #{ float; float }; float }   *)
  (*******************************************)
  (*************************************************************)
  (*   t204 = { #{ float32#; int64# }; #{ string; int64# } }   *)
  (*************************************************************)
  ()

let () =
  print_endline "test_array_idx_with_makearray_dynamic";
  iter sizes ~f:test_array_idx_with_makearray_dynamic;
  print_endline "test_array_idx_with_makearray_dynamic_local";
  iter sizes ~f:test_array_idx_with_makearray_dynamic_local;
  ()
;;

for i = 1 to 2762 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
