
(* One of the tests. *)
type t =
  { mod_name : string;
    elt_type : string;
    array_type : string;
    of_int : string;
    array_elt_of_int : string;
    init : string;
    eq : string
  }

let int64 = {
  mod_name = "Int64";
  elt_type = "int64#";
  array_type = "int64# array";
  of_int = "Int64_u.of_int";
  array_elt_of_int = "Int64_u.of_int";
  init = "init_int64";
  eq = "Int64_u.equal"
}

let float64 = {
  mod_name = "Float64";
  elt_type = "float#";
  array_type = "floatarray";
  of_int = "Float_u.of_int";
  array_elt_of_int = "Float.of_int";
  init = "Float.ArrayLabels.init";
  eq = "Float_u.equal"
}

let string = {
  mod_name = "Strings";
  elt_type = "string";
  array_type = "string array";
  of_int = "string_of_int";
  array_elt_of_int = "string_of_int";
  init = "ArrayLabels.init";
  eq = "String.equal";
}

let types = [int64; float64; string]

let line ?(indent = 0) fmt =
  Printf.ksprintf
    (fun s ->
       let indent = Seq.init indent (fun _ -> ' ') |> String.of_seq in
       print_endline (indent ^ s))
    fmt

(* let reference_arrays n =
 *   let a = Array.init n (fun i -> i) in
 *   a.(3) <- 4; a *)

let reference_arrays n =
  let a1 = Array.init n (fun i -> i) in
  let a2 = Array.init n (fun i -> i) in
  let set_four i =
    a2.(i) <- i + 1000;
    a2.(i+1) <- i + 1001;
    a2.(i+2) <- i + 1002;
    a2.(i+3) <- i + 1003
  in
  set_four 0;
  set_four (n/2);
  set_four (n-4);
  a1, a2

(* Produces a series of reads, reading [i+1] elements starting at index [i], until
   [i+i+1 = n]. Compares them against the known correct values in [reference]. *)
let rec read_vals t n i reference =
  if i + i + 1 > n then () else begin
    if i = 0 then begin
      line "    let x0 : elt = reinterp_get a 0 in";
      line "    assert (%s x0 (%s %d));" t.eq t.of_int (reference.(0));
    end else begin
      let vars = Array.init (i+1) (fun x -> Format.sprintf "x%d" (i+x)) in
      let tuple = Format.sprintf "#(%s)" (String.concat ", " (Array.to_list vars)) in
      let tuple_type =
        Format.sprintf "#(%s)" (String.concat " * " (List.init (i+1) (fun _ -> "elt")))
      in
      line "    let %s : %s = reinterp_get a %d in" tuple tuple_type i;
      for x = 0 to i do
        line "    assert (%s %s (%s %d));" t.eq vars.(x) t.of_int (reference.(i+x))
      done;
    end;
    read_vals t n (i + 1) reference
  end

(* A series of overlapping writes to the array that results in adding 1000 to
   elements [0,3], [len/2,len/2+3], and [len-4,len-1]. *)
let write_vals t n =
  let garbage = 123456 in
  let final_val i = i + 1000 in
  let write_four i =
    line "    reinterp_set a %d #(%s %d, %s %d, %s %d, %s %d);"
      i t.of_int garbage t.of_int garbage t.of_int garbage t.of_int
      (final_val (i+3));
    line "    reinterp_set a %d #(%s %d, %s %d, %s %d);"
      i t.of_int garbage t.of_int garbage t.of_int (final_val (i+2));
    line "    reinterp_set a %d #(%s %d, %s %d);"
      i t.of_int garbage t.of_int (final_val (i+1));
    line "    reinterp_set a %d (%s %d);"
      i t.of_int (final_val i)
  in
  write_four 0;
  write_four (n/2);
  write_four (n-4)

let for_type n t =
  let ref1, ref2 = reference_arrays n in
  line "";
  line "module %s = struct" t.mod_name;
  line "  type elt = %s" t.elt_type;
  line "  type t = %s" t.array_type;
  line {|
  external[@layout_poly] reinterp_get :
    ('a : any). t -> int -> 'a = "%%obj_reinterp_array_unsafe_get"

  external[@layout_poly] reinterp_set :
    ('a : any). t -> int -> 'a -> unit = "%%obj_reinterp_array_unsafe_set"

  |};
  line "  let a = %s %d ~f:(fun i -> %s i)" t.init n t.array_elt_of_int;
  line "";
  line "  let _ = begin";
  read_vals t n 0 ref1;
  line "";
  write_vals t n;
  line "";
  read_vals t n 0 ref2;
  line "  end";
  line "  end"

let main n =
  (* Don't overrepresent all-float mixed blocks. *)
  line {|(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 flags = "-extension layouts_beta";
 flambda2;
 {
   native;
 }|};
 (* CR ccasinghino: In the future, this may work in bytecode. *)
 (*  line {| {
  *   bytecode;
  * }|}; *)
  line {|*)|};
  line "(** This is code generated by [generate_array_reinterp_tests.ml]. *)";
  line "";
  line "open Stdlib_upstream_compatible";
  line "";
  line {|external[@layout_poly] unsafe_set :
  ('a : any_non_null). 'a array -> int -> 'a -> unit
  = "%%array_unsafe_set"

  external create_int64_array
    :  int -> int64# array
    = "caml_make_unboxed_int64_vect_bytecode" "caml_make_unboxed_int64_vect"

  let init_int64 len ~f =
    let r = create_int64_array len in
    for i = 0 to len - 1 do
      unsafe_set r i (f i)
    done;
    r
|};
  line "";
  List.iter (for_type n) types

let () =
  let n =
    match Sys.argv with
    | [| _; n |] ->
      let n = int_of_string n in
      if n mod 2 = 0 || n < 15 then
        failwith "N must be odd and at least 15";
      n
    | _ -> failwith (Printf.sprintf "Usage: %s N" Sys.argv.(0))
  in
  main n
