(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [generate_array_idx_tests.ml]. *)



[@@@ocaml.warning "-23"]

open Stdlib_upstream_compatible
open Stdlib_stable

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] get_idx_imm :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_imm -> ('b [@local_opt]) =
  "%unsafe_get_idx_imm"

external[@layout_poly] get_idx_mut :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) =
  "%unsafe_get_idx"

external[@layout_poly] set_idx_mut :
  'a ('b : any).
    ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) -> unit =
  "%unsafe_set_idx"

module Idx_repr : sig
  type t
  val of_idx_imm : 'a ('b : any). ('a, 'b) idx_imm -> t
  val of_idx_mut : 'a ('b : any). ('a, 'b) idx_mut -> t
  val equal : t -> t -> bool
  val debug_string : t -> string
end = struct
  (* See Note [Representation of block indices] in [lambda/translcore.ml] *)
  type t =
    | Bytecode of { path : int list }
    | Native of { offset : int; gap : int }

  external magic_box_bits64 : ('a : bits64) 'b . 'a -> 'b =
    "%box_int64"
  external lessthan_if_bytecode : int -> int -> bool =
    "caml_lessthan" "caml_greaterthan"

  let of_idx idx =
    let is_bytecode = lessthan_if_bytecode 0 1 in
    if is_bytecode then
      let r = Obj.repr (magic_box_bits64 idx) in
      let nth_idx n : int = Obj.magic (Obj.field r n) in
      let path = List.init (Obj.size r) nth_idx in
      Bytecode { path }
    else
      let i : int64 = magic_box_bits64 idx in
      let offset =
        Int64.(logand (sub (shift_left one 48) one)) i
        |> Int64.to_int
      in
      let gap =
        Int64.shift_right i 48
        |> Int64.to_int
      in
      Native { offset; gap }

  let of_idx_imm = of_idx
  let of_idx_mut = of_idx

  let equal t1 t2 =
    match t1, t2 with
    | Bytecode { path = path1 }, Bytecode { path = path2 } ->
      List.equal Int.equal path1 path2
    | Native { gap = gap1; offset = offset1 },
      Native { gap = gap2; offset = offset2 } ->
      Int.equal gap1 gap2 && Int.equal offset1 offset2
    | Bytecode _, Native _ | Native _, Bytecode _ -> assert false

  let debug_string = function
    | Bytecode { path } ->
      Printf.sprintf "{ %s }"
        (String.concat "; " (List.map Int.to_string path))
    | Native { offset; gap } ->
      Printf.sprintf "offset %d; gap %d" offset gap
end

let failwithf fmt = Printf.ksprintf failwith fmt

external globalize : local_ 'a -> 'a = "%obj_dup";;

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

let tests_run = ref []

let mark_test_run test_id =
  if not (List.mem test_id !tests_run) then
    tests_run := test_id :: !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30; 31; 32 ]

let indices_in_deepening_tests = [0; 1; 2; 100_000]


type t0 = #{ a0 : int64#; b0 : float# }
type t1 = #{ a1 : int64# }
type t2 = #{ a2 : int; b2 : int64# }
type t3 = #{ a3 : t2; b3 : t1 }

(* Catch metaprogramming errors early *)
let () =
  (* Check types and constants *)
  let _ : int = 0 in
  let _ : int64 = 0L in
  let _ : float32# = #0.s in
  let _ : float# = #0. in
  let _ : int32# = #0l in
  let _ : int64# = #0L in
  let _ : nativeint# = #0n in
  let _ : float32 = 0.s in
  let _ : int32 = 0l in
  let _ : nativeint = 0n in
  let _ : int = 0 in
  let _ : t0 = (#{ a0 = #0L; b0 = #1. } : t0) in
  let _ : t1 = (#{ a1 = #0L } : t1) in
  let _ : t3 = (#{ a3 = (#{ a2 = 0; b2 = #1L } : t2); b3 = (#{ a1 = #2L } : t1) } : t3) in
  let _ : t2 = (#{ a2 = 0; b2 = #1L } : t2) in
  let _ : #(float# * int32# * int64#) = #(#0., #1l, #2L) in
  let _ : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) = #(#0., #(#1L, #2L), #3.s, #(#4l, #(#5.s, #6.)), #7L) in
  let _ : #(int64# * t0) = #(#0L, (#{ a0 = #1L; b0 = #2. } : t0)) in
  let _ : #(int * int64) = #(0, 1L) in
  let _ : #(int64 option * int32 * #(int32 * float) * float) = #(None, 1l, #(2l, 3.), 4.) in
  let _ : #(float * float * float) = #(0., 1., 2.) in
  let _ : #(float * #(float * float) * #(float * #(float * float * float))) = #(0., #(1., 2.), #(3., #(4., 5., 6.))) in
  (* Check equality and mk_value functions *)
  let eq : int @ local -> int @ local -> bool = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  mark_test_run 1;
  let test = eq (mk_value 1) 1 in
  if not test then failwithf "test 1 failed";
  mark_test_run 2;
  let test = eq 1 1 in
  if not test then failwithf "test 2 failed";
  mark_test_run 3;
  let test = not (eq 1 2) in
  if not test then failwithf "test 3 failed";
  let eq : int64 @ local -> int64 @ local -> bool = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  mark_test_run 4;
  let test = eq (mk_value 1) 1L in
  if not test then failwithf "test 4 failed";
  mark_test_run 5;
  let test = eq 1L 1L in
  if not test then failwithf "test 5 failed";
  mark_test_run 6;
  let test = not (eq 1L 2L) in
  if not test then failwithf "test 6 failed";
  let eq : float32# @ local -> float32# @ local -> bool = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int (i + 0) in
  mark_test_run 7;
  let test = eq (mk_value 1) #1.s in
  if not test then failwithf "test 7 failed";
  mark_test_run 8;
  let test = eq #1.s #1.s in
  if not test then failwithf "test 8 failed";
  mark_test_run 9;
  let test = not (eq #1.s #2.s) in
  if not test then failwithf "test 9 failed";
  let eq : float# @ local -> float# @ local -> bool = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  mark_test_run 10;
  let test = eq (mk_value 1) #1. in
  if not test then failwithf "test 10 failed";
  mark_test_run 11;
  let test = eq #1. #1. in
  if not test then failwithf "test 11 failed";
  mark_test_run 12;
  let test = not (eq #1. #2.) in
  if not test then failwithf "test 12 failed";
  let eq : int32# @ local -> int32# @ local -> bool = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  mark_test_run 13;
  let test = eq (mk_value 1) #1l in
  if not test then failwithf "test 13 failed";
  mark_test_run 14;
  let test = eq #1l #1l in
  if not test then failwithf "test 14 failed";
  mark_test_run 15;
  let test = not (eq #1l #2l) in
  if not test then failwithf "test 15 failed";
  let eq : int64# @ local -> int64# @ local -> bool = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  mark_test_run 16;
  let test = eq (mk_value 1) #1L in
  if not test then failwithf "test 16 failed";
  mark_test_run 17;
  let test = eq #1L #1L in
  if not test then failwithf "test 17 failed";
  mark_test_run 18;
  let test = not (eq #1L #2L) in
  if not test then failwithf "test 18 failed";
  let eq : nativeint# @ local -> nativeint# @ local -> bool = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  mark_test_run 19;
  let test = eq (mk_value 1) #1n in
  if not test then failwithf "test 19 failed";
  mark_test_run 20;
  let test = eq #1n #1n in
  if not test then failwithf "test 20 failed";
  mark_test_run 21;
  let test = not (eq #1n #2n) in
  if not test then failwithf "test 21 failed";
  let eq : float32 @ local -> float32 @ local -> bool = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int (i + 0) in
  mark_test_run 22;
  let test = eq (mk_value 1) 1.s in
  if not test then failwithf "test 22 failed";
  mark_test_run 23;
  let test = eq 1.s 1.s in
  if not test then failwithf "test 23 failed";
  mark_test_run 24;
  let test = not (eq 1.s 2.s) in
  if not test then failwithf "test 24 failed";
  let eq : int32 @ local -> int32 @ local -> bool = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int (i + 0) in
  mark_test_run 25;
  let test = eq (mk_value 1) 1l in
  if not test then failwithf "test 25 failed";
  mark_test_run 26;
  let test = eq 1l 1l in
  if not test then failwithf "test 26 failed";
  mark_test_run 27;
  let test = not (eq 1l 2l) in
  if not test then failwithf "test 27 failed";
  let eq : nativeint @ local -> nativeint @ local -> bool = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int (i + 0) in
  mark_test_run 28;
  let test = eq (mk_value 1) 1n in
  if not test then failwithf "test 28 failed";
  mark_test_run 29;
  let test = eq 1n 1n in
  if not test then failwithf "test 29 failed";
  mark_test_run 30;
  let test = not (eq 1n 2n) in
  if not test then failwithf "test 30 failed";
  let eq : int @ local -> int @ local -> bool = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  mark_test_run 31;
  let test = eq (mk_value 1) 1 in
  if not test then failwithf "test 31 failed";
  mark_test_run 32;
  let test = eq 1 1 in
  if not test then failwithf "test 32 failed";
  mark_test_run 33;
  let test = not (eq 1 2) in
  if not test then failwithf "test 33 failed";
  let eq : t0 @ local -> t0 @ local -> bool = (fun (#{ a0 = a01; b0 = b01 } : t0) (#{ a0 = a02; b0 = b02 } : t0) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a01 a02 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b01 b02) in
  let mk_value i = (#{ a0 = Int64_u.of_int (i + 0); b0 = Float_u.of_int (i + 1) } : t0) in
  mark_test_run 34;
  let test = eq (mk_value 1) (#{ a0 = #1L; b0 = #2. } : t0) in
  if not test then failwithf "test 34 failed";
  mark_test_run 35;
  let test = eq (#{ a0 = #1L; b0 = #2. } : t0) (#{ a0 = #1L; b0 = #2. } : t0) in
  if not test then failwithf "test 35 failed";
  mark_test_run 36;
  let test = not (eq (#{ a0 = #1L; b0 = #2. } : t0) (#{ a0 = #2L; b0 = #3. } : t0)) in
  if not test then failwithf "test 36 failed";
  let eq : t1 @ local -> t1 @ local -> bool = (fun (#{ a1 = a11 } : t1) (#{ a1 = a12 } : t1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a11 a12) in
  let mk_value i = (#{ a1 = Int64_u.of_int (i + 0) } : t1) in
  mark_test_run 37;
  let test = eq (mk_value 1) (#{ a1 = #1L } : t1) in
  if not test then failwithf "test 37 failed";
  mark_test_run 38;
  let test = eq (#{ a1 = #1L } : t1) (#{ a1 = #1L } : t1) in
  if not test then failwithf "test 38 failed";
  mark_test_run 39;
  let test = not (eq (#{ a1 = #1L } : t1) (#{ a1 = #2L } : t1)) in
  if not test then failwithf "test 39 failed";
  let eq : t3 @ local -> t3 @ local -> bool = (fun (#{ a3 = a31; b3 = b31 } : t3) (#{ a3 = a32; b3 = b32 } : t3) -> (fun (#{ a2 = a21; b2 = b21 } : t2) (#{ a2 = a22; b2 = b22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b21 b22) a31 a32 && (fun (#{ a1 = a11 } : t1) (#{ a1 = a12 } : t1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a11 a12) b31 b32) in
  let mk_value i = (#{ a3 = (#{ a2 = (i + 0); b2 = Int64_u.of_int (i + 1) } : t2); b3 = (#{ a1 = Int64_u.of_int (i + 2) } : t1) } : t3) in
  mark_test_run 40;
  let test = eq (mk_value 1) (#{ a3 = (#{ a2 = 1; b2 = #2L } : t2); b3 = (#{ a1 = #3L } : t1) } : t3) in
  if not test then failwithf "test 40 failed";
  mark_test_run 41;
  let test = eq (#{ a3 = (#{ a2 = 1; b2 = #2L } : t2); b3 = (#{ a1 = #3L } : t1) } : t3) (#{ a3 = (#{ a2 = 1; b2 = #2L } : t2); b3 = (#{ a1 = #3L } : t1) } : t3) in
  if not test then failwithf "test 41 failed";
  mark_test_run 42;
  let test = not (eq (#{ a3 = (#{ a2 = 1; b2 = #2L } : t2); b3 = (#{ a1 = #3L } : t1) } : t3) (#{ a3 = (#{ a2 = 2; b2 = #3L } : t2); b3 = (#{ a1 = #4L } : t1) } : t3)) in
  if not test then failwithf "test 42 failed";
  let eq : t2 @ local -> t2 @ local -> bool = (fun (#{ a2 = a21; b2 = b21 } : t2) (#{ a2 = a22; b2 = b22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b21 b22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = Int64_u.of_int (i + 1) } : t2) in
  mark_test_run 43;
  let test = eq (mk_value 1) (#{ a2 = 1; b2 = #2L } : t2) in
  if not test then failwithf "test 43 failed";
  mark_test_run 44;
  let test = eq (#{ a2 = 1; b2 = #2L } : t2) (#{ a2 = 1; b2 = #2L } : t2) in
  if not test then failwithf "test 44 failed";
  mark_test_run 45;
  let test = not (eq (#{ a2 = 1; b2 = #2L } : t2) (#{ a2 = 2; b2 = #3L } : t2)) in
  if not test then failwithf "test 45 failed";
  let eq : #(float# * int32# * int64#) @ local -> #(float# * int32# * int64#) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int (i + 0), Int32_u.of_int (i + 1), Int64_u.of_int (i + 2)) in
  mark_test_run 46;
  let test = eq (mk_value 1) #(#1., #2l, #3L) in
  if not test then failwithf "test 46 failed";
  mark_test_run 47;
  let test = eq #(#1., #2l, #3L) #(#1., #2l, #3L) in
  if not test then failwithf "test 47 failed";
  mark_test_run 48;
  let test = not (eq #(#1., #2l, #3L) #(#2., #3l, #4L)) in
  if not test then failwithf "test 48 failed";
  let eq : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int (i + 0), #(Int64_u.of_int (i + 1), Int64_u.of_int (i + 2)), Float32_u.of_int (i + 3), #(Int32_u.of_int (i + 4), #(Float32_u.of_int (i + 5), Float_u.of_int (i + 6))), Int64_u.of_int (i + 7)) in
  mark_test_run 49;
  let test = eq (mk_value 1) #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) in
  if not test then failwithf "test 49 failed";
  mark_test_run 50;
  let test = eq #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) in
  if not test then failwithf "test 50 failed";
  mark_test_run 51;
  let test = not (eq #(#1., #(#2L, #3L), #4.s, #(#5l, #(#6.s, #7.)), #8L) #(#2., #(#3L, #4L), #5.s, #(#6l, #(#7.s, #8.)), #9L)) in
  if not test then failwithf "test 51 failed";
  let eq : #(int64# * t0) @ local -> #(int64# * t0) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a0 = a01; b0 = b01 } : t0) (#{ a0 = a02; b0 = b02 } : t0) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a01 a02 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b01 b02) a1 b1) in
  let mk_value i = #(Int64_u.of_int (i + 0), (#{ a0 = Int64_u.of_int (i + 1); b0 = Float_u.of_int (i + 2) } : t0)) in
  mark_test_run 52;
  let test = eq (mk_value 1) #(#1L, (#{ a0 = #2L; b0 = #3. } : t0)) in
  if not test then failwithf "test 52 failed";
  mark_test_run 53;
  let test = eq #(#1L, (#{ a0 = #2L; b0 = #3. } : t0)) #(#1L, (#{ a0 = #2L; b0 = #3. } : t0)) in
  if not test then failwithf "test 53 failed";
  mark_test_run 54;
  let test = not (eq #(#1L, (#{ a0 = #2L; b0 = #3. } : t0)) #(#2L, (#{ a0 = #3L; b0 = #4. } : t0))) in
  if not test then failwithf "test 54 failed";
  let eq : #(int * int64) @ local -> #(int * int64) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #((i + 0), Int64.of_int (i + 1)) in
  mark_test_run 55;
  let test = eq (mk_value 1) #(1, 2L) in
  if not test then failwithf "test 55 failed";
  mark_test_run 56;
  let test = eq #(1, 2L) #(1, 2L) in
  if not test then failwithf "test 56 failed";
  mark_test_run 57;
  let test = not (eq #(1, 2L) #(2, 3L)) in
  if not test then failwithf "test 57 failed";
  let eq : #(int64 option * int32 * #(int32 * float) * float) @ local -> #(int64 option * int32 * #(int32 * float) * float) @ local -> bool = (fun #(a0, a1, a2, a3) #(b0, b1, b2, b3) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a2 b2 && (fun a b -> Float.equal (globalize a) (globalize b)) a3 b3) in
  let mk_value i = #((if (i + 0) == 0 then None else Some (Int64.of_int (i + 0))), Int32.of_int (i + 1), #(Int32.of_int (i + 2), Float.of_int (i + 3)), Float.of_int (i + 4)) in
  mark_test_run 58;
  let test = eq (mk_value 1) #(Some 1L, 2l, #(3l, 4.), 5.) in
  if not test then failwithf "test 58 failed";
  mark_test_run 59;
  let test = eq #(Some 1L, 2l, #(3l, 4.), 5.) #(Some 1L, 2l, #(3l, 4.), 5.) in
  if not test then failwithf "test 59 failed";
  mark_test_run 60;
  let test = not (eq #(Some 1L, 2l, #(3l, 4.), 5.) #(Some 2L, 3l, #(4l, 5.), 6.)) in
  if not test then failwithf "test 60 failed";
  let eq : #(float * float * float) @ local -> #(float * float * float) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), Float.of_int (i + 1), Float.of_int (i + 2)) in
  mark_test_run 61;
  let test = eq (mk_value 1) #(1., 2., 3.) in
  if not test then failwithf "test 61 failed";
  mark_test_run 62;
  let test = eq #(1., 2., 3.) #(1., 2., 3.) in
  if not test then failwithf "test 62 failed";
  mark_test_run 63;
  let test = not (eq #(1., 2., 3.) #(2., 3., 4.)) in
  if not test then failwithf "test 63 failed";
  let eq : #(float * #(float * float) * #(float * #(float * float * float))) @ local -> #(float * #(float * float) * #(float * #(float * float * float))) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), #(Float.of_int (i + 1), Float.of_int (i + 2)), #(Float.of_int (i + 3), #(Float.of_int (i + 4), Float.of_int (i + 5), Float.of_int (i + 6)))) in
  mark_test_run 64;
  let test = eq (mk_value 1) #(1., #(2., 3.), #(4., #(5., 6., 7.))) in
  if not test then failwithf "test 64 failed";
  mark_test_run 65;
  let test = eq #(1., #(2., 3.), #(4., #(5., 6., 7.))) #(1., #(2., 3.), #(4., #(5., 6., 7.))) in
  if not test then failwithf "test 65 failed";
  mark_test_run 66;
  let test = not (eq #(1., #(2., 3.), #(4., #(5., 6., 7.))) #(2., #(3., 4.), #(5., #(6., 7., 8.)))) in
  if not test then failwithf "test 66 failed";
  ()
;;

let test_array_idx_with_makearray_dynamic size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 67;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 67 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 68;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 68 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 69;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 69 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 70;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 70 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic size #0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 71;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 71 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 72;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 72 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic size #0. in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 73;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 73 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 74;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 74 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 75;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 75 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 76;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 76 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 77;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 77 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 78;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 78 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 79;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 79 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 80;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 80 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic size 0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 81;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 81 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 82;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 82 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic size 0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 83;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 83 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 84;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 84 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic size 0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 85;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 85 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 86;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 86 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 87;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 87 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 88;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 88 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t0   *)
  (**********)
  let eq = (fun (#{ a0 = a01; b0 = b01 } : t0) (#{ a0 = a02; b0 = b02 } : t0) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a01 a02 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b01 b02) in
  let mk_value i = (#{ a0 = Int64_u.of_int (i + 0); b0 = Float_u.of_int (i + 1) } : t0) in
  (* 1. Create an array of size [size] *)
  let a : t0 array = makearray_dynamic size (#{ a0 = #0L; b0 = #1. } : t0) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 89;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 89 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 90;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 90 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a0 *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 91;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 91 failed %d %d" size i;
    (* .#b0 *)
    let el = #{ el with b0 = next_el.#b0 } in
    set_idx_mut a ((.(i).#b0) : (t0 array, _) idx_mut) next_el.#b0;
    mark_test_run 92;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 92 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t1   *)
  (**********)
  let eq = (fun (#{ a1 = a11 } : t1) (#{ a1 = a12 } : t1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a11 a12) in
  let mk_value i = (#{ a1 = Int64_u.of_int (i + 0) } : t1) in
  (* 1. Create an array of size [size] *)
  let a : t1 array = makearray_dynamic size (#{ a1 = #0L } : t1) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 93;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 93 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 94;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 94 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a1 *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 95;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 95 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t3   *)
  (**********)
  let eq = (fun (#{ a3 = a31; b3 = b31 } : t3) (#{ a3 = a32; b3 = b32 } : t3) -> (fun (#{ a2 = a21; b2 = b21 } : t2) (#{ a2 = a22; b2 = b22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b21 b22) a31 a32 && (fun (#{ a1 = a11 } : t1) (#{ a1 = a12 } : t1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a11 a12) b31 b32) in
  let mk_value i = (#{ a3 = (#{ a2 = (i + 0); b2 = Int64_u.of_int (i + 1) } : t2); b3 = (#{ a1 = Int64_u.of_int (i + 2) } : t1) } : t3) in
  (* 1. Create an array of size [size] *)
  let a : t3 array = makearray_dynamic size (#{ a3 = (#{ a2 = 0; b2 = #1L } : t2); b3 = (#{ a1 = #2L } : t1) } : t3) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 96 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 97;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 97 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a3 *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 98;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 98 failed %d %d" size i;
    (* .#b3 *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 99;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 99 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a3.#a2 *)
    let el = #{ el with a3 = #{ el.#a3 with a2 = next_el.#a3.#a2 } } in
    set_idx_mut a ((.(i).#a3.#a2) : (t3 array, _) idx_mut) next_el.#a3.#a2;
    mark_test_run 100;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 100 failed %d %d" size i;
    (* .#a3.#b2 *)
    let el = #{ el with a3 = #{ el.#a3 with b2 = next_el.#a3.#b2 } } in
    set_idx_mut a ((.(i).#a3.#b2) : (t3 array, _) idx_mut) next_el.#a3.#b2;
    mark_test_run 101;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 101 failed %d %d" size i;
    (* .#b3.#a1 *)
    let el = #{ el with b3 = #{ el.#b3 with a1 = next_el.#b3.#a1 } } in
    set_idx_mut a ((.(i).#b3.#a1) : (t3 array, _) idx_mut) next_el.#b3.#a1;
    mark_test_run 102;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 102 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t2   *)
  (**********)
  let eq = (fun (#{ a2 = a21; b2 = b21 } : t2) (#{ a2 = a22; b2 = b22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b21 b22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = Int64_u.of_int (i + 1) } : t2) in
  (* 1. Create an array of size [size] *)
  let a : t2 array = makearray_dynamic size (#{ a2 = 0; b2 = #1L } : t2) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 103;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 103 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 104;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 104 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a2 *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 105;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* .#b2 *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 106;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 106 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int (i + 0), Int32_u.of_int (i + 1), Int64_u.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic size #(#0., #1l, #2L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 108;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 108 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int (i + 0), #(Int64_u.of_int (i + 1), Int64_u.of_int (i + 2)), Float32_u.of_int (i + 3), #(Int32_u.of_int (i + 4), #(Float32_u.of_int (i + 5), Float_u.of_int (i + 6))), Int64_u.of_int (i + 7)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic size #(#0., #(#1L, #2L), #3.s, #(#4l, #(#5.s, #6.)), #7L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 109;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 109 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 110;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 110 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************)
  (*   #(int64# * t0)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a0 = a01; b0 = b01 } : t0) (#{ a0 = a02; b0 = b02 } : t0) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a01 a02 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b01 b02) a1 b1) in
  let mk_value i = #(Int64_u.of_int (i + 0), (#{ a0 = Int64_u.of_int (i + 1); b0 = Float_u.of_int (i + 2) } : t0)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * t0) array = makearray_dynamic size #(#0L, (#{ a0 = #1L; b0 = #2. } : t0)) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 111;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 111 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 112;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 112 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #((i + 0), Int64.of_int (i + 1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic size #(0, 1L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 113;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 113 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 114;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 114 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************************************************)
  (*   #(int64 option * int32 * #(int32 * float) * float)   *)
  (**********************************************************)
  let eq = (fun #(a0, a1, a2, a3) #(b0, b1, b2, b3) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a2 b2 && (fun a b -> Float.equal (globalize a) (globalize b)) a3 b3) in
  let mk_value i = #((if (i + 0) == 0 then None else Some (Int64.of_int (i + 0))), Int32.of_int (i + 1), #(Int32.of_int (i + 2), Float.of_int (i + 3)), Float.of_int (i + 4)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * int32 * #(int32 * float) * float) array = makearray_dynamic size #(None, 1l, #(2l, 3.), 4.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 115;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 115 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 116;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 116 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), Float.of_int (i + 1), Float.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic size #(0., 1., 2.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 117;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 117 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 118;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 118 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), #(Float.of_int (i + 1), Float.of_int (i + 2)), #(Float.of_int (i + 3), #(Float.of_int (i + 4), Float.of_int (i + 5), Float.of_int (i + 6)))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic size #(0., #(1., 2.), #(3., #(4., 5., 6.))) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 119;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 119 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  ()

let test_array_idx_with_makearray_dynamic_local size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 121;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 121 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 122;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 122 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 123;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 123 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 124;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 124 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_local size #0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 125;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 125 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 126;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 126 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_local size #0. in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 127;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 127 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 128;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 128 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 129;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 129 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 130;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 130 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 131 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 132;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 132 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 133;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 133 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 134;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 134 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic_local size 0.s in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 135;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 135 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 136;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 136 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic_local size 0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 137;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 137 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 138;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 138 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic_local size 0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 139;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 139 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 140;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 140 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 141;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 141 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 142;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 142 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t0   *)
  (**********)
  let eq = (fun (#{ a0 = a01; b0 = b01 } : t0) (#{ a0 = a02; b0 = b02 } : t0) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a01 a02 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b01 b02) in
  let mk_value i = (#{ a0 = Int64_u.of_int (i + 0); b0 = Float_u.of_int (i + 1) } : t0) in
  (* 1. Create an array of size [size] *)
  let a : t0 array = makearray_dynamic_local size (#{ a0 = #0L; b0 = #1. } : t0) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 143;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 143 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 144;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 144 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a0 *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 145;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 145 failed %d %d" size i;
    (* .#b0 *)
    let el = #{ el with b0 = next_el.#b0 } in
    set_idx_mut a ((.(i).#b0) : (t0 array, _) idx_mut) next_el.#b0;
    mark_test_run 146;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 146 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t1   *)
  (**********)
  let eq = (fun (#{ a1 = a11 } : t1) (#{ a1 = a12 } : t1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a11 a12) in
  let mk_value i = (#{ a1 = Int64_u.of_int (i + 0) } : t1) in
  (* 1. Create an array of size [size] *)
  let a : t1 array = makearray_dynamic_local size (#{ a1 = #0L } : t1) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 147;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 147 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 148;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 148 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a1 *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 149;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 149 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t3   *)
  (**********)
  let eq = (fun (#{ a3 = a31; b3 = b31 } : t3) (#{ a3 = a32; b3 = b32 } : t3) -> (fun (#{ a2 = a21; b2 = b21 } : t2) (#{ a2 = a22; b2 = b22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b21 b22) a31 a32 && (fun (#{ a1 = a11 } : t1) (#{ a1 = a12 } : t1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a11 a12) b31 b32) in
  let mk_value i = (#{ a3 = (#{ a2 = (i + 0); b2 = Int64_u.of_int (i + 1) } : t2); b3 = (#{ a1 = Int64_u.of_int (i + 2) } : t1) } : t3) in
  (* 1. Create an array of size [size] *)
  let a : t3 array = makearray_dynamic_local size (#{ a3 = (#{ a2 = 0; b2 = #1L } : t2); b3 = (#{ a1 = #2L } : t1) } : t3) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 150;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 150 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 151;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 151 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a3 *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 152;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 152 failed %d %d" size i;
    (* .#b3 *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 153;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 153 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a3.#a2 *)
    let el = #{ el with a3 = #{ el.#a3 with a2 = next_el.#a3.#a2 } } in
    set_idx_mut a ((.(i).#a3.#a2) : (t3 array, _) idx_mut) next_el.#a3.#a2;
    mark_test_run 154;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 154 failed %d %d" size i;
    (* .#a3.#b2 *)
    let el = #{ el with a3 = #{ el.#a3 with b2 = next_el.#a3.#b2 } } in
    set_idx_mut a ((.(i).#a3.#b2) : (t3 array, _) idx_mut) next_el.#a3.#b2;
    mark_test_run 155;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 155 failed %d %d" size i;
    (* .#b3.#a1 *)
    let el = #{ el with b3 = #{ el.#b3 with a1 = next_el.#b3.#a1 } } in
    set_idx_mut a ((.(i).#b3.#a1) : (t3 array, _) idx_mut) next_el.#b3.#a1;
    mark_test_run 156;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 156 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********)
  (*   t2   *)
  (**********)
  let eq = (fun (#{ a2 = a21; b2 = b21 } : t2) (#{ a2 = a22; b2 = b22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b21 b22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = Int64_u.of_int (i + 1) } : t2) in
  (* 1. Create an array of size [size] *)
  let a : t2 array = makearray_dynamic_local size (#{ a2 = 0; b2 = #1L } : t2) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 157;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 157 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 158;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 158 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a2 *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 159;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 159 failed %d %d" size i;
    (* .#b2 *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 160;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 160 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int (i + 0), Int32_u.of_int (i + 1), Int64_u.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_local size #(#0., #1l, #2L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 161;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 161 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 162;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 162 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int (i + 0), #(Int64_u.of_int (i + 1), Int64_u.of_int (i + 2)), Float32_u.of_int (i + 3), #(Int32_u.of_int (i + 4), #(Float32_u.of_int (i + 5), Float_u.of_int (i + 6))), Int64_u.of_int (i + 7)) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_local size #(#0., #(#1L, #2L), #3.s, #(#4l, #(#5.s, #6.)), #7L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 163;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 163 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 164;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 164 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************)
  (*   #(int64# * t0)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a0 = a01; b0 = b01 } : t0) (#{ a0 = a02; b0 = b02 } : t0) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a01 a02 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b01 b02) a1 b1) in
  let mk_value i = #(Int64_u.of_int (i + 0), (#{ a0 = Int64_u.of_int (i + 1); b0 = Float_u.of_int (i + 2) } : t0)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * t0) array = makearray_dynamic_local size #(#0L, (#{ a0 = #1L; b0 = #2. } : t0)) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 165;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 165 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 166;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 166 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #((i + 0), Int64.of_int (i + 1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic_local size #(0, 1L) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 167;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 167 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 168;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 168 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**********************************************************)
  (*   #(int64 option * int32 * #(int32 * float) * float)   *)
  (**********************************************************)
  let eq = (fun #(a0, a1, a2, a3) #(b0, b1, b2, b3) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a2 b2 && (fun a b -> Float.equal (globalize a) (globalize b)) a3 b3) in
  let mk_value i = #((if (i + 0) == 0 then None else Some (Int64.of_int (i + 0))), Int32.of_int (i + 1), #(Int32.of_int (i + 2), Float.of_int (i + 3)), Float.of_int (i + 4)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * int32 * #(int32 * float) * float) array = makearray_dynamic_local size #(None, 1l, #(2l, 3.), 4.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 169;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 169 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 170;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 170 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), Float.of_int (i + 1), Float.of_int (i + 2)) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic_local size #(0., 1., 2.) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 171;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 171 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 172;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 172 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int (i + 0), #(Float.of_int (i + 1), Float.of_int (i + 2)), #(Float.of_int (i + 3), #(Float.of_int (i + 4), Float.of_int (i + 5), Float.of_int (i + 6)))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic_local size #(0., #(1., 2.), #(3., #(4., 5., 6.))) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 173;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 173 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 174;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 174 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  ()

(* Test array idx deepening *)
let () =
  (***********)
  (*   int   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int array, _) idx_mut = (.(i)) in
    let shallow : (int array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 175;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 175 failed";
  );

  (*************)
  (*   int64   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64 array, _) idx_mut = (.(i)) in
    let shallow : (int64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 176;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 176 failed";
  );

  (****************)
  (*   float32#   *)
  (****************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (float32# array, _) idx_mut = (.(i)) in
    let shallow : (float32# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 177;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 177 failed";
  );

  (**************)
  (*   float#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (float# array, _) idx_mut = (.(i)) in
    let shallow : (float# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 178;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 178 failed";
  );

  (**************)
  (*   int32#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int32# array, _) idx_mut = (.(i)) in
    let shallow : (int32# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 179;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 179 failed";
  );

  (**************)
  (*   int64#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64# array, _) idx_mut = (.(i)) in
    let shallow : (int64# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 180;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 180 failed";
  );

  (******************)
  (*   nativeint#   *)
  (******************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (nativeint# array, _) idx_mut = (.(i)) in
    let shallow : (nativeint# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 181;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 181 failed";
  );

  (***************)
  (*   float32   *)
  (***************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (float32 array, _) idx_mut = (.(i)) in
    let shallow : (float32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 182;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 182 failed";
  );

  (*************)
  (*   int32   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int32 array, _) idx_mut = (.(i)) in
    let shallow : (int32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 183;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 183 failed";
  );

  (*****************)
  (*   nativeint   *)
  (*****************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (nativeint array, _) idx_mut = (.(i)) in
    let shallow : (nativeint array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 184;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 184 failed";
  );

  (***********)
  (*   int   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int array, _) idx_mut = (.(i)) in
    let shallow : (int array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 185;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 185 failed";
  );

  (**********)
  (*   t0   *)
  (**********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i)) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 186;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 186 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i).#a0) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 187;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 187 failed";
    let shallow : (t0 array, _) idx_mut = (.(i).#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 188;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 188 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i).#b0) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b0) in
    mark_test_run 189;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 189 failed";
    let shallow : (t0 array, _) idx_mut = (.(i).#b0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 190;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 190 failed";
  );

  (**********)
  (*   t1   *)
  (**********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i)) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 191;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 191 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i).#a1) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 192;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 192 failed";
    let shallow : (t1 array, _) idx_mut = (.(i).#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 193;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 193 failed";
  );

  (**********)
  (*   t3   *)
  (**********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i)) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 194;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 194 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#a3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a3) in
    mark_test_run 195;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 195 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 196;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 196 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#b3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b3) in
    mark_test_run 197;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 197 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#b3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 198;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 198 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#a3.#a2) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a3.#a2) in
    mark_test_run 199;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 199 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3) in
    let deepened = (.idx_mut(shallow).#a2) in
    mark_test_run 200;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 200 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3.#a2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 201;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 201 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#a3.#b2) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a3.#b2) in
    mark_test_run 202;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 202 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3) in
    let deepened = (.idx_mut(shallow).#b2) in
    mark_test_run 203;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 203 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3.#b2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 204;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 204 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#b3.#a1) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b3.#a1) in
    mark_test_run 205;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 205 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#b3) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 206;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 206 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#b3.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 207;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 207 failed";
  );

  (**********)
  (*   t2   *)
  (**********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i)) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 208;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 208 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#a2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a2) in
    mark_test_run 209;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 209 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#a2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 210;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 210 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#b2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b2) in
    mark_test_run 211;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 211 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#b2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 212;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 212 failed";
  );

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float# * int32# * int64#) array, _) idx_mut = (.(i)) in
    let shallow : (#(float# * int32# * int64#) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 213;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 213 failed";
  );

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array, _) idx_mut = (.(i)) in
    let shallow : (#(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 214;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 214 failed";
  );

  (**********************)
  (*   #(int64# * t0)   *)
  (**********************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(int64# * t0) array, _) idx_mut = (.(i)) in
    let shallow : (#(int64# * t0) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 215;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 215 failed";
  );

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(int * int64) array, _) idx_mut = (.(i)) in
    let shallow : (#(int * int64) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 216;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 216 failed";
  );

  (**********************************************************)
  (*   #(int64 option * int32 * #(int32 * float) * float)   *)
  (**********************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(int64 option * int32 * #(int32 * float) * float) array, _) idx_mut = (.(i)) in
    let shallow : (#(int64 option * int32 * #(int32 * float) * float) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 217;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 217 failed";
  );

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float * float * float) array, _) idx_mut = (.(i)) in
    let shallow : (#(float * float * float) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 218;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 218 failed";
  );

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (#(float * #(float * float) * #(float * #(float * float * float))) array, _) idx_mut = (.(i)) in
    let shallow : (#(float * #(float * float) * #(float * #(float * float * float))) array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 219;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 219 failed";
  );

  ()
(* *)
let () =
  print_endline "test_array_idx_with_makearray_dynamic";
  iter sizes ~f:test_array_idx_with_makearray_dynamic;
  print_endline "test_array_idx_with_makearray_dynamic_local";
  iter sizes ~f:test_array_idx_with_makearray_dynamic_local;
  ()
;;

for i = 1 to 219 do
  if not (List.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
