(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension simd_beta -extension layouts_alpha";
 flambda2;
 stack-allocation;
 native;
*)
(** This is code generated by [generate_array_idx_tests.ml]. *)

[@@@warning "-23"]
module Metaprogramming_lib__ = struct
  external box_int64x2 : int64x2# -> int64x2 = "%box_vec128"
  external unbox_int64x2 : int64x2 -> int64x2# = "%unbox_vec128"
  external interleave_low_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_low_64" [@@unboxed] [@@builtin]
  external interleave_high_64 : int64x2# -> int64x2# -> int64x2# = "caml_vec128_unreachable" "caml_simd_vec128_interleave_high_64" [@@unboxed] [@@builtin]
  external int64x2_of_int64 : int64 -> int64x2# = "caml_vec128_unreachable" "caml_int64x2_low_of_int64" [@@unboxed] [@@builtin]
  external int64_of_int64x2 : int64x2# -> int64 = "caml_vec128_unreachable" "caml_int64x2_low_to_int64" [@@unboxed] [@@builtin]

  let int64x2_u_equal i1 i2 =
      let a1 = int64_of_int64x2 i1 in
      let b1 = int64_of_int64x2 (interleave_high_64 i1 i1) in
      let a2 = int64_of_int64x2 i2 in
      let b2 = int64_of_int64x2 (interleave_high_64 i2 i2) in
      Int64.equal a1 a2 && Int64.equal b1 b2
end

open Stdlib_upstream_compatible
open Stdlib_stable

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] get_idx_imm :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_imm -> ('b [@local_opt]) =
  "%unsafe_get_idx_imm"

external[@layout_poly] get_idx_mut :
  'a ('b : any). ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) =
  "%unsafe_get_idx"

external[@layout_poly] set_idx_mut :
  'a ('b : any).
    ('a [@local_opt]) -> ('a, 'b) idx_mut -> ('b [@local_opt]) -> unit =
  "%unsafe_set_idx"

module Idx_repr : sig
  type t
  val of_idx_imm : 'a ('b : any). ('a, 'b) idx_imm -> t
  val of_idx_mut : 'a ('b : any). ('a, 'b) idx_mut -> t
  val equal : t -> t -> bool
  val debug_string : t -> string
end = struct
  (* See Note [Representation of block indices] in [lambda/translcore.ml] *)
  type t =
    | Bytecode of { path : int list }
    | Native of { offset : int; gap : int }

  external magic_box_bits64 : ('a : bits64) 'b . 'a -> 'b =
    "%box_int64"
  external lessthan_if_bytecode : int -> int -> bool =
    "caml_lessthan" "caml_greaterthan"

  let of_idx idx =
    let is_bytecode = lessthan_if_bytecode 0 1 in
    if is_bytecode then
      let r = Obj.repr (magic_box_bits64 idx) in
      let nth_idx n : int = Obj.magic (Obj.field r n) in
      let path = List.init (Obj.size r) nth_idx in
      Bytecode { path }
    else
      let i : int64 = magic_box_bits64 idx in
      let offset =
        Int64.(logand (sub (shift_left one 48) one)) i
        |> Int64.to_int
      in
      let gap =
        Int64.shift_right i 48
        |> Int64.to_int
      in
      Native { offset; gap }

  let of_idx_imm = of_idx
  let of_idx_mut = of_idx

  let equal t1 t2 =
    match t1, t2 with
    | Bytecode { path = path1 }, Bytecode { path = path2 } ->
      List.equal Int.equal path1 path2
    | Native { gap = gap1; offset = offset1 },
      Native { gap = gap2; offset = offset2 } ->
      Int.equal gap1 gap2 && Int.equal offset1 offset2
    | Bytecode _, Native _ | Native _, Bytecode _ -> assert false

  let debug_string = function
    | Bytecode { path } ->
      Printf.sprintf "{ %s }"
        (String.concat "; " (List.map Int.to_string path))
    | Native { offset; gap } ->
      Printf.sprintf "offset %d; gap %d" offset gap
end

let failwithf fmt = Printf.ksprintf failwith fmt

external globalize : local_ 'a -> 'a = "%obj_dup";;

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

module Int_set = Set.Make(Int)

let tests_run = ref Int_set.empty

let mark_test_run test_id =
  tests_run := Int_set.add test_id !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30 ]

let indices_in_deepening_tests = [0; 100_000]


type t0 = #{ a0 : int }
type t1 = #{ a1 : int; b1 : int }
type t2 = #{ a2 : int; b2 : int; c2 : int }
type t3 = #{ a3 : int; b3 : int; c3 : int32# }
type t4 = #{ a4 : int; b4 : int; c4 : float }
type t5 = #{ a5 : int; b5 : int32# }
type t6 = #{ a6 : int; b6 : int32#; c6 : int32# }
type t7 = #{ a7 : int; b7 : float }
type t8 = #{ a8 : int; b8 : float; c8 : int }
type t9 = #{ a9 : int; b9 : float; c9 : float }
type t10 = #{ a10 : int; b10 : t0 }
type t11 = #{ a11 : int; b11 : t1 }
type t12 = #{ a12 : int; b12 : t5 }
type t13 = #{ a13 : int; b13 : t7 }
type t14 = #{ a14 : int32# }
type t15 = #{ a15 : int; b15 : t14 }
type t16 = #{ a16 : int32#; b16 : int32# }
type t17 = #{ a17 : int; b17 : t16 }
type t18 = #{ a18 : float }
type t19 = #{ a19 : int; b19 : t18 }
type t20 = #{ a20 : float; b20 : int }
type t21 = #{ a21 : int; b21 : t20 }
type t22 = #{ a22 : float; b22 : float }
type t23 = #{ a23 : int; b23 : t22 }
type t24 = #{ a24 : int64 }
type t25 = #{ a25 : int64# }
type t26 = #{ a26 : int32#; b26 : int32#; c26 : int32# }
type t27 = #{ a27 : int32#; b27 : t14 }
type t28 = #{ a28 : int32#; b28 : t16 }
type t29 = #{ a29 : nativeint# }
type t30 = #{ a30 : float; b30 : int; c30 : int }
type t31 = #{ a31 : float; b31 : int; c31 : float }
type t32 = #{ a32 : float; b32 : float; c32 : int }
type t33 = #{ a33 : float; b33 : float; c33 : float }
type t34 = #{ a34 : float; b34 : t0 }
type t35 = #{ a35 : float; b35 : t1 }
type t36 = #{ a36 : float; b36 : t7 }
type t37 = #{ a37 : float; b37 : t18 }
type t38 = #{ a38 : float; b38 : t20 }
type t39 = #{ a39 : float; b39 : t22 }
type t40 = #{ a40 : t0 }
type t41 = #{ a41 : t0; b41 : int }
type t42 = #{ a42 : t0; b42 : int32# }
type t43 = #{ a43 : t0; b43 : float }
type t44 = #{ a44 : t1 }
type t45 = #{ a45 : t1; b45 : int }
type t46 = #{ a46 : t1; b46 : int32# }
type t47 = #{ a47 : t1; b47 : float }
type t48 = #{ a48 : int; b48 : int64# }
type t49 = #{ a49 : int64#; b49 : float# }
type t50 = #{ a50 : t48; b50 : t49 }
type t51 = #{ a51 : t5 }
type t52 = #{ a52 : t5; b52 : int32# }
type t53 = #{ a53 : t7 }
type t54 = #{ a54 : t7; b54 : int }
type t55 = #{ a55 : t7; b55 : float }
type t56 = #{ a56 : t14 }
type t57 = #{ a57 : t14; b57 : int32# }
type t58 = #{ a58 : t16 }
type t59 = #{ a59 : t16; b59 : int32# }
type t60 = #{ a60 : t18; b60 : int }
type t61 = #{ a61 : t18; b61 : float }
type t62 = #{ a62 : t20 }
type t63 = #{ a63 : t20; b63 : int }
type t64 = #{ a64 : t20; b64 : float }
type t65 = #{ a65 : t22 }
type t66 = #{ a66 : t22; b66 : int }
type t67 = #{ a67 : t22; b67 : float }
type t68 = { mutable a68 : int }
type t69 = { mutable a69 : int; mutable b69 : int }
type t70 = { mutable a70 : int; mutable b70 : int; mutable c70 : int }
type t71 = { mutable a71 : int; mutable b71 : int; mutable c71 : int32# }
type t72 = { mutable a72 : int; mutable b72 : int; mutable c72 : float }
type t73 = { mutable a73 : int; mutable b73 : int; mutable c73 : int64x2# }
type t74 = { mutable a74 : int; mutable b74 : int32# }
type t75 = { mutable a75 : int; mutable b75 : int32#; mutable c75 : int }
type t76 = { mutable a76 : int; mutable b76 : int32#; mutable c76 : int32# }
type t77 = { mutable a77 : int; mutable b77 : float }
type t78 = { mutable a78 : int; mutable b78 : float; mutable c78 : int }
type t79 = { mutable a79 : int; mutable b79 : float; mutable c79 : float }
type t80 = { mutable a80 : int; mutable b80 : int64x2# }
type t81 = { mutable a81 : int; mutable b81 : int64x2#; mutable c81 : int }
type t82 = { mutable a82 : int; mutable b82 : int64x2#; mutable c82 : int64x2# }
type t83 = { mutable a83 : int; mutable b83 : t0 }
type t84 = { mutable a84 : int; mutable b84 : t1 }
type t85 = { mutable a85 : int; mutable b85 : t5 }
type t86 = { mutable a86 : int; mutable b86 : t7 }
type t87 = #{ a87 : int; b87 : int64x2# }
type t88 = { mutable a88 : int; mutable b88 : t87 }
type t89 = { mutable a89 : int; mutable b89 : t14 }
type t90 = #{ a90 : int32#; b90 : int }
type t91 = { mutable a91 : int; mutable b91 : t90 }
type t92 = { mutable a92 : int; mutable b92 : t16 }
type t93 = { mutable a93 : int; mutable b93 : t18 }
type t94 = { mutable a94 : int; mutable b94 : t20 }
type t95 = { mutable a95 : int; mutable b95 : t22 }
type t96 = #{ a96 : int64x2# }
type t97 = { mutable a97 : int; mutable b97 : t96 }
type t98 = #{ a98 : int64x2#; b98 : int }
type t99 = { mutable a99 : int; mutable b99 : t98 }
type t100 = #{ a100 : int64x2#; b100 : int64x2# }
type t101 = { mutable a101 : int; mutable b101 : t100 }
type t102 = { mutable a102 : int64 }
type t103 = { mutable a103 : int64# }
type t104 = { mutable a104 : int32# }
type t105 = { mutable a105 : int32#; mutable b105 : int }
type t106 = { mutable a106 : int32#; mutable b106 : int; mutable c106 : int }
type t107 = { mutable a107 : int32#; mutable b107 : int; mutable c107 : int32# }
type t108 = { mutable a108 : int32#; mutable b108 : int32# }
type t109 = { mutable a109 : int32#; mutable b109 : int32#; mutable c109 : int }
type t110 = { mutable a110 : int32#; mutable b110 : int32#; mutable c110 : int32# }
type t111 = { mutable a111 : int32#; mutable b111 : t0 }
type t112 = { mutable a112 : int32#; mutable b112 : t1 }
type t113 = { mutable a113 : int32#; mutable b113 : t5 }
type t114 = { mutable a114 : int32#; mutable b114 : t14 }
type t115 = { mutable a115 : int32#; mutable b115 : t90 }
type t116 = { mutable a116 : int32#; mutable b116 : t16 }
type t117 = { mutable a117 : nativeint# }
type t118 = { mutable a118 : float }
type t119 = { mutable a119 : float; mutable b119 : int }
type t120 = { mutable a120 : float; mutable b120 : int; mutable c120 : int }
type t121 = { mutable a121 : float; mutable b121 : int; mutable c121 : float }
type t122 = { mutable a122 : float; mutable b122 : float }
type t123 = { mutable a123 : float; mutable b123 : float; mutable c123 : int }
type t124 = { mutable a124 : float; mutable b124 : float; mutable c124 : float }
type t125 = { mutable a125 : float; mutable b125 : t0 }
type t126 = { mutable a126 : float; mutable b126 : t1 }
type t127 = { mutable a127 : float; mutable b127 : t7 }
type t128 = { mutable a128 : float; mutable b128 : t18 }
type t129 = { mutable a129 : float; mutable b129 : t20 }
type t130 = { mutable a130 : float; mutable b130 : t22 }
type t131 = { mutable a131 : int64x2# }
type t132 = { mutable a132 : int64x2#; mutable b132 : int }
type t133 = { mutable a133 : int64x2#; mutable b133 : int; mutable c133 : int }
type t134 = { mutable a134 : int64x2#; mutable b134 : int; mutable c134 : int64x2# }
type t135 = { mutable a135 : int64x2#; mutable b135 : int64x2# }
type t136 = { mutable a136 : int64x2#; mutable b136 : int64x2#; mutable c136 : int }
type t137 = { mutable a137 : int64x2#; mutable b137 : int64x2#; mutable c137 : int64x2# }
type t138 = { mutable a138 : int64x2#; mutable b138 : t0 }
type t139 = { mutable a139 : int64x2#; mutable b139 : t1 }
type t140 = { mutable a140 : int64x2#; mutable b140 : t87 }
type t141 = #{ a141 : string; b141 : float# }
type t142 = { mutable a142 : int64x2#; mutable b142 : t141 }
type t143 = { mutable a143 : int64x2#; mutable b143 : t96 }
type t144 = { mutable a144 : int64x2#; mutable b144 : t98 }
type t145 = { mutable a145 : int64x2#; mutable b145 : t100 }
type t146 = { mutable a146 : t0 }
type t147 = { mutable a147 : t0; mutable b147 : int }
type t148 = { mutable a148 : t0; mutable b148 : int32# }
type t149 = { mutable a149 : t0; mutable b149 : float }
type t150 = { mutable a150 : t0; mutable b150 : int64x2# }
type t151 = { mutable a151 : t1 }
type t152 = { mutable a152 : t1; mutable b152 : int }
type t153 = { mutable a153 : t1; mutable b153 : int32# }
type t154 = { mutable a154 : t1; mutable b154 : float }
type t155 = { mutable a155 : t1; mutable b155 : int64x2# }
type t156 = { mutable a156 : t48; mutable b156 : t49 }
type t157 = { mutable a157 : t5 }
type t158 = { mutable a158 : t5; mutable b158 : int }
type t159 = { mutable a159 : t5; mutable b159 : int32# }
type t160 = { mutable a160 : t7 }
type t161 = { mutable a161 : t7; mutable b161 : int }
type t162 = { mutable a162 : t7; mutable b162 : float }
type t163 = { mutable a163 : t87 }
type t164 = { mutable a164 : t87; mutable b164 : int }
type t165 = { mutable a165 : t87; mutable b165 : int64x2# }
type t166 = { mutable a166 : t14 }
type t167 = { mutable a167 : t14; mutable b167 : int }
type t168 = { mutable a168 : t14; mutable b168 : int32# }
type t169 = { mutable a169 : t90 }
type t170 = { mutable a170 : t90; mutable b170 : int }
type t171 = { mutable a171 : t90; mutable b171 : int32# }
type t172 = { mutable a172 : t16 }
type t173 = { mutable a173 : t16; mutable b173 : int }
type t174 = { mutable a174 : t16; mutable b174 : int32# }
type t175 = { mutable a175 : t18 }
type t176 = { mutable a176 : t18; mutable b176 : int }
type t177 = { mutable a177 : t18; mutable b177 : float }
type t178 = { mutable a178 : t20 }
type t179 = { mutable a179 : t20; mutable b179 : int }
type t180 = { mutable a180 : t20; mutable b180 : float }
type t181 = { mutable a181 : t22 }
type t182 = { mutable a182 : t22; mutable b182 : int }
type t183 = { mutable a183 : t22; mutable b183 : float }
type t184 = { mutable a184 : t96 }
type t185 = { mutable a185 : t96; mutable b185 : int }
type t186 = { mutable a186 : t96; mutable b186 : int64x2# }
type t187 = { mutable a187 : t98 }
type t188 = { mutable a188 : t98; mutable b188 : int }
type t189 = { mutable a189 : t98; mutable b189 : int64x2# }
type t190 = #{ a190 : int64x2#; b190 : string }
type t191 = #{ a191 : int64; b191 : float# }
type t192 = { mutable a192 : t190; mutable b192 : t191 }
type t193 = { mutable a193 : t100 }
type t194 = { mutable a194 : t100; mutable b194 : int }
type t195 = { mutable a195 : t100; mutable b195 : int64x2# }

let test_array_idx_with_makearray_dynamic size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 1;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 1 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 2;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 2 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 3;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 3 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 4;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 4 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 5;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 5 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 6;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 6 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 7;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 7 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 8;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 8 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 9;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 9 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 10;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 10 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  let eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let mk_value i = (#{ a0 = (i + 0) } : t0) in
  (* 1. Create an array of size [size] *)
  let a : t0 array = makearray_dynamic size (#{ a0 = 0 } : t0) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 11;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 11 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 12;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 12 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a0 *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 13;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 13 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  let eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let mk_value i = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) in
  (* 1. Create an array of size [size] *)
  let a : t1 array = makearray_dynamic size (#{ a1 = 0; b1 = 1 } : t1) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 14;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 14 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 15;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 15 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a1 *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 16;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 16 failed %d %d" size i;
    (* .#b1 *)
    let el = #{ el with b1 = next_el.#b1 } in
    set_idx_mut a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 17;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 17 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  let eq = (fun (#{ a2 = a21; b2 = b21; c2 = c21 } : t2) (#{ a2 = a22; b2 = b22; c2 = c22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = (i + 1); c2 = (i + 2) } : t2) in
  (* 1. Create an array of size [size] *)
  let a : t2 array = makearray_dynamic size (#{ a2 = 0; b2 = 1; c2 = 2 } : t2) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 18;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 18 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 19;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 19 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a2 *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 20;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 20 failed %d %d" size i;
    (* .#b2 *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 21;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 21 failed %d %d" size i;
    (* .#c2 *)
    let el = #{ el with c2 = next_el.#c2 } in
    set_idx_mut a ((.(i).#c2) : (t2 array, _) idx_mut) next_el.#c2;
    mark_test_run 22;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 22 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  let eq = (fun (#{ a3 = a31; b3 = b31; c3 = c31 } : t3) (#{ a3 = a32; b3 = b32; c3 = c32 } : t3) -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let mk_value i = (#{ a3 = (i + 0); b3 = (i + 1); c3 = Int32_u.of_int (i + 2) } : t3) in
  (* 1. Create an array of size [size] *)
  let a : t3 array = makearray_dynamic size (#{ a3 = 0; b3 = 1; c3 = #2l } : t3) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 23;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 23 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 24;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 24 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a3 *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 25;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 25 failed %d %d" size i;
    (* .#b3 *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 26;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 26 failed %d %d" size i;
    (* .#c3 *)
    let el = #{ el with c3 = next_el.#c3 } in
    set_idx_mut a ((.(i).#c3) : (t3 array, _) idx_mut) next_el.#c3;
    mark_test_run 27;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 27 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  let eq = (fun (#{ a4 = a41; b4 = b41; c4 = c41 } : t4) (#{ a4 = a42; b4 = b42; c4 = c42 } : t4) -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let mk_value i = (#{ a4 = (i + 0); b4 = (i + 1); c4 = Float.of_int (i + 2) } : t4) in
  (* 1. Create an array of size [size] *)
  let a : t4 array = makearray_dynamic size (#{ a4 = 0; b4 = 1; c4 = 2. } : t4) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 28;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 28 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 29;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 29 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a4 *)
    let el = #{ el with a4 = next_el.#a4 } in
    set_idx_mut a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 30;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 30 failed %d %d" size i;
    (* .#b4 *)
    let el = #{ el with b4 = next_el.#b4 } in
    set_idx_mut a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 31;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 31 failed %d %d" size i;
    (* .#c4 *)
    let el = #{ el with c4 = next_el.#c4 } in
    set_idx_mut a ((.(i).#c4) : (t4 array, _) idx_mut) next_el.#c4;
    mark_test_run 32;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 32 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t5 = #{ int; int32# }   *)
  (*****************************)
  let eq = (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) in
  let mk_value i = (#{ a5 = (i + 0); b5 = Int32_u.of_int (i + 1) } : t5) in
  (* 1. Create an array of size [size] *)
  let a : t5 array = makearray_dynamic size (#{ a5 = 0; b5 = #1l } : t5) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 33;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 33 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 34;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 34 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a5 *)
    let el = #{ el with a5 = next_el.#a5 } in
    set_idx_mut a ((.(i).#a5) : (t5 array, _) idx_mut) next_el.#a5;
    mark_test_run 35;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 35 failed %d %d" size i;
    (* .#b5 *)
    let el = #{ el with b5 = next_el.#b5 } in
    set_idx_mut a ((.(i).#b5) : (t5 array, _) idx_mut) next_el.#b5;
    mark_test_run 36;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 36 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t6 = #{ int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a6 = a61; b6 = b61; c6 = c61 } : t6) (#{ a6 = a62; b6 = b62; c6 = c62 } : t6) -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b61 b62 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c61 c62) in
  let mk_value i = (#{ a6 = (i + 0); b6 = Int32_u.of_int (i + 1); c6 = Int32_u.of_int (i + 2) } : t6) in
  (* 1. Create an array of size [size] *)
  let a : t6 array = makearray_dynamic size (#{ a6 = 0; b6 = #1l; c6 = #2l } : t6) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 37;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 37 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 38;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 38 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a6 *)
    let el = #{ el with a6 = next_el.#a6 } in
    set_idx_mut a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 39;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 39 failed %d %d" size i;
    (* .#b6 *)
    let el = #{ el with b6 = next_el.#b6 } in
    set_idx_mut a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 40;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 40 failed %d %d" size i;
    (* .#c6 *)
    let el = #{ el with c6 = next_el.#c6 } in
    set_idx_mut a ((.(i).#c6) : (t6 array, _) idx_mut) next_el.#c6;
    mark_test_run 41;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 41 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t7 = #{ int; float }   *)
  (****************************)
  let eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) in
  let mk_value i = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7) in
  (* 1. Create an array of size [size] *)
  let a : t7 array = makearray_dynamic size (#{ a7 = 0; b7 = 1. } : t7) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 42;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 42 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 43;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 43 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a7 *)
    let el = #{ el with a7 = next_el.#a7 } in
    set_idx_mut a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 44;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 44 failed %d %d" size i;
    (* .#b7 *)
    let el = #{ el with b7 = next_el.#b7 } in
    set_idx_mut a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 45;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 45 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t8 = #{ int; float; int }   *)
  (*********************************)
  let eq = (fun (#{ a8 = a81; b8 = b81; c8 = c81 } : t8) (#{ a8 = a82; b8 = b82; c8 = c82 } : t8) -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Float.equal (globalize a) (globalize b)) b81 b82 && (fun a b -> Int.equal a b) c81 c82) in
  let mk_value i = (#{ a8 = (i + 0); b8 = Float.of_int (i + 1); c8 = (i + 2) } : t8) in
  (* 1. Create an array of size [size] *)
  let a : t8 array = makearray_dynamic size (#{ a8 = 0; b8 = 1.; c8 = 2 } : t8) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 46;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 46 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 47;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 47 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a8 *)
    let el = #{ el with a8 = next_el.#a8 } in
    set_idx_mut a ((.(i).#a8) : (t8 array, _) idx_mut) next_el.#a8;
    mark_test_run 48;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 48 failed %d %d" size i;
    (* .#b8 *)
    let el = #{ el with b8 = next_el.#b8 } in
    set_idx_mut a ((.(i).#b8) : (t8 array, _) idx_mut) next_el.#b8;
    mark_test_run 49;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 49 failed %d %d" size i;
    (* .#c8 *)
    let el = #{ el with c8 = next_el.#c8 } in
    set_idx_mut a ((.(i).#c8) : (t8 array, _) idx_mut) next_el.#c8;
    mark_test_run 50;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 50 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t9 = #{ int; float; float }   *)
  (***********************************)
  let eq = (fun (#{ a9 = a91; b9 = b91; c9 = c91 } : t9) (#{ a9 = a92; b9 = b92; c9 = c92 } : t9) -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Float.equal (globalize a) (globalize b)) b91 b92 && (fun a b -> Float.equal (globalize a) (globalize b)) c91 c92) in
  let mk_value i = (#{ a9 = (i + 0); b9 = Float.of_int (i + 1); c9 = Float.of_int (i + 2) } : t9) in
  (* 1. Create an array of size [size] *)
  let a : t9 array = makearray_dynamic size (#{ a9 = 0; b9 = 1.; c9 = 2. } : t9) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 51;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 51 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 52;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 52 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a9 *)
    let el = #{ el with a9 = next_el.#a9 } in
    set_idx_mut a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 53;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 53 failed %d %d" size i;
    (* .#b9 *)
    let el = #{ el with b9 = next_el.#b9 } in
    set_idx_mut a ((.(i).#b9) : (t9 array, _) idx_mut) next_el.#b9;
    mark_test_run 54;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 54 failed %d %d" size i;
    (* .#c9 *)
    let el = #{ el with c9 = next_el.#c9 } in
    set_idx_mut a ((.(i).#c9) : (t9 array, _) idx_mut) next_el.#c9;
    mark_test_run 55;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 55 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t10 = #{ int; #{ int } }   *)
  (********************************)
  let eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b101 b102) in
  let mk_value i = (#{ a10 = (i + 0); b10 = (#{ a0 = (i + 1) } : t0) } : t10) in
  (* 1. Create an array of size [size] *)
  let a : t10 array = makearray_dynamic size (#{ a10 = 0; b10 = (#{ a0 = 1 } : t0) } : t10) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 56;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 56 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 57;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 57 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a10 *)
    let el = #{ el with a10 = next_el.#a10 } in
    set_idx_mut a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 58;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 58 failed %d %d" size i;
    (* .#b10 *)
    let el = #{ el with b10 = next_el.#b10 } in
    set_idx_mut a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 59;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 59 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b10.#a0 *)
    let el = #{ el with b10 = #{ el.#b10 with a0 = next_el.#b10.#a0 } } in
    set_idx_mut a ((.(i).#b10.#a0) : (t10 array, _) idx_mut) next_el.#b10.#a0;
    mark_test_run 60;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 60 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t11 = #{ int; #{ int; int } }   *)
  (*************************************)
  let eq = (fun (#{ a11 = a111; b11 = b111 } : t11) (#{ a11 = a112; b11 = b112 } : t11) -> (fun a b -> Int.equal a b) a111 a112 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b111 b112) in
  let mk_value i = (#{ a11 = (i + 0); b11 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t11) in
  (* 1. Create an array of size [size] *)
  let a : t11 array = makearray_dynamic size (#{ a11 = 0; b11 = (#{ a1 = 1; b1 = 2 } : t1) } : t11) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 61;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 61 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 62;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 62 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a11 *)
    let el = #{ el with a11 = next_el.#a11 } in
    set_idx_mut a ((.(i).#a11) : (t11 array, _) idx_mut) next_el.#a11;
    mark_test_run 63;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 63 failed %d %d" size i;
    (* .#b11 *)
    let el = #{ el with b11 = next_el.#b11 } in
    set_idx_mut a ((.(i).#b11) : (t11 array, _) idx_mut) next_el.#b11;
    mark_test_run 64;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 64 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b11.#a1 *)
    let el = #{ el with b11 = #{ el.#b11 with a1 = next_el.#b11.#a1 } } in
    set_idx_mut a ((.(i).#b11.#a1) : (t11 array, _) idx_mut) next_el.#b11.#a1;
    mark_test_run 65;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 65 failed %d %d" size i;
    (* .#b11.#b1 *)
    let el = #{ el with b11 = #{ el.#b11 with b1 = next_el.#b11.#b1 } } in
    set_idx_mut a ((.(i).#b11.#b1) : (t11 array, _) idx_mut) next_el.#b11.#b1;
    mark_test_run 66;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 66 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t12 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  let eq = (fun (#{ a12 = a121; b12 = b121 } : t12) (#{ a12 = a122; b12 = b122 } : t12) -> (fun a b -> Int.equal a b) a121 a122 && (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) b121 b122) in
  let mk_value i = (#{ a12 = (i + 0); b12 = (#{ a5 = (i + 1); b5 = Int32_u.of_int (i + 2) } : t5) } : t12) in
  (* 1. Create an array of size [size] *)
  let a : t12 array = makearray_dynamic size (#{ a12 = 0; b12 = (#{ a5 = 1; b5 = #2l } : t5) } : t12) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 67;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 67 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 68;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 68 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a12 *)
    let el = #{ el with a12 = next_el.#a12 } in
    set_idx_mut a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 69;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 69 failed %d %d" size i;
    (* .#b12 *)
    let el = #{ el with b12 = next_el.#b12 } in
    set_idx_mut a ((.(i).#b12) : (t12 array, _) idx_mut) next_el.#b12;
    mark_test_run 70;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 70 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b12.#a5 *)
    let el = #{ el with b12 = #{ el.#b12 with a5 = next_el.#b12.#a5 } } in
    set_idx_mut a ((.(i).#b12.#a5) : (t12 array, _) idx_mut) next_el.#b12.#a5;
    mark_test_run 71;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 71 failed %d %d" size i;
    (* .#b12.#b5 *)
    let el = #{ el with b12 = #{ el.#b12 with b5 = next_el.#b12.#b5 } } in
    set_idx_mut a ((.(i).#b12.#b5) : (t12 array, _) idx_mut) next_el.#b12.#b5;
    mark_test_run 72;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 72 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t13 = #{ int; #{ int; float } }   *)
  (***************************************)
  let eq = (fun (#{ a13 = a131; b13 = b131 } : t13) (#{ a13 = a132; b13 = b132 } : t13) -> (fun a b -> Int.equal a b) a131 a132 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) b131 b132) in
  let mk_value i = (#{ a13 = (i + 0); b13 = (#{ a7 = (i + 1); b7 = Float.of_int (i + 2) } : t7) } : t13) in
  (* 1. Create an array of size [size] *)
  let a : t13 array = makearray_dynamic size (#{ a13 = 0; b13 = (#{ a7 = 1; b7 = 2. } : t7) } : t13) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 73;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 73 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 74;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 74 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a13 *)
    let el = #{ el with a13 = next_el.#a13 } in
    set_idx_mut a ((.(i).#a13) : (t13 array, _) idx_mut) next_el.#a13;
    mark_test_run 75;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 75 failed %d %d" size i;
    (* .#b13 *)
    let el = #{ el with b13 = next_el.#b13 } in
    set_idx_mut a ((.(i).#b13) : (t13 array, _) idx_mut) next_el.#b13;
    mark_test_run 76;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 76 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b13.#a7 *)
    let el = #{ el with b13 = #{ el.#b13 with a7 = next_el.#b13.#a7 } } in
    set_idx_mut a ((.(i).#b13.#a7) : (t13 array, _) idx_mut) next_el.#b13.#a7;
    mark_test_run 77;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 77 failed %d %d" size i;
    (* .#b13.#b7 *)
    let el = #{ el with b13 = #{ el.#b13 with b7 = next_el.#b13.#b7 } } in
    set_idx_mut a ((.(i).#b13.#b7) : (t13 array, _) idx_mut) next_el.#b13.#b7;
    mark_test_run 78;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 78 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t15 = #{ int; #{ int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a15 = a151; b15 = b151 } : t15) (#{ a15 = a152; b15 = b152 } : t15) -> (fun a b -> Int.equal a b) a151 a152 && (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) b151 b152) in
  let mk_value i = (#{ a15 = (i + 0); b15 = (#{ a14 = Int32_u.of_int (i + 1) } : t14) } : t15) in
  (* 1. Create an array of size [size] *)
  let a : t15 array = makearray_dynamic size (#{ a15 = 0; b15 = (#{ a14 = #1l } : t14) } : t15) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 79;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 79 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 80;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 80 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a15 *)
    let el = #{ el with a15 = next_el.#a15 } in
    set_idx_mut a ((.(i).#a15) : (t15 array, _) idx_mut) next_el.#a15;
    mark_test_run 81;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 81 failed %d %d" size i;
    (* .#b15 *)
    let el = #{ el with b15 = next_el.#b15 } in
    set_idx_mut a ((.(i).#b15) : (t15 array, _) idx_mut) next_el.#b15;
    mark_test_run 82;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 82 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b15.#a14 *)
    let el = #{ el with b15 = #{ el.#b15 with a14 = next_el.#b15.#a14 } } in
    set_idx_mut a ((.(i).#b15.#a14) : (t15 array, _) idx_mut) next_el.#b15.#a14;
    mark_test_run 83;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 83 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t17 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun (#{ a17 = a171; b17 = b171 } : t17) (#{ a17 = a172; b17 = b172 } : t17) -> (fun a b -> Int.equal a b) a171 a172 && (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) b171 b172) in
  let mk_value i = (#{ a17 = (i + 0); b17 = (#{ a16 = Int32_u.of_int (i + 1); b16 = Int32_u.of_int (i + 2) } : t16) } : t17) in
  (* 1. Create an array of size [size] *)
  let a : t17 array = makearray_dynamic size (#{ a17 = 0; b17 = (#{ a16 = #1l; b16 = #2l } : t16) } : t17) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 84;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 84 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 85;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 85 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a17 *)
    let el = #{ el with a17 = next_el.#a17 } in
    set_idx_mut a ((.(i).#a17) : (t17 array, _) idx_mut) next_el.#a17;
    mark_test_run 86;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 86 failed %d %d" size i;
    (* .#b17 *)
    let el = #{ el with b17 = next_el.#b17 } in
    set_idx_mut a ((.(i).#b17) : (t17 array, _) idx_mut) next_el.#b17;
    mark_test_run 87;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 87 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b17.#a16 *)
    let el = #{ el with b17 = #{ el.#b17 with a16 = next_el.#b17.#a16 } } in
    set_idx_mut a ((.(i).#b17.#a16) : (t17 array, _) idx_mut) next_el.#b17.#a16;
    mark_test_run 88;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 88 failed %d %d" size i;
    (* .#b17.#b16 *)
    let el = #{ el with b17 = #{ el.#b17 with b16 = next_el.#b17.#b16 } } in
    set_idx_mut a ((.(i).#b17.#b16) : (t17 array, _) idx_mut) next_el.#b17.#b16;
    mark_test_run 89;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 89 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t19 = #{ int; #{ float } }   *)
  (**********************************)
  let eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int.equal a b) a191 a192 && (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) b191 b192) in
  let mk_value i = (#{ a19 = (i + 0); b19 = (#{ a18 = Float.of_int (i + 1) } : t18) } : t19) in
  (* 1. Create an array of size [size] *)
  let a : t19 array = makearray_dynamic size (#{ a19 = 0; b19 = (#{ a18 = 1. } : t18) } : t19) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 90;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 90 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 91 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a19 *)
    let el = #{ el with a19 = next_el.#a19 } in
    set_idx_mut a ((.(i).#a19) : (t19 array, _) idx_mut) next_el.#a19;
    mark_test_run 92;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 92 failed %d %d" size i;
    (* .#b19 *)
    let el = #{ el with b19 = next_el.#b19 } in
    set_idx_mut a ((.(i).#b19) : (t19 array, _) idx_mut) next_el.#b19;
    mark_test_run 93;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 93 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b19.#a18 *)
    let el = #{ el with b19 = #{ el.#b19 with a18 = next_el.#b19.#a18 } } in
    set_idx_mut a ((.(i).#b19.#a18) : (t19 array, _) idx_mut) next_el.#b19.#a18;
    mark_test_run 94;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 94 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t21 = #{ int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun (#{ a21 = a211; b21 = b211 } : t21) (#{ a21 = a212; b21 = b212 } : t21) -> (fun a b -> Int.equal a b) a211 a212 && (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) b211 b212) in
  let mk_value i = (#{ a21 = (i + 0); b21 = (#{ a20 = Float.of_int (i + 1); b20 = (i + 2) } : t20) } : t21) in
  (* 1. Create an array of size [size] *)
  let a : t21 array = makearray_dynamic size (#{ a21 = 0; b21 = (#{ a20 = 1.; b20 = 2 } : t20) } : t21) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 95;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 95 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 96 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a21 *)
    let el = #{ el with a21 = next_el.#a21 } in
    set_idx_mut a ((.(i).#a21) : (t21 array, _) idx_mut) next_el.#a21;
    mark_test_run 97;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 97 failed %d %d" size i;
    (* .#b21 *)
    let el = #{ el with b21 = next_el.#b21 } in
    set_idx_mut a ((.(i).#b21) : (t21 array, _) idx_mut) next_el.#b21;
    mark_test_run 98;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 98 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b21.#a20 *)
    let el = #{ el with b21 = #{ el.#b21 with a20 = next_el.#b21.#a20 } } in
    set_idx_mut a ((.(i).#b21.#a20) : (t21 array, _) idx_mut) next_el.#b21.#a20;
    mark_test_run 99;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 99 failed %d %d" size i;
    (* .#b21.#b20 *)
    let el = #{ el with b21 = #{ el.#b21 with b20 = next_el.#b21.#b20 } } in
    set_idx_mut a ((.(i).#b21.#b20) : (t21 array, _) idx_mut) next_el.#b21.#b20;
    mark_test_run 100;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 100 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t23 = #{ int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Int.equal a b) a231 a232 && (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) b231 b232) in
  let mk_value i = (#{ a23 = (i + 0); b23 = (#{ a22 = Float.of_int (i + 1); b22 = Float.of_int (i + 2) } : t22) } : t23) in
  (* 1. Create an array of size [size] *)
  let a : t23 array = makearray_dynamic size (#{ a23 = 0; b23 = (#{ a22 = 1.; b22 = 2. } : t22) } : t23) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 101;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 101 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 102;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 102 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a23 *)
    let el = #{ el with a23 = next_el.#a23 } in
    set_idx_mut a ((.(i).#a23) : (t23 array, _) idx_mut) next_el.#a23;
    mark_test_run 103;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 103 failed %d %d" size i;
    (* .#b23 *)
    let el = #{ el with b23 = next_el.#b23 } in
    set_idx_mut a ((.(i).#b23) : (t23 array, _) idx_mut) next_el.#b23;
    mark_test_run 104;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 104 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b23.#a22 *)
    let el = #{ el with b23 = #{ el.#b23 with a22 = next_el.#b23.#a22 } } in
    set_idx_mut a ((.(i).#b23.#a22) : (t23 array, _) idx_mut) next_el.#b23.#a22;
    mark_test_run 105;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* .#b23.#b22 *)
    let el = #{ el with b23 = #{ el.#b23 with b22 = next_el.#b23.#b22 } } in
    set_idx_mut a ((.(i).#b23.#b22) : (t23 array, _) idx_mut) next_el.#b23.#b22;
    mark_test_run 106;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 106 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************)
  (*   t24 = #{ int64 }   *)
  (************************)
  let eq = (fun (#{ a24 = a241 } : t24) (#{ a24 = a242 } : t24) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a241 a242) in
  let mk_value i = (#{ a24 = Int64.of_int (i + 0) } : t24) in
  (* 1. Create an array of size [size] *)
  let a : t24 array = makearray_dynamic size (#{ a24 = 0L } : t24) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 108;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 108 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a24 *)
    let el = #{ el with a24 = next_el.#a24 } in
    set_idx_mut a ((.(i).#a24) : (t24 array, _) idx_mut) next_el.#a24;
    mark_test_run 109;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 109 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t25 = #{ int64# }   *)
  (*************************)
  let eq = (fun (#{ a25 = a251 } : t25) (#{ a25 = a252 } : t25) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a251 a252) in
  let mk_value i = (#{ a25 = Int64_u.of_int (i + 0) } : t25) in
  (* 1. Create an array of size [size] *)
  let a : t25 array = makearray_dynamic size (#{ a25 = #0L } : t25) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 110;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 110 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 111;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 111 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a25 *)
    let el = #{ el with a25 = next_el.#a25 } in
    set_idx_mut a ((.(i).#a25) : (t25 array, _) idx_mut) next_el.#a25;
    mark_test_run 112;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 112 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t14 = #{ int32# }   *)
  (*************************)
  let eq = (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) in
  let mk_value i = (#{ a14 = Int32_u.of_int (i + 0) } : t14) in
  (* 1. Create an array of size [size] *)
  let a : t14 array = makearray_dynamic size (#{ a14 = #0l } : t14) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 113;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 113 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 114;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 114 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a14 *)
    let el = #{ el with a14 = next_el.#a14 } in
    set_idx_mut a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 115;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 115 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t16 = #{ int32#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) in
  let mk_value i = (#{ a16 = Int32_u.of_int (i + 0); b16 = Int32_u.of_int (i + 1) } : t16) in
  (* 1. Create an array of size [size] *)
  let a : t16 array = makearray_dynamic size (#{ a16 = #0l; b16 = #1l } : t16) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 116;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 116 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 117;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 117 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a16 *)
    let el = #{ el with a16 = next_el.#a16 } in
    set_idx_mut a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 118;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 118 failed %d %d" size i;
    (* .#b16 *)
    let el = #{ el with b16 = next_el.#b16 } in
    set_idx_mut a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 119;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 119 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t26 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun (#{ a26 = a261; b26 = b261; c26 = c261 } : t26) (#{ a26 = a262; b26 = b262; c26 = c262 } : t26) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a261 a262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b261 b262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c261 c262) in
  let mk_value i = (#{ a26 = Int32_u.of_int (i + 0); b26 = Int32_u.of_int (i + 1); c26 = Int32_u.of_int (i + 2) } : t26) in
  (* 1. Create an array of size [size] *)
  let a : t26 array = makearray_dynamic size (#{ a26 = #0l; b26 = #1l; c26 = #2l } : t26) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 121;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 121 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a26 *)
    let el = #{ el with a26 = next_el.#a26 } in
    set_idx_mut a ((.(i).#a26) : (t26 array, _) idx_mut) next_el.#a26;
    mark_test_run 122;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 122 failed %d %d" size i;
    (* .#b26 *)
    let el = #{ el with b26 = next_el.#b26 } in
    set_idx_mut a ((.(i).#b26) : (t26 array, _) idx_mut) next_el.#b26;
    mark_test_run 123;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 123 failed %d %d" size i;
    (* .#c26 *)
    let el = #{ el with c26 = next_el.#c26 } in
    set_idx_mut a ((.(i).#c26) : (t26 array, _) idx_mut) next_el.#c26;
    mark_test_run 124;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 124 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t27 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a27 = a271; b27 = b271 } : t27) (#{ a27 = a272; b27 = b272 } : t27) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a271 a272 && (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) b271 b272) in
  let mk_value i = (#{ a27 = Int32_u.of_int (i + 0); b27 = (#{ a14 = Int32_u.of_int (i + 1) } : t14) } : t27) in
  (* 1. Create an array of size [size] *)
  let a : t27 array = makearray_dynamic size (#{ a27 = #0l; b27 = (#{ a14 = #1l } : t14) } : t27) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 125;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 125 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 126;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 126 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a27 *)
    let el = #{ el with a27 = next_el.#a27 } in
    set_idx_mut a ((.(i).#a27) : (t27 array, _) idx_mut) next_el.#a27;
    mark_test_run 127;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 127 failed %d %d" size i;
    (* .#b27 *)
    let el = #{ el with b27 = next_el.#b27 } in
    set_idx_mut a ((.(i).#b27) : (t27 array, _) idx_mut) next_el.#b27;
    mark_test_run 128;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 128 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b27.#a14 *)
    let el = #{ el with b27 = #{ el.#b27 with a14 = next_el.#b27.#a14 } } in
    set_idx_mut a ((.(i).#b27.#a14) : (t27 array, _) idx_mut) next_el.#b27.#a14;
    mark_test_run 129;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 129 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t28 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun (#{ a28 = a281; b28 = b281 } : t28) (#{ a28 = a282; b28 = b282 } : t28) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a281 a282 && (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) b281 b282) in
  let mk_value i = (#{ a28 = Int32_u.of_int (i + 0); b28 = (#{ a16 = Int32_u.of_int (i + 1); b16 = Int32_u.of_int (i + 2) } : t16) } : t28) in
  (* 1. Create an array of size [size] *)
  let a : t28 array = makearray_dynamic size (#{ a28 = #0l; b28 = (#{ a16 = #1l; b16 = #2l } : t16) } : t28) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 130;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 130 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 131 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a28 *)
    let el = #{ el with a28 = next_el.#a28 } in
    set_idx_mut a ((.(i).#a28) : (t28 array, _) idx_mut) next_el.#a28;
    mark_test_run 132;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 132 failed %d %d" size i;
    (* .#b28 *)
    let el = #{ el with b28 = next_el.#b28 } in
    set_idx_mut a ((.(i).#b28) : (t28 array, _) idx_mut) next_el.#b28;
    mark_test_run 133;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 133 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b28.#a16 *)
    let el = #{ el with b28 = #{ el.#b28 with a16 = next_el.#b28.#a16 } } in
    set_idx_mut a ((.(i).#b28.#a16) : (t28 array, _) idx_mut) next_el.#b28.#a16;
    mark_test_run 134;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 134 failed %d %d" size i;
    (* .#b28.#b16 *)
    let el = #{ el with b28 = #{ el.#b28 with b16 = next_el.#b28.#b16 } } in
    set_idx_mut a ((.(i).#b28.#b16) : (t28 array, _) idx_mut) next_el.#b28.#b16;
    mark_test_run 135;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 135 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t29 = #{ nativeint# }   *)
  (*****************************)
  let eq = (fun (#{ a29 = a291 } : t29) (#{ a29 = a292 } : t29) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a291 a292) in
  let mk_value i = (#{ a29 = Nativeint_u.of_int (i + 0) } : t29) in
  (* 1. Create an array of size [size] *)
  let a : t29 array = makearray_dynamic size (#{ a29 = #0n } : t29) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 136;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 136 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 137;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 137 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a29 *)
    let el = #{ el with a29 = next_el.#a29 } in
    set_idx_mut a ((.(i).#a29) : (t29 array, _) idx_mut) next_el.#a29;
    mark_test_run 138;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 138 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t20 = #{ float; int }   *)
  (*****************************)
  let eq = (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) in
  let mk_value i = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20) in
  (* 1. Create an array of size [size] *)
  let a : t20 array = makearray_dynamic size (#{ a20 = 0.; b20 = 1 } : t20) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 139;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 139 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 140;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 140 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a20 *)
    let el = #{ el with a20 = next_el.#a20 } in
    set_idx_mut a ((.(i).#a20) : (t20 array, _) idx_mut) next_el.#a20;
    mark_test_run 141;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 141 failed %d %d" size i;
    (* .#b20 *)
    let el = #{ el with b20 = next_el.#b20 } in
    set_idx_mut a ((.(i).#b20) : (t20 array, _) idx_mut) next_el.#b20;
    mark_test_run 142;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 142 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t30 = #{ float; int; int }   *)
  (**********************************)
  let eq = (fun (#{ a30 = a301; b30 = b301; c30 = c301 } : t30) (#{ a30 = a302; b30 = b302; c30 = c302 } : t30) -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Int.equal a b) b301 b302 && (fun a b -> Int.equal a b) c301 c302) in
  let mk_value i = (#{ a30 = Float.of_int (i + 0); b30 = (i + 1); c30 = (i + 2) } : t30) in
  (* 1. Create an array of size [size] *)
  let a : t30 array = makearray_dynamic size (#{ a30 = 0.; b30 = 1; c30 = 2 } : t30) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 143;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 143 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 144;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 144 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a30 *)
    let el = #{ el with a30 = next_el.#a30 } in
    set_idx_mut a ((.(i).#a30) : (t30 array, _) idx_mut) next_el.#a30;
    mark_test_run 145;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 145 failed %d %d" size i;
    (* .#b30 *)
    let el = #{ el with b30 = next_el.#b30 } in
    set_idx_mut a ((.(i).#b30) : (t30 array, _) idx_mut) next_el.#b30;
    mark_test_run 146;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 146 failed %d %d" size i;
    (* .#c30 *)
    let el = #{ el with c30 = next_el.#c30 } in
    set_idx_mut a ((.(i).#c30) : (t30 array, _) idx_mut) next_el.#c30;
    mark_test_run 147;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 147 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t31 = #{ float; int; float }   *)
  (************************************)
  let eq = (fun (#{ a31 = a311; b31 = b311; c31 = c311 } : t31) (#{ a31 = a312; b31 = b312; c31 = c312 } : t31) -> (fun a b -> Float.equal (globalize a) (globalize b)) a311 a312 && (fun a b -> Int.equal a b) b311 b312 && (fun a b -> Float.equal (globalize a) (globalize b)) c311 c312) in
  let mk_value i = (#{ a31 = Float.of_int (i + 0); b31 = (i + 1); c31 = Float.of_int (i + 2) } : t31) in
  (* 1. Create an array of size [size] *)
  let a : t31 array = makearray_dynamic size (#{ a31 = 0.; b31 = 1; c31 = 2. } : t31) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 148;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 148 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 149;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 149 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a31 *)
    let el = #{ el with a31 = next_el.#a31 } in
    set_idx_mut a ((.(i).#a31) : (t31 array, _) idx_mut) next_el.#a31;
    mark_test_run 150;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 150 failed %d %d" size i;
    (* .#b31 *)
    let el = #{ el with b31 = next_el.#b31 } in
    set_idx_mut a ((.(i).#b31) : (t31 array, _) idx_mut) next_el.#b31;
    mark_test_run 151;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 151 failed %d %d" size i;
    (* .#c31 *)
    let el = #{ el with c31 = next_el.#c31 } in
    set_idx_mut a ((.(i).#c31) : (t31 array, _) idx_mut) next_el.#c31;
    mark_test_run 152;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 152 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t22 = #{ float; float }   *)
  (*******************************)
  let eq = (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) in
  let mk_value i = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22) in
  (* 1. Create an array of size [size] *)
  let a : t22 array = makearray_dynamic size (#{ a22 = 0.; b22 = 1. } : t22) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 153;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 153 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 154;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 154 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a22 *)
    let el = #{ el with a22 = next_el.#a22 } in
    set_idx_mut a ((.(i).#a22) : (t22 array, _) idx_mut) next_el.#a22;
    mark_test_run 155;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 155 failed %d %d" size i;
    (* .#b22 *)
    let el = #{ el with b22 = next_el.#b22 } in
    set_idx_mut a ((.(i).#b22) : (t22 array, _) idx_mut) next_el.#b22;
    mark_test_run 156;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 156 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t32 = #{ float; float; int }   *)
  (************************************)
  let eq = (fun (#{ a32 = a321; b32 = b321; c32 = c321 } : t32) (#{ a32 = a322; b32 = b322; c32 = c322 } : t32) -> (fun a b -> Float.equal (globalize a) (globalize b)) a321 a322 && (fun a b -> Float.equal (globalize a) (globalize b)) b321 b322 && (fun a b -> Int.equal a b) c321 c322) in
  let mk_value i = (#{ a32 = Float.of_int (i + 0); b32 = Float.of_int (i + 1); c32 = (i + 2) } : t32) in
  (* 1. Create an array of size [size] *)
  let a : t32 array = makearray_dynamic size (#{ a32 = 0.; b32 = 1.; c32 = 2 } : t32) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 157;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 157 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 158;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 158 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a32 *)
    let el = #{ el with a32 = next_el.#a32 } in
    set_idx_mut a ((.(i).#a32) : (t32 array, _) idx_mut) next_el.#a32;
    mark_test_run 159;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 159 failed %d %d" size i;
    (* .#b32 *)
    let el = #{ el with b32 = next_el.#b32 } in
    set_idx_mut a ((.(i).#b32) : (t32 array, _) idx_mut) next_el.#b32;
    mark_test_run 160;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 160 failed %d %d" size i;
    (* .#c32 *)
    let el = #{ el with c32 = next_el.#c32 } in
    set_idx_mut a ((.(i).#c32) : (t32 array, _) idx_mut) next_el.#c32;
    mark_test_run 161;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 161 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t33 = #{ float; float; float }   *)
  (**************************************)
  let eq = (fun (#{ a33 = a331; b33 = b331; c33 = c331 } : t33) (#{ a33 = a332; b33 = b332; c33 = c332 } : t33) -> (fun a b -> Float.equal (globalize a) (globalize b)) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332 && (fun a b -> Float.equal (globalize a) (globalize b)) c331 c332) in
  let mk_value i = (#{ a33 = Float.of_int (i + 0); b33 = Float.of_int (i + 1); c33 = Float.of_int (i + 2) } : t33) in
  (* 1. Create an array of size [size] *)
  let a : t33 array = makearray_dynamic size (#{ a33 = 0.; b33 = 1.; c33 = 2. } : t33) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 162;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 162 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 163;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 163 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a33 *)
    let el = #{ el with a33 = next_el.#a33 } in
    set_idx_mut a ((.(i).#a33) : (t33 array, _) idx_mut) next_el.#a33;
    mark_test_run 164;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 164 failed %d %d" size i;
    (* .#b33 *)
    let el = #{ el with b33 = next_el.#b33 } in
    set_idx_mut a ((.(i).#b33) : (t33 array, _) idx_mut) next_el.#b33;
    mark_test_run 165;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 165 failed %d %d" size i;
    (* .#c33 *)
    let el = #{ el with c33 = next_el.#c33 } in
    set_idx_mut a ((.(i).#c33) : (t33 array, _) idx_mut) next_el.#c33;
    mark_test_run 166;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 166 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t34 = #{ float; #{ int } }   *)
  (**********************************)
  let eq = (fun (#{ a34 = a341; b34 = b341 } : t34) (#{ a34 = a342; b34 = b342 } : t34) -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b341 b342) in
  let mk_value i = (#{ a34 = Float.of_int (i + 0); b34 = (#{ a0 = (i + 1) } : t0) } : t34) in
  (* 1. Create an array of size [size] *)
  let a : t34 array = makearray_dynamic size (#{ a34 = 0.; b34 = (#{ a0 = 1 } : t0) } : t34) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 167;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 167 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 168;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 168 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a34 *)
    let el = #{ el with a34 = next_el.#a34 } in
    set_idx_mut a ((.(i).#a34) : (t34 array, _) idx_mut) next_el.#a34;
    mark_test_run 169;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 169 failed %d %d" size i;
    (* .#b34 *)
    let el = #{ el with b34 = next_el.#b34 } in
    set_idx_mut a ((.(i).#b34) : (t34 array, _) idx_mut) next_el.#b34;
    mark_test_run 170;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 170 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b34.#a0 *)
    let el = #{ el with b34 = #{ el.#b34 with a0 = next_el.#b34.#a0 } } in
    set_idx_mut a ((.(i).#b34.#a0) : (t34 array, _) idx_mut) next_el.#b34.#a0;
    mark_test_run 171;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 171 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t35 = #{ float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun (#{ a35 = a351; b35 = b351 } : t35) (#{ a35 = a352; b35 = b352 } : t35) -> (fun a b -> Float.equal (globalize a) (globalize b)) a351 a352 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b351 b352) in
  let mk_value i = (#{ a35 = Float.of_int (i + 0); b35 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t35) in
  (* 1. Create an array of size [size] *)
  let a : t35 array = makearray_dynamic size (#{ a35 = 0.; b35 = (#{ a1 = 1; b1 = 2 } : t1) } : t35) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 172;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 172 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 173;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 173 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a35 *)
    let el = #{ el with a35 = next_el.#a35 } in
    set_idx_mut a ((.(i).#a35) : (t35 array, _) idx_mut) next_el.#a35;
    mark_test_run 174;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 174 failed %d %d" size i;
    (* .#b35 *)
    let el = #{ el with b35 = next_el.#b35 } in
    set_idx_mut a ((.(i).#b35) : (t35 array, _) idx_mut) next_el.#b35;
    mark_test_run 175;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 175 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b35.#a1 *)
    let el = #{ el with b35 = #{ el.#b35 with a1 = next_el.#b35.#a1 } } in
    set_idx_mut a ((.(i).#b35.#a1) : (t35 array, _) idx_mut) next_el.#b35.#a1;
    mark_test_run 176;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 176 failed %d %d" size i;
    (* .#b35.#b1 *)
    let el = #{ el with b35 = #{ el.#b35 with b1 = next_el.#b35.#b1 } } in
    set_idx_mut a ((.(i).#b35.#b1) : (t35 array, _) idx_mut) next_el.#b35.#b1;
    mark_test_run 177;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 177 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t36 = #{ float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a36 = a361; b36 = b361 } : t36) (#{ a36 = a362; b36 = b362 } : t36) -> (fun a b -> Float.equal (globalize a) (globalize b)) a361 a362 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) b361 b362) in
  let mk_value i = (#{ a36 = Float.of_int (i + 0); b36 = (#{ a7 = (i + 1); b7 = Float.of_int (i + 2) } : t7) } : t36) in
  (* 1. Create an array of size [size] *)
  let a : t36 array = makearray_dynamic size (#{ a36 = 0.; b36 = (#{ a7 = 1; b7 = 2. } : t7) } : t36) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 178;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 178 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 179;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 179 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a36 *)
    let el = #{ el with a36 = next_el.#a36 } in
    set_idx_mut a ((.(i).#a36) : (t36 array, _) idx_mut) next_el.#a36;
    mark_test_run 180;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 180 failed %d %d" size i;
    (* .#b36 *)
    let el = #{ el with b36 = next_el.#b36 } in
    set_idx_mut a ((.(i).#b36) : (t36 array, _) idx_mut) next_el.#b36;
    mark_test_run 181;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 181 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b36.#a7 *)
    let el = #{ el with b36 = #{ el.#b36 with a7 = next_el.#b36.#a7 } } in
    set_idx_mut a ((.(i).#b36.#a7) : (t36 array, _) idx_mut) next_el.#b36.#a7;
    mark_test_run 182;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 182 failed %d %d" size i;
    (* .#b36.#b7 *)
    let el = #{ el with b36 = #{ el.#b36 with b7 = next_el.#b36.#b7 } } in
    set_idx_mut a ((.(i).#b36.#b7) : (t36 array, _) idx_mut) next_el.#b36.#b7;
    mark_test_run 183;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 183 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t37 = #{ float; #{ float } }   *)
  (************************************)
  let eq = (fun (#{ a37 = a371; b37 = b371 } : t37) (#{ a37 = a372; b37 = b372 } : t37) -> (fun a b -> Float.equal (globalize a) (globalize b)) a371 a372 && (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) b371 b372) in
  let mk_value i = (#{ a37 = Float.of_int (i + 0); b37 = (#{ a18 = Float.of_int (i + 1) } : t18) } : t37) in
  (* 1. Create an array of size [size] *)
  let a : t37 array = makearray_dynamic size (#{ a37 = 0.; b37 = (#{ a18 = 1. } : t18) } : t37) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 184;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 184 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 185;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 185 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a37 *)
    let el = #{ el with a37 = next_el.#a37 } in
    set_idx_mut a ((.(i).#a37) : (t37 array, _) idx_mut) next_el.#a37;
    mark_test_run 186;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 186 failed %d %d" size i;
    (* .#b37 *)
    let el = #{ el with b37 = next_el.#b37 } in
    set_idx_mut a ((.(i).#b37) : (t37 array, _) idx_mut) next_el.#b37;
    mark_test_run 187;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 187 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b37.#a18 *)
    let el = #{ el with b37 = #{ el.#b37 with a18 = next_el.#b37.#a18 } } in
    set_idx_mut a ((.(i).#b37.#a18) : (t37 array, _) idx_mut) next_el.#b37.#a18;
    mark_test_run 188;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 188 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t38 = #{ float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun (#{ a38 = a381; b38 = b381 } : t38) (#{ a38 = a382; b38 = b382 } : t38) -> (fun a b -> Float.equal (globalize a) (globalize b)) a381 a382 && (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) b381 b382) in
  let mk_value i = (#{ a38 = Float.of_int (i + 0); b38 = (#{ a20 = Float.of_int (i + 1); b20 = (i + 2) } : t20) } : t38) in
  (* 1. Create an array of size [size] *)
  let a : t38 array = makearray_dynamic size (#{ a38 = 0.; b38 = (#{ a20 = 1.; b20 = 2 } : t20) } : t38) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 189;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 189 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 190;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 190 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a38 *)
    let el = #{ el with a38 = next_el.#a38 } in
    set_idx_mut a ((.(i).#a38) : (t38 array, _) idx_mut) next_el.#a38;
    mark_test_run 191;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 191 failed %d %d" size i;
    (* .#b38 *)
    let el = #{ el with b38 = next_el.#b38 } in
    set_idx_mut a ((.(i).#b38) : (t38 array, _) idx_mut) next_el.#b38;
    mark_test_run 192;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 192 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b38.#a20 *)
    let el = #{ el with b38 = #{ el.#b38 with a20 = next_el.#b38.#a20 } } in
    set_idx_mut a ((.(i).#b38.#a20) : (t38 array, _) idx_mut) next_el.#b38.#a20;
    mark_test_run 193;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 193 failed %d %d" size i;
    (* .#b38.#b20 *)
    let el = #{ el with b38 = #{ el.#b38 with b20 = next_el.#b38.#b20 } } in
    set_idx_mut a ((.(i).#b38.#b20) : (t38 array, _) idx_mut) next_el.#b38.#b20;
    mark_test_run 194;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 194 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t39 = #{ float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun (#{ a39 = a391; b39 = b391 } : t39) (#{ a39 = a392; b39 = b392 } : t39) -> (fun a b -> Float.equal (globalize a) (globalize b)) a391 a392 && (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) b391 b392) in
  let mk_value i = (#{ a39 = Float.of_int (i + 0); b39 = (#{ a22 = Float.of_int (i + 1); b22 = Float.of_int (i + 2) } : t22) } : t39) in
  (* 1. Create an array of size [size] *)
  let a : t39 array = makearray_dynamic size (#{ a39 = 0.; b39 = (#{ a22 = 1.; b22 = 2. } : t22) } : t39) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 195;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 195 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 196;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 196 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a39 *)
    let el = #{ el with a39 = next_el.#a39 } in
    set_idx_mut a ((.(i).#a39) : (t39 array, _) idx_mut) next_el.#a39;
    mark_test_run 197;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 197 failed %d %d" size i;
    (* .#b39 *)
    let el = #{ el with b39 = next_el.#b39 } in
    set_idx_mut a ((.(i).#b39) : (t39 array, _) idx_mut) next_el.#b39;
    mark_test_run 198;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 198 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b39.#a22 *)
    let el = #{ el with b39 = #{ el.#b39 with a22 = next_el.#b39.#a22 } } in
    set_idx_mut a ((.(i).#b39.#a22) : (t39 array, _) idx_mut) next_el.#b39.#a22;
    mark_test_run 199;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 199 failed %d %d" size i;
    (* .#b39.#b22 *)
    let el = #{ el with b39 = #{ el.#b39 with b22 = next_el.#b39.#b22 } } in
    set_idx_mut a ((.(i).#b39.#b22) : (t39 array, _) idx_mut) next_el.#b39.#b22;
    mark_test_run 200;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 200 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************)
  (*   t40 = #{ #{ int } }   *)
  (***************************)
  let eq = (fun (#{ a40 = a401 } : t40) (#{ a40 = a402 } : t40) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a401 a402) in
  let mk_value i = (#{ a40 = (#{ a0 = (i + 0) } : t0) } : t40) in
  (* 1. Create an array of size [size] *)
  let a : t40 array = makearray_dynamic size (#{ a40 = (#{ a0 = 0 } : t0) } : t40) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 201;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 201 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 202;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 202 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a40 *)
    let el = #{ el with a40 = next_el.#a40 } in
    set_idx_mut a ((.(i).#a40) : (t40 array, _) idx_mut) next_el.#a40;
    mark_test_run 203;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 203 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a40.#a0 *)
    let el = #{ el with a40 = #{ el.#a40 with a0 = next_el.#a40.#a0 } } in
    set_idx_mut a ((.(i).#a40.#a0) : (t40 array, _) idx_mut) next_el.#a40.#a0;
    mark_test_run 204;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 204 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t41 = #{ #{ int }; int }   *)
  (********************************)
  let eq = (fun (#{ a41 = a411; b41 = b411 } : t41) (#{ a41 = a412; b41 = b412 } : t41) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a411 a412 && (fun a b -> Int.equal a b) b411 b412) in
  let mk_value i = (#{ a41 = (#{ a0 = (i + 0) } : t0); b41 = (i + 1) } : t41) in
  (* 1. Create an array of size [size] *)
  let a : t41 array = makearray_dynamic size (#{ a41 = (#{ a0 = 0 } : t0); b41 = 1 } : t41) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 205;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 205 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 206;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 206 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a41 *)
    let el = #{ el with a41 = next_el.#a41 } in
    set_idx_mut a ((.(i).#a41) : (t41 array, _) idx_mut) next_el.#a41;
    mark_test_run 207;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 207 failed %d %d" size i;
    (* .#b41 *)
    let el = #{ el with b41 = next_el.#b41 } in
    set_idx_mut a ((.(i).#b41) : (t41 array, _) idx_mut) next_el.#b41;
    mark_test_run 208;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 208 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a41.#a0 *)
    let el = #{ el with a41 = #{ el.#a41 with a0 = next_el.#a41.#a0 } } in
    set_idx_mut a ((.(i).#a41.#a0) : (t41 array, _) idx_mut) next_el.#a41.#a0;
    mark_test_run 209;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 209 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t42 = #{ #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun (#{ a42 = a421; b42 = b421 } : t42) (#{ a42 = a422; b42 = b422 } : t42) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a421 a422 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b421 b422) in
  let mk_value i = (#{ a42 = (#{ a0 = (i + 0) } : t0); b42 = Int32_u.of_int (i + 1) } : t42) in
  (* 1. Create an array of size [size] *)
  let a : t42 array = makearray_dynamic size (#{ a42 = (#{ a0 = 0 } : t0); b42 = #1l } : t42) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 210;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 210 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 211;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 211 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a42 *)
    let el = #{ el with a42 = next_el.#a42 } in
    set_idx_mut a ((.(i).#a42) : (t42 array, _) idx_mut) next_el.#a42;
    mark_test_run 212;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 212 failed %d %d" size i;
    (* .#b42 *)
    let el = #{ el with b42 = next_el.#b42 } in
    set_idx_mut a ((.(i).#b42) : (t42 array, _) idx_mut) next_el.#b42;
    mark_test_run 213;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 213 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a42.#a0 *)
    let el = #{ el with a42 = #{ el.#a42 with a0 = next_el.#a42.#a0 } } in
    set_idx_mut a ((.(i).#a42.#a0) : (t42 array, _) idx_mut) next_el.#a42.#a0;
    mark_test_run 214;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 214 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t43 = #{ #{ int }; float }   *)
  (**********************************)
  let eq = (fun (#{ a43 = a431; b43 = b431 } : t43) (#{ a43 = a432; b43 = b432 } : t43) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a431 a432 && (fun a b -> Float.equal (globalize a) (globalize b)) b431 b432) in
  let mk_value i = (#{ a43 = (#{ a0 = (i + 0) } : t0); b43 = Float.of_int (i + 1) } : t43) in
  (* 1. Create an array of size [size] *)
  let a : t43 array = makearray_dynamic size (#{ a43 = (#{ a0 = 0 } : t0); b43 = 1. } : t43) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 215;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 215 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 216;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 216 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a43 *)
    let el = #{ el with a43 = next_el.#a43 } in
    set_idx_mut a ((.(i).#a43) : (t43 array, _) idx_mut) next_el.#a43;
    mark_test_run 217;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 217 failed %d %d" size i;
    (* .#b43 *)
    let el = #{ el with b43 = next_el.#b43 } in
    set_idx_mut a ((.(i).#b43) : (t43 array, _) idx_mut) next_el.#b43;
    mark_test_run 218;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 218 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a43.#a0 *)
    let el = #{ el with a43 = #{ el.#a43 with a0 = next_el.#a43.#a0 } } in
    set_idx_mut a ((.(i).#a43.#a0) : (t43 array, _) idx_mut) next_el.#a43.#a0;
    mark_test_run 219;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 219 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t44 = #{ #{ int; int } }   *)
  (********************************)
  let eq = (fun (#{ a44 = a441 } : t44) (#{ a44 = a442 } : t44) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a441 a442) in
  let mk_value i = (#{ a44 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) } : t44) in
  (* 1. Create an array of size [size] *)
  let a : t44 array = makearray_dynamic size (#{ a44 = (#{ a1 = 0; b1 = 1 } : t1) } : t44) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 220;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 220 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 221;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 221 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a44 *)
    let el = #{ el with a44 = next_el.#a44 } in
    set_idx_mut a ((.(i).#a44) : (t44 array, _) idx_mut) next_el.#a44;
    mark_test_run 222;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 222 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a44.#a1 *)
    let el = #{ el with a44 = #{ el.#a44 with a1 = next_el.#a44.#a1 } } in
    set_idx_mut a ((.(i).#a44.#a1) : (t44 array, _) idx_mut) next_el.#a44.#a1;
    mark_test_run 223;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 223 failed %d %d" size i;
    (* .#a44.#b1 *)
    let el = #{ el with a44 = #{ el.#a44 with b1 = next_el.#a44.#b1 } } in
    set_idx_mut a ((.(i).#a44.#b1) : (t44 array, _) idx_mut) next_el.#a44.#b1;
    mark_test_run 224;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 224 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t45 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun (#{ a45 = a451; b45 = b451 } : t45) (#{ a45 = a452; b45 = b452 } : t45) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a451 a452 && (fun a b -> Int.equal a b) b451 b452) in
  let mk_value i = (#{ a45 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b45 = (i + 2) } : t45) in
  (* 1. Create an array of size [size] *)
  let a : t45 array = makearray_dynamic size (#{ a45 = (#{ a1 = 0; b1 = 1 } : t1); b45 = 2 } : t45) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 225;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 225 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 226;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 226 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a45 *)
    let el = #{ el with a45 = next_el.#a45 } in
    set_idx_mut a ((.(i).#a45) : (t45 array, _) idx_mut) next_el.#a45;
    mark_test_run 227;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 227 failed %d %d" size i;
    (* .#b45 *)
    let el = #{ el with b45 = next_el.#b45 } in
    set_idx_mut a ((.(i).#b45) : (t45 array, _) idx_mut) next_el.#b45;
    mark_test_run 228;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 228 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a45.#a1 *)
    let el = #{ el with a45 = #{ el.#a45 with a1 = next_el.#a45.#a1 } } in
    set_idx_mut a ((.(i).#a45.#a1) : (t45 array, _) idx_mut) next_el.#a45.#a1;
    mark_test_run 229;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 229 failed %d %d" size i;
    (* .#a45.#b1 *)
    let el = #{ el with a45 = #{ el.#a45 with b1 = next_el.#a45.#b1 } } in
    set_idx_mut a ((.(i).#a45.#b1) : (t45 array, _) idx_mut) next_el.#a45.#b1;
    mark_test_run 230;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 230 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t46 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun (#{ a46 = a461; b46 = b461 } : t46) (#{ a46 = a462; b46 = b462 } : t46) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a461 a462 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b461 b462) in
  let mk_value i = (#{ a46 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b46 = Int32_u.of_int (i + 2) } : t46) in
  (* 1. Create an array of size [size] *)
  let a : t46 array = makearray_dynamic size (#{ a46 = (#{ a1 = 0; b1 = 1 } : t1); b46 = #2l } : t46) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 231;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 231 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 232;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 232 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a46 *)
    let el = #{ el with a46 = next_el.#a46 } in
    set_idx_mut a ((.(i).#a46) : (t46 array, _) idx_mut) next_el.#a46;
    mark_test_run 233;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 233 failed %d %d" size i;
    (* .#b46 *)
    let el = #{ el with b46 = next_el.#b46 } in
    set_idx_mut a ((.(i).#b46) : (t46 array, _) idx_mut) next_el.#b46;
    mark_test_run 234;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 234 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a46.#a1 *)
    let el = #{ el with a46 = #{ el.#a46 with a1 = next_el.#a46.#a1 } } in
    set_idx_mut a ((.(i).#a46.#a1) : (t46 array, _) idx_mut) next_el.#a46.#a1;
    mark_test_run 235;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 235 failed %d %d" size i;
    (* .#a46.#b1 *)
    let el = #{ el with a46 = #{ el.#a46 with b1 = next_el.#a46.#b1 } } in
    set_idx_mut a ((.(i).#a46.#b1) : (t46 array, _) idx_mut) next_el.#a46.#b1;
    mark_test_run 236;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 236 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t47 = #{ #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun (#{ a47 = a471; b47 = b471 } : t47) (#{ a47 = a472; b47 = b472 } : t47) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a471 a472 && (fun a b -> Float.equal (globalize a) (globalize b)) b471 b472) in
  let mk_value i = (#{ a47 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b47 = Float.of_int (i + 2) } : t47) in
  (* 1. Create an array of size [size] *)
  let a : t47 array = makearray_dynamic size (#{ a47 = (#{ a1 = 0; b1 = 1 } : t1); b47 = 2. } : t47) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 237;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 237 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 238;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 238 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a47 *)
    let el = #{ el with a47 = next_el.#a47 } in
    set_idx_mut a ((.(i).#a47) : (t47 array, _) idx_mut) next_el.#a47;
    mark_test_run 239;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 239 failed %d %d" size i;
    (* .#b47 *)
    let el = #{ el with b47 = next_el.#b47 } in
    set_idx_mut a ((.(i).#b47) : (t47 array, _) idx_mut) next_el.#b47;
    mark_test_run 240;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 240 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a47.#a1 *)
    let el = #{ el with a47 = #{ el.#a47 with a1 = next_el.#a47.#a1 } } in
    set_idx_mut a ((.(i).#a47.#a1) : (t47 array, _) idx_mut) next_el.#a47.#a1;
    mark_test_run 241;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 241 failed %d %d" size i;
    (* .#a47.#b1 *)
    let el = #{ el with a47 = #{ el.#a47 with b1 = next_el.#a47.#b1 } } in
    set_idx_mut a ((.(i).#a47.#b1) : (t47 array, _) idx_mut) next_el.#a47.#b1;
    mark_test_run 242;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 242 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************************)
  (*   t50 = #{ #{ int; int64# }; #{ int64#; float# } }   *)
  (********************************************************)
  let eq = (fun (#{ a50 = a501; b50 = b501 } : t50) (#{ a50 = a502; b50 = b502 } : t50) -> (fun (#{ a48 = a481; b48 = b481 } : t48) (#{ a48 = a482; b48 = b482 } : t48) -> (fun a b -> Int.equal a b) a481 a482 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b481 b482) a501 a502 && (fun (#{ a49 = a491; b49 = b491 } : t49) (#{ a49 = a492; b49 = b492 } : t49) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a491 a492 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b491 b492) b501 b502) in
  let mk_value i = (#{ a50 = (#{ a48 = (i + 0); b48 = Int64_u.of_int (i + 1) } : t48); b50 = (#{ a49 = Int64_u.of_int (i + 2); b49 = Float_u.of_int (i + 3) } : t49) } : t50) in
  (* 1. Create an array of size [size] *)
  let a : t50 array = makearray_dynamic size (#{ a50 = (#{ a48 = 0; b48 = #1L } : t48); b50 = (#{ a49 = #2L; b49 = #3. } : t49) } : t50) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 243;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 243 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 244;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 244 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a50 *)
    let el = #{ el with a50 = next_el.#a50 } in
    set_idx_mut a ((.(i).#a50) : (t50 array, _) idx_mut) next_el.#a50;
    mark_test_run 245;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 245 failed %d %d" size i;
    (* .#b50 *)
    let el = #{ el with b50 = next_el.#b50 } in
    set_idx_mut a ((.(i).#b50) : (t50 array, _) idx_mut) next_el.#b50;
    mark_test_run 246;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 246 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a50.#a48 *)
    let el = #{ el with a50 = #{ el.#a50 with a48 = next_el.#a50.#a48 } } in
    set_idx_mut a ((.(i).#a50.#a48) : (t50 array, _) idx_mut) next_el.#a50.#a48;
    mark_test_run 247;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 247 failed %d %d" size i;
    (* .#a50.#b48 *)
    let el = #{ el with a50 = #{ el.#a50 with b48 = next_el.#a50.#b48 } } in
    set_idx_mut a ((.(i).#a50.#b48) : (t50 array, _) idx_mut) next_el.#a50.#b48;
    mark_test_run 248;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 248 failed %d %d" size i;
    (* .#b50.#a49 *)
    let el = #{ el with b50 = #{ el.#b50 with a49 = next_el.#b50.#a49 } } in
    set_idx_mut a ((.(i).#b50.#a49) : (t50 array, _) idx_mut) next_el.#b50.#a49;
    mark_test_run 249;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 249 failed %d %d" size i;
    (* .#b50.#b49 *)
    let el = #{ el with b50 = #{ el.#b50 with b49 = next_el.#b50.#b49 } } in
    set_idx_mut a ((.(i).#b50.#b49) : (t50 array, _) idx_mut) next_el.#b50.#b49;
    mark_test_run 250;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 250 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t51 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a51 = a511 } : t51) (#{ a51 = a512 } : t51) -> (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) a511 a512) in
  let mk_value i = (#{ a51 = (#{ a5 = (i + 0); b5 = Int32_u.of_int (i + 1) } : t5) } : t51) in
  (* 1. Create an array of size [size] *)
  let a : t51 array = makearray_dynamic size (#{ a51 = (#{ a5 = 0; b5 = #1l } : t5) } : t51) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 251;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 251 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 252;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 252 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a51 *)
    let el = #{ el with a51 = next_el.#a51 } in
    set_idx_mut a ((.(i).#a51) : (t51 array, _) idx_mut) next_el.#a51;
    mark_test_run 253;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 253 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a51.#a5 *)
    let el = #{ el with a51 = #{ el.#a51 with a5 = next_el.#a51.#a5 } } in
    set_idx_mut a ((.(i).#a51.#a5) : (t51 array, _) idx_mut) next_el.#a51.#a5;
    mark_test_run 254;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 254 failed %d %d" size i;
    (* .#a51.#b5 *)
    let el = #{ el with a51 = #{ el.#a51 with b5 = next_el.#a51.#b5 } } in
    set_idx_mut a ((.(i).#a51.#b5) : (t51 array, _) idx_mut) next_el.#a51.#b5;
    mark_test_run 255;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 255 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t52 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun (#{ a52 = a521; b52 = b521 } : t52) (#{ a52 = a522; b52 = b522 } : t52) -> (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) a521 a522 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b521 b522) in
  let mk_value i = (#{ a52 = (#{ a5 = (i + 0); b5 = Int32_u.of_int (i + 1) } : t5); b52 = Int32_u.of_int (i + 2) } : t52) in
  (* 1. Create an array of size [size] *)
  let a : t52 array = makearray_dynamic size (#{ a52 = (#{ a5 = 0; b5 = #1l } : t5); b52 = #2l } : t52) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 256;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 256 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 257;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 257 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a52 *)
    let el = #{ el with a52 = next_el.#a52 } in
    set_idx_mut a ((.(i).#a52) : (t52 array, _) idx_mut) next_el.#a52;
    mark_test_run 258;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 258 failed %d %d" size i;
    (* .#b52 *)
    let el = #{ el with b52 = next_el.#b52 } in
    set_idx_mut a ((.(i).#b52) : (t52 array, _) idx_mut) next_el.#b52;
    mark_test_run 259;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 259 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a52.#a5 *)
    let el = #{ el with a52 = #{ el.#a52 with a5 = next_el.#a52.#a5 } } in
    set_idx_mut a ((.(i).#a52.#a5) : (t52 array, _) idx_mut) next_el.#a52.#a5;
    mark_test_run 260;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 260 failed %d %d" size i;
    (* .#a52.#b5 *)
    let el = #{ el with a52 = #{ el.#a52 with b5 = next_el.#a52.#b5 } } in
    set_idx_mut a ((.(i).#a52.#b5) : (t52 array, _) idx_mut) next_el.#a52.#b5;
    mark_test_run 261;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 261 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t53 = #{ #{ int; float } }   *)
  (**********************************)
  let eq = (fun (#{ a53 = a531 } : t53) (#{ a53 = a532 } : t53) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) a531 a532) in
  let mk_value i = (#{ a53 = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7) } : t53) in
  (* 1. Create an array of size [size] *)
  let a : t53 array = makearray_dynamic size (#{ a53 = (#{ a7 = 0; b7 = 1. } : t7) } : t53) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 262;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 262 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 263;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 263 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a53 *)
    let el = #{ el with a53 = next_el.#a53 } in
    set_idx_mut a ((.(i).#a53) : (t53 array, _) idx_mut) next_el.#a53;
    mark_test_run 264;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 264 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a53.#a7 *)
    let el = #{ el with a53 = #{ el.#a53 with a7 = next_el.#a53.#a7 } } in
    set_idx_mut a ((.(i).#a53.#a7) : (t53 array, _) idx_mut) next_el.#a53.#a7;
    mark_test_run 265;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 265 failed %d %d" size i;
    (* .#a53.#b7 *)
    let el = #{ el with a53 = #{ el.#a53 with b7 = next_el.#a53.#b7 } } in
    set_idx_mut a ((.(i).#a53.#b7) : (t53 array, _) idx_mut) next_el.#a53.#b7;
    mark_test_run 266;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 266 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t54 = #{ #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun (#{ a54 = a541; b54 = b541 } : t54) (#{ a54 = a542; b54 = b542 } : t54) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) a541 a542 && (fun a b -> Int.equal a b) b541 b542) in
  let mk_value i = (#{ a54 = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7); b54 = (i + 2) } : t54) in
  (* 1. Create an array of size [size] *)
  let a : t54 array = makearray_dynamic size (#{ a54 = (#{ a7 = 0; b7 = 1. } : t7); b54 = 2 } : t54) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 267;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 267 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 268;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 268 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a54 *)
    let el = #{ el with a54 = next_el.#a54 } in
    set_idx_mut a ((.(i).#a54) : (t54 array, _) idx_mut) next_el.#a54;
    mark_test_run 269;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 269 failed %d %d" size i;
    (* .#b54 *)
    let el = #{ el with b54 = next_el.#b54 } in
    set_idx_mut a ((.(i).#b54) : (t54 array, _) idx_mut) next_el.#b54;
    mark_test_run 270;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 270 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a54.#a7 *)
    let el = #{ el with a54 = #{ el.#a54 with a7 = next_el.#a54.#a7 } } in
    set_idx_mut a ((.(i).#a54.#a7) : (t54 array, _) idx_mut) next_el.#a54.#a7;
    mark_test_run 271;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 271 failed %d %d" size i;
    (* .#a54.#b7 *)
    let el = #{ el with a54 = #{ el.#a54 with b7 = next_el.#a54.#b7 } } in
    set_idx_mut a ((.(i).#a54.#b7) : (t54 array, _) idx_mut) next_el.#a54.#b7;
    mark_test_run 272;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 272 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t55 = #{ #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a55 = a551; b55 = b551 } : t55) (#{ a55 = a552; b55 = b552 } : t55) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) a551 a552 && (fun a b -> Float.equal (globalize a) (globalize b)) b551 b552) in
  let mk_value i = (#{ a55 = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7); b55 = Float.of_int (i + 2) } : t55) in
  (* 1. Create an array of size [size] *)
  let a : t55 array = makearray_dynamic size (#{ a55 = (#{ a7 = 0; b7 = 1. } : t7); b55 = 2. } : t55) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 273;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 273 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 274;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 274 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a55 *)
    let el = #{ el with a55 = next_el.#a55 } in
    set_idx_mut a ((.(i).#a55) : (t55 array, _) idx_mut) next_el.#a55;
    mark_test_run 275;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 275 failed %d %d" size i;
    (* .#b55 *)
    let el = #{ el with b55 = next_el.#b55 } in
    set_idx_mut a ((.(i).#b55) : (t55 array, _) idx_mut) next_el.#b55;
    mark_test_run 276;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 276 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a55.#a7 *)
    let el = #{ el with a55 = #{ el.#a55 with a7 = next_el.#a55.#a7 } } in
    set_idx_mut a ((.(i).#a55.#a7) : (t55 array, _) idx_mut) next_el.#a55.#a7;
    mark_test_run 277;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 277 failed %d %d" size i;
    (* .#a55.#b7 *)
    let el = #{ el with a55 = #{ el.#a55 with b7 = next_el.#a55.#b7 } } in
    set_idx_mut a ((.(i).#a55.#b7) : (t55 array, _) idx_mut) next_el.#a55.#b7;
    mark_test_run 278;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 278 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************)
  (*   t56 = #{ #{ int32# } }   *)
  (******************************)
  let eq = (fun (#{ a56 = a561 } : t56) (#{ a56 = a562 } : t56) -> (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) a561 a562) in
  let mk_value i = (#{ a56 = (#{ a14 = Int32_u.of_int (i + 0) } : t14) } : t56) in
  (* 1. Create an array of size [size] *)
  let a : t56 array = makearray_dynamic size (#{ a56 = (#{ a14 = #0l } : t14) } : t56) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 279;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 279 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 280;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 280 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a56 *)
    let el = #{ el with a56 = next_el.#a56 } in
    set_idx_mut a ((.(i).#a56) : (t56 array, _) idx_mut) next_el.#a56;
    mark_test_run 281;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 281 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a56.#a14 *)
    let el = #{ el with a56 = #{ el.#a56 with a14 = next_el.#a56.#a14 } } in
    set_idx_mut a ((.(i).#a56.#a14) : (t56 array, _) idx_mut) next_el.#a56.#a14;
    mark_test_run 282;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 282 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t57 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun (#{ a57 = a571; b57 = b571 } : t57) (#{ a57 = a572; b57 = b572 } : t57) -> (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) a571 a572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b571 b572) in
  let mk_value i = (#{ a57 = (#{ a14 = Int32_u.of_int (i + 0) } : t14); b57 = Int32_u.of_int (i + 1) } : t57) in
  (* 1. Create an array of size [size] *)
  let a : t57 array = makearray_dynamic size (#{ a57 = (#{ a14 = #0l } : t14); b57 = #1l } : t57) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 283;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 283 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 284;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 284 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a57 *)
    let el = #{ el with a57 = next_el.#a57 } in
    set_idx_mut a ((.(i).#a57) : (t57 array, _) idx_mut) next_el.#a57;
    mark_test_run 285;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 285 failed %d %d" size i;
    (* .#b57 *)
    let el = #{ el with b57 = next_el.#b57 } in
    set_idx_mut a ((.(i).#b57) : (t57 array, _) idx_mut) next_el.#b57;
    mark_test_run 286;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 286 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a57.#a14 *)
    let el = #{ el with a57 = #{ el.#a57 with a14 = next_el.#a57.#a14 } } in
    set_idx_mut a ((.(i).#a57.#a14) : (t57 array, _) idx_mut) next_el.#a57.#a14;
    mark_test_run 287;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 287 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t58 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a58 = a581 } : t58) (#{ a58 = a582 } : t58) -> (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) a581 a582) in
  let mk_value i = (#{ a58 = (#{ a16 = Int32_u.of_int (i + 0); b16 = Int32_u.of_int (i + 1) } : t16) } : t58) in
  (* 1. Create an array of size [size] *)
  let a : t58 array = makearray_dynamic size (#{ a58 = (#{ a16 = #0l; b16 = #1l } : t16) } : t58) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 288;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 288 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 289;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 289 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a58 *)
    let el = #{ el with a58 = next_el.#a58 } in
    set_idx_mut a ((.(i).#a58) : (t58 array, _) idx_mut) next_el.#a58;
    mark_test_run 290;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 290 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a58.#a16 *)
    let el = #{ el with a58 = #{ el.#a58 with a16 = next_el.#a58.#a16 } } in
    set_idx_mut a ((.(i).#a58.#a16) : (t58 array, _) idx_mut) next_el.#a58.#a16;
    mark_test_run 291;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 291 failed %d %d" size i;
    (* .#a58.#b16 *)
    let el = #{ el with a58 = #{ el.#a58 with b16 = next_el.#a58.#b16 } } in
    set_idx_mut a ((.(i).#a58.#b16) : (t58 array, _) idx_mut) next_el.#a58.#b16;
    mark_test_run 292;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 292 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t59 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun (#{ a59 = a591; b59 = b591 } : t59) (#{ a59 = a592; b59 = b592 } : t59) -> (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) a591 a592 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b591 b592) in
  let mk_value i = (#{ a59 = (#{ a16 = Int32_u.of_int (i + 0); b16 = Int32_u.of_int (i + 1) } : t16); b59 = Int32_u.of_int (i + 2) } : t59) in
  (* 1. Create an array of size [size] *)
  let a : t59 array = makearray_dynamic size (#{ a59 = (#{ a16 = #0l; b16 = #1l } : t16); b59 = #2l } : t59) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 293;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 293 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 294;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 294 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a59 *)
    let el = #{ el with a59 = next_el.#a59 } in
    set_idx_mut a ((.(i).#a59) : (t59 array, _) idx_mut) next_el.#a59;
    mark_test_run 295;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 295 failed %d %d" size i;
    (* .#b59 *)
    let el = #{ el with b59 = next_el.#b59 } in
    set_idx_mut a ((.(i).#b59) : (t59 array, _) idx_mut) next_el.#b59;
    mark_test_run 296;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 296 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a59.#a16 *)
    let el = #{ el with a59 = #{ el.#a59 with a16 = next_el.#a59.#a16 } } in
    set_idx_mut a ((.(i).#a59.#a16) : (t59 array, _) idx_mut) next_el.#a59.#a16;
    mark_test_run 297;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 297 failed %d %d" size i;
    (* .#a59.#b16 *)
    let el = #{ el with a59 = #{ el.#a59 with b16 = next_el.#a59.#b16 } } in
    set_idx_mut a ((.(i).#a59.#b16) : (t59 array, _) idx_mut) next_el.#a59.#b16;
    mark_test_run 298;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 298 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t60 = #{ #{ float }; int }   *)
  (**********************************)
  let eq = (fun (#{ a60 = a601; b60 = b601 } : t60) (#{ a60 = a602; b60 = b602 } : t60) -> (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) a601 a602 && (fun a b -> Int.equal a b) b601 b602) in
  let mk_value i = (#{ a60 = (#{ a18 = Float.of_int (i + 0) } : t18); b60 = (i + 1) } : t60) in
  (* 1. Create an array of size [size] *)
  let a : t60 array = makearray_dynamic size (#{ a60 = (#{ a18 = 0. } : t18); b60 = 1 } : t60) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 299;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 299 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 300;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 300 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a60 *)
    let el = #{ el with a60 = next_el.#a60 } in
    set_idx_mut a ((.(i).#a60) : (t60 array, _) idx_mut) next_el.#a60;
    mark_test_run 301;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 301 failed %d %d" size i;
    (* .#b60 *)
    let el = #{ el with b60 = next_el.#b60 } in
    set_idx_mut a ((.(i).#b60) : (t60 array, _) idx_mut) next_el.#b60;
    mark_test_run 302;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 302 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a60.#a18 *)
    let el = #{ el with a60 = #{ el.#a60 with a18 = next_el.#a60.#a18 } } in
    set_idx_mut a ((.(i).#a60.#a18) : (t60 array, _) idx_mut) next_el.#a60.#a18;
    mark_test_run 303;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 303 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t61 = #{ #{ float }; float }   *)
  (************************************)
  let eq = (fun (#{ a61 = a611; b61 = b611 } : t61) (#{ a61 = a612; b61 = b612 } : t61) -> (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) a611 a612 && (fun a b -> Float.equal (globalize a) (globalize b)) b611 b612) in
  let mk_value i = (#{ a61 = (#{ a18 = Float.of_int (i + 0) } : t18); b61 = Float.of_int (i + 1) } : t61) in
  (* 1. Create an array of size [size] *)
  let a : t61 array = makearray_dynamic size (#{ a61 = (#{ a18 = 0. } : t18); b61 = 1. } : t61) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 304;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 304 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 305;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 305 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a61 *)
    let el = #{ el with a61 = next_el.#a61 } in
    set_idx_mut a ((.(i).#a61) : (t61 array, _) idx_mut) next_el.#a61;
    mark_test_run 306;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 306 failed %d %d" size i;
    (* .#b61 *)
    let el = #{ el with b61 = next_el.#b61 } in
    set_idx_mut a ((.(i).#b61) : (t61 array, _) idx_mut) next_el.#b61;
    mark_test_run 307;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 307 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a61.#a18 *)
    let el = #{ el with a61 = #{ el.#a61 with a18 = next_el.#a61.#a18 } } in
    set_idx_mut a ((.(i).#a61.#a18) : (t61 array, _) idx_mut) next_el.#a61.#a18;
    mark_test_run 308;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 308 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t62 = #{ #{ float; int } }   *)
  (**********************************)
  let eq = (fun (#{ a62 = a621 } : t62) (#{ a62 = a622 } : t62) -> (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) a621 a622) in
  let mk_value i = (#{ a62 = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20) } : t62) in
  (* 1. Create an array of size [size] *)
  let a : t62 array = makearray_dynamic size (#{ a62 = (#{ a20 = 0.; b20 = 1 } : t20) } : t62) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 309;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 309 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 310;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 310 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a62 *)
    let el = #{ el with a62 = next_el.#a62 } in
    set_idx_mut a ((.(i).#a62) : (t62 array, _) idx_mut) next_el.#a62;
    mark_test_run 311;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 311 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a62.#a20 *)
    let el = #{ el with a62 = #{ el.#a62 with a20 = next_el.#a62.#a20 } } in
    set_idx_mut a ((.(i).#a62.#a20) : (t62 array, _) idx_mut) next_el.#a62.#a20;
    mark_test_run 312;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 312 failed %d %d" size i;
    (* .#a62.#b20 *)
    let el = #{ el with a62 = #{ el.#a62 with b20 = next_el.#a62.#b20 } } in
    set_idx_mut a ((.(i).#a62.#b20) : (t62 array, _) idx_mut) next_el.#a62.#b20;
    mark_test_run 313;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 313 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t63 = #{ #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun (#{ a63 = a631; b63 = b631 } : t63) (#{ a63 = a632; b63 = b632 } : t63) -> (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) a631 a632 && (fun a b -> Int.equal a b) b631 b632) in
  let mk_value i = (#{ a63 = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20); b63 = (i + 2) } : t63) in
  (* 1. Create an array of size [size] *)
  let a : t63 array = makearray_dynamic size (#{ a63 = (#{ a20 = 0.; b20 = 1 } : t20); b63 = 2 } : t63) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 314;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 314 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 315;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 315 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a63 *)
    let el = #{ el with a63 = next_el.#a63 } in
    set_idx_mut a ((.(i).#a63) : (t63 array, _) idx_mut) next_el.#a63;
    mark_test_run 316;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 316 failed %d %d" size i;
    (* .#b63 *)
    let el = #{ el with b63 = next_el.#b63 } in
    set_idx_mut a ((.(i).#b63) : (t63 array, _) idx_mut) next_el.#b63;
    mark_test_run 317;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 317 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a63.#a20 *)
    let el = #{ el with a63 = #{ el.#a63 with a20 = next_el.#a63.#a20 } } in
    set_idx_mut a ((.(i).#a63.#a20) : (t63 array, _) idx_mut) next_el.#a63.#a20;
    mark_test_run 318;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 318 failed %d %d" size i;
    (* .#a63.#b20 *)
    let el = #{ el with a63 = #{ el.#a63 with b20 = next_el.#a63.#b20 } } in
    set_idx_mut a ((.(i).#a63.#b20) : (t63 array, _) idx_mut) next_el.#a63.#b20;
    mark_test_run 319;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 319 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t64 = #{ #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a64 = a641; b64 = b641 } : t64) (#{ a64 = a642; b64 = b642 } : t64) -> (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) a641 a642 && (fun a b -> Float.equal (globalize a) (globalize b)) b641 b642) in
  let mk_value i = (#{ a64 = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20); b64 = Float.of_int (i + 2) } : t64) in
  (* 1. Create an array of size [size] *)
  let a : t64 array = makearray_dynamic size (#{ a64 = (#{ a20 = 0.; b20 = 1 } : t20); b64 = 2. } : t64) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 320;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 320 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 321;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 321 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a64 *)
    let el = #{ el with a64 = next_el.#a64 } in
    set_idx_mut a ((.(i).#a64) : (t64 array, _) idx_mut) next_el.#a64;
    mark_test_run 322;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 322 failed %d %d" size i;
    (* .#b64 *)
    let el = #{ el with b64 = next_el.#b64 } in
    set_idx_mut a ((.(i).#b64) : (t64 array, _) idx_mut) next_el.#b64;
    mark_test_run 323;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 323 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a64.#a20 *)
    let el = #{ el with a64 = #{ el.#a64 with a20 = next_el.#a64.#a20 } } in
    set_idx_mut a ((.(i).#a64.#a20) : (t64 array, _) idx_mut) next_el.#a64.#a20;
    mark_test_run 324;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 324 failed %d %d" size i;
    (* .#a64.#b20 *)
    let el = #{ el with a64 = #{ el.#a64 with b20 = next_el.#a64.#b20 } } in
    set_idx_mut a ((.(i).#a64.#b20) : (t64 array, _) idx_mut) next_el.#a64.#b20;
    mark_test_run 325;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 325 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t65 = #{ #{ float; float } }   *)
  (************************************)
  let eq = (fun (#{ a65 = a651 } : t65) (#{ a65 = a652 } : t65) -> (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) a651 a652) in
  let mk_value i = (#{ a65 = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22) } : t65) in
  (* 1. Create an array of size [size] *)
  let a : t65 array = makearray_dynamic size (#{ a65 = (#{ a22 = 0.; b22 = 1. } : t22) } : t65) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 326;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 326 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 327;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 327 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a65 *)
    let el = #{ el with a65 = next_el.#a65 } in
    set_idx_mut a ((.(i).#a65) : (t65 array, _) idx_mut) next_el.#a65;
    mark_test_run 328;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 328 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a65.#a22 *)
    let el = #{ el with a65 = #{ el.#a65 with a22 = next_el.#a65.#a22 } } in
    set_idx_mut a ((.(i).#a65.#a22) : (t65 array, _) idx_mut) next_el.#a65.#a22;
    mark_test_run 329;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 329 failed %d %d" size i;
    (* .#a65.#b22 *)
    let el = #{ el with a65 = #{ el.#a65 with b22 = next_el.#a65.#b22 } } in
    set_idx_mut a ((.(i).#a65.#b22) : (t65 array, _) idx_mut) next_el.#a65.#b22;
    mark_test_run 330;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 330 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t66 = #{ #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun (#{ a66 = a661; b66 = b661 } : t66) (#{ a66 = a662; b66 = b662 } : t66) -> (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) a661 a662 && (fun a b -> Int.equal a b) b661 b662) in
  let mk_value i = (#{ a66 = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22); b66 = (i + 2) } : t66) in
  (* 1. Create an array of size [size] *)
  let a : t66 array = makearray_dynamic size (#{ a66 = (#{ a22 = 0.; b22 = 1. } : t22); b66 = 2 } : t66) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 331;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 331 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 332;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 332 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a66 *)
    let el = #{ el with a66 = next_el.#a66 } in
    set_idx_mut a ((.(i).#a66) : (t66 array, _) idx_mut) next_el.#a66;
    mark_test_run 333;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 333 failed %d %d" size i;
    (* .#b66 *)
    let el = #{ el with b66 = next_el.#b66 } in
    set_idx_mut a ((.(i).#b66) : (t66 array, _) idx_mut) next_el.#b66;
    mark_test_run 334;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 334 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a66.#a22 *)
    let el = #{ el with a66 = #{ el.#a66 with a22 = next_el.#a66.#a22 } } in
    set_idx_mut a ((.(i).#a66.#a22) : (t66 array, _) idx_mut) next_el.#a66.#a22;
    mark_test_run 335;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 335 failed %d %d" size i;
    (* .#a66.#b22 *)
    let el = #{ el with a66 = #{ el.#a66 with b22 = next_el.#a66.#b22 } } in
    set_idx_mut a ((.(i).#a66.#b22) : (t66 array, _) idx_mut) next_el.#a66.#b22;
    mark_test_run 336;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 336 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t67 = #{ #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun (#{ a67 = a671; b67 = b671 } : t67) (#{ a67 = a672; b67 = b672 } : t67) -> (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) a671 a672 && (fun a b -> Float.equal (globalize a) (globalize b)) b671 b672) in
  let mk_value i = (#{ a67 = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22); b67 = Float.of_int (i + 2) } : t67) in
  (* 1. Create an array of size [size] *)
  let a : t67 array = makearray_dynamic size (#{ a67 = (#{ a22 = 0.; b22 = 1. } : t22); b67 = 2. } : t67) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 337;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 337 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 338;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 338 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a67 *)
    let el = #{ el with a67 = next_el.#a67 } in
    set_idx_mut a ((.(i).#a67) : (t67 array, _) idx_mut) next_el.#a67;
    mark_test_run 339;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 339 failed %d %d" size i;
    (* .#b67 *)
    let el = #{ el with b67 = next_el.#b67 } in
    set_idx_mut a ((.(i).#b67) : (t67 array, _) idx_mut) next_el.#b67;
    mark_test_run 340;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 340 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a67.#a22 *)
    let el = #{ el with a67 = #{ el.#a67 with a22 = next_el.#a67.#a22 } } in
    set_idx_mut a ((.(i).#a67.#a22) : (t67 array, _) idx_mut) next_el.#a67.#a22;
    mark_test_run 341;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 341 failed %d %d" size i;
    (* .#a67.#b22 *)
    let el = #{ el with a67 = #{ el.#a67 with b22 = next_el.#a67.#b22 } } in
    set_idx_mut a ((.(i).#a67.#b22) : (t67 array, _) idx_mut) next_el.#a67.#b22;
    mark_test_run 342;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 342 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()

let test_array_idx_with_makearray_dynamic_local size =
  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 343;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 343 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 344;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 344 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 345;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 345 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 346;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 346 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 347;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 347 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 348;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 348 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 349;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 349 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 350;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 350 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int (i + 0) in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 351;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 351 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 352;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 352 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    ()
  done;
  Gc.compact ();

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  let eq = (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) in
  let mk_value i = (#{ a0 = (i + 0) } : t0) in
  (* 1. Create an array of size [size] *)
  let a : t0 array = makearray_dynamic_local size (#{ a0 = 0 } : t0) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 353;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 353 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 354;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 354 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a0 *)
    let el = #{ el with a0 = next_el.#a0 } in
    set_idx_mut a ((.(i).#a0) : (t0 array, _) idx_mut) next_el.#a0;
    mark_test_run 355;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 355 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  let eq = (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) in
  let mk_value i = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) in
  (* 1. Create an array of size [size] *)
  let a : t1 array = makearray_dynamic_local size (#{ a1 = 0; b1 = 1 } : t1) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 356;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 356 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 357;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 357 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a1 *)
    let el = #{ el with a1 = next_el.#a1 } in
    set_idx_mut a ((.(i).#a1) : (t1 array, _) idx_mut) next_el.#a1;
    mark_test_run 358;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 358 failed %d %d" size i;
    (* .#b1 *)
    let el = #{ el with b1 = next_el.#b1 } in
    set_idx_mut a ((.(i).#b1) : (t1 array, _) idx_mut) next_el.#b1;
    mark_test_run 359;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 359 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  let eq = (fun (#{ a2 = a21; b2 = b21; c2 = c21 } : t2) (#{ a2 = a22; b2 = b22; c2 = c22 } : t2) -> (fun a b -> Int.equal a b) a21 a22 && (fun a b -> Int.equal a b) b21 b22 && (fun a b -> Int.equal a b) c21 c22) in
  let mk_value i = (#{ a2 = (i + 0); b2 = (i + 1); c2 = (i + 2) } : t2) in
  (* 1. Create an array of size [size] *)
  let a : t2 array = makearray_dynamic_local size (#{ a2 = 0; b2 = 1; c2 = 2 } : t2) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 360;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 360 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 361;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 361 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a2 *)
    let el = #{ el with a2 = next_el.#a2 } in
    set_idx_mut a ((.(i).#a2) : (t2 array, _) idx_mut) next_el.#a2;
    mark_test_run 362;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 362 failed %d %d" size i;
    (* .#b2 *)
    let el = #{ el with b2 = next_el.#b2 } in
    set_idx_mut a ((.(i).#b2) : (t2 array, _) idx_mut) next_el.#b2;
    mark_test_run 363;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 363 failed %d %d" size i;
    (* .#c2 *)
    let el = #{ el with c2 = next_el.#c2 } in
    set_idx_mut a ((.(i).#c2) : (t2 array, _) idx_mut) next_el.#c2;
    mark_test_run 364;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 364 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  let eq = (fun (#{ a3 = a31; b3 = b31; c3 = c31 } : t3) (#{ a3 = a32; b3 = b32; c3 = c32 } : t3) -> (fun a b -> Int.equal a b) a31 a32 && (fun a b -> Int.equal a b) b31 b32 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c31 c32) in
  let mk_value i = (#{ a3 = (i + 0); b3 = (i + 1); c3 = Int32_u.of_int (i + 2) } : t3) in
  (* 1. Create an array of size [size] *)
  let a : t3 array = makearray_dynamic_local size (#{ a3 = 0; b3 = 1; c3 = #2l } : t3) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 365;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 365 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 366;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 366 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a3 *)
    let el = #{ el with a3 = next_el.#a3 } in
    set_idx_mut a ((.(i).#a3) : (t3 array, _) idx_mut) next_el.#a3;
    mark_test_run 367;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 367 failed %d %d" size i;
    (* .#b3 *)
    let el = #{ el with b3 = next_el.#b3 } in
    set_idx_mut a ((.(i).#b3) : (t3 array, _) idx_mut) next_el.#b3;
    mark_test_run 368;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 368 failed %d %d" size i;
    (* .#c3 *)
    let el = #{ el with c3 = next_el.#c3 } in
    set_idx_mut a ((.(i).#c3) : (t3 array, _) idx_mut) next_el.#c3;
    mark_test_run 369;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 369 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  let eq = (fun (#{ a4 = a41; b4 = b41; c4 = c41 } : t4) (#{ a4 = a42; b4 = b42; c4 = c42 } : t4) -> (fun a b -> Int.equal a b) a41 a42 && (fun a b -> Int.equal a b) b41 b42 && (fun a b -> Float.equal (globalize a) (globalize b)) c41 c42) in
  let mk_value i = (#{ a4 = (i + 0); b4 = (i + 1); c4 = Float.of_int (i + 2) } : t4) in
  (* 1. Create an array of size [size] *)
  let a : t4 array = makearray_dynamic_local size (#{ a4 = 0; b4 = 1; c4 = 2. } : t4) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 370;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 370 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 371;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 371 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a4 *)
    let el = #{ el with a4 = next_el.#a4 } in
    set_idx_mut a ((.(i).#a4) : (t4 array, _) idx_mut) next_el.#a4;
    mark_test_run 372;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 372 failed %d %d" size i;
    (* .#b4 *)
    let el = #{ el with b4 = next_el.#b4 } in
    set_idx_mut a ((.(i).#b4) : (t4 array, _) idx_mut) next_el.#b4;
    mark_test_run 373;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 373 failed %d %d" size i;
    (* .#c4 *)
    let el = #{ el with c4 = next_el.#c4 } in
    set_idx_mut a ((.(i).#c4) : (t4 array, _) idx_mut) next_el.#c4;
    mark_test_run 374;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 374 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t5 = #{ int; int32# }   *)
  (*****************************)
  let eq = (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) in
  let mk_value i = (#{ a5 = (i + 0); b5 = Int32_u.of_int (i + 1) } : t5) in
  (* 1. Create an array of size [size] *)
  let a : t5 array = makearray_dynamic_local size (#{ a5 = 0; b5 = #1l } : t5) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 375;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 375 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 376;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 376 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a5 *)
    let el = #{ el with a5 = next_el.#a5 } in
    set_idx_mut a ((.(i).#a5) : (t5 array, _) idx_mut) next_el.#a5;
    mark_test_run 377;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 377 failed %d %d" size i;
    (* .#b5 *)
    let el = #{ el with b5 = next_el.#b5 } in
    set_idx_mut a ((.(i).#b5) : (t5 array, _) idx_mut) next_el.#b5;
    mark_test_run 378;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 378 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t6 = #{ int; int32#; int32# }   *)
  (*************************************)
  let eq = (fun (#{ a6 = a61; b6 = b61; c6 = c61 } : t6) (#{ a6 = a62; b6 = b62; c6 = c62 } : t6) -> (fun a b -> Int.equal a b) a61 a62 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b61 b62 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c61 c62) in
  let mk_value i = (#{ a6 = (i + 0); b6 = Int32_u.of_int (i + 1); c6 = Int32_u.of_int (i + 2) } : t6) in
  (* 1. Create an array of size [size] *)
  let a : t6 array = makearray_dynamic_local size (#{ a6 = 0; b6 = #1l; c6 = #2l } : t6) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 379;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 379 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 380;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 380 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a6 *)
    let el = #{ el with a6 = next_el.#a6 } in
    set_idx_mut a ((.(i).#a6) : (t6 array, _) idx_mut) next_el.#a6;
    mark_test_run 381;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 381 failed %d %d" size i;
    (* .#b6 *)
    let el = #{ el with b6 = next_el.#b6 } in
    set_idx_mut a ((.(i).#b6) : (t6 array, _) idx_mut) next_el.#b6;
    mark_test_run 382;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 382 failed %d %d" size i;
    (* .#c6 *)
    let el = #{ el with c6 = next_el.#c6 } in
    set_idx_mut a ((.(i).#c6) : (t6 array, _) idx_mut) next_el.#c6;
    mark_test_run 383;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 383 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************)
  (*   t7 = #{ int; float }   *)
  (****************************)
  let eq = (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) in
  let mk_value i = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7) in
  (* 1. Create an array of size [size] *)
  let a : t7 array = makearray_dynamic_local size (#{ a7 = 0; b7 = 1. } : t7) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 384;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 384 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 385;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 385 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a7 *)
    let el = #{ el with a7 = next_el.#a7 } in
    set_idx_mut a ((.(i).#a7) : (t7 array, _) idx_mut) next_el.#a7;
    mark_test_run 386;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 386 failed %d %d" size i;
    (* .#b7 *)
    let el = #{ el with b7 = next_el.#b7 } in
    set_idx_mut a ((.(i).#b7) : (t7 array, _) idx_mut) next_el.#b7;
    mark_test_run 387;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 387 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t8 = #{ int; float; int }   *)
  (*********************************)
  let eq = (fun (#{ a8 = a81; b8 = b81; c8 = c81 } : t8) (#{ a8 = a82; b8 = b82; c8 = c82 } : t8) -> (fun a b -> Int.equal a b) a81 a82 && (fun a b -> Float.equal (globalize a) (globalize b)) b81 b82 && (fun a b -> Int.equal a b) c81 c82) in
  let mk_value i = (#{ a8 = (i + 0); b8 = Float.of_int (i + 1); c8 = (i + 2) } : t8) in
  (* 1. Create an array of size [size] *)
  let a : t8 array = makearray_dynamic_local size (#{ a8 = 0; b8 = 1.; c8 = 2 } : t8) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 388;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 388 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 389;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 389 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a8 *)
    let el = #{ el with a8 = next_el.#a8 } in
    set_idx_mut a ((.(i).#a8) : (t8 array, _) idx_mut) next_el.#a8;
    mark_test_run 390;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 390 failed %d %d" size i;
    (* .#b8 *)
    let el = #{ el with b8 = next_el.#b8 } in
    set_idx_mut a ((.(i).#b8) : (t8 array, _) idx_mut) next_el.#b8;
    mark_test_run 391;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 391 failed %d %d" size i;
    (* .#c8 *)
    let el = #{ el with c8 = next_el.#c8 } in
    set_idx_mut a ((.(i).#c8) : (t8 array, _) idx_mut) next_el.#c8;
    mark_test_run 392;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 392 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t9 = #{ int; float; float }   *)
  (***********************************)
  let eq = (fun (#{ a9 = a91; b9 = b91; c9 = c91 } : t9) (#{ a9 = a92; b9 = b92; c9 = c92 } : t9) -> (fun a b -> Int.equal a b) a91 a92 && (fun a b -> Float.equal (globalize a) (globalize b)) b91 b92 && (fun a b -> Float.equal (globalize a) (globalize b)) c91 c92) in
  let mk_value i = (#{ a9 = (i + 0); b9 = Float.of_int (i + 1); c9 = Float.of_int (i + 2) } : t9) in
  (* 1. Create an array of size [size] *)
  let a : t9 array = makearray_dynamic_local size (#{ a9 = 0; b9 = 1.; c9 = 2. } : t9) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 393;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 393 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 394;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 394 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a9 *)
    let el = #{ el with a9 = next_el.#a9 } in
    set_idx_mut a ((.(i).#a9) : (t9 array, _) idx_mut) next_el.#a9;
    mark_test_run 395;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 395 failed %d %d" size i;
    (* .#b9 *)
    let el = #{ el with b9 = next_el.#b9 } in
    set_idx_mut a ((.(i).#b9) : (t9 array, _) idx_mut) next_el.#b9;
    mark_test_run 396;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 396 failed %d %d" size i;
    (* .#c9 *)
    let el = #{ el with c9 = next_el.#c9 } in
    set_idx_mut a ((.(i).#c9) : (t9 array, _) idx_mut) next_el.#c9;
    mark_test_run 397;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 397 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t10 = #{ int; #{ int } }   *)
  (********************************)
  let eq = (fun (#{ a10 = a101; b10 = b101 } : t10) (#{ a10 = a102; b10 = b102 } : t10) -> (fun a b -> Int.equal a b) a101 a102 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b101 b102) in
  let mk_value i = (#{ a10 = (i + 0); b10 = (#{ a0 = (i + 1) } : t0) } : t10) in
  (* 1. Create an array of size [size] *)
  let a : t10 array = makearray_dynamic_local size (#{ a10 = 0; b10 = (#{ a0 = 1 } : t0) } : t10) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 398;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 398 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 399;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 399 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a10 *)
    let el = #{ el with a10 = next_el.#a10 } in
    set_idx_mut a ((.(i).#a10) : (t10 array, _) idx_mut) next_el.#a10;
    mark_test_run 400;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 400 failed %d %d" size i;
    (* .#b10 *)
    let el = #{ el with b10 = next_el.#b10 } in
    set_idx_mut a ((.(i).#b10) : (t10 array, _) idx_mut) next_el.#b10;
    mark_test_run 401;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 401 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b10.#a0 *)
    let el = #{ el with b10 = #{ el.#b10 with a0 = next_el.#b10.#a0 } } in
    set_idx_mut a ((.(i).#b10.#a0) : (t10 array, _) idx_mut) next_el.#b10.#a0;
    mark_test_run 402;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 402 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t11 = #{ int; #{ int; int } }   *)
  (*************************************)
  let eq = (fun (#{ a11 = a111; b11 = b111 } : t11) (#{ a11 = a112; b11 = b112 } : t11) -> (fun a b -> Int.equal a b) a111 a112 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b111 b112) in
  let mk_value i = (#{ a11 = (i + 0); b11 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t11) in
  (* 1. Create an array of size [size] *)
  let a : t11 array = makearray_dynamic_local size (#{ a11 = 0; b11 = (#{ a1 = 1; b1 = 2 } : t1) } : t11) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 403;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 403 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 404;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 404 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a11 *)
    let el = #{ el with a11 = next_el.#a11 } in
    set_idx_mut a ((.(i).#a11) : (t11 array, _) idx_mut) next_el.#a11;
    mark_test_run 405;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 405 failed %d %d" size i;
    (* .#b11 *)
    let el = #{ el with b11 = next_el.#b11 } in
    set_idx_mut a ((.(i).#b11) : (t11 array, _) idx_mut) next_el.#b11;
    mark_test_run 406;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 406 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b11.#a1 *)
    let el = #{ el with b11 = #{ el.#b11 with a1 = next_el.#b11.#a1 } } in
    set_idx_mut a ((.(i).#b11.#a1) : (t11 array, _) idx_mut) next_el.#b11.#a1;
    mark_test_run 407;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 407 failed %d %d" size i;
    (* .#b11.#b1 *)
    let el = #{ el with b11 = #{ el.#b11 with b1 = next_el.#b11.#b1 } } in
    set_idx_mut a ((.(i).#b11.#b1) : (t11 array, _) idx_mut) next_el.#b11.#b1;
    mark_test_run 408;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 408 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t12 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  let eq = (fun (#{ a12 = a121; b12 = b121 } : t12) (#{ a12 = a122; b12 = b122 } : t12) -> (fun a b -> Int.equal a b) a121 a122 && (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) b121 b122) in
  let mk_value i = (#{ a12 = (i + 0); b12 = (#{ a5 = (i + 1); b5 = Int32_u.of_int (i + 2) } : t5) } : t12) in
  (* 1. Create an array of size [size] *)
  let a : t12 array = makearray_dynamic_local size (#{ a12 = 0; b12 = (#{ a5 = 1; b5 = #2l } : t5) } : t12) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 409;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 409 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 410;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 410 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a12 *)
    let el = #{ el with a12 = next_el.#a12 } in
    set_idx_mut a ((.(i).#a12) : (t12 array, _) idx_mut) next_el.#a12;
    mark_test_run 411;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 411 failed %d %d" size i;
    (* .#b12 *)
    let el = #{ el with b12 = next_el.#b12 } in
    set_idx_mut a ((.(i).#b12) : (t12 array, _) idx_mut) next_el.#b12;
    mark_test_run 412;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 412 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b12.#a5 *)
    let el = #{ el with b12 = #{ el.#b12 with a5 = next_el.#b12.#a5 } } in
    set_idx_mut a ((.(i).#b12.#a5) : (t12 array, _) idx_mut) next_el.#b12.#a5;
    mark_test_run 413;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 413 failed %d %d" size i;
    (* .#b12.#b5 *)
    let el = #{ el with b12 = #{ el.#b12 with b5 = next_el.#b12.#b5 } } in
    set_idx_mut a ((.(i).#b12.#b5) : (t12 array, _) idx_mut) next_el.#b12.#b5;
    mark_test_run 414;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 414 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t13 = #{ int; #{ int; float } }   *)
  (***************************************)
  let eq = (fun (#{ a13 = a131; b13 = b131 } : t13) (#{ a13 = a132; b13 = b132 } : t13) -> (fun a b -> Int.equal a b) a131 a132 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) b131 b132) in
  let mk_value i = (#{ a13 = (i + 0); b13 = (#{ a7 = (i + 1); b7 = Float.of_int (i + 2) } : t7) } : t13) in
  (* 1. Create an array of size [size] *)
  let a : t13 array = makearray_dynamic_local size (#{ a13 = 0; b13 = (#{ a7 = 1; b7 = 2. } : t7) } : t13) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 415;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 415 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 416;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 416 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a13 *)
    let el = #{ el with a13 = next_el.#a13 } in
    set_idx_mut a ((.(i).#a13) : (t13 array, _) idx_mut) next_el.#a13;
    mark_test_run 417;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 417 failed %d %d" size i;
    (* .#b13 *)
    let el = #{ el with b13 = next_el.#b13 } in
    set_idx_mut a ((.(i).#b13) : (t13 array, _) idx_mut) next_el.#b13;
    mark_test_run 418;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 418 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b13.#a7 *)
    let el = #{ el with b13 = #{ el.#b13 with a7 = next_el.#b13.#a7 } } in
    set_idx_mut a ((.(i).#b13.#a7) : (t13 array, _) idx_mut) next_el.#b13.#a7;
    mark_test_run 419;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 419 failed %d %d" size i;
    (* .#b13.#b7 *)
    let el = #{ el with b13 = #{ el.#b13 with b7 = next_el.#b13.#b7 } } in
    set_idx_mut a ((.(i).#b13.#b7) : (t13 array, _) idx_mut) next_el.#b13.#b7;
    mark_test_run 420;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 420 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t15 = #{ int; #{ int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a15 = a151; b15 = b151 } : t15) (#{ a15 = a152; b15 = b152 } : t15) -> (fun a b -> Int.equal a b) a151 a152 && (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) b151 b152) in
  let mk_value i = (#{ a15 = (i + 0); b15 = (#{ a14 = Int32_u.of_int (i + 1) } : t14) } : t15) in
  (* 1. Create an array of size [size] *)
  let a : t15 array = makearray_dynamic_local size (#{ a15 = 0; b15 = (#{ a14 = #1l } : t14) } : t15) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 421;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 421 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 422;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 422 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a15 *)
    let el = #{ el with a15 = next_el.#a15 } in
    set_idx_mut a ((.(i).#a15) : (t15 array, _) idx_mut) next_el.#a15;
    mark_test_run 423;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 423 failed %d %d" size i;
    (* .#b15 *)
    let el = #{ el with b15 = next_el.#b15 } in
    set_idx_mut a ((.(i).#b15) : (t15 array, _) idx_mut) next_el.#b15;
    mark_test_run 424;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 424 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b15.#a14 *)
    let el = #{ el with b15 = #{ el.#b15 with a14 = next_el.#b15.#a14 } } in
    set_idx_mut a ((.(i).#b15.#a14) : (t15 array, _) idx_mut) next_el.#b15.#a14;
    mark_test_run 425;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 425 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t17 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  let eq = (fun (#{ a17 = a171; b17 = b171 } : t17) (#{ a17 = a172; b17 = b172 } : t17) -> (fun a b -> Int.equal a b) a171 a172 && (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) b171 b172) in
  let mk_value i = (#{ a17 = (i + 0); b17 = (#{ a16 = Int32_u.of_int (i + 1); b16 = Int32_u.of_int (i + 2) } : t16) } : t17) in
  (* 1. Create an array of size [size] *)
  let a : t17 array = makearray_dynamic_local size (#{ a17 = 0; b17 = (#{ a16 = #1l; b16 = #2l } : t16) } : t17) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 426;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 426 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 427;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 427 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a17 *)
    let el = #{ el with a17 = next_el.#a17 } in
    set_idx_mut a ((.(i).#a17) : (t17 array, _) idx_mut) next_el.#a17;
    mark_test_run 428;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 428 failed %d %d" size i;
    (* .#b17 *)
    let el = #{ el with b17 = next_el.#b17 } in
    set_idx_mut a ((.(i).#b17) : (t17 array, _) idx_mut) next_el.#b17;
    mark_test_run 429;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 429 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b17.#a16 *)
    let el = #{ el with b17 = #{ el.#b17 with a16 = next_el.#b17.#a16 } } in
    set_idx_mut a ((.(i).#b17.#a16) : (t17 array, _) idx_mut) next_el.#b17.#a16;
    mark_test_run 430;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 430 failed %d %d" size i;
    (* .#b17.#b16 *)
    let el = #{ el with b17 = #{ el.#b17 with b16 = next_el.#b17.#b16 } } in
    set_idx_mut a ((.(i).#b17.#b16) : (t17 array, _) idx_mut) next_el.#b17.#b16;
    mark_test_run 431;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 431 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t19 = #{ int; #{ float } }   *)
  (**********************************)
  let eq = (fun (#{ a19 = a191; b19 = b191 } : t19) (#{ a19 = a192; b19 = b192 } : t19) -> (fun a b -> Int.equal a b) a191 a192 && (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) b191 b192) in
  let mk_value i = (#{ a19 = (i + 0); b19 = (#{ a18 = Float.of_int (i + 1) } : t18) } : t19) in
  (* 1. Create an array of size [size] *)
  let a : t19 array = makearray_dynamic_local size (#{ a19 = 0; b19 = (#{ a18 = 1. } : t18) } : t19) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 432;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 432 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 433;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 433 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a19 *)
    let el = #{ el with a19 = next_el.#a19 } in
    set_idx_mut a ((.(i).#a19) : (t19 array, _) idx_mut) next_el.#a19;
    mark_test_run 434;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 434 failed %d %d" size i;
    (* .#b19 *)
    let el = #{ el with b19 = next_el.#b19 } in
    set_idx_mut a ((.(i).#b19) : (t19 array, _) idx_mut) next_el.#b19;
    mark_test_run 435;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 435 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b19.#a18 *)
    let el = #{ el with b19 = #{ el.#b19 with a18 = next_el.#b19.#a18 } } in
    set_idx_mut a ((.(i).#b19.#a18) : (t19 array, _) idx_mut) next_el.#b19.#a18;
    mark_test_run 436;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 436 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t21 = #{ int; #{ float; int } }   *)
  (***************************************)
  let eq = (fun (#{ a21 = a211; b21 = b211 } : t21) (#{ a21 = a212; b21 = b212 } : t21) -> (fun a b -> Int.equal a b) a211 a212 && (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) b211 b212) in
  let mk_value i = (#{ a21 = (i + 0); b21 = (#{ a20 = Float.of_int (i + 1); b20 = (i + 2) } : t20) } : t21) in
  (* 1. Create an array of size [size] *)
  let a : t21 array = makearray_dynamic_local size (#{ a21 = 0; b21 = (#{ a20 = 1.; b20 = 2 } : t20) } : t21) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 437;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 437 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 438;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 438 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a21 *)
    let el = #{ el with a21 = next_el.#a21 } in
    set_idx_mut a ((.(i).#a21) : (t21 array, _) idx_mut) next_el.#a21;
    mark_test_run 439;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 439 failed %d %d" size i;
    (* .#b21 *)
    let el = #{ el with b21 = next_el.#b21 } in
    set_idx_mut a ((.(i).#b21) : (t21 array, _) idx_mut) next_el.#b21;
    mark_test_run 440;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 440 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b21.#a20 *)
    let el = #{ el with b21 = #{ el.#b21 with a20 = next_el.#b21.#a20 } } in
    set_idx_mut a ((.(i).#b21.#a20) : (t21 array, _) idx_mut) next_el.#b21.#a20;
    mark_test_run 441;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 441 failed %d %d" size i;
    (* .#b21.#b20 *)
    let el = #{ el with b21 = #{ el.#b21 with b20 = next_el.#b21.#b20 } } in
    set_idx_mut a ((.(i).#b21.#b20) : (t21 array, _) idx_mut) next_el.#b21.#b20;
    mark_test_run 442;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 442 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t23 = #{ int; #{ float; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a23 = a231; b23 = b231 } : t23) (#{ a23 = a232; b23 = b232 } : t23) -> (fun a b -> Int.equal a b) a231 a232 && (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) b231 b232) in
  let mk_value i = (#{ a23 = (i + 0); b23 = (#{ a22 = Float.of_int (i + 1); b22 = Float.of_int (i + 2) } : t22) } : t23) in
  (* 1. Create an array of size [size] *)
  let a : t23 array = makearray_dynamic_local size (#{ a23 = 0; b23 = (#{ a22 = 1.; b22 = 2. } : t22) } : t23) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 443;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 443 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 444;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 444 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a23 *)
    let el = #{ el with a23 = next_el.#a23 } in
    set_idx_mut a ((.(i).#a23) : (t23 array, _) idx_mut) next_el.#a23;
    mark_test_run 445;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 445 failed %d %d" size i;
    (* .#b23 *)
    let el = #{ el with b23 = next_el.#b23 } in
    set_idx_mut a ((.(i).#b23) : (t23 array, _) idx_mut) next_el.#b23;
    mark_test_run 446;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 446 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b23.#a22 *)
    let el = #{ el with b23 = #{ el.#b23 with a22 = next_el.#b23.#a22 } } in
    set_idx_mut a ((.(i).#b23.#a22) : (t23 array, _) idx_mut) next_el.#b23.#a22;
    mark_test_run 447;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 447 failed %d %d" size i;
    (* .#b23.#b22 *)
    let el = #{ el with b23 = #{ el.#b23 with b22 = next_el.#b23.#b22 } } in
    set_idx_mut a ((.(i).#b23.#b22) : (t23 array, _) idx_mut) next_el.#b23.#b22;
    mark_test_run 448;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 448 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************)
  (*   t24 = #{ int64 }   *)
  (************************)
  let eq = (fun (#{ a24 = a241 } : t24) (#{ a24 = a242 } : t24) -> (fun a b -> Int64.equal (globalize a) (globalize b)) a241 a242) in
  let mk_value i = (#{ a24 = Int64.of_int (i + 0) } : t24) in
  (* 1. Create an array of size [size] *)
  let a : t24 array = makearray_dynamic_local size (#{ a24 = 0L } : t24) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 449;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 449 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 450;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 450 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a24 *)
    let el = #{ el with a24 = next_el.#a24 } in
    set_idx_mut a ((.(i).#a24) : (t24 array, _) idx_mut) next_el.#a24;
    mark_test_run 451;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 451 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t25 = #{ int64# }   *)
  (*************************)
  let eq = (fun (#{ a25 = a251 } : t25) (#{ a25 = a252 } : t25) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a251 a252) in
  let mk_value i = (#{ a25 = Int64_u.of_int (i + 0) } : t25) in
  (* 1. Create an array of size [size] *)
  let a : t25 array = makearray_dynamic_local size (#{ a25 = #0L } : t25) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 452;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 452 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 453;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 453 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a25 *)
    let el = #{ el with a25 = next_el.#a25 } in
    set_idx_mut a ((.(i).#a25) : (t25 array, _) idx_mut) next_el.#a25;
    mark_test_run 454;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 454 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************)
  (*   t14 = #{ int32# }   *)
  (*************************)
  let eq = (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) in
  let mk_value i = (#{ a14 = Int32_u.of_int (i + 0) } : t14) in
  (* 1. Create an array of size [size] *)
  let a : t14 array = makearray_dynamic_local size (#{ a14 = #0l } : t14) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 455;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 455 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 456;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 456 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a14 *)
    let el = #{ el with a14 = next_el.#a14 } in
    set_idx_mut a ((.(i).#a14) : (t14 array, _) idx_mut) next_el.#a14;
    mark_test_run 457;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 457 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*********************************)
  (*   t16 = #{ int32#; int32# }   *)
  (*********************************)
  let eq = (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) in
  let mk_value i = (#{ a16 = Int32_u.of_int (i + 0); b16 = Int32_u.of_int (i + 1) } : t16) in
  (* 1. Create an array of size [size] *)
  let a : t16 array = makearray_dynamic_local size (#{ a16 = #0l; b16 = #1l } : t16) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 458;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 458 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 459;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 459 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a16 *)
    let el = #{ el with a16 = next_el.#a16 } in
    set_idx_mut a ((.(i).#a16) : (t16 array, _) idx_mut) next_el.#a16;
    mark_test_run 460;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 460 failed %d %d" size i;
    (* .#b16 *)
    let el = #{ el with b16 = next_el.#b16 } in
    set_idx_mut a ((.(i).#b16) : (t16 array, _) idx_mut) next_el.#b16;
    mark_test_run 461;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 461 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t26 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  let eq = (fun (#{ a26 = a261; b26 = b261; c26 = c261 } : t26) (#{ a26 = a262; b26 = b262; c26 = c262 } : t26) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a261 a262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b261 b262 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) c261 c262) in
  let mk_value i = (#{ a26 = Int32_u.of_int (i + 0); b26 = Int32_u.of_int (i + 1); c26 = Int32_u.of_int (i + 2) } : t26) in
  (* 1. Create an array of size [size] *)
  let a : t26 array = makearray_dynamic_local size (#{ a26 = #0l; b26 = #1l; c26 = #2l } : t26) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 462;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 462 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 463;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 463 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a26 *)
    let el = #{ el with a26 = next_el.#a26 } in
    set_idx_mut a ((.(i).#a26) : (t26 array, _) idx_mut) next_el.#a26;
    mark_test_run 464;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 464 failed %d %d" size i;
    (* .#b26 *)
    let el = #{ el with b26 = next_el.#b26 } in
    set_idx_mut a ((.(i).#b26) : (t26 array, _) idx_mut) next_el.#b26;
    mark_test_run 465;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 465 failed %d %d" size i;
    (* .#c26 *)
    let el = #{ el with c26 = next_el.#c26 } in
    set_idx_mut a ((.(i).#c26) : (t26 array, _) idx_mut) next_el.#c26;
    mark_test_run 466;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 466 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t27 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a27 = a271; b27 = b271 } : t27) (#{ a27 = a272; b27 = b272 } : t27) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a271 a272 && (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) b271 b272) in
  let mk_value i = (#{ a27 = Int32_u.of_int (i + 0); b27 = (#{ a14 = Int32_u.of_int (i + 1) } : t14) } : t27) in
  (* 1. Create an array of size [size] *)
  let a : t27 array = makearray_dynamic_local size (#{ a27 = #0l; b27 = (#{ a14 = #1l } : t14) } : t27) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 467;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 467 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 468;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 468 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a27 *)
    let el = #{ el with a27 = next_el.#a27 } in
    set_idx_mut a ((.(i).#a27) : (t27 array, _) idx_mut) next_el.#a27;
    mark_test_run 469;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 469 failed %d %d" size i;
    (* .#b27 *)
    let el = #{ el with b27 = next_el.#b27 } in
    set_idx_mut a ((.(i).#b27) : (t27 array, _) idx_mut) next_el.#b27;
    mark_test_run 470;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 470 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b27.#a14 *)
    let el = #{ el with b27 = #{ el.#b27 with a14 = next_el.#b27.#a14 } } in
    set_idx_mut a ((.(i).#b27.#a14) : (t27 array, _) idx_mut) next_el.#b27.#a14;
    mark_test_run 471;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 471 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t28 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  let eq = (fun (#{ a28 = a281; b28 = b281 } : t28) (#{ a28 = a282; b28 = b282 } : t28) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a281 a282 && (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) b281 b282) in
  let mk_value i = (#{ a28 = Int32_u.of_int (i + 0); b28 = (#{ a16 = Int32_u.of_int (i + 1); b16 = Int32_u.of_int (i + 2) } : t16) } : t28) in
  (* 1. Create an array of size [size] *)
  let a : t28 array = makearray_dynamic_local size (#{ a28 = #0l; b28 = (#{ a16 = #1l; b16 = #2l } : t16) } : t28) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 472;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 472 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 473;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 473 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a28 *)
    let el = #{ el with a28 = next_el.#a28 } in
    set_idx_mut a ((.(i).#a28) : (t28 array, _) idx_mut) next_el.#a28;
    mark_test_run 474;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 474 failed %d %d" size i;
    (* .#b28 *)
    let el = #{ el with b28 = next_el.#b28 } in
    set_idx_mut a ((.(i).#b28) : (t28 array, _) idx_mut) next_el.#b28;
    mark_test_run 475;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 475 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b28.#a16 *)
    let el = #{ el with b28 = #{ el.#b28 with a16 = next_el.#b28.#a16 } } in
    set_idx_mut a ((.(i).#b28.#a16) : (t28 array, _) idx_mut) next_el.#b28.#a16;
    mark_test_run 476;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 476 failed %d %d" size i;
    (* .#b28.#b16 *)
    let el = #{ el with b28 = #{ el.#b28 with b16 = next_el.#b28.#b16 } } in
    set_idx_mut a ((.(i).#b28.#b16) : (t28 array, _) idx_mut) next_el.#b28.#b16;
    mark_test_run 477;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 477 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t29 = #{ nativeint# }   *)
  (*****************************)
  let eq = (fun (#{ a29 = a291 } : t29) (#{ a29 = a292 } : t29) -> (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) a291 a292) in
  let mk_value i = (#{ a29 = Nativeint_u.of_int (i + 0) } : t29) in
  (* 1. Create an array of size [size] *)
  let a : t29 array = makearray_dynamic_local size (#{ a29 = #0n } : t29) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 478;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 478 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 479;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 479 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a29 *)
    let el = #{ el with a29 = next_el.#a29 } in
    set_idx_mut a ((.(i).#a29) : (t29 array, _) idx_mut) next_el.#a29;
    mark_test_run 480;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 480 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************)
  (*   t20 = #{ float; int }   *)
  (*****************************)
  let eq = (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) in
  let mk_value i = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20) in
  (* 1. Create an array of size [size] *)
  let a : t20 array = makearray_dynamic_local size (#{ a20 = 0.; b20 = 1 } : t20) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 481;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 481 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 482;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 482 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a20 *)
    let el = #{ el with a20 = next_el.#a20 } in
    set_idx_mut a ((.(i).#a20) : (t20 array, _) idx_mut) next_el.#a20;
    mark_test_run 483;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 483 failed %d %d" size i;
    (* .#b20 *)
    let el = #{ el with b20 = next_el.#b20 } in
    set_idx_mut a ((.(i).#b20) : (t20 array, _) idx_mut) next_el.#b20;
    mark_test_run 484;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 484 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t30 = #{ float; int; int }   *)
  (**********************************)
  let eq = (fun (#{ a30 = a301; b30 = b301; c30 = c301 } : t30) (#{ a30 = a302; b30 = b302; c30 = c302 } : t30) -> (fun a b -> Float.equal (globalize a) (globalize b)) a301 a302 && (fun a b -> Int.equal a b) b301 b302 && (fun a b -> Int.equal a b) c301 c302) in
  let mk_value i = (#{ a30 = Float.of_int (i + 0); b30 = (i + 1); c30 = (i + 2) } : t30) in
  (* 1. Create an array of size [size] *)
  let a : t30 array = makearray_dynamic_local size (#{ a30 = 0.; b30 = 1; c30 = 2 } : t30) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 485;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 485 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 486;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 486 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a30 *)
    let el = #{ el with a30 = next_el.#a30 } in
    set_idx_mut a ((.(i).#a30) : (t30 array, _) idx_mut) next_el.#a30;
    mark_test_run 487;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 487 failed %d %d" size i;
    (* .#b30 *)
    let el = #{ el with b30 = next_el.#b30 } in
    set_idx_mut a ((.(i).#b30) : (t30 array, _) idx_mut) next_el.#b30;
    mark_test_run 488;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 488 failed %d %d" size i;
    (* .#c30 *)
    let el = #{ el with c30 = next_el.#c30 } in
    set_idx_mut a ((.(i).#c30) : (t30 array, _) idx_mut) next_el.#c30;
    mark_test_run 489;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 489 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t31 = #{ float; int; float }   *)
  (************************************)
  let eq = (fun (#{ a31 = a311; b31 = b311; c31 = c311 } : t31) (#{ a31 = a312; b31 = b312; c31 = c312 } : t31) -> (fun a b -> Float.equal (globalize a) (globalize b)) a311 a312 && (fun a b -> Int.equal a b) b311 b312 && (fun a b -> Float.equal (globalize a) (globalize b)) c311 c312) in
  let mk_value i = (#{ a31 = Float.of_int (i + 0); b31 = (i + 1); c31 = Float.of_int (i + 2) } : t31) in
  (* 1. Create an array of size [size] *)
  let a : t31 array = makearray_dynamic_local size (#{ a31 = 0.; b31 = 1; c31 = 2. } : t31) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 490;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 490 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 491;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 491 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a31 *)
    let el = #{ el with a31 = next_el.#a31 } in
    set_idx_mut a ((.(i).#a31) : (t31 array, _) idx_mut) next_el.#a31;
    mark_test_run 492;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 492 failed %d %d" size i;
    (* .#b31 *)
    let el = #{ el with b31 = next_el.#b31 } in
    set_idx_mut a ((.(i).#b31) : (t31 array, _) idx_mut) next_el.#b31;
    mark_test_run 493;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 493 failed %d %d" size i;
    (* .#c31 *)
    let el = #{ el with c31 = next_el.#c31 } in
    set_idx_mut a ((.(i).#c31) : (t31 array, _) idx_mut) next_el.#c31;
    mark_test_run 494;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 494 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************)
  (*   t22 = #{ float; float }   *)
  (*******************************)
  let eq = (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) in
  let mk_value i = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22) in
  (* 1. Create an array of size [size] *)
  let a : t22 array = makearray_dynamic_local size (#{ a22 = 0.; b22 = 1. } : t22) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 495;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 495 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 496;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 496 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a22 *)
    let el = #{ el with a22 = next_el.#a22 } in
    set_idx_mut a ((.(i).#a22) : (t22 array, _) idx_mut) next_el.#a22;
    mark_test_run 497;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 497 failed %d %d" size i;
    (* .#b22 *)
    let el = #{ el with b22 = next_el.#b22 } in
    set_idx_mut a ((.(i).#b22) : (t22 array, _) idx_mut) next_el.#b22;
    mark_test_run 498;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 498 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t32 = #{ float; float; int }   *)
  (************************************)
  let eq = (fun (#{ a32 = a321; b32 = b321; c32 = c321 } : t32) (#{ a32 = a322; b32 = b322; c32 = c322 } : t32) -> (fun a b -> Float.equal (globalize a) (globalize b)) a321 a322 && (fun a b -> Float.equal (globalize a) (globalize b)) b321 b322 && (fun a b -> Int.equal a b) c321 c322) in
  let mk_value i = (#{ a32 = Float.of_int (i + 0); b32 = Float.of_int (i + 1); c32 = (i + 2) } : t32) in
  (* 1. Create an array of size [size] *)
  let a : t32 array = makearray_dynamic_local size (#{ a32 = 0.; b32 = 1.; c32 = 2 } : t32) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 499;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 499 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 500;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 500 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a32 *)
    let el = #{ el with a32 = next_el.#a32 } in
    set_idx_mut a ((.(i).#a32) : (t32 array, _) idx_mut) next_el.#a32;
    mark_test_run 501;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 501 failed %d %d" size i;
    (* .#b32 *)
    let el = #{ el with b32 = next_el.#b32 } in
    set_idx_mut a ((.(i).#b32) : (t32 array, _) idx_mut) next_el.#b32;
    mark_test_run 502;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 502 failed %d %d" size i;
    (* .#c32 *)
    let el = #{ el with c32 = next_el.#c32 } in
    set_idx_mut a ((.(i).#c32) : (t32 array, _) idx_mut) next_el.#c32;
    mark_test_run 503;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 503 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t33 = #{ float; float; float }   *)
  (**************************************)
  let eq = (fun (#{ a33 = a331; b33 = b331; c33 = c331 } : t33) (#{ a33 = a332; b33 = b332; c33 = c332 } : t33) -> (fun a b -> Float.equal (globalize a) (globalize b)) a331 a332 && (fun a b -> Float.equal (globalize a) (globalize b)) b331 b332 && (fun a b -> Float.equal (globalize a) (globalize b)) c331 c332) in
  let mk_value i = (#{ a33 = Float.of_int (i + 0); b33 = Float.of_int (i + 1); c33 = Float.of_int (i + 2) } : t33) in
  (* 1. Create an array of size [size] *)
  let a : t33 array = makearray_dynamic_local size (#{ a33 = 0.; b33 = 1.; c33 = 2. } : t33) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 504;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 504 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 505;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 505 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a33 *)
    let el = #{ el with a33 = next_el.#a33 } in
    set_idx_mut a ((.(i).#a33) : (t33 array, _) idx_mut) next_el.#a33;
    mark_test_run 506;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 506 failed %d %d" size i;
    (* .#b33 *)
    let el = #{ el with b33 = next_el.#b33 } in
    set_idx_mut a ((.(i).#b33) : (t33 array, _) idx_mut) next_el.#b33;
    mark_test_run 507;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 507 failed %d %d" size i;
    (* .#c33 *)
    let el = #{ el with c33 = next_el.#c33 } in
    set_idx_mut a ((.(i).#c33) : (t33 array, _) idx_mut) next_el.#c33;
    mark_test_run 508;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 508 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t34 = #{ float; #{ int } }   *)
  (**********************************)
  let eq = (fun (#{ a34 = a341; b34 = b341 } : t34) (#{ a34 = a342; b34 = b342 } : t34) -> (fun a b -> Float.equal (globalize a) (globalize b)) a341 a342 && (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) b341 b342) in
  let mk_value i = (#{ a34 = Float.of_int (i + 0); b34 = (#{ a0 = (i + 1) } : t0) } : t34) in
  (* 1. Create an array of size [size] *)
  let a : t34 array = makearray_dynamic_local size (#{ a34 = 0.; b34 = (#{ a0 = 1 } : t0) } : t34) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 509;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 509 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 510;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 510 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a34 *)
    let el = #{ el with a34 = next_el.#a34 } in
    set_idx_mut a ((.(i).#a34) : (t34 array, _) idx_mut) next_el.#a34;
    mark_test_run 511;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 511 failed %d %d" size i;
    (* .#b34 *)
    let el = #{ el with b34 = next_el.#b34 } in
    set_idx_mut a ((.(i).#b34) : (t34 array, _) idx_mut) next_el.#b34;
    mark_test_run 512;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 512 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b34.#a0 *)
    let el = #{ el with b34 = #{ el.#b34 with a0 = next_el.#b34.#a0 } } in
    set_idx_mut a ((.(i).#b34.#a0) : (t34 array, _) idx_mut) next_el.#b34.#a0;
    mark_test_run 513;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 513 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t35 = #{ float; #{ int; int } }   *)
  (***************************************)
  let eq = (fun (#{ a35 = a351; b35 = b351 } : t35) (#{ a35 = a352; b35 = b352 } : t35) -> (fun a b -> Float.equal (globalize a) (globalize b)) a351 a352 && (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) b351 b352) in
  let mk_value i = (#{ a35 = Float.of_int (i + 0); b35 = (#{ a1 = (i + 1); b1 = (i + 2) } : t1) } : t35) in
  (* 1. Create an array of size [size] *)
  let a : t35 array = makearray_dynamic_local size (#{ a35 = 0.; b35 = (#{ a1 = 1; b1 = 2 } : t1) } : t35) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 514;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 514 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 515;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 515 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a35 *)
    let el = #{ el with a35 = next_el.#a35 } in
    set_idx_mut a ((.(i).#a35) : (t35 array, _) idx_mut) next_el.#a35;
    mark_test_run 516;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 516 failed %d %d" size i;
    (* .#b35 *)
    let el = #{ el with b35 = next_el.#b35 } in
    set_idx_mut a ((.(i).#b35) : (t35 array, _) idx_mut) next_el.#b35;
    mark_test_run 517;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 517 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b35.#a1 *)
    let el = #{ el with b35 = #{ el.#b35 with a1 = next_el.#b35.#a1 } } in
    set_idx_mut a ((.(i).#b35.#a1) : (t35 array, _) idx_mut) next_el.#b35.#a1;
    mark_test_run 518;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 518 failed %d %d" size i;
    (* .#b35.#b1 *)
    let el = #{ el with b35 = #{ el.#b35 with b1 = next_el.#b35.#b1 } } in
    set_idx_mut a ((.(i).#b35.#b1) : (t35 array, _) idx_mut) next_el.#b35.#b1;
    mark_test_run 519;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 519 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t36 = #{ float; #{ int; float } }   *)
  (*****************************************)
  let eq = (fun (#{ a36 = a361; b36 = b361 } : t36) (#{ a36 = a362; b36 = b362 } : t36) -> (fun a b -> Float.equal (globalize a) (globalize b)) a361 a362 && (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) b361 b362) in
  let mk_value i = (#{ a36 = Float.of_int (i + 0); b36 = (#{ a7 = (i + 1); b7 = Float.of_int (i + 2) } : t7) } : t36) in
  (* 1. Create an array of size [size] *)
  let a : t36 array = makearray_dynamic_local size (#{ a36 = 0.; b36 = (#{ a7 = 1; b7 = 2. } : t7) } : t36) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 520;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 520 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 521;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 521 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a36 *)
    let el = #{ el with a36 = next_el.#a36 } in
    set_idx_mut a ((.(i).#a36) : (t36 array, _) idx_mut) next_el.#a36;
    mark_test_run 522;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 522 failed %d %d" size i;
    (* .#b36 *)
    let el = #{ el with b36 = next_el.#b36 } in
    set_idx_mut a ((.(i).#b36) : (t36 array, _) idx_mut) next_el.#b36;
    mark_test_run 523;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 523 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b36.#a7 *)
    let el = #{ el with b36 = #{ el.#b36 with a7 = next_el.#b36.#a7 } } in
    set_idx_mut a ((.(i).#b36.#a7) : (t36 array, _) idx_mut) next_el.#b36.#a7;
    mark_test_run 524;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 524 failed %d %d" size i;
    (* .#b36.#b7 *)
    let el = #{ el with b36 = #{ el.#b36 with b7 = next_el.#b36.#b7 } } in
    set_idx_mut a ((.(i).#b36.#b7) : (t36 array, _) idx_mut) next_el.#b36.#b7;
    mark_test_run 525;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 525 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t37 = #{ float; #{ float } }   *)
  (************************************)
  let eq = (fun (#{ a37 = a371; b37 = b371 } : t37) (#{ a37 = a372; b37 = b372 } : t37) -> (fun a b -> Float.equal (globalize a) (globalize b)) a371 a372 && (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) b371 b372) in
  let mk_value i = (#{ a37 = Float.of_int (i + 0); b37 = (#{ a18 = Float.of_int (i + 1) } : t18) } : t37) in
  (* 1. Create an array of size [size] *)
  let a : t37 array = makearray_dynamic_local size (#{ a37 = 0.; b37 = (#{ a18 = 1. } : t18) } : t37) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 526;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 526 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 527;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 527 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a37 *)
    let el = #{ el with a37 = next_el.#a37 } in
    set_idx_mut a ((.(i).#a37) : (t37 array, _) idx_mut) next_el.#a37;
    mark_test_run 528;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 528 failed %d %d" size i;
    (* .#b37 *)
    let el = #{ el with b37 = next_el.#b37 } in
    set_idx_mut a ((.(i).#b37) : (t37 array, _) idx_mut) next_el.#b37;
    mark_test_run 529;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 529 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b37.#a18 *)
    let el = #{ el with b37 = #{ el.#b37 with a18 = next_el.#b37.#a18 } } in
    set_idx_mut a ((.(i).#b37.#a18) : (t37 array, _) idx_mut) next_el.#b37.#a18;
    mark_test_run 530;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 530 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t38 = #{ float; #{ float; int } }   *)
  (*****************************************)
  let eq = (fun (#{ a38 = a381; b38 = b381 } : t38) (#{ a38 = a382; b38 = b382 } : t38) -> (fun a b -> Float.equal (globalize a) (globalize b)) a381 a382 && (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) b381 b382) in
  let mk_value i = (#{ a38 = Float.of_int (i + 0); b38 = (#{ a20 = Float.of_int (i + 1); b20 = (i + 2) } : t20) } : t38) in
  (* 1. Create an array of size [size] *)
  let a : t38 array = makearray_dynamic_local size (#{ a38 = 0.; b38 = (#{ a20 = 1.; b20 = 2 } : t20) } : t38) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 531;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 531 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 532;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 532 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a38 *)
    let el = #{ el with a38 = next_el.#a38 } in
    set_idx_mut a ((.(i).#a38) : (t38 array, _) idx_mut) next_el.#a38;
    mark_test_run 533;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 533 failed %d %d" size i;
    (* .#b38 *)
    let el = #{ el with b38 = next_el.#b38 } in
    set_idx_mut a ((.(i).#b38) : (t38 array, _) idx_mut) next_el.#b38;
    mark_test_run 534;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 534 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b38.#a20 *)
    let el = #{ el with b38 = #{ el.#b38 with a20 = next_el.#b38.#a20 } } in
    set_idx_mut a ((.(i).#b38.#a20) : (t38 array, _) idx_mut) next_el.#b38.#a20;
    mark_test_run 535;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 535 failed %d %d" size i;
    (* .#b38.#b20 *)
    let el = #{ el with b38 = #{ el.#b38 with b20 = next_el.#b38.#b20 } } in
    set_idx_mut a ((.(i).#b38.#b20) : (t38 array, _) idx_mut) next_el.#b38.#b20;
    mark_test_run 536;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 536 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t39 = #{ float; #{ float; float } }   *)
  (*******************************************)
  let eq = (fun (#{ a39 = a391; b39 = b391 } : t39) (#{ a39 = a392; b39 = b392 } : t39) -> (fun a b -> Float.equal (globalize a) (globalize b)) a391 a392 && (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) b391 b392) in
  let mk_value i = (#{ a39 = Float.of_int (i + 0); b39 = (#{ a22 = Float.of_int (i + 1); b22 = Float.of_int (i + 2) } : t22) } : t39) in
  (* 1. Create an array of size [size] *)
  let a : t39 array = makearray_dynamic_local size (#{ a39 = 0.; b39 = (#{ a22 = 1.; b22 = 2. } : t22) } : t39) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 537;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 537 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 538;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 538 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a39 *)
    let el = #{ el with a39 = next_el.#a39 } in
    set_idx_mut a ((.(i).#a39) : (t39 array, _) idx_mut) next_el.#a39;
    mark_test_run 539;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 539 failed %d %d" size i;
    (* .#b39 *)
    let el = #{ el with b39 = next_el.#b39 } in
    set_idx_mut a ((.(i).#b39) : (t39 array, _) idx_mut) next_el.#b39;
    mark_test_run 540;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 540 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#b39.#a22 *)
    let el = #{ el with b39 = #{ el.#b39 with a22 = next_el.#b39.#a22 } } in
    set_idx_mut a ((.(i).#b39.#a22) : (t39 array, _) idx_mut) next_el.#b39.#a22;
    mark_test_run 541;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 541 failed %d %d" size i;
    (* .#b39.#b22 *)
    let el = #{ el with b39 = #{ el.#b39 with b22 = next_el.#b39.#b22 } } in
    set_idx_mut a ((.(i).#b39.#b22) : (t39 array, _) idx_mut) next_el.#b39.#b22;
    mark_test_run 542;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 542 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************)
  (*   t40 = #{ #{ int } }   *)
  (***************************)
  let eq = (fun (#{ a40 = a401 } : t40) (#{ a40 = a402 } : t40) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a401 a402) in
  let mk_value i = (#{ a40 = (#{ a0 = (i + 0) } : t0) } : t40) in
  (* 1. Create an array of size [size] *)
  let a : t40 array = makearray_dynamic_local size (#{ a40 = (#{ a0 = 0 } : t0) } : t40) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 543;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 543 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 544;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 544 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a40 *)
    let el = #{ el with a40 = next_el.#a40 } in
    set_idx_mut a ((.(i).#a40) : (t40 array, _) idx_mut) next_el.#a40;
    mark_test_run 545;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 545 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a40.#a0 *)
    let el = #{ el with a40 = #{ el.#a40 with a0 = next_el.#a40.#a0 } } in
    set_idx_mut a ((.(i).#a40.#a0) : (t40 array, _) idx_mut) next_el.#a40.#a0;
    mark_test_run 546;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 546 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t41 = #{ #{ int }; int }   *)
  (********************************)
  let eq = (fun (#{ a41 = a411; b41 = b411 } : t41) (#{ a41 = a412; b41 = b412 } : t41) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a411 a412 && (fun a b -> Int.equal a b) b411 b412) in
  let mk_value i = (#{ a41 = (#{ a0 = (i + 0) } : t0); b41 = (i + 1) } : t41) in
  (* 1. Create an array of size [size] *)
  let a : t41 array = makearray_dynamic_local size (#{ a41 = (#{ a0 = 0 } : t0); b41 = 1 } : t41) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 547;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 547 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 548;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 548 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a41 *)
    let el = #{ el with a41 = next_el.#a41 } in
    set_idx_mut a ((.(i).#a41) : (t41 array, _) idx_mut) next_el.#a41;
    mark_test_run 549;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 549 failed %d %d" size i;
    (* .#b41 *)
    let el = #{ el with b41 = next_el.#b41 } in
    set_idx_mut a ((.(i).#b41) : (t41 array, _) idx_mut) next_el.#b41;
    mark_test_run 550;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 550 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a41.#a0 *)
    let el = #{ el with a41 = #{ el.#a41 with a0 = next_el.#a41.#a0 } } in
    set_idx_mut a ((.(i).#a41.#a0) : (t41 array, _) idx_mut) next_el.#a41.#a0;
    mark_test_run 551;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 551 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t42 = #{ #{ int }; int32# }   *)
  (***********************************)
  let eq = (fun (#{ a42 = a421; b42 = b421 } : t42) (#{ a42 = a422; b42 = b422 } : t42) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a421 a422 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b421 b422) in
  let mk_value i = (#{ a42 = (#{ a0 = (i + 0) } : t0); b42 = Int32_u.of_int (i + 1) } : t42) in
  (* 1. Create an array of size [size] *)
  let a : t42 array = makearray_dynamic_local size (#{ a42 = (#{ a0 = 0 } : t0); b42 = #1l } : t42) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 552;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 552 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 553;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 553 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a42 *)
    let el = #{ el with a42 = next_el.#a42 } in
    set_idx_mut a ((.(i).#a42) : (t42 array, _) idx_mut) next_el.#a42;
    mark_test_run 554;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 554 failed %d %d" size i;
    (* .#b42 *)
    let el = #{ el with b42 = next_el.#b42 } in
    set_idx_mut a ((.(i).#b42) : (t42 array, _) idx_mut) next_el.#b42;
    mark_test_run 555;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 555 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a42.#a0 *)
    let el = #{ el with a42 = #{ el.#a42 with a0 = next_el.#a42.#a0 } } in
    set_idx_mut a ((.(i).#a42.#a0) : (t42 array, _) idx_mut) next_el.#a42.#a0;
    mark_test_run 556;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 556 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t43 = #{ #{ int }; float }   *)
  (**********************************)
  let eq = (fun (#{ a43 = a431; b43 = b431 } : t43) (#{ a43 = a432; b43 = b432 } : t43) -> (fun (#{ a0 = a01 } : t0) (#{ a0 = a02 } : t0) -> (fun a b -> Int.equal a b) a01 a02) a431 a432 && (fun a b -> Float.equal (globalize a) (globalize b)) b431 b432) in
  let mk_value i = (#{ a43 = (#{ a0 = (i + 0) } : t0); b43 = Float.of_int (i + 1) } : t43) in
  (* 1. Create an array of size [size] *)
  let a : t43 array = makearray_dynamic_local size (#{ a43 = (#{ a0 = 0 } : t0); b43 = 1. } : t43) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 557;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 557 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 558;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 558 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a43 *)
    let el = #{ el with a43 = next_el.#a43 } in
    set_idx_mut a ((.(i).#a43) : (t43 array, _) idx_mut) next_el.#a43;
    mark_test_run 559;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 559 failed %d %d" size i;
    (* .#b43 *)
    let el = #{ el with b43 = next_el.#b43 } in
    set_idx_mut a ((.(i).#b43) : (t43 array, _) idx_mut) next_el.#b43;
    mark_test_run 560;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 560 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a43.#a0 *)
    let el = #{ el with a43 = #{ el.#a43 with a0 = next_el.#a43.#a0 } } in
    set_idx_mut a ((.(i).#a43.#a0) : (t43 array, _) idx_mut) next_el.#a43.#a0;
    mark_test_run 561;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 561 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************)
  (*   t44 = #{ #{ int; int } }   *)
  (********************************)
  let eq = (fun (#{ a44 = a441 } : t44) (#{ a44 = a442 } : t44) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a441 a442) in
  let mk_value i = (#{ a44 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1) } : t44) in
  (* 1. Create an array of size [size] *)
  let a : t44 array = makearray_dynamic_local size (#{ a44 = (#{ a1 = 0; b1 = 1 } : t1) } : t44) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 562;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 562 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 563;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 563 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a44 *)
    let el = #{ el with a44 = next_el.#a44 } in
    set_idx_mut a ((.(i).#a44) : (t44 array, _) idx_mut) next_el.#a44;
    mark_test_run 564;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 564 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a44.#a1 *)
    let el = #{ el with a44 = #{ el.#a44 with a1 = next_el.#a44.#a1 } } in
    set_idx_mut a ((.(i).#a44.#a1) : (t44 array, _) idx_mut) next_el.#a44.#a1;
    mark_test_run 565;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 565 failed %d %d" size i;
    (* .#a44.#b1 *)
    let el = #{ el with a44 = #{ el.#a44 with b1 = next_el.#a44.#b1 } } in
    set_idx_mut a ((.(i).#a44.#b1) : (t44 array, _) idx_mut) next_el.#a44.#b1;
    mark_test_run 566;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 566 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*************************************)
  (*   t45 = #{ #{ int; int }; int }   *)
  (*************************************)
  let eq = (fun (#{ a45 = a451; b45 = b451 } : t45) (#{ a45 = a452; b45 = b452 } : t45) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a451 a452 && (fun a b -> Int.equal a b) b451 b452) in
  let mk_value i = (#{ a45 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b45 = (i + 2) } : t45) in
  (* 1. Create an array of size [size] *)
  let a : t45 array = makearray_dynamic_local size (#{ a45 = (#{ a1 = 0; b1 = 1 } : t1); b45 = 2 } : t45) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 567;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 567 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 568;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 568 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a45 *)
    let el = #{ el with a45 = next_el.#a45 } in
    set_idx_mut a ((.(i).#a45) : (t45 array, _) idx_mut) next_el.#a45;
    mark_test_run 569;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 569 failed %d %d" size i;
    (* .#b45 *)
    let el = #{ el with b45 = next_el.#b45 } in
    set_idx_mut a ((.(i).#b45) : (t45 array, _) idx_mut) next_el.#b45;
    mark_test_run 570;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 570 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a45.#a1 *)
    let el = #{ el with a45 = #{ el.#a45 with a1 = next_el.#a45.#a1 } } in
    set_idx_mut a ((.(i).#a45.#a1) : (t45 array, _) idx_mut) next_el.#a45.#a1;
    mark_test_run 571;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 571 failed %d %d" size i;
    (* .#a45.#b1 *)
    let el = #{ el with a45 = #{ el.#a45 with b1 = next_el.#a45.#b1 } } in
    set_idx_mut a ((.(i).#a45.#b1) : (t45 array, _) idx_mut) next_el.#a45.#b1;
    mark_test_run 572;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 572 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (****************************************)
  (*   t46 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  let eq = (fun (#{ a46 = a461; b46 = b461 } : t46) (#{ a46 = a462; b46 = b462 } : t46) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a461 a462 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b461 b462) in
  let mk_value i = (#{ a46 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b46 = Int32_u.of_int (i + 2) } : t46) in
  (* 1. Create an array of size [size] *)
  let a : t46 array = makearray_dynamic_local size (#{ a46 = (#{ a1 = 0; b1 = 1 } : t1); b46 = #2l } : t46) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 573;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 573 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 574;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 574 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a46 *)
    let el = #{ el with a46 = next_el.#a46 } in
    set_idx_mut a ((.(i).#a46) : (t46 array, _) idx_mut) next_el.#a46;
    mark_test_run 575;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 575 failed %d %d" size i;
    (* .#b46 *)
    let el = #{ el with b46 = next_el.#b46 } in
    set_idx_mut a ((.(i).#b46) : (t46 array, _) idx_mut) next_el.#b46;
    mark_test_run 576;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 576 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a46.#a1 *)
    let el = #{ el with a46 = #{ el.#a46 with a1 = next_el.#a46.#a1 } } in
    set_idx_mut a ((.(i).#a46.#a1) : (t46 array, _) idx_mut) next_el.#a46.#a1;
    mark_test_run 577;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 577 failed %d %d" size i;
    (* .#a46.#b1 *)
    let el = #{ el with a46 = #{ el.#a46 with b1 = next_el.#a46.#b1 } } in
    set_idx_mut a ((.(i).#a46.#b1) : (t46 array, _) idx_mut) next_el.#a46.#b1;
    mark_test_run 578;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 578 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t47 = #{ #{ int; int }; float }   *)
  (***************************************)
  let eq = (fun (#{ a47 = a471; b47 = b471 } : t47) (#{ a47 = a472; b47 = b472 } : t47) -> (fun (#{ a1 = a11; b1 = b11 } : t1) (#{ a1 = a12; b1 = b12 } : t1) -> (fun a b -> Int.equal a b) a11 a12 && (fun a b -> Int.equal a b) b11 b12) a471 a472 && (fun a b -> Float.equal (globalize a) (globalize b)) b471 b472) in
  let mk_value i = (#{ a47 = (#{ a1 = (i + 0); b1 = (i + 1) } : t1); b47 = Float.of_int (i + 2) } : t47) in
  (* 1. Create an array of size [size] *)
  let a : t47 array = makearray_dynamic_local size (#{ a47 = (#{ a1 = 0; b1 = 1 } : t1); b47 = 2. } : t47) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 579;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 579 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 580;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 580 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a47 *)
    let el = #{ el with a47 = next_el.#a47 } in
    set_idx_mut a ((.(i).#a47) : (t47 array, _) idx_mut) next_el.#a47;
    mark_test_run 581;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 581 failed %d %d" size i;
    (* .#b47 *)
    let el = #{ el with b47 = next_el.#b47 } in
    set_idx_mut a ((.(i).#b47) : (t47 array, _) idx_mut) next_el.#b47;
    mark_test_run 582;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 582 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a47.#a1 *)
    let el = #{ el with a47 = #{ el.#a47 with a1 = next_el.#a47.#a1 } } in
    set_idx_mut a ((.(i).#a47.#a1) : (t47 array, _) idx_mut) next_el.#a47.#a1;
    mark_test_run 583;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 583 failed %d %d" size i;
    (* .#a47.#b1 *)
    let el = #{ el with a47 = #{ el.#a47 with b1 = next_el.#a47.#b1 } } in
    set_idx_mut a ((.(i).#a47.#b1) : (t47 array, _) idx_mut) next_el.#a47.#b1;
    mark_test_run 584;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 584 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (********************************************************)
  (*   t50 = #{ #{ int; int64# }; #{ int64#; float# } }   *)
  (********************************************************)
  let eq = (fun (#{ a50 = a501; b50 = b501 } : t50) (#{ a50 = a502; b50 = b502 } : t50) -> (fun (#{ a48 = a481; b48 = b481 } : t48) (#{ a48 = a482; b48 = b482 } : t48) -> (fun a b -> Int.equal a b) a481 a482 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) b481 b482) a501 a502 && (fun (#{ a49 = a491; b49 = b491 } : t49) (#{ a49 = a492; b49 = b492 } : t49) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a491 a492 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b491 b492) b501 b502) in
  let mk_value i = (#{ a50 = (#{ a48 = (i + 0); b48 = Int64_u.of_int (i + 1) } : t48); b50 = (#{ a49 = Int64_u.of_int (i + 2); b49 = Float_u.of_int (i + 3) } : t49) } : t50) in
  (* 1. Create an array of size [size] *)
  let a : t50 array = makearray_dynamic_local size (#{ a50 = (#{ a48 = 0; b48 = #1L } : t48); b50 = (#{ a49 = #2L; b49 = #3. } : t49) } : t50) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 585;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 585 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 586;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 586 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a50 *)
    let el = #{ el with a50 = next_el.#a50 } in
    set_idx_mut a ((.(i).#a50) : (t50 array, _) idx_mut) next_el.#a50;
    mark_test_run 587;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 587 failed %d %d" size i;
    (* .#b50 *)
    let el = #{ el with b50 = next_el.#b50 } in
    set_idx_mut a ((.(i).#b50) : (t50 array, _) idx_mut) next_el.#b50;
    mark_test_run 588;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 588 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a50.#a48 *)
    let el = #{ el with a50 = #{ el.#a50 with a48 = next_el.#a50.#a48 } } in
    set_idx_mut a ((.(i).#a50.#a48) : (t50 array, _) idx_mut) next_el.#a50.#a48;
    mark_test_run 589;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 589 failed %d %d" size i;
    (* .#a50.#b48 *)
    let el = #{ el with a50 = #{ el.#a50 with b48 = next_el.#a50.#b48 } } in
    set_idx_mut a ((.(i).#a50.#b48) : (t50 array, _) idx_mut) next_el.#a50.#b48;
    mark_test_run 590;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 590 failed %d %d" size i;
    (* .#b50.#a49 *)
    let el = #{ el with b50 = #{ el.#b50 with a49 = next_el.#b50.#a49 } } in
    set_idx_mut a ((.(i).#b50.#a49) : (t50 array, _) idx_mut) next_el.#b50.#a49;
    mark_test_run 591;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 591 failed %d %d" size i;
    (* .#b50.#b49 *)
    let el = #{ el with b50 = #{ el.#b50 with b49 = next_el.#b50.#b49 } } in
    set_idx_mut a ((.(i).#b50.#b49) : (t50 array, _) idx_mut) next_el.#b50.#b49;
    mark_test_run 592;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 592 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***********************************)
  (*   t51 = #{ #{ int; int32# } }   *)
  (***********************************)
  let eq = (fun (#{ a51 = a511 } : t51) (#{ a51 = a512 } : t51) -> (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) a511 a512) in
  let mk_value i = (#{ a51 = (#{ a5 = (i + 0); b5 = Int32_u.of_int (i + 1) } : t5) } : t51) in
  (* 1. Create an array of size [size] *)
  let a : t51 array = makearray_dynamic_local size (#{ a51 = (#{ a5 = 0; b5 = #1l } : t5) } : t51) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 593;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 593 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 594;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 594 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a51 *)
    let el = #{ el with a51 = next_el.#a51 } in
    set_idx_mut a ((.(i).#a51) : (t51 array, _) idx_mut) next_el.#a51;
    mark_test_run 595;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 595 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a51.#a5 *)
    let el = #{ el with a51 = #{ el.#a51 with a5 = next_el.#a51.#a5 } } in
    set_idx_mut a ((.(i).#a51.#a5) : (t51 array, _) idx_mut) next_el.#a51.#a5;
    mark_test_run 596;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 596 failed %d %d" size i;
    (* .#a51.#b5 *)
    let el = #{ el with a51 = #{ el.#a51 with b5 = next_el.#a51.#b5 } } in
    set_idx_mut a ((.(i).#a51.#b5) : (t51 array, _) idx_mut) next_el.#a51.#b5;
    mark_test_run 597;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 597 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t52 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  let eq = (fun (#{ a52 = a521; b52 = b521 } : t52) (#{ a52 = a522; b52 = b522 } : t52) -> (fun (#{ a5 = a51; b5 = b51 } : t5) (#{ a5 = a52; b5 = b52 } : t5) -> (fun a b -> Int.equal a b) a51 a52 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b51 b52) a521 a522 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b521 b522) in
  let mk_value i = (#{ a52 = (#{ a5 = (i + 0); b5 = Int32_u.of_int (i + 1) } : t5); b52 = Int32_u.of_int (i + 2) } : t52) in
  (* 1. Create an array of size [size] *)
  let a : t52 array = makearray_dynamic_local size (#{ a52 = (#{ a5 = 0; b5 = #1l } : t5); b52 = #2l } : t52) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 598;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 598 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 599;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 599 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a52 *)
    let el = #{ el with a52 = next_el.#a52 } in
    set_idx_mut a ((.(i).#a52) : (t52 array, _) idx_mut) next_el.#a52;
    mark_test_run 600;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 600 failed %d %d" size i;
    (* .#b52 *)
    let el = #{ el with b52 = next_el.#b52 } in
    set_idx_mut a ((.(i).#b52) : (t52 array, _) idx_mut) next_el.#b52;
    mark_test_run 601;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 601 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a52.#a5 *)
    let el = #{ el with a52 = #{ el.#a52 with a5 = next_el.#a52.#a5 } } in
    set_idx_mut a ((.(i).#a52.#a5) : (t52 array, _) idx_mut) next_el.#a52.#a5;
    mark_test_run 602;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 602 failed %d %d" size i;
    (* .#a52.#b5 *)
    let el = #{ el with a52 = #{ el.#a52 with b5 = next_el.#a52.#b5 } } in
    set_idx_mut a ((.(i).#a52.#b5) : (t52 array, _) idx_mut) next_el.#a52.#b5;
    mark_test_run 603;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 603 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t53 = #{ #{ int; float } }   *)
  (**********************************)
  let eq = (fun (#{ a53 = a531 } : t53) (#{ a53 = a532 } : t53) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) a531 a532) in
  let mk_value i = (#{ a53 = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7) } : t53) in
  (* 1. Create an array of size [size] *)
  let a : t53 array = makearray_dynamic_local size (#{ a53 = (#{ a7 = 0; b7 = 1. } : t7) } : t53) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 604;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 604 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 605;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 605 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a53 *)
    let el = #{ el with a53 = next_el.#a53 } in
    set_idx_mut a ((.(i).#a53) : (t53 array, _) idx_mut) next_el.#a53;
    mark_test_run 606;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 606 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a53.#a7 *)
    let el = #{ el with a53 = #{ el.#a53 with a7 = next_el.#a53.#a7 } } in
    set_idx_mut a ((.(i).#a53.#a7) : (t53 array, _) idx_mut) next_el.#a53.#a7;
    mark_test_run 607;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 607 failed %d %d" size i;
    (* .#a53.#b7 *)
    let el = #{ el with a53 = #{ el.#a53 with b7 = next_el.#a53.#b7 } } in
    set_idx_mut a ((.(i).#a53.#b7) : (t53 array, _) idx_mut) next_el.#a53.#b7;
    mark_test_run 608;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 608 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t54 = #{ #{ int; float }; int }   *)
  (***************************************)
  let eq = (fun (#{ a54 = a541; b54 = b541 } : t54) (#{ a54 = a542; b54 = b542 } : t54) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) a541 a542 && (fun a b -> Int.equal a b) b541 b542) in
  let mk_value i = (#{ a54 = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7); b54 = (i + 2) } : t54) in
  (* 1. Create an array of size [size] *)
  let a : t54 array = makearray_dynamic_local size (#{ a54 = (#{ a7 = 0; b7 = 1. } : t7); b54 = 2 } : t54) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 609;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 609 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 610;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 610 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a54 *)
    let el = #{ el with a54 = next_el.#a54 } in
    set_idx_mut a ((.(i).#a54) : (t54 array, _) idx_mut) next_el.#a54;
    mark_test_run 611;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 611 failed %d %d" size i;
    (* .#b54 *)
    let el = #{ el with b54 = next_el.#b54 } in
    set_idx_mut a ((.(i).#b54) : (t54 array, _) idx_mut) next_el.#b54;
    mark_test_run 612;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 612 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a54.#a7 *)
    let el = #{ el with a54 = #{ el.#a54 with a7 = next_el.#a54.#a7 } } in
    set_idx_mut a ((.(i).#a54.#a7) : (t54 array, _) idx_mut) next_el.#a54.#a7;
    mark_test_run 613;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 613 failed %d %d" size i;
    (* .#a54.#b7 *)
    let el = #{ el with a54 = #{ el.#a54 with b7 = next_el.#a54.#b7 } } in
    set_idx_mut a ((.(i).#a54.#b7) : (t54 array, _) idx_mut) next_el.#a54.#b7;
    mark_test_run 614;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 614 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t55 = #{ #{ int; float }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a55 = a551; b55 = b551 } : t55) (#{ a55 = a552; b55 = b552 } : t55) -> (fun (#{ a7 = a71; b7 = b71 } : t7) (#{ a7 = a72; b7 = b72 } : t7) -> (fun a b -> Int.equal a b) a71 a72 && (fun a b -> Float.equal (globalize a) (globalize b)) b71 b72) a551 a552 && (fun a b -> Float.equal (globalize a) (globalize b)) b551 b552) in
  let mk_value i = (#{ a55 = (#{ a7 = (i + 0); b7 = Float.of_int (i + 1) } : t7); b55 = Float.of_int (i + 2) } : t55) in
  (* 1. Create an array of size [size] *)
  let a : t55 array = makearray_dynamic_local size (#{ a55 = (#{ a7 = 0; b7 = 1. } : t7); b55 = 2. } : t55) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 615;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 615 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 616;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 616 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a55 *)
    let el = #{ el with a55 = next_el.#a55 } in
    set_idx_mut a ((.(i).#a55) : (t55 array, _) idx_mut) next_el.#a55;
    mark_test_run 617;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 617 failed %d %d" size i;
    (* .#b55 *)
    let el = #{ el with b55 = next_el.#b55 } in
    set_idx_mut a ((.(i).#b55) : (t55 array, _) idx_mut) next_el.#b55;
    mark_test_run 618;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 618 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a55.#a7 *)
    let el = #{ el with a55 = #{ el.#a55 with a7 = next_el.#a55.#a7 } } in
    set_idx_mut a ((.(i).#a55.#a7) : (t55 array, _) idx_mut) next_el.#a55.#a7;
    mark_test_run 619;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 619 failed %d %d" size i;
    (* .#a55.#b7 *)
    let el = #{ el with a55 = #{ el.#a55 with b7 = next_el.#a55.#b7 } } in
    set_idx_mut a ((.(i).#a55.#b7) : (t55 array, _) idx_mut) next_el.#a55.#b7;
    mark_test_run 620;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 620 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (******************************)
  (*   t56 = #{ #{ int32# } }   *)
  (******************************)
  let eq = (fun (#{ a56 = a561 } : t56) (#{ a56 = a562 } : t56) -> (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) a561 a562) in
  let mk_value i = (#{ a56 = (#{ a14 = Int32_u.of_int (i + 0) } : t14) } : t56) in
  (* 1. Create an array of size [size] *)
  let a : t56 array = makearray_dynamic_local size (#{ a56 = (#{ a14 = #0l } : t14) } : t56) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 621;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 621 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 622;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 622 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a56 *)
    let el = #{ el with a56 = next_el.#a56 } in
    set_idx_mut a ((.(i).#a56) : (t56 array, _) idx_mut) next_el.#a56;
    mark_test_run 623;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 623 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a56.#a14 *)
    let el = #{ el with a56 = #{ el.#a56 with a14 = next_el.#a56.#a14 } } in
    set_idx_mut a ((.(i).#a56.#a14) : (t56 array, _) idx_mut) next_el.#a56.#a14;
    mark_test_run 624;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 624 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t57 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  let eq = (fun (#{ a57 = a571; b57 = b571 } : t57) (#{ a57 = a572; b57 = b572 } : t57) -> (fun (#{ a14 = a141 } : t14) (#{ a14 = a142 } : t14) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a141 a142) a571 a572 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b571 b572) in
  let mk_value i = (#{ a57 = (#{ a14 = Int32_u.of_int (i + 0) } : t14); b57 = Int32_u.of_int (i + 1) } : t57) in
  (* 1. Create an array of size [size] *)
  let a : t57 array = makearray_dynamic_local size (#{ a57 = (#{ a14 = #0l } : t14); b57 = #1l } : t57) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 625;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 625 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 626;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 626 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a57 *)
    let el = #{ el with a57 = next_el.#a57 } in
    set_idx_mut a ((.(i).#a57) : (t57 array, _) idx_mut) next_el.#a57;
    mark_test_run 627;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 627 failed %d %d" size i;
    (* .#b57 *)
    let el = #{ el with b57 = next_el.#b57 } in
    set_idx_mut a ((.(i).#b57) : (t57 array, _) idx_mut) next_el.#b57;
    mark_test_run 628;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 628 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a57.#a14 *)
    let el = #{ el with a57 = #{ el.#a57 with a14 = next_el.#a57.#a14 } } in
    set_idx_mut a ((.(i).#a57.#a14) : (t57 array, _) idx_mut) next_el.#a57.#a14;
    mark_test_run 629;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 629 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**************************************)
  (*   t58 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  let eq = (fun (#{ a58 = a581 } : t58) (#{ a58 = a582 } : t58) -> (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) a581 a582) in
  let mk_value i = (#{ a58 = (#{ a16 = Int32_u.of_int (i + 0); b16 = Int32_u.of_int (i + 1) } : t16) } : t58) in
  (* 1. Create an array of size [size] *)
  let a : t58 array = makearray_dynamic_local size (#{ a58 = (#{ a16 = #0l; b16 = #1l } : t16) } : t58) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 630;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 630 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 631;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 631 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a58 *)
    let el = #{ el with a58 = next_el.#a58 } in
    set_idx_mut a ((.(i).#a58) : (t58 array, _) idx_mut) next_el.#a58;
    mark_test_run 632;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 632 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a58.#a16 *)
    let el = #{ el with a58 = #{ el.#a58 with a16 = next_el.#a58.#a16 } } in
    set_idx_mut a ((.(i).#a58.#a16) : (t58 array, _) idx_mut) next_el.#a58.#a16;
    mark_test_run 633;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 633 failed %d %d" size i;
    (* .#a58.#b16 *)
    let el = #{ el with a58 = #{ el.#a58 with b16 = next_el.#a58.#b16 } } in
    set_idx_mut a ((.(i).#a58.#b16) : (t58 array, _) idx_mut) next_el.#a58.#b16;
    mark_test_run 634;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 634 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************************)
  (*   t59 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  let eq = (fun (#{ a59 = a591; b59 = b591 } : t59) (#{ a59 = a592; b59 = b592 } : t59) -> (fun (#{ a16 = a161; b16 = b161 } : t16) (#{ a16 = a162; b16 = b162 } : t16) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a161 a162 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b161 b162) a591 a592 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) b591 b592) in
  let mk_value i = (#{ a59 = (#{ a16 = Int32_u.of_int (i + 0); b16 = Int32_u.of_int (i + 1) } : t16); b59 = Int32_u.of_int (i + 2) } : t59) in
  (* 1. Create an array of size [size] *)
  let a : t59 array = makearray_dynamic_local size (#{ a59 = (#{ a16 = #0l; b16 = #1l } : t16); b59 = #2l } : t59) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 635;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 635 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 636;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 636 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a59 *)
    let el = #{ el with a59 = next_el.#a59 } in
    set_idx_mut a ((.(i).#a59) : (t59 array, _) idx_mut) next_el.#a59;
    mark_test_run 637;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 637 failed %d %d" size i;
    (* .#b59 *)
    let el = #{ el with b59 = next_el.#b59 } in
    set_idx_mut a ((.(i).#b59) : (t59 array, _) idx_mut) next_el.#b59;
    mark_test_run 638;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 638 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a59.#a16 *)
    let el = #{ el with a59 = #{ el.#a59 with a16 = next_el.#a59.#a16 } } in
    set_idx_mut a ((.(i).#a59.#a16) : (t59 array, _) idx_mut) next_el.#a59.#a16;
    mark_test_run 639;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 639 failed %d %d" size i;
    (* .#a59.#b16 *)
    let el = #{ el with a59 = #{ el.#a59 with b16 = next_el.#a59.#b16 } } in
    set_idx_mut a ((.(i).#a59.#b16) : (t59 array, _) idx_mut) next_el.#a59.#b16;
    mark_test_run 640;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 640 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t60 = #{ #{ float }; int }   *)
  (**********************************)
  let eq = (fun (#{ a60 = a601; b60 = b601 } : t60) (#{ a60 = a602; b60 = b602 } : t60) -> (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) a601 a602 && (fun a b -> Int.equal a b) b601 b602) in
  let mk_value i = (#{ a60 = (#{ a18 = Float.of_int (i + 0) } : t18); b60 = (i + 1) } : t60) in
  (* 1. Create an array of size [size] *)
  let a : t60 array = makearray_dynamic_local size (#{ a60 = (#{ a18 = 0. } : t18); b60 = 1 } : t60) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 641;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 641 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 642;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 642 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a60 *)
    let el = #{ el with a60 = next_el.#a60 } in
    set_idx_mut a ((.(i).#a60) : (t60 array, _) idx_mut) next_el.#a60;
    mark_test_run 643;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 643 failed %d %d" size i;
    (* .#b60 *)
    let el = #{ el with b60 = next_el.#b60 } in
    set_idx_mut a ((.(i).#b60) : (t60 array, _) idx_mut) next_el.#b60;
    mark_test_run 644;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 644 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a60.#a18 *)
    let el = #{ el with a60 = #{ el.#a60 with a18 = next_el.#a60.#a18 } } in
    set_idx_mut a ((.(i).#a60.#a18) : (t60 array, _) idx_mut) next_el.#a60.#a18;
    mark_test_run 645;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 645 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t61 = #{ #{ float }; float }   *)
  (************************************)
  let eq = (fun (#{ a61 = a611; b61 = b611 } : t61) (#{ a61 = a612; b61 = b612 } : t61) -> (fun (#{ a18 = a181 } : t18) (#{ a18 = a182 } : t18) -> (fun a b -> Float.equal (globalize a) (globalize b)) a181 a182) a611 a612 && (fun a b -> Float.equal (globalize a) (globalize b)) b611 b612) in
  let mk_value i = (#{ a61 = (#{ a18 = Float.of_int (i + 0) } : t18); b61 = Float.of_int (i + 1) } : t61) in
  (* 1. Create an array of size [size] *)
  let a : t61 array = makearray_dynamic_local size (#{ a61 = (#{ a18 = 0. } : t18); b61 = 1. } : t61) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 646;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 646 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 647;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 647 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a61 *)
    let el = #{ el with a61 = next_el.#a61 } in
    set_idx_mut a ((.(i).#a61) : (t61 array, _) idx_mut) next_el.#a61;
    mark_test_run 648;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 648 failed %d %d" size i;
    (* .#b61 *)
    let el = #{ el with b61 = next_el.#b61 } in
    set_idx_mut a ((.(i).#b61) : (t61 array, _) idx_mut) next_el.#b61;
    mark_test_run 649;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 649 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a61.#a18 *)
    let el = #{ el with a61 = #{ el.#a61 with a18 = next_el.#a61.#a18 } } in
    set_idx_mut a ((.(i).#a61.#a18) : (t61 array, _) idx_mut) next_el.#a61.#a18;
    mark_test_run 650;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 650 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (**********************************)
  (*   t62 = #{ #{ float; int } }   *)
  (**********************************)
  let eq = (fun (#{ a62 = a621 } : t62) (#{ a62 = a622 } : t62) -> (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) a621 a622) in
  let mk_value i = (#{ a62 = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20) } : t62) in
  (* 1. Create an array of size [size] *)
  let a : t62 array = makearray_dynamic_local size (#{ a62 = (#{ a20 = 0.; b20 = 1 } : t20) } : t62) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 651;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 651 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 652;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 652 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a62 *)
    let el = #{ el with a62 = next_el.#a62 } in
    set_idx_mut a ((.(i).#a62) : (t62 array, _) idx_mut) next_el.#a62;
    mark_test_run 653;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 653 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a62.#a20 *)
    let el = #{ el with a62 = #{ el.#a62 with a20 = next_el.#a62.#a20 } } in
    set_idx_mut a ((.(i).#a62.#a20) : (t62 array, _) idx_mut) next_el.#a62.#a20;
    mark_test_run 654;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 654 failed %d %d" size i;
    (* .#a62.#b20 *)
    let el = #{ el with a62 = #{ el.#a62 with b20 = next_el.#a62.#b20 } } in
    set_idx_mut a ((.(i).#a62.#b20) : (t62 array, _) idx_mut) next_el.#a62.#b20;
    mark_test_run 655;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 655 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (***************************************)
  (*   t63 = #{ #{ float; int }; int }   *)
  (***************************************)
  let eq = (fun (#{ a63 = a631; b63 = b631 } : t63) (#{ a63 = a632; b63 = b632 } : t63) -> (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) a631 a632 && (fun a b -> Int.equal a b) b631 b632) in
  let mk_value i = (#{ a63 = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20); b63 = (i + 2) } : t63) in
  (* 1. Create an array of size [size] *)
  let a : t63 array = makearray_dynamic_local size (#{ a63 = (#{ a20 = 0.; b20 = 1 } : t20); b63 = 2 } : t63) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 656;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 656 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 657;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 657 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a63 *)
    let el = #{ el with a63 = next_el.#a63 } in
    set_idx_mut a ((.(i).#a63) : (t63 array, _) idx_mut) next_el.#a63;
    mark_test_run 658;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 658 failed %d %d" size i;
    (* .#b63 *)
    let el = #{ el with b63 = next_el.#b63 } in
    set_idx_mut a ((.(i).#b63) : (t63 array, _) idx_mut) next_el.#b63;
    mark_test_run 659;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 659 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a63.#a20 *)
    let el = #{ el with a63 = #{ el.#a63 with a20 = next_el.#a63.#a20 } } in
    set_idx_mut a ((.(i).#a63.#a20) : (t63 array, _) idx_mut) next_el.#a63.#a20;
    mark_test_run 660;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 660 failed %d %d" size i;
    (* .#a63.#b20 *)
    let el = #{ el with a63 = #{ el.#a63 with b20 = next_el.#a63.#b20 } } in
    set_idx_mut a ((.(i).#a63.#b20) : (t63 array, _) idx_mut) next_el.#a63.#b20;
    mark_test_run 661;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 661 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t64 = #{ #{ float; int }; float }   *)
  (*****************************************)
  let eq = (fun (#{ a64 = a641; b64 = b641 } : t64) (#{ a64 = a642; b64 = b642 } : t64) -> (fun (#{ a20 = a201; b20 = b201 } : t20) (#{ a20 = a202; b20 = b202 } : t20) -> (fun a b -> Float.equal (globalize a) (globalize b)) a201 a202 && (fun a b -> Int.equal a b) b201 b202) a641 a642 && (fun a b -> Float.equal (globalize a) (globalize b)) b641 b642) in
  let mk_value i = (#{ a64 = (#{ a20 = Float.of_int (i + 0); b20 = (i + 1) } : t20); b64 = Float.of_int (i + 2) } : t64) in
  (* 1. Create an array of size [size] *)
  let a : t64 array = makearray_dynamic_local size (#{ a64 = (#{ a20 = 0.; b20 = 1 } : t20); b64 = 2. } : t64) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 662;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 662 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 663;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 663 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a64 *)
    let el = #{ el with a64 = next_el.#a64 } in
    set_idx_mut a ((.(i).#a64) : (t64 array, _) idx_mut) next_el.#a64;
    mark_test_run 664;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 664 failed %d %d" size i;
    (* .#b64 *)
    let el = #{ el with b64 = next_el.#b64 } in
    set_idx_mut a ((.(i).#b64) : (t64 array, _) idx_mut) next_el.#b64;
    mark_test_run 665;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 665 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a64.#a20 *)
    let el = #{ el with a64 = #{ el.#a64 with a20 = next_el.#a64.#a20 } } in
    set_idx_mut a ((.(i).#a64.#a20) : (t64 array, _) idx_mut) next_el.#a64.#a20;
    mark_test_run 666;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 666 failed %d %d" size i;
    (* .#a64.#b20 *)
    let el = #{ el with a64 = #{ el.#a64 with b20 = next_el.#a64.#b20 } } in
    set_idx_mut a ((.(i).#a64.#b20) : (t64 array, _) idx_mut) next_el.#a64.#b20;
    mark_test_run 667;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 667 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (************************************)
  (*   t65 = #{ #{ float; float } }   *)
  (************************************)
  let eq = (fun (#{ a65 = a651 } : t65) (#{ a65 = a652 } : t65) -> (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) a651 a652) in
  let mk_value i = (#{ a65 = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22) } : t65) in
  (* 1. Create an array of size [size] *)
  let a : t65 array = makearray_dynamic_local size (#{ a65 = (#{ a22 = 0.; b22 = 1. } : t22) } : t65) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 668;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 668 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 669;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 669 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a65 *)
    let el = #{ el with a65 = next_el.#a65 } in
    set_idx_mut a ((.(i).#a65) : (t65 array, _) idx_mut) next_el.#a65;
    mark_test_run 670;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 670 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a65.#a22 *)
    let el = #{ el with a65 = #{ el.#a65 with a22 = next_el.#a65.#a22 } } in
    set_idx_mut a ((.(i).#a65.#a22) : (t65 array, _) idx_mut) next_el.#a65.#a22;
    mark_test_run 671;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 671 failed %d %d" size i;
    (* .#a65.#b22 *)
    let el = #{ el with a65 = #{ el.#a65 with b22 = next_el.#a65.#b22 } } in
    set_idx_mut a ((.(i).#a65.#b22) : (t65 array, _) idx_mut) next_el.#a65.#b22;
    mark_test_run 672;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 672 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*****************************************)
  (*   t66 = #{ #{ float; float }; int }   *)
  (*****************************************)
  let eq = (fun (#{ a66 = a661; b66 = b661 } : t66) (#{ a66 = a662; b66 = b662 } : t66) -> (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) a661 a662 && (fun a b -> Int.equal a b) b661 b662) in
  let mk_value i = (#{ a66 = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22); b66 = (i + 2) } : t66) in
  (* 1. Create an array of size [size] *)
  let a : t66 array = makearray_dynamic_local size (#{ a66 = (#{ a22 = 0.; b22 = 1. } : t22); b66 = 2 } : t66) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 673;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 673 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 674;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 674 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a66 *)
    let el = #{ el with a66 = next_el.#a66 } in
    set_idx_mut a ((.(i).#a66) : (t66 array, _) idx_mut) next_el.#a66;
    mark_test_run 675;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 675 failed %d %d" size i;
    (* .#b66 *)
    let el = #{ el with b66 = next_el.#b66 } in
    set_idx_mut a ((.(i).#b66) : (t66 array, _) idx_mut) next_el.#b66;
    mark_test_run 676;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 676 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a66.#a22 *)
    let el = #{ el with a66 = #{ el.#a66 with a22 = next_el.#a66.#a22 } } in
    set_idx_mut a ((.(i).#a66.#a22) : (t66 array, _) idx_mut) next_el.#a66.#a22;
    mark_test_run 677;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 677 failed %d %d" size i;
    (* .#a66.#b22 *)
    let el = #{ el with a66 = #{ el.#a66 with b22 = next_el.#a66.#b22 } } in
    set_idx_mut a ((.(i).#a66.#b22) : (t66 array, _) idx_mut) next_el.#a66.#b22;
    mark_test_run 678;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 678 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  (*******************************************)
  (*   t67 = #{ #{ float; float }; float }   *)
  (*******************************************)
  let eq = (fun (#{ a67 = a671; b67 = b671 } : t67) (#{ a67 = a672; b67 = b672 } : t67) -> (fun (#{ a22 = a221; b22 = b221 } : t22) (#{ a22 = a222; b22 = b222 } : t22) -> (fun a b -> Float.equal (globalize a) (globalize b)) a221 a222 && (fun a b -> Float.equal (globalize a) (globalize b)) b221 b222) a671 a672 && (fun a b -> Float.equal (globalize a) (globalize b)) b671 b672) in
  let mk_value i = (#{ a67 = (#{ a22 = Float.of_int (i + 0); b22 = Float.of_int (i + 1) } : t22); b67 = Float.of_int (i + 2) } : t67) in
  (* 1. Create an array of size [size] *)
  let a : t67 array = makearray_dynamic_local size (#{ a67 = (#{ a22 = 0.; b22 = 1. } : t22); b67 = 2. } : t67) in
  (* 3. Fill [a] with distinct values using block indices *)
  for i = 0 to size - 1 do
    set_idx_mut a (.(i)) (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 679;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 679 failed %d %d" size i;
  done;
  (* Also read back those values with block indices *)
  for i = 0 to size - 1 do
    mark_test_run 680;
    let test = eq (get_idx_mut a (.(i))) (mk_value i) in
    if not test then failwithf "test 680 failed %d %d" size i;
  done;
  for i = 0 to size - 1 do
    (* Paths of depth 1 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 1) in
    (* .#a67 *)
    let el = #{ el with a67 = next_el.#a67 } in
    set_idx_mut a ((.(i).#a67) : (t67 array, _) idx_mut) next_el.#a67;
    mark_test_run 681;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 681 failed %d %d" size i;
    (* .#b67 *)
    let el = #{ el with b67 = next_el.#b67 } in
    set_idx_mut a ((.(i).#b67) : (t67 array, _) idx_mut) next_el.#b67;
    mark_test_run 682;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 682 failed %d %d" size i;
    (* Paths of depth 2 *)
    let el = get a i in
    let next_el = mk_value (i + 100 * 2) in
    (* .#a67.#a22 *)
    let el = #{ el with a67 = #{ el.#a67 with a22 = next_el.#a67.#a22 } } in
    set_idx_mut a ((.(i).#a67.#a22) : (t67 array, _) idx_mut) next_el.#a67.#a22;
    mark_test_run 683;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 683 failed %d %d" size i;
    (* .#a67.#b22 *)
    let el = #{ el with a67 = #{ el.#a67 with b22 = next_el.#a67.#b22 } } in
    set_idx_mut a ((.(i).#a67.#b22) : (t67 array, _) idx_mut) next_el.#a67.#b22;
    mark_test_run 684;
    let test = eq (get_idx_mut a (.(i))) el in
    if not test then failwithf "test 684 failed %d %d" size i;
    ()
  done;
  Gc.compact ();

  ()

(* Test array idx deepening *)
let () =
  (***********)
  (*   int   *)
  (***********)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int array, _) idx_mut = (.(i)) in
    let shallow : (int array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 685;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 685 failed";
  );

  (*************)
  (*   int64   *)
  (*************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64 array, _) idx_mut = (.(i)) in
    let shallow : (int64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 686;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 686 failed";
  );

  (**************)
  (*   int64#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int64# array, _) idx_mut = (.(i)) in
    let shallow : (int64# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 687;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 687 failed";
  );

  (**************)
  (*   int32#   *)
  (**************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (int32# array, _) idx_mut = (.(i)) in
    let shallow : (int32# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 688;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 688 failed";
  );

  (******************)
  (*   nativeint#   *)
  (******************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (nativeint# array, _) idx_mut = (.(i)) in
    let shallow : (nativeint# array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 689;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 689 failed";
  );

  (*********************)
  (*   t0 = #{ int }   *)
  (*********************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i)) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 690;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 690 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t0 array, _) idx_mut = (.(i).#a0) in
    let shallow : (t0 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 691;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 691 failed";
    let shallow : (t0 array, _) idx_mut = (.(i).#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 692;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 692 failed";
  );

  (**************************)
  (*   t1 = #{ int; int }   *)
  (**************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i)) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 693;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 693 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i).#a1) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 694;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 694 failed";
    let shallow : (t1 array, _) idx_mut = (.(i).#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 695;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 695 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t1 array, _) idx_mut = (.(i).#b1) in
    let shallow : (t1 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 696;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 696 failed";
    let shallow : (t1 array, _) idx_mut = (.(i).#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 697;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 697 failed";
  );

  (*******************************)
  (*   t2 = #{ int; int; int }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i)) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 698;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 698 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#a2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a2) in
    mark_test_run 699;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 699 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#a2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 700;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 700 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#b2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b2) in
    mark_test_run 701;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 701 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#b2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 702;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 702 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t2 array, _) idx_mut = (.(i).#c2) in
    let shallow : (t2 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c2) in
    mark_test_run 703;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 703 failed";
    let shallow : (t2 array, _) idx_mut = (.(i).#c2) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 704;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 704 failed";
  );

  (**********************************)
  (*   t3 = #{ int; int; int32# }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i)) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 705;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 705 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#a3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a3) in
    mark_test_run 706;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 706 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#a3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 707;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 707 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#b3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b3) in
    mark_test_run 708;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 708 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#b3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 709;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 709 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t3 array, _) idx_mut = (.(i).#c3) in
    let shallow : (t3 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c3) in
    mark_test_run 710;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 710 failed";
    let shallow : (t3 array, _) idx_mut = (.(i).#c3) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 711;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 711 failed";
  );

  (*********************************)
  (*   t4 = #{ int; int; float }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i)) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 712;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 712 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i).#a4) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a4) in
    mark_test_run 713;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 713 failed";
    let shallow : (t4 array, _) idx_mut = (.(i).#a4) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 714;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 714 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i).#b4) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b4) in
    mark_test_run 715;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 715 failed";
    let shallow : (t4 array, _) idx_mut = (.(i).#b4) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 716;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 716 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t4 array, _) idx_mut = (.(i).#c4) in
    let shallow : (t4 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c4) in
    mark_test_run 717;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 717 failed";
    let shallow : (t4 array, _) idx_mut = (.(i).#c4) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 718;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 718 failed";
  );

  (*****************************)
  (*   t5 = #{ int; int32# }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t5 array, _) idx_mut = (.(i)) in
    let shallow : (t5 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 719;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 719 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t5 array, _) idx_mut = (.(i).#a5) in
    let shallow : (t5 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a5) in
    mark_test_run 720;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 720 failed";
    let shallow : (t5 array, _) idx_mut = (.(i).#a5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 721;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 721 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t5 array, _) idx_mut = (.(i).#b5) in
    let shallow : (t5 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b5) in
    mark_test_run 722;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 722 failed";
    let shallow : (t5 array, _) idx_mut = (.(i).#b5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 723;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 723 failed";
  );

  (*************************************)
  (*   t6 = #{ int; int32#; int32# }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i)) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 724;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 724 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i).#a6) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a6) in
    mark_test_run 725;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 725 failed";
    let shallow : (t6 array, _) idx_mut = (.(i).#a6) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 726;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 726 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i).#b6) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b6) in
    mark_test_run 727;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 727 failed";
    let shallow : (t6 array, _) idx_mut = (.(i).#b6) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 728;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 728 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t6 array, _) idx_mut = (.(i).#c6) in
    let shallow : (t6 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c6) in
    mark_test_run 729;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 729 failed";
    let shallow : (t6 array, _) idx_mut = (.(i).#c6) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 730;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 730 failed";
  );

  (****************************)
  (*   t7 = #{ int; float }   *)
  (****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t7 array, _) idx_mut = (.(i)) in
    let shallow : (t7 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 731;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 731 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t7 array, _) idx_mut = (.(i).#a7) in
    let shallow : (t7 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 732;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 732 failed";
    let shallow : (t7 array, _) idx_mut = (.(i).#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 733;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 733 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t7 array, _) idx_mut = (.(i).#b7) in
    let shallow : (t7 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 734;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 734 failed";
    let shallow : (t7 array, _) idx_mut = (.(i).#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 735;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 735 failed";
  );

  (*********************************)
  (*   t8 = #{ int; float; int }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i)) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 736;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 736 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i).#a8) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a8) in
    mark_test_run 737;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 737 failed";
    let shallow : (t8 array, _) idx_mut = (.(i).#a8) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 738;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 738 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i).#b8) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b8) in
    mark_test_run 739;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 739 failed";
    let shallow : (t8 array, _) idx_mut = (.(i).#b8) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 740;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 740 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t8 array, _) idx_mut = (.(i).#c8) in
    let shallow : (t8 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c8) in
    mark_test_run 741;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 741 failed";
    let shallow : (t8 array, _) idx_mut = (.(i).#c8) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 742;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 742 failed";
  );

  (***********************************)
  (*   t9 = #{ int; float; float }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i)) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 743;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 743 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i).#a9) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a9) in
    mark_test_run 744;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 744 failed";
    let shallow : (t9 array, _) idx_mut = (.(i).#a9) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 745;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 745 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i).#b9) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b9) in
    mark_test_run 746;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 746 failed";
    let shallow : (t9 array, _) idx_mut = (.(i).#b9) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 747;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 747 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t9 array, _) idx_mut = (.(i).#c9) in
    let shallow : (t9 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c9) in
    mark_test_run 748;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 748 failed";
    let shallow : (t9 array, _) idx_mut = (.(i).#c9) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 749;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 749 failed";
  );

  (********************************)
  (*   t10 = #{ int; #{ int } }   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i)) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 750;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 750 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i).#a10) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a10) in
    mark_test_run 751;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 751 failed";
    let shallow : (t10 array, _) idx_mut = (.(i).#a10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 752;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 752 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i).#b10) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b10) in
    mark_test_run 753;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 753 failed";
    let shallow : (t10 array, _) idx_mut = (.(i).#b10) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 754;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 754 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t10 array, _) idx_mut = (.(i).#b10.#a0) in
    let shallow : (t10 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b10.#a0) in
    mark_test_run 755;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 755 failed";
    let shallow : (t10 array, _) idx_mut = (.(i).#b10) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 756;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 756 failed";
    let shallow : (t10 array, _) idx_mut = (.(i).#b10.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 757;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 757 failed";
  );

  (*************************************)
  (*   t11 = #{ int; #{ int; int } }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i)) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 758;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 758 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#a11) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a11) in
    mark_test_run 759;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 759 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#a11) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 760;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 760 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#b11) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b11) in
    mark_test_run 761;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 761 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#b11) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 762;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 762 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#b11.#a1) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b11.#a1) in
    mark_test_run 763;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 763 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#b11) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 764;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 764 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#b11.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 765;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 765 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t11 array, _) idx_mut = (.(i).#b11.#b1) in
    let shallow : (t11 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b11.#b1) in
    mark_test_run 766;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 766 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#b11) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 767;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 767 failed";
    let shallow : (t11 array, _) idx_mut = (.(i).#b11.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 768;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 768 failed";
  );

  (****************************************)
  (*   t12 = #{ int; #{ int; int32# } }   *)
  (****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i)) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 769;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 769 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#a12) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a12) in
    mark_test_run 770;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 770 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#a12) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 771;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 771 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#b12) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b12) in
    mark_test_run 772;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 772 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#b12) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 773;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 773 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#b12.#a5) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b12.#a5) in
    mark_test_run 774;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 774 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#b12) in
    let deepened = (.idx_mut(shallow).#a5) in
    mark_test_run 775;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 775 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#b12.#a5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 776;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 776 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t12 array, _) idx_mut = (.(i).#b12.#b5) in
    let shallow : (t12 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b12.#b5) in
    mark_test_run 777;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 777 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#b12) in
    let deepened = (.idx_mut(shallow).#b5) in
    mark_test_run 778;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 778 failed";
    let shallow : (t12 array, _) idx_mut = (.(i).#b12.#b5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 779;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 779 failed";
  );

  (***************************************)
  (*   t13 = #{ int; #{ int; float } }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i)) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 780;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 780 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#a13) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a13) in
    mark_test_run 781;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 781 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#a13) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 782;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 782 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#b13) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b13) in
    mark_test_run 783;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 783 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 784;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 784 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#b13.#a7) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b13.#a7) in
    mark_test_run 785;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 785 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 786;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 786 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 787;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 787 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t13 array, _) idx_mut = (.(i).#b13.#b7) in
    let shallow : (t13 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b13.#b7) in
    mark_test_run 788;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 788 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 789;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 789 failed";
    let shallow : (t13 array, _) idx_mut = (.(i).#b13.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 790;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 790 failed";
  );

  (***********************************)
  (*   t15 = #{ int; #{ int32# } }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i)) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 791;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 791 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#a15) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a15) in
    mark_test_run 792;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 792 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#a15) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 793;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 793 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#b15) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b15) in
    mark_test_run 794;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 794 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 795;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 795 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t15 array, _) idx_mut = (.(i).#b15.#a14) in
    let shallow : (t15 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b15.#a14) in
    mark_test_run 796;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 796 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15) in
    let deepened = (.idx_mut(shallow).#a14) in
    mark_test_run 797;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 797 failed";
    let shallow : (t15 array, _) idx_mut = (.(i).#b15.#a14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 798;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 798 failed";
  );

  (*******************************************)
  (*   t17 = #{ int; #{ int32#; int32# } }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i)) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 799;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 799 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i).#a17) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a17) in
    mark_test_run 800;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 800 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#a17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 801;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 801 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i).#b17) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b17) in
    mark_test_run 802;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 802 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#b17) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 803;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 803 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i).#b17.#a16) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b17.#a16) in
    mark_test_run 804;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 804 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#b17) in
    let deepened = (.idx_mut(shallow).#a16) in
    mark_test_run 805;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 805 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#b17.#a16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 806;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 806 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t17 array, _) idx_mut = (.(i).#b17.#b16) in
    let shallow : (t17 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b17.#b16) in
    mark_test_run 807;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 807 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#b17) in
    let deepened = (.idx_mut(shallow).#b16) in
    mark_test_run 808;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 808 failed";
    let shallow : (t17 array, _) idx_mut = (.(i).#b17.#b16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 809;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 809 failed";
  );

  (**********************************)
  (*   t19 = #{ int; #{ float } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i)) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 810;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 810 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i).#a19) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a19) in
    mark_test_run 811;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 811 failed";
    let shallow : (t19 array, _) idx_mut = (.(i).#a19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 812;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 812 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i).#b19) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b19) in
    mark_test_run 813;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 813 failed";
    let shallow : (t19 array, _) idx_mut = (.(i).#b19) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 814;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 814 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t19 array, _) idx_mut = (.(i).#b19.#a18) in
    let shallow : (t19 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b19.#a18) in
    mark_test_run 815;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 815 failed";
    let shallow : (t19 array, _) idx_mut = (.(i).#b19) in
    let deepened = (.idx_mut(shallow).#a18) in
    mark_test_run 816;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 816 failed";
    let shallow : (t19 array, _) idx_mut = (.(i).#b19.#a18) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 817;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 817 failed";
  );

  (***************************************)
  (*   t21 = #{ int; #{ float; int } }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t21 array, _) idx_mut = (.(i)) in
    let shallow : (t21 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 818;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 818 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t21 array, _) idx_mut = (.(i).#a21) in
    let shallow : (t21 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a21) in
    mark_test_run 819;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 819 failed";
    let shallow : (t21 array, _) idx_mut = (.(i).#a21) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 820;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 820 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t21 array, _) idx_mut = (.(i).#b21) in
    let shallow : (t21 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b21) in
    mark_test_run 821;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 821 failed";
    let shallow : (t21 array, _) idx_mut = (.(i).#b21) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 822;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 822 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t21 array, _) idx_mut = (.(i).#b21.#a20) in
    let shallow : (t21 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b21.#a20) in
    mark_test_run 823;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 823 failed";
    let shallow : (t21 array, _) idx_mut = (.(i).#b21) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 824;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 824 failed";
    let shallow : (t21 array, _) idx_mut = (.(i).#b21.#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 825;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 825 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t21 array, _) idx_mut = (.(i).#b21.#b20) in
    let shallow : (t21 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b21.#b20) in
    mark_test_run 826;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 826 failed";
    let shallow : (t21 array, _) idx_mut = (.(i).#b21) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 827;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 827 failed";
    let shallow : (t21 array, _) idx_mut = (.(i).#b21.#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 828;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 828 failed";
  );

  (*****************************************)
  (*   t23 = #{ int; #{ float; float } }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i)) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 829;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 829 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i).#a23) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a23) in
    mark_test_run 830;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 830 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#a23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 831;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 831 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i).#b23) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b23) in
    mark_test_run 832;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 832 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#b23) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 833;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 833 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i).#b23.#a22) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b23.#a22) in
    mark_test_run 834;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 834 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#b23) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 835;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 835 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#b23.#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 836;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 836 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t23 array, _) idx_mut = (.(i).#b23.#b22) in
    let shallow : (t23 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b23.#b22) in
    mark_test_run 837;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 837 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#b23) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 838;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 838 failed";
    let shallow : (t23 array, _) idx_mut = (.(i).#b23.#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 839;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 839 failed";
  );

  (************************)
  (*   t24 = #{ int64 }   *)
  (************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i)) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 840;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 840 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t24 array, _) idx_mut = (.(i).#a24) in
    let shallow : (t24 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a24) in
    mark_test_run 841;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 841 failed";
    let shallow : (t24 array, _) idx_mut = (.(i).#a24) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 842;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 842 failed";
  );

  (*************************)
  (*   t25 = #{ int64# }   *)
  (*************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t25 array, _) idx_mut = (.(i)) in
    let shallow : (t25 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 843;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 843 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t25 array, _) idx_mut = (.(i).#a25) in
    let shallow : (t25 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a25) in
    mark_test_run 844;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 844 failed";
    let shallow : (t25 array, _) idx_mut = (.(i).#a25) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 845;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 845 failed";
  );

  (*************************)
  (*   t14 = #{ int32# }   *)
  (*************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i)) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 846;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 846 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t14 array, _) idx_mut = (.(i).#a14) in
    let shallow : (t14 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a14) in
    mark_test_run 847;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 847 failed";
    let shallow : (t14 array, _) idx_mut = (.(i).#a14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 848;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 848 failed";
  );

  (*********************************)
  (*   t16 = #{ int32#; int32# }   *)
  (*********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i)) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 849;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 849 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i).#a16) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a16) in
    mark_test_run 850;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 850 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#a16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 851;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 851 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t16 array, _) idx_mut = (.(i).#b16) in
    let shallow : (t16 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b16) in
    mark_test_run 852;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 852 failed";
    let shallow : (t16 array, _) idx_mut = (.(i).#b16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 853;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 853 failed";
  );

  (*****************************************)
  (*   t26 = #{ int32#; int32#; int32# }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i)) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 854;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 854 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#a26) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a26) in
    mark_test_run 855;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 855 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#a26) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 856;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 856 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#b26) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b26) in
    mark_test_run 857;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 857 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#b26) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 858;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 858 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t26 array, _) idx_mut = (.(i).#c26) in
    let shallow : (t26 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c26) in
    mark_test_run 859;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 859 failed";
    let shallow : (t26 array, _) idx_mut = (.(i).#c26) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 860;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 860 failed";
  );

  (**************************************)
  (*   t27 = #{ int32#; #{ int32# } }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t27 array, _) idx_mut = (.(i)) in
    let shallow : (t27 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 861;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 861 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t27 array, _) idx_mut = (.(i).#a27) in
    let shallow : (t27 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a27) in
    mark_test_run 862;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 862 failed";
    let shallow : (t27 array, _) idx_mut = (.(i).#a27) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 863;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 863 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t27 array, _) idx_mut = (.(i).#b27) in
    let shallow : (t27 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b27) in
    mark_test_run 864;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 864 failed";
    let shallow : (t27 array, _) idx_mut = (.(i).#b27) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 865;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 865 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t27 array, _) idx_mut = (.(i).#b27.#a14) in
    let shallow : (t27 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b27.#a14) in
    mark_test_run 866;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 866 failed";
    let shallow : (t27 array, _) idx_mut = (.(i).#b27) in
    let deepened = (.idx_mut(shallow).#a14) in
    mark_test_run 867;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 867 failed";
    let shallow : (t27 array, _) idx_mut = (.(i).#b27.#a14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 868;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 868 failed";
  );

  (**********************************************)
  (*   t28 = #{ int32#; #{ int32#; int32# } }   *)
  (**********************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i)) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 869;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 869 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i).#a28) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a28) in
    mark_test_run 870;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 870 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#a28) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 871;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 871 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i).#b28) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b28) in
    mark_test_run 872;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 872 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#b28) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 873;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 873 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i).#b28.#a16) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b28.#a16) in
    mark_test_run 874;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 874 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#b28) in
    let deepened = (.idx_mut(shallow).#a16) in
    mark_test_run 875;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 875 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#b28.#a16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 876;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 876 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t28 array, _) idx_mut = (.(i).#b28.#b16) in
    let shallow : (t28 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b28.#b16) in
    mark_test_run 877;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 877 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#b28) in
    let deepened = (.idx_mut(shallow).#b16) in
    mark_test_run 878;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 878 failed";
    let shallow : (t28 array, _) idx_mut = (.(i).#b28.#b16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 879;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 879 failed";
  );

  (*****************************)
  (*   t29 = #{ nativeint# }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t29 array, _) idx_mut = (.(i)) in
    let shallow : (t29 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 880;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 880 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t29 array, _) idx_mut = (.(i).#a29) in
    let shallow : (t29 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a29) in
    mark_test_run 881;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 881 failed";
    let shallow : (t29 array, _) idx_mut = (.(i).#a29) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 882;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 882 failed";
  );

  (*****************************)
  (*   t20 = #{ float; int }   *)
  (*****************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i)) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 883;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 883 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i).#a20) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 884;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 884 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 885;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 885 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t20 array, _) idx_mut = (.(i).#b20) in
    let shallow : (t20 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 886;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 886 failed";
    let shallow : (t20 array, _) idx_mut = (.(i).#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 887;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 887 failed";
  );

  (**********************************)
  (*   t30 = #{ float; int; int }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i)) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 888;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 888 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i).#a30) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a30) in
    mark_test_run 889;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 889 failed";
    let shallow : (t30 array, _) idx_mut = (.(i).#a30) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 890;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 890 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i).#b30) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b30) in
    mark_test_run 891;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 891 failed";
    let shallow : (t30 array, _) idx_mut = (.(i).#b30) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 892;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 892 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t30 array, _) idx_mut = (.(i).#c30) in
    let shallow : (t30 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c30) in
    mark_test_run 893;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 893 failed";
    let shallow : (t30 array, _) idx_mut = (.(i).#c30) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 894;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 894 failed";
  );

  (************************************)
  (*   t31 = #{ float; int; float }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t31 array, _) idx_mut = (.(i)) in
    let shallow : (t31 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 895;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 895 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t31 array, _) idx_mut = (.(i).#a31) in
    let shallow : (t31 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a31) in
    mark_test_run 896;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 896 failed";
    let shallow : (t31 array, _) idx_mut = (.(i).#a31) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 897;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 897 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t31 array, _) idx_mut = (.(i).#b31) in
    let shallow : (t31 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b31) in
    mark_test_run 898;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 898 failed";
    let shallow : (t31 array, _) idx_mut = (.(i).#b31) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 899;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 899 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t31 array, _) idx_mut = (.(i).#c31) in
    let shallow : (t31 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c31) in
    mark_test_run 900;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 900 failed";
    let shallow : (t31 array, _) idx_mut = (.(i).#c31) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 901;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 901 failed";
  );

  (*******************************)
  (*   t22 = #{ float; float }   *)
  (*******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i)) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 902;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 902 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i).#a22) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 903;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 903 failed";
    let shallow : (t22 array, _) idx_mut = (.(i).#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 904;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 904 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t22 array, _) idx_mut = (.(i).#b22) in
    let shallow : (t22 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 905;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 905 failed";
    let shallow : (t22 array, _) idx_mut = (.(i).#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 906;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 906 failed";
  );

  (************************************)
  (*   t32 = #{ float; float; int }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i)) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 907;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 907 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i).#a32) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a32) in
    mark_test_run 908;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 908 failed";
    let shallow : (t32 array, _) idx_mut = (.(i).#a32) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 909;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 909 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i).#b32) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b32) in
    mark_test_run 910;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 910 failed";
    let shallow : (t32 array, _) idx_mut = (.(i).#b32) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 911;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 911 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t32 array, _) idx_mut = (.(i).#c32) in
    let shallow : (t32 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c32) in
    mark_test_run 912;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 912 failed";
    let shallow : (t32 array, _) idx_mut = (.(i).#c32) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 913;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 913 failed";
  );

  (**************************************)
  (*   t33 = #{ float; float; float }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i)) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 914;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 914 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i).#a33) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a33) in
    mark_test_run 915;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 915 failed";
    let shallow : (t33 array, _) idx_mut = (.(i).#a33) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 916;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 916 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i).#b33) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b33) in
    mark_test_run 917;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 917 failed";
    let shallow : (t33 array, _) idx_mut = (.(i).#b33) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 918;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 918 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t33 array, _) idx_mut = (.(i).#c33) in
    let shallow : (t33 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#c33) in
    mark_test_run 919;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 919 failed";
    let shallow : (t33 array, _) idx_mut = (.(i).#c33) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 920;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 920 failed";
  );

  (**********************************)
  (*   t34 = #{ float; #{ int } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i)) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 921;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 921 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i).#a34) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a34) in
    mark_test_run 922;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 922 failed";
    let shallow : (t34 array, _) idx_mut = (.(i).#a34) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 923;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 923 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i).#b34) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b34) in
    mark_test_run 924;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 924 failed";
    let shallow : (t34 array, _) idx_mut = (.(i).#b34) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 925;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 925 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t34 array, _) idx_mut = (.(i).#b34.#a0) in
    let shallow : (t34 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b34.#a0) in
    mark_test_run 926;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 926 failed";
    let shallow : (t34 array, _) idx_mut = (.(i).#b34) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 927;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 927 failed";
    let shallow : (t34 array, _) idx_mut = (.(i).#b34.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 928;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 928 failed";
  );

  (***************************************)
  (*   t35 = #{ float; #{ int; int } }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i)) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 929;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 929 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i).#a35) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a35) in
    mark_test_run 930;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 930 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#a35) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 931;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 931 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i).#b35) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b35) in
    mark_test_run 932;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 932 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#b35) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 933;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 933 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i).#b35.#a1) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b35.#a1) in
    mark_test_run 934;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 934 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#b35) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 935;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 935 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#b35.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 936;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 936 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t35 array, _) idx_mut = (.(i).#b35.#b1) in
    let shallow : (t35 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b35.#b1) in
    mark_test_run 937;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 937 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#b35) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 938;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 938 failed";
    let shallow : (t35 array, _) idx_mut = (.(i).#b35.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 939;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 939 failed";
  );

  (*****************************************)
  (*   t36 = #{ float; #{ int; float } }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i)) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 940;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 940 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#a36) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a36) in
    mark_test_run 941;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 941 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#a36) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 942;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 942 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#b36) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b36) in
    mark_test_run 943;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 943 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#b36) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 944;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 944 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#b36.#a7) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b36.#a7) in
    mark_test_run 945;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 945 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#b36) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 946;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 946 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#b36.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 947;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 947 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t36 array, _) idx_mut = (.(i).#b36.#b7) in
    let shallow : (t36 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b36.#b7) in
    mark_test_run 948;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 948 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#b36) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 949;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 949 failed";
    let shallow : (t36 array, _) idx_mut = (.(i).#b36.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 950;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 950 failed";
  );

  (************************************)
  (*   t37 = #{ float; #{ float } }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i)) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 951;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 951 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i).#a37) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a37) in
    mark_test_run 952;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 952 failed";
    let shallow : (t37 array, _) idx_mut = (.(i).#a37) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 953;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 953 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i).#b37) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b37) in
    mark_test_run 954;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 954 failed";
    let shallow : (t37 array, _) idx_mut = (.(i).#b37) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 955;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 955 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t37 array, _) idx_mut = (.(i).#b37.#a18) in
    let shallow : (t37 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b37.#a18) in
    mark_test_run 956;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 956 failed";
    let shallow : (t37 array, _) idx_mut = (.(i).#b37) in
    let deepened = (.idx_mut(shallow).#a18) in
    mark_test_run 957;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 957 failed";
    let shallow : (t37 array, _) idx_mut = (.(i).#b37.#a18) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 958;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 958 failed";
  );

  (*****************************************)
  (*   t38 = #{ float; #{ float; int } }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i)) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 959;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 959 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#a38) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a38) in
    mark_test_run 960;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 960 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#a38) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 961;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 961 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#b38) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b38) in
    mark_test_run 962;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 962 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 963;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 963 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#b38.#a20) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b38.#a20) in
    mark_test_run 964;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 964 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 965;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 965 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38.#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 966;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 966 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t38 array, _) idx_mut = (.(i).#b38.#b20) in
    let shallow : (t38 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b38.#b20) in
    mark_test_run 967;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 967 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 968;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 968 failed";
    let shallow : (t38 array, _) idx_mut = (.(i).#b38.#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 969;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 969 failed";
  );

  (*******************************************)
  (*   t39 = #{ float; #{ float; float } }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i)) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 970;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 970 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#a39) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a39) in
    mark_test_run 971;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 971 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#a39) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 972;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 972 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#b39) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b39) in
    mark_test_run 973;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 973 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 974;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 974 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#b39.#a22) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b39.#a22) in
    mark_test_run 975;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 975 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 976;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 976 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39.#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 977;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 977 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t39 array, _) idx_mut = (.(i).#b39.#b22) in
    let shallow : (t39 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b39.#b22) in
    mark_test_run 978;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 978 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 979;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 979 failed";
    let shallow : (t39 array, _) idx_mut = (.(i).#b39.#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 980;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 980 failed";
  );

  (***************************)
  (*   t40 = #{ #{ int } }   *)
  (***************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t40 array, _) idx_mut = (.(i)) in
    let shallow : (t40 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 981;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 981 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t40 array, _) idx_mut = (.(i).#a40) in
    let shallow : (t40 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a40) in
    mark_test_run 982;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 982 failed";
    let shallow : (t40 array, _) idx_mut = (.(i).#a40) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 983;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 983 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t40 array, _) idx_mut = (.(i).#a40.#a0) in
    let shallow : (t40 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a40.#a0) in
    mark_test_run 984;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 984 failed";
    let shallow : (t40 array, _) idx_mut = (.(i).#a40) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 985;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 985 failed";
    let shallow : (t40 array, _) idx_mut = (.(i).#a40.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 986;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 986 failed";
  );

  (********************************)
  (*   t41 = #{ #{ int }; int }   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i)) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 987;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 987 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i).#a41) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a41) in
    mark_test_run 988;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 988 failed";
    let shallow : (t41 array, _) idx_mut = (.(i).#a41) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 989;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 989 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i).#b41) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b41) in
    mark_test_run 990;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 990 failed";
    let shallow : (t41 array, _) idx_mut = (.(i).#b41) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 991;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 991 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t41 array, _) idx_mut = (.(i).#a41.#a0) in
    let shallow : (t41 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a41.#a0) in
    mark_test_run 992;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 992 failed";
    let shallow : (t41 array, _) idx_mut = (.(i).#a41) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 993;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 993 failed";
    let shallow : (t41 array, _) idx_mut = (.(i).#a41.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 994;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 994 failed";
  );

  (***********************************)
  (*   t42 = #{ #{ int }; int32# }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i)) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 995;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 995 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i).#a42) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a42) in
    mark_test_run 996;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 996 failed";
    let shallow : (t42 array, _) idx_mut = (.(i).#a42) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 997;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 997 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i).#b42) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b42) in
    mark_test_run 998;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 998 failed";
    let shallow : (t42 array, _) idx_mut = (.(i).#b42) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 999;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 999 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t42 array, _) idx_mut = (.(i).#a42.#a0) in
    let shallow : (t42 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a42.#a0) in
    mark_test_run 1000;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1000 failed";
    let shallow : (t42 array, _) idx_mut = (.(i).#a42) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1001;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1001 failed";
    let shallow : (t42 array, _) idx_mut = (.(i).#a42.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1002;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1002 failed";
  );

  (**********************************)
  (*   t43 = #{ #{ int }; float }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i)) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1003;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1003 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i).#a43) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a43) in
    mark_test_run 1004;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1004 failed";
    let shallow : (t43 array, _) idx_mut = (.(i).#a43) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1005;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1005 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i).#b43) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b43) in
    mark_test_run 1006;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1006 failed";
    let shallow : (t43 array, _) idx_mut = (.(i).#b43) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1007;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1007 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t43 array, _) idx_mut = (.(i).#a43.#a0) in
    let shallow : (t43 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a43.#a0) in
    mark_test_run 1008;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1008 failed";
    let shallow : (t43 array, _) idx_mut = (.(i).#a43) in
    let deepened = (.idx_mut(shallow).#a0) in
    mark_test_run 1009;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1009 failed";
    let shallow : (t43 array, _) idx_mut = (.(i).#a43.#a0) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1010;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1010 failed";
  );

  (********************************)
  (*   t44 = #{ #{ int; int } }   *)
  (********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i)) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1011;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1011 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i).#a44) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a44) in
    mark_test_run 1012;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1012 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#a44) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1013;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1013 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i).#a44.#a1) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a44.#a1) in
    mark_test_run 1014;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1014 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#a44) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1015;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1015 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#a44.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1016;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1016 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t44 array, _) idx_mut = (.(i).#a44.#b1) in
    let shallow : (t44 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a44.#b1) in
    mark_test_run 1017;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1017 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#a44) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1018;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1018 failed";
    let shallow : (t44 array, _) idx_mut = (.(i).#a44.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1019;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1019 failed";
  );

  (*************************************)
  (*   t45 = #{ #{ int; int }; int }   *)
  (*************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i)) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1020;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1020 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#a45) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a45) in
    mark_test_run 1021;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1021 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#a45) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1022;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1022 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#b45) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b45) in
    mark_test_run 1023;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1023 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#b45) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1024;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1024 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#a45.#a1) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a45.#a1) in
    mark_test_run 1025;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1025 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#a45) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1026;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1026 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#a45.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1027;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1027 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t45 array, _) idx_mut = (.(i).#a45.#b1) in
    let shallow : (t45 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a45.#b1) in
    mark_test_run 1028;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1028 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#a45) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1029;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1029 failed";
    let shallow : (t45 array, _) idx_mut = (.(i).#a45.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1030;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1030 failed";
  );

  (****************************************)
  (*   t46 = #{ #{ int; int }; int32# }   *)
  (****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i)) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1031;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1031 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i).#a46) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a46) in
    mark_test_run 1032;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1032 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#a46) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1033;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1033 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i).#b46) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b46) in
    mark_test_run 1034;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1034 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#b46) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1035;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1035 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i).#a46.#a1) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a46.#a1) in
    mark_test_run 1036;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1036 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#a46) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1037;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1037 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#a46.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1038;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1038 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t46 array, _) idx_mut = (.(i).#a46.#b1) in
    let shallow : (t46 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a46.#b1) in
    mark_test_run 1039;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1039 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#a46) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1040;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1040 failed";
    let shallow : (t46 array, _) idx_mut = (.(i).#a46.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1041;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1041 failed";
  );

  (***************************************)
  (*   t47 = #{ #{ int; int }; float }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i)) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1042;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1042 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#a47) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a47) in
    mark_test_run 1043;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1043 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#a47) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1044;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1044 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#b47) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b47) in
    mark_test_run 1045;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1045 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#b47) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1046;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1046 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#a47.#a1) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a47.#a1) in
    mark_test_run 1047;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1047 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#a47) in
    let deepened = (.idx_mut(shallow).#a1) in
    mark_test_run 1048;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1048 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#a47.#a1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1049;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1049 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t47 array, _) idx_mut = (.(i).#a47.#b1) in
    let shallow : (t47 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a47.#b1) in
    mark_test_run 1050;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1050 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#a47) in
    let deepened = (.idx_mut(shallow).#b1) in
    mark_test_run 1051;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1051 failed";
    let shallow : (t47 array, _) idx_mut = (.(i).#a47.#b1) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1052;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1052 failed";
  );

  (********************************************************)
  (*   t50 = #{ #{ int; int64# }; #{ int64#; float# } }   *)
  (********************************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i)) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1053;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1053 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#a50) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a50) in
    mark_test_run 1054;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1054 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#a50) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1055;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1055 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#b50) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b50) in
    mark_test_run 1056;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1056 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1057;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1057 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#a50.#a48) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a50.#a48) in
    mark_test_run 1058;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1058 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#a50) in
    let deepened = (.idx_mut(shallow).#a48) in
    mark_test_run 1059;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1059 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#a50.#a48) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1060;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1060 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#a50.#b48) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a50.#b48) in
    mark_test_run 1061;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1061 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#a50) in
    let deepened = (.idx_mut(shallow).#b48) in
    mark_test_run 1062;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1062 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#a50.#b48) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1063;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1063 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#b50.#a49) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b50.#a49) in
    mark_test_run 1064;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1064 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50) in
    let deepened = (.idx_mut(shallow).#a49) in
    mark_test_run 1065;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1065 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50.#a49) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1066;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1066 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t50 array, _) idx_mut = (.(i).#b50.#b49) in
    let shallow : (t50 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b50.#b49) in
    mark_test_run 1067;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1067 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50) in
    let deepened = (.idx_mut(shallow).#b49) in
    mark_test_run 1068;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1068 failed";
    let shallow : (t50 array, _) idx_mut = (.(i).#b50.#b49) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1069;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1069 failed";
  );

  (***********************************)
  (*   t51 = #{ #{ int; int32# } }   *)
  (***********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i)) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1070;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1070 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#a51) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a51) in
    mark_test_run 1071;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1071 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#a51) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1072;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1072 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#a51.#a5) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a51.#a5) in
    mark_test_run 1073;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1073 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#a51) in
    let deepened = (.idx_mut(shallow).#a5) in
    mark_test_run 1074;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1074 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#a51.#a5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1075;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1075 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t51 array, _) idx_mut = (.(i).#a51.#b5) in
    let shallow : (t51 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a51.#b5) in
    mark_test_run 1076;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1076 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#a51) in
    let deepened = (.idx_mut(shallow).#b5) in
    mark_test_run 1077;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1077 failed";
    let shallow : (t51 array, _) idx_mut = (.(i).#a51.#b5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1078;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1078 failed";
  );

  (*******************************************)
  (*   t52 = #{ #{ int; int32# }; int32# }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i)) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1079;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1079 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#a52) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a52) in
    mark_test_run 1080;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1080 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#a52) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1081;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1081 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#b52) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b52) in
    mark_test_run 1082;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1082 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#b52) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1083;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1083 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#a52.#a5) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a52.#a5) in
    mark_test_run 1084;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1084 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#a52) in
    let deepened = (.idx_mut(shallow).#a5) in
    mark_test_run 1085;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1085 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#a52.#a5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1086;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1086 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t52 array, _) idx_mut = (.(i).#a52.#b5) in
    let shallow : (t52 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a52.#b5) in
    mark_test_run 1087;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1087 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#a52) in
    let deepened = (.idx_mut(shallow).#b5) in
    mark_test_run 1088;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1088 failed";
    let shallow : (t52 array, _) idx_mut = (.(i).#a52.#b5) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1089;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1089 failed";
  );

  (**********************************)
  (*   t53 = #{ #{ int; float } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i)) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1090;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1090 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#a53) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a53) in
    mark_test_run 1091;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1091 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#a53) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1092;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1092 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#a53.#a7) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a53.#a7) in
    mark_test_run 1093;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1093 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#a53) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 1094;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1094 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#a53.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1095;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1095 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t53 array, _) idx_mut = (.(i).#a53.#b7) in
    let shallow : (t53 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a53.#b7) in
    mark_test_run 1096;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1096 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#a53) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 1097;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1097 failed";
    let shallow : (t53 array, _) idx_mut = (.(i).#a53.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1098;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1098 failed";
  );

  (***************************************)
  (*   t54 = #{ #{ int; float }; int }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i)) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1099;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1099 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#a54) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a54) in
    mark_test_run 1100;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1100 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#a54) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1101;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1101 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#b54) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b54) in
    mark_test_run 1102;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1102 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#b54) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1103;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1103 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#a54.#a7) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a54.#a7) in
    mark_test_run 1104;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1104 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#a54) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 1105;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1105 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#a54.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1106;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1106 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t54 array, _) idx_mut = (.(i).#a54.#b7) in
    let shallow : (t54 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a54.#b7) in
    mark_test_run 1107;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1107 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#a54) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 1108;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1108 failed";
    let shallow : (t54 array, _) idx_mut = (.(i).#a54.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1109;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1109 failed";
  );

  (*****************************************)
  (*   t55 = #{ #{ int; float }; float }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i)) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1110;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1110 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i).#a55) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a55) in
    mark_test_run 1111;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1111 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1112;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1112 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i).#b55) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b55) in
    mark_test_run 1113;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1113 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#b55) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1114;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1114 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i).#a55.#a7) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a55.#a7) in
    mark_test_run 1115;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1115 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55) in
    let deepened = (.idx_mut(shallow).#a7) in
    mark_test_run 1116;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1116 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55.#a7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1117;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1117 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t55 array, _) idx_mut = (.(i).#a55.#b7) in
    let shallow : (t55 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a55.#b7) in
    mark_test_run 1118;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1118 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55) in
    let deepened = (.idx_mut(shallow).#b7) in
    mark_test_run 1119;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1119 failed";
    let shallow : (t55 array, _) idx_mut = (.(i).#a55.#b7) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1120;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1120 failed";
  );

  (******************************)
  (*   t56 = #{ #{ int32# } }   *)
  (******************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i)) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1121;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1121 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i).#a56) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a56) in
    mark_test_run 1122;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1122 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#a56) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1123;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1123 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t56 array, _) idx_mut = (.(i).#a56.#a14) in
    let shallow : (t56 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a56.#a14) in
    mark_test_run 1124;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1124 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#a56) in
    let deepened = (.idx_mut(shallow).#a14) in
    mark_test_run 1125;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1125 failed";
    let shallow : (t56 array, _) idx_mut = (.(i).#a56.#a14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1126;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1126 failed";
  );

  (**************************************)
  (*   t57 = #{ #{ int32# }; int32# }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i)) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1127;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1127 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i).#a57) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a57) in
    mark_test_run 1128;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1128 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#a57) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1129;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1129 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i).#b57) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b57) in
    mark_test_run 1130;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1130 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#b57) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1131;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1131 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t57 array, _) idx_mut = (.(i).#a57.#a14) in
    let shallow : (t57 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a57.#a14) in
    mark_test_run 1132;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1132 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#a57) in
    let deepened = (.idx_mut(shallow).#a14) in
    mark_test_run 1133;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1133 failed";
    let shallow : (t57 array, _) idx_mut = (.(i).#a57.#a14) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1134;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1134 failed";
  );

  (**************************************)
  (*   t58 = #{ #{ int32#; int32# } }   *)
  (**************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i)) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1135;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1135 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i).#a58) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a58) in
    mark_test_run 1136;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1136 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1137;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1137 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i).#a58.#a16) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a58.#a16) in
    mark_test_run 1138;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1138 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58) in
    let deepened = (.idx_mut(shallow).#a16) in
    mark_test_run 1139;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1139 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58.#a16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1140;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1140 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t58 array, _) idx_mut = (.(i).#a58.#b16) in
    let shallow : (t58 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a58.#b16) in
    mark_test_run 1141;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1141 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58) in
    let deepened = (.idx_mut(shallow).#b16) in
    mark_test_run 1142;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1142 failed";
    let shallow : (t58 array, _) idx_mut = (.(i).#a58.#b16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1143;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1143 failed";
  );

  (**********************************************)
  (*   t59 = #{ #{ int32#; int32# }; int32# }   *)
  (**********************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i)) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1144;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1144 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#a59) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a59) in
    mark_test_run 1145;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1145 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1146;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1146 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#b59) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b59) in
    mark_test_run 1147;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1147 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#b59) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1148;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1148 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#a59.#a16) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a59.#a16) in
    mark_test_run 1149;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1149 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59) in
    let deepened = (.idx_mut(shallow).#a16) in
    mark_test_run 1150;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1150 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59.#a16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1151;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1151 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t59 array, _) idx_mut = (.(i).#a59.#b16) in
    let shallow : (t59 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a59.#b16) in
    mark_test_run 1152;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1152 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59) in
    let deepened = (.idx_mut(shallow).#b16) in
    mark_test_run 1153;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1153 failed";
    let shallow : (t59 array, _) idx_mut = (.(i).#a59.#b16) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1154;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1154 failed";
  );

  (**********************************)
  (*   t60 = #{ #{ float }; int }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i)) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1155;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1155 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#a60) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a60) in
    mark_test_run 1156;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1156 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1157;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1157 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#b60) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b60) in
    mark_test_run 1158;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1158 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#b60) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1159;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1159 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t60 array, _) idx_mut = (.(i).#a60.#a18) in
    let shallow : (t60 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a60.#a18) in
    mark_test_run 1160;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1160 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60) in
    let deepened = (.idx_mut(shallow).#a18) in
    mark_test_run 1161;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1161 failed";
    let shallow : (t60 array, _) idx_mut = (.(i).#a60.#a18) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1162;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1162 failed";
  );

  (************************************)
  (*   t61 = #{ #{ float }; float }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i)) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1163;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1163 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#a61) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a61) in
    mark_test_run 1164;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1164 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1165;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1165 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#b61) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b61) in
    mark_test_run 1166;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1166 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#b61) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1167;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1167 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t61 array, _) idx_mut = (.(i).#a61.#a18) in
    let shallow : (t61 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a61.#a18) in
    mark_test_run 1168;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1168 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61) in
    let deepened = (.idx_mut(shallow).#a18) in
    mark_test_run 1169;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1169 failed";
    let shallow : (t61 array, _) idx_mut = (.(i).#a61.#a18) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1170;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1170 failed";
  );

  (**********************************)
  (*   t62 = #{ #{ float; int } }   *)
  (**********************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i)) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1171;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1171 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#a62) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a62) in
    mark_test_run 1172;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1172 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1173;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1173 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#a62.#a20) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a62.#a20) in
    mark_test_run 1174;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1174 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 1175;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1175 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62.#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1176;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1176 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t62 array, _) idx_mut = (.(i).#a62.#b20) in
    let shallow : (t62 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a62.#b20) in
    mark_test_run 1177;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1177 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 1178;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1178 failed";
    let shallow : (t62 array, _) idx_mut = (.(i).#a62.#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1179;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1179 failed";
  );

  (***************************************)
  (*   t63 = #{ #{ float; int }; int }   *)
  (***************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i)) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1180;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1180 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#a63) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a63) in
    mark_test_run 1181;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1181 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1182;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1182 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#b63) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b63) in
    mark_test_run 1183;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1183 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#b63) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1184;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1184 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#a63.#a20) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a63.#a20) in
    mark_test_run 1185;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1185 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 1186;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1186 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63.#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1187;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1187 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t63 array, _) idx_mut = (.(i).#a63.#b20) in
    let shallow : (t63 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a63.#b20) in
    mark_test_run 1188;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1188 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 1189;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1189 failed";
    let shallow : (t63 array, _) idx_mut = (.(i).#a63.#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1190;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1190 failed";
  );

  (*****************************************)
  (*   t64 = #{ #{ float; int }; float }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i)) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1191;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1191 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#a64) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a64) in
    mark_test_run 1192;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1192 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1193;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1193 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#b64) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b64) in
    mark_test_run 1194;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1194 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#b64) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1195;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1195 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#a64.#a20) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a64.#a20) in
    mark_test_run 1196;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1196 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64) in
    let deepened = (.idx_mut(shallow).#a20) in
    mark_test_run 1197;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1197 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64.#a20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1198;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1198 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t64 array, _) idx_mut = (.(i).#a64.#b20) in
    let shallow : (t64 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a64.#b20) in
    mark_test_run 1199;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1199 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64) in
    let deepened = (.idx_mut(shallow).#b20) in
    mark_test_run 1200;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1200 failed";
    let shallow : (t64 array, _) idx_mut = (.(i).#a64.#b20) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1201;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1201 failed";
  );

  (************************************)
  (*   t65 = #{ #{ float; float } }   *)
  (************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i)) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1202;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1202 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i).#a65) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a65) in
    mark_test_run 1203;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1203 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1204;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1204 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i).#a65.#a22) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a65.#a22) in
    mark_test_run 1205;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1205 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 1206;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1206 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65.#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1207;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1207 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t65 array, _) idx_mut = (.(i).#a65.#b22) in
    let shallow : (t65 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a65.#b22) in
    mark_test_run 1208;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1208 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 1209;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1209 failed";
    let shallow : (t65 array, _) idx_mut = (.(i).#a65.#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1210;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1210 failed";
  );

  (*****************************************)
  (*   t66 = #{ #{ float; float }; int }   *)
  (*****************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i)) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1211;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1211 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#a66) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a66) in
    mark_test_run 1212;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1212 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1213;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1213 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#b66) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b66) in
    mark_test_run 1214;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1214 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#b66) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1215;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1215 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#a66.#a22) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a66.#a22) in
    mark_test_run 1216;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1216 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 1217;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1217 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66.#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1218;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1218 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t66 array, _) idx_mut = (.(i).#a66.#b22) in
    let shallow : (t66 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a66.#b22) in
    mark_test_run 1219;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1219 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 1220;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1220 failed";
    let shallow : (t66 array, _) idx_mut = (.(i).#a66.#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1221;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1221 failed";
  );

  (*******************************************)
  (*   t67 = #{ #{ float; float }; float }   *)
  (*******************************************)
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i)) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1222;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1222 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#a67) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a67) in
    mark_test_run 1223;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1223 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1224;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1224 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#b67) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#b67) in
    mark_test_run 1225;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1225 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#b67) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1226;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1226 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#a67.#a22) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a67.#a22) in
    mark_test_run 1227;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1227 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67) in
    let deepened = (.idx_mut(shallow).#a22) in
    mark_test_run 1228;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1228 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67.#a22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1229;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1229 failed";
  );
  iter indices_in_deepening_tests ~f:(fun i ->
    let unboxed_path : (t67 array, _) idx_mut = (.(i).#a67.#b22) in
    let shallow : (t67 array, _) idx_mut = (.(i)) in
    let deepened = (.idx_mut(shallow).#a67.#b22) in
    mark_test_run 1230;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1230 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67) in
    let deepened = (.idx_mut(shallow).#b22) in
    mark_test_run 1231;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1231 failed";
    let shallow : (t67 array, _) idx_mut = (.(i).#a67.#b22) in
    let deepened = (.idx_mut(shallow)) in
    mark_test_run 1232;
    let test = Idx_repr.equal (Idx_repr.of_idx_mut unboxed_path) (Idx_repr.of_idx_mut deepened) in
    if not test then failwithf "test 1232 failed";
  );

  ()
(* *)
let () =
  print_endline "test_array_idx_with_makearray_dynamic";
  iter sizes ~f:test_array_idx_with_makearray_dynamic;
  print_endline "test_array_idx_with_makearray_dynamic_local";
  iter sizes ~f:test_array_idx_with_makearray_dynamic_local;
  ()
;;

for i = 1 to 1232 do
  if not (Int_set.mem i !tests_run) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
