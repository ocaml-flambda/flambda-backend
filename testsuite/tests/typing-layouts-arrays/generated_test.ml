(* TEST
 include stdlib_stable;
 include stdlib_upstream_compatible;
 modules = "stubs.c";
 flags = "-extension layouts_beta -extension simd_beta";
 flambda2;
 stack-allocation;
 arch_amd64;
 native;
*)
(** This is code generated by [generate_makearray_dynamic_tests.ml]. *)


open Stdlib_upstream_compatible
open Stdlib_stable
module List = ListLabels
module String = StringLabels

external[@layout_poly] makearray_dynamic_uninit_local :
  ('a : any_non_null) . int -> 'a array @ local =
  "%makearray_dynamic_uninit"

external[@layout_poly] makearray_dynamic_uninit :
  ('a : any_non_null) . int -> 'a array =
  "%makearray_dynamic_uninit"

external[@layout_poly] makearray_dynamic_local :
  ('a : any_non_null) . int -> 'a -> 'a array @ local =
  "%makearray_dynamic"

external[@layout_poly] makearray_dynamic :
  ('a : any_non_null) . int -> 'a -> 'a array =
  "%makearray_dynamic"

external[@layout_poly] get :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a =
  "%array_safe_get"

external[@layout_poly] set :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> 'a -> unit =
  "%array_safe_set"

external[@layout_poly] unsafe_blit :
  ('a : any_non_null) . ('a array[@local_opt]) -> (int[@local_opt]) -> ('a array[@local_opt]) -> (int[@local_opt]) -> (int[@local_opt]) -> unit =
  "%arrayblit"

let failwithf fmt = Printf.ksprintf failwith fmt

external globalize : local_ 'a -> 'a = "%obj_dup";;

(* Redefine iter to infer locality *)
let rec iter ~f = function
    [] -> ()
  | a::l -> f a; iter ~f l

let tests_run = ref []

let mark_test_run test_id =
  if not (List.mem ~set:!tests_run test_id) then
    tests_run := test_id :: !tests_run

(* Various interesting values *)

let sizes = [ 0; 1; 2; 30; 31; 32 ]

let bad_indices size =
  [ -100; -2; -1; size; size + 1; size + 100; Int.min_int; Int.max_int ]

let blit_offsets size =
  let candidates = [ 0; 1; size / 3; size / 2; size - 1; size ] in
  List.filter candidates ~f:(fun ofs -> ofs > 0 && ofs < size)
  |> List.sort_uniq ~cmp:Int.compare

let blit_lens ~ofs1 ~ofs2 ~size1 ~size2 =
  let len_until_end = Int.min (size1 - ofs1) (size2 - ofs2) in
  let candidates = [ 0; 1; size1 / 2; len_until_end - 1; len_until_end ] in
  List.filter candidates ~f:(fun len -> ofs1 + len <= size1 && ofs2 + len <= size2)
  |> List.sort_uniq ~cmp:Int.compare

type ur1 = #{ a : int64#; b : float# }
and ur2 = #{ a : int64#; b : int }
and ur3 = #{ a : int64# }
and ur4 = #{ a : ur1; b : ur3 }
and enum3 = A3_0 | A3_1 | A3_2

(* Catch metaprogramming errors early *)
let () =
  (* Check types and constants *)
  let _ : float32# = #0.s in
  let _ : float# = #0. in
  let _ : int32# = #0l in
  let _ : int64# = #0L in
  let _ : nativeint# = #0n in
  let _ : ur1 = (#{ a = #0L; b = #0. } : ur1) in
  let _ : ur3 = (#{ a = #0L } : ur3) in
  let _ : ur4 = (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
  let _ : #(float# * int32# * int64#) = #(#0., #0l, #0L) in
  let _ : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) = #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  let _ : #(int64# * ur1) = #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
  let _ : float32 = 0.s in
  let _ : float = 0. in
  let _ : int32 = 0l in
  let _ : int64 = 0L in
  let _ : nativeint = 0n in
  let _ : int = 0 in
  let _ : enum3 = A3_0 in
  let _ : ur2 = (#{ a = #0L; b = 0 } : ur2) in
  let _ : #(int * int64) = #(0, 0L) in
  let _ : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) = #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  let _ : #(float * float * float) = #(0., 0., 0.) in
  let _ : #(float * #(float * float) * #(float * #(float * float * float))) = #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
  let _ : #(float# * int * int64#) = #(#0., 0, #0L) in
  let _ : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) = #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
  let _ : #(ur2 * ur1) = #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* Check equality and mk_value functions *)
  let eq : float32# @ local -> float32# @ local -> bool = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  mark_test_run 1;
  let test = eq (mk_value 1) #1.s in
  if not test then failwithf "test 1 failed";
  mark_test_run 2;
  let test = eq #1.s #1.s in
  if not test then failwithf "test 2 failed";
  mark_test_run 3;
  let test = not (eq #1.s #2.s) in
  if not test then failwithf "test 3 failed";
  let eq : float# @ local -> float# @ local -> bool = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  mark_test_run 4;
  let test = eq (mk_value 1) #1. in
  if not test then failwithf "test 4 failed";
  mark_test_run 5;
  let test = eq #1. #1. in
  if not test then failwithf "test 5 failed";
  mark_test_run 6;
  let test = not (eq #1. #2.) in
  if not test then failwithf "test 6 failed";
  let eq : int32# @ local -> int32# @ local -> bool = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  mark_test_run 7;
  let test = eq (mk_value 1) #1l in
  if not test then failwithf "test 7 failed";
  mark_test_run 8;
  let test = eq #1l #1l in
  if not test then failwithf "test 8 failed";
  mark_test_run 9;
  let test = not (eq #1l #2l) in
  if not test then failwithf "test 9 failed";
  let eq : int64# @ local -> int64# @ local -> bool = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  mark_test_run 10;
  let test = eq (mk_value 1) #1L in
  if not test then failwithf "test 10 failed";
  mark_test_run 11;
  let test = eq #1L #1L in
  if not test then failwithf "test 11 failed";
  mark_test_run 12;
  let test = not (eq #1L #2L) in
  if not test then failwithf "test 12 failed";
  let eq : nativeint# @ local -> nativeint# @ local -> bool = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  mark_test_run 13;
  let test = eq (mk_value 1) #1n in
  if not test then failwithf "test 13 failed";
  mark_test_run 14;
  let test = eq #1n #1n in
  if not test then failwithf "test 14 failed";
  mark_test_run 15;
  let test = not (eq #1n #2n) in
  if not test then failwithf "test 15 failed";
  let eq : ur1 @ local -> ur1 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  mark_test_run 16;
  let test = eq (mk_value 1) (#{ a = #1L; b = #1. } : ur1) in
  if not test then failwithf "test 16 failed";
  mark_test_run 17;
  let test = eq (#{ a = #1L; b = #1. } : ur1) (#{ a = #1L; b = #1. } : ur1) in
  if not test then failwithf "test 17 failed";
  mark_test_run 18;
  let test = not (eq (#{ a = #1L; b = #1. } : ur1) (#{ a = #2L; b = #2. } : ur1)) in
  if not test then failwithf "test 18 failed";
  let eq : ur3 @ local -> ur3 @ local -> bool = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  mark_test_run 19;
  let test = eq (mk_value 1) (#{ a = #1L } : ur3) in
  if not test then failwithf "test 19 failed";
  mark_test_run 20;
  let test = eq (#{ a = #1L } : ur3) (#{ a = #1L } : ur3) in
  if not test then failwithf "test 20 failed";
  mark_test_run 21;
  let test = not (eq (#{ a = #1L } : ur3) (#{ a = #2L } : ur3)) in
  if not test then failwithf "test 21 failed";
  let eq : ur4 @ local -> ur4 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  mark_test_run 22;
  let test = eq (mk_value 1) (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) in
  if not test then failwithf "test 22 failed";
  mark_test_run 23;
  let test = eq (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) in
  if not test then failwithf "test 23 failed";
  mark_test_run 24;
  let test = not (eq (#{ a = (#{ a = #1L; b = #1. } : ur1); b = (#{ a = #1L } : ur3) } : ur4) (#{ a = (#{ a = #2L; b = #2. } : ur1); b = (#{ a = #2L } : ur3) } : ur4)) in
  if not test then failwithf "test 24 failed";
  let eq : #(float# * int32# * int64#) @ local -> #(float# * int32# * int64#) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  mark_test_run 25;
  let test = eq (mk_value 1) #(#1., #1l, #1L) in
  if not test then failwithf "test 25 failed";
  mark_test_run 26;
  let test = eq #(#1., #1l, #1L) #(#1., #1l, #1L) in
  if not test then failwithf "test 26 failed";
  mark_test_run 27;
  let test = not (eq #(#1., #1l, #1L) #(#2., #2l, #2L)) in
  if not test then failwithf "test 27 failed";
  let eq : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  mark_test_run 28;
  let test = eq (mk_value 1) #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) in
  if not test then failwithf "test 28 failed";
  mark_test_run 29;
  let test = eq #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) in
  if not test then failwithf "test 29 failed";
  mark_test_run 30;
  let test = not (eq #(#1., #(#1L, #1L), #1.s, #(#1l, #(#1.s, #1.)), #1L) #(#2., #(#2L, #2L), #2.s, #(#2l, #(#2.s, #2.)), #2L)) in
  if not test then failwithf "test 30 failed";
  let eq : #(int64# * ur1) @ local -> #(int64# * ur1) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  mark_test_run 31;
  let test = eq (mk_value 1) #(#1L, (#{ a = #1L; b = #1. } : ur1)) in
  if not test then failwithf "test 31 failed";
  mark_test_run 32;
  let test = eq #(#1L, (#{ a = #1L; b = #1. } : ur1)) #(#1L, (#{ a = #1L; b = #1. } : ur1)) in
  if not test then failwithf "test 32 failed";
  mark_test_run 33;
  let test = not (eq #(#1L, (#{ a = #1L; b = #1. } : ur1)) #(#2L, (#{ a = #2L; b = #2. } : ur1))) in
  if not test then failwithf "test 33 failed";
  let eq : float32 @ local -> float32 @ local -> bool = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int i in
  mark_test_run 34;
  let test = eq (mk_value 1) 1.s in
  if not test then failwithf "test 34 failed";
  mark_test_run 35;
  let test = eq 1.s 1.s in
  if not test then failwithf "test 35 failed";
  mark_test_run 36;
  let test = not (eq 1.s 2.s) in
  if not test then failwithf "test 36 failed";
  let eq : float @ local -> float @ local -> bool = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let mk_value i = Float.of_int i in
  mark_test_run 37;
  let test = eq (mk_value 1) 1. in
  if not test then failwithf "test 37 failed";
  mark_test_run 38;
  let test = eq 1. 1. in
  if not test then failwithf "test 38 failed";
  mark_test_run 39;
  let test = not (eq 1. 2.) in
  if not test then failwithf "test 39 failed";
  let eq : int32 @ local -> int32 @ local -> bool = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int i in
  mark_test_run 40;
  let test = eq (mk_value 1) 1l in
  if not test then failwithf "test 40 failed";
  mark_test_run 41;
  let test = eq 1l 1l in
  if not test then failwithf "test 41 failed";
  mark_test_run 42;
  let test = not (eq 1l 2l) in
  if not test then failwithf "test 42 failed";
  let eq : int64 @ local -> int64 @ local -> bool = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int i in
  mark_test_run 43;
  let test = eq (mk_value 1) 1L in
  if not test then failwithf "test 43 failed";
  mark_test_run 44;
  let test = eq 1L 1L in
  if not test then failwithf "test 44 failed";
  mark_test_run 45;
  let test = not (eq 1L 2L) in
  if not test then failwithf "test 45 failed";
  let eq : nativeint @ local -> nativeint @ local -> bool = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  mark_test_run 46;
  let test = eq (mk_value 1) 1n in
  if not test then failwithf "test 46 failed";
  mark_test_run 47;
  let test = eq 1n 1n in
  if not test then failwithf "test 47 failed";
  mark_test_run 48;
  let test = not (eq 1n 2n) in
  if not test then failwithf "test 48 failed";
  let eq : int @ local -> int @ local -> bool = (fun a b -> Int.equal a b) in
  let mk_value i = i in
  mark_test_run 49;
  let test = eq (mk_value 1) 1 in
  if not test then failwithf "test 49 failed";
  mark_test_run 50;
  let test = eq 1 1 in
  if not test then failwithf "test 50 failed";
  mark_test_run 51;
  let test = not (eq 1 2) in
  if not test then failwithf "test 51 failed";
  let eq : enum3 @ local -> enum3 @ local -> bool = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem i 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  mark_test_run 52;
  let test = eq (mk_value 1) A3_1 in
  if not test then failwithf "test 52 failed";
  mark_test_run 53;
  let test = eq A3_1 A3_1 in
  if not test then failwithf "test 53 failed";
  mark_test_run 54;
  let test = not (eq A3_1 A3_2) in
  if not test then failwithf "test 54 failed";
  let eq : ur2 @ local -> ur2 @ local -> bool = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = i } : ur2) in
  mark_test_run 55;
  let test = eq (mk_value 1) (#{ a = #1L; b = 1 } : ur2) in
  if not test then failwithf "test 55 failed";
  mark_test_run 56;
  let test = eq (#{ a = #1L; b = 1 } : ur2) (#{ a = #1L; b = 1 } : ur2) in
  if not test then failwithf "test 56 failed";
  mark_test_run 57;
  let test = not (eq (#{ a = #1L; b = 1 } : ur2) (#{ a = #2L; b = 2 } : ur2)) in
  if not test then failwithf "test 57 failed";
  let eq : #(int * int64) @ local -> #(int * int64) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i, Int64.of_int i) in
  mark_test_run 58;
  let test = eq (mk_value 1) #(1, 1L) in
  if not test then failwithf "test 58 failed";
  mark_test_run 59;
  let test = eq #(1, 1L) #(1, 1L) in
  if not test then failwithf "test 59 failed";
  mark_test_run 60;
  let test = not (eq #(1, 1L) #(2, 2L)) in
  if not test then failwithf "test 60 failed";
  let eq : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) @ local -> #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  mark_test_run 61;
  let test = eq (mk_value 1) #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) in
  if not test then failwithf "test 61 failed";
  mark_test_run 62;
  let test = eq #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) in
  if not test then failwithf "test 62 failed";
  mark_test_run 63;
  let test = not (eq #(Some 1L, #(1, 1l, 1.), 1., #(1.s, Some (1n, 1n)), 1l) #(Some 2L, #(2, 2l, 2.), 2., #(2.s, Some (2n, 2n)), 2l)) in
  if not test then failwithf "test 63 failed";
  let eq : #(float * float * float) @ local -> #(float * float * float) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int i, Float.of_int i, Float.of_int i) in
  mark_test_run 64;
  let test = eq (mk_value 1) #(1., 1., 1.) in
  if not test then failwithf "test 64 failed";
  mark_test_run 65;
  let test = eq #(1., 1., 1.) #(1., 1., 1.) in
  if not test then failwithf "test 65 failed";
  mark_test_run 66;
  let test = not (eq #(1., 1., 1.) #(2., 2., 2.)) in
  if not test then failwithf "test 66 failed";
  let eq : #(float * #(float * float) * #(float * #(float * float * float))) @ local -> #(float * #(float * float) * #(float * #(float * float * float))) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int i, #(Float.of_int i, Float.of_int i), #(Float.of_int i, #(Float.of_int i, Float.of_int i, Float.of_int i))) in
  mark_test_run 67;
  let test = eq (mk_value 1) #(1., #(1., 1.), #(1., #(1., 1., 1.))) in
  if not test then failwithf "test 67 failed";
  mark_test_run 68;
  let test = eq #(1., #(1., 1.), #(1., #(1., 1., 1.))) #(1., #(1., 1.), #(1., #(1., 1., 1.))) in
  if not test then failwithf "test 68 failed";
  mark_test_run 69;
  let test = not (eq #(1., #(1., 1.), #(1., #(1., 1., 1.))) #(2., #(2., 2.), #(2., #(2., 2., 2.)))) in
  if not test then failwithf "test 69 failed";
  let eq : #(float# * int * int64#) @ local -> #(float# * int * int64#) @ local -> bool = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int.equal a b) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, i, Int64_u.of_int i) in
  mark_test_run 70;
  let test = eq (mk_value 1) #(#1., 1, #1L) in
  if not test then failwithf "test 70 failed";
  mark_test_run 71;
  let test = eq #(#1., 1, #1L) #(#1., 1, #1L) in
  if not test then failwithf "test 71 failed";
  mark_test_run 72;
  let test = not (eq #(#1., 1, #1L) #(#2., 2, #2L)) in
  if not test then failwithf "test 72 failed";
  let eq : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) @ local -> #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) @ local -> bool = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int.equal a b) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), i) in
  mark_test_run 73;
  let test = eq (mk_value 1) #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) in
  if not test then failwithf "test 73 failed";
  mark_test_run 74;
  let test = eq #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) in
  if not test then failwithf "test 74 failed";
  mark_test_run 75;
  let test = not (eq #(#1., #(1, #1L), #1.s, #(#1l, #(#1.s, #1.)), 1) #(#2., #(2, #2L), #2.s, #(#2l, #(#2.s, #2.)), 2)) in
  if not test then failwithf "test 75 failed";
  let eq : #(ur2 * ur1) @ local -> #(ur2 * ur1) @ local -> bool = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  mark_test_run 76;
  let test = eq (mk_value 1) #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) in
  if not test then failwithf "test 76 failed";
  mark_test_run 77;
  let test = eq #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) in
  if not test then failwithf "test 77 failed";
  mark_test_run 78;
  let test = not (eq #((#{ a = #1L; b = 1 } : ur2), (#{ a = #1L; b = #1. } : ur1)) #((#{ a = #2L; b = 2 } : ur2), (#{ a = #2L; b = #2. } : ur1))) in
  if not test then failwithf "test 78 failed";
  (* Check always-GC-ignored types *)
  let _ = (makearray_dynamic_uninit 1 : float32# array) in
  let _ = (makearray_dynamic_uninit 1 : float# array) in
  let _ = (makearray_dynamic_uninit 1 : int32# array) in
  let _ = (makearray_dynamic_uninit 1 : int64# array) in
  let _ = (makearray_dynamic_uninit 1 : nativeint# array) in
  let _ = (makearray_dynamic_uninit 1 : ur1 array) in
  let _ = (makearray_dynamic_uninit 1 : ur3 array) in
  let _ = (makearray_dynamic_uninit 1 : ur4 array) in
  let _ = (makearray_dynamic_uninit 1 : #(float# * int32# * int64#) array) in
  let _ = (makearray_dynamic_uninit 1 : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array) in
  let _ = (makearray_dynamic_uninit 1 : #(int64# * ur1) array) in
  ()
;;

let test_makearray_dynamic size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic size #0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 79;
    let test = eq el #0.s in
    if not test then failwithf "test 79 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 80;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 80 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 81;
    let test = raises in
    if not test then failwithf "test 81 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 82;
    let test = raises in
    if not test then failwithf "test 82 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 83;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 83 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 84;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 84 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 85;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 85 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 86;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 86 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic size #0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 87;
    let test = eq el #0. in
    if not test then failwithf "test 87 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 88;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 88 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 89;
    let test = raises in
    if not test then failwithf "test 89 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 90;
    let test = raises in
    if not test then failwithf "test 90 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 91;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 91 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 92;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 92 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 93;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 93 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 94;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 94 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic size #0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 95;
    let test = eq el #0l in
    if not test then failwithf "test 95 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 96;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 96 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 97;
    let test = raises in
    if not test then failwithf "test 97 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 98;
    let test = raises in
    if not test then failwithf "test 98 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 99;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 99 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 100;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 100 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 101;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 101 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 102;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 102 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic size #0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 103;
    let test = eq el #0L in
    if not test then failwithf "test 103 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 104;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 104 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 105;
    let test = raises in
    if not test then failwithf "test 105 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 106;
    let test = raises in
    if not test then failwithf "test 106 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 107;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 107 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 108;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 108 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 109;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 109 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 110;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 110 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic size #0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 111;
    let test = eq el #0n in
    if not test then failwithf "test 111 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 112;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 112 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 113;
    let test = raises in
    if not test then failwithf "test 113 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 114;
    let test = raises in
    if not test then failwithf "test 114 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 115;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 115 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 116;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 116 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 117;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 117 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 118;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 118 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic size (#{ a = #0L; b = #0. } : ur1) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 119;
    let test = eq el (#{ a = #0L; b = #0. } : ur1) in
    if not test then failwithf "test 119 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 120;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 120 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 121;
    let test = raises in
    if not test then failwithf "test 121 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 122;
    let test = raises in
    if not test then failwithf "test 122 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 123;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 123 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 124;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 124 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 125;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 125 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 126;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 126 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic size (#{ a = #0L } : ur3) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 127;
    let test = eq el (#{ a = #0L } : ur3) in
    if not test then failwithf "test 127 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 128;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 128 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 129;
    let test = raises in
    if not test then failwithf "test 129 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 130;
    let test = raises in
    if not test then failwithf "test 130 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 131;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 131 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 132;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 132 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 133;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 133 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 134;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 134 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic size (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 135;
    let test = eq el (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
    if not test then failwithf "test 135 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 136;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 136 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 137;
    let test = raises in
    if not test then failwithf "test 137 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 138;
    let test = raises in
    if not test then failwithf "test 138 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 139;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 139 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 140;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 140 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 141;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 141 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 142;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 142 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic size #(#0., #0l, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 143;
    let test = eq el #(#0., #0l, #0L) in
    if not test then failwithf "test 143 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 144;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 144 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 145;
    let test = raises in
    if not test then failwithf "test 145 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 146;
    let test = raises in
    if not test then failwithf "test 146 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 147;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 147 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 148;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 148 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 149;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 149 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 150;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 150 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic size #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 151;
    let test = eq el #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
    if not test then failwithf "test 151 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 152;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 152 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 153;
    let test = raises in
    if not test then failwithf "test 153 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 154;
    let test = raises in
    if not test then failwithf "test 154 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 155;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 155 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 156;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 156 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 157;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 157 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 158;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 158 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic size #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 159;
    let test = eq el #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
    if not test then failwithf "test 159 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 160;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 160 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 161;
    let test = raises in
    if not test then failwithf "test 161 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 162;
    let test = raises in
    if not test then failwithf "test 162 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 163;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 163 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 164;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 164 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 165;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 165 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 166;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 166 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic size 0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 167;
    let test = eq el 0.s in
    if not test then failwithf "test 167 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 168;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 168 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 169;
    let test = raises in
    if not test then failwithf "test 169 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 170;
    let test = raises in
    if not test then failwithf "test 170 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 171;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 171 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 172;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 172 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 173;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 173 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 174;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 174 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   float   *)
  (*************)
  let eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let mk_value i = Float.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float array = makearray_dynamic size 0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 175;
    let test = eq el 0. in
    if not test then failwithf "test 175 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 176;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 176 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 177;
    let test = raises in
    if not test then failwithf "test 177 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 178;
    let test = raises in
    if not test then failwithf "test 178 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 179;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 179 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 180;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 180 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 181;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 181 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 182;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 182 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic size 0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 183;
    let test = eq el 0l in
    if not test then failwithf "test 183 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 184;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 184 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 185;
    let test = raises in
    if not test then failwithf "test 185 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 186;
    let test = raises in
    if not test then failwithf "test 186 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 187;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 187 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 188;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 188 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 189;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 189 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 190;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 190 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic size 0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 191;
    let test = eq el 0L in
    if not test then failwithf "test 191 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 192;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 192 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 193;
    let test = raises in
    if not test then failwithf "test 193 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 194;
    let test = raises in
    if not test then failwithf "test 194 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 195;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 195 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 196;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 196 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 197;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 197 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 198;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 198 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic size 0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 199;
    let test = eq el 0n in
    if not test then failwithf "test 199 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 200;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 200 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 201;
    let test = raises in
    if not test then failwithf "test 201 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 202;
    let test = raises in
    if not test then failwithf "test 202 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 203;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 203 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 204;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 204 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 205;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 205 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 206;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 206 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = i in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic size 0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 207;
    let test = eq el 0 in
    if not test then failwithf "test 207 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 208;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 208 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 209;
    let test = raises in
    if not test then failwithf "test 209 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 210;
    let test = raises in
    if not test then failwithf "test 210 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 211;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 211 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 212;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 212 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 213;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 213 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 214;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 214 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   enum3   *)
  (*************)
  let eq = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem i 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  (* 1. Create an array of size [size] *)
  let a : enum3 array = makearray_dynamic size A3_0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 215;
    let test = eq el A3_0 in
    if not test then failwithf "test 215 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 216;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 216 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 217;
    let test = raises in
    if not test then failwithf "test 217 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i A3_0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 218;
    let test = raises in
    if not test then failwithf "test 218 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 219;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 219 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 220;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 220 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 221;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 221 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 222;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 222 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur2   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = i } : ur2) in
  (* 1. Create an array of size [size] *)
  let a : ur2 array = makearray_dynamic size (#{ a = #0L; b = 0 } : ur2) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 223;
    let test = eq el (#{ a = #0L; b = 0 } : ur2) in
    if not test then failwithf "test 223 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 224;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 224 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 225;
    let test = raises in
    if not test then failwithf "test 225 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = 0 } : ur2) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 226;
    let test = raises in
    if not test then failwithf "test 226 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 227;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 227 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 228;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 228 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 229;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 229 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 230;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 230 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i, Int64.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic size #(0, 0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 231;
    let test = eq el #(0, 0L) in
    if not test then failwithf "test 231 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 232;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 232 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 233;
    let test = raises in
    if not test then failwithf "test 233 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0, 0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 234;
    let test = raises in
    if not test then failwithf "test 234 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 235;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 235 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 236;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 236 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 237;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 237 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 238;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 238 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************************************************************************************************************)
  (*   #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)   *)
  (**************************************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) array = makearray_dynamic size #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 239;
    let test = eq el #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
    if not test then failwithf "test 239 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 240;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 240 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 241;
    let test = raises in
    if not test then failwithf "test 241 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 242;
    let test = raises in
    if not test then failwithf "test 242 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 243;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 243 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 244;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 244 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 245;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 245 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 246;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 246 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int i, Float.of_int i, Float.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic size #(0., 0., 0.) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 247;
    let test = eq el #(0., 0., 0.) in
    if not test then failwithf "test 247 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 248;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 248 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 249;
    let test = raises in
    if not test then failwithf "test 249 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., 0., 0.) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 250;
    let test = raises in
    if not test then failwithf "test 250 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 251;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 251 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 252;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 252 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 253;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 253 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 254;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 254 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int i, #(Float.of_int i, Float.of_int i), #(Float.of_int i, #(Float.of_int i, Float.of_int i, Float.of_int i))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic size #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 255;
    let test = eq el #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
    if not test then failwithf "test 255 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 256;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 256 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 257;
    let test = raises in
    if not test then failwithf "test 257 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., #(0., 0.), #(0., #(0., 0., 0.))) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 258;
    let test = raises in
    if not test then failwithf "test 258 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 259;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 259 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 260;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 260 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 261;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 261 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 262;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 262 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float# * int * int64#)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int.equal a b) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int * int64#) array = makearray_dynamic size #(#0., 0, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 263;
    let test = eq el #(#0., 0, #0L) in
    if not test then failwithf "test 263 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 264;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 264 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 265;
    let test = raises in
    if not test then failwithf "test 265 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., 0, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 266;
    let test = raises in
    if not test then failwithf "test 266 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 267;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 267 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 268;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 268 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 269;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 269 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 270;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 270 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************************************************************************************)
  (*   #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)   *)
  (***************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int.equal a b) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) array = makearray_dynamic size #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 271;
    let test = eq el #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
    if not test then failwithf "test 271 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 272;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 272 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 273;
    let test = raises in
    if not test then failwithf "test 273 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 274;
    let test = raises in
    if not test then failwithf "test 274 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 275;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 275 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 276;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 276 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 277;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 277 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 278;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 278 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************)
  (*   #(ur2 * ur1)   *)
  (********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(ur2 * ur1) array = makearray_dynamic size #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 279;
    let test = eq el #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
    if not test then failwithf "test 279 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 280;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 280 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 281;
    let test = raises in
    if not test then failwithf "test 281 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 282;
    let test = raises in
    if not test then failwithf "test 282 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 283;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 283 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 284;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 284 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 285;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 285 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 286;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 286 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_local size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_local size #0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 287;
    let test = eq el #0.s in
    if not test then failwithf "test 287 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 288;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 288 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 289;
    let test = raises in
    if not test then failwithf "test 289 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 290;
    let test = raises in
    if not test then failwithf "test 290 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 291;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 291 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 292;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 292 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 293;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 293 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 294;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 294 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_local size #0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 295;
    let test = eq el #0. in
    if not test then failwithf "test 295 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 296;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 296 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 297;
    let test = raises in
    if not test then failwithf "test 297 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 298;
    let test = raises in
    if not test then failwithf "test 298 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 299;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 299 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 300;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 300 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 301;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 301 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 302;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 302 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_local size #0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 303;
    let test = eq el #0l in
    if not test then failwithf "test 303 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 304;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 304 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 305;
    let test = raises in
    if not test then failwithf "test 305 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 306;
    let test = raises in
    if not test then failwithf "test 306 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 307;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 307 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 308;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 308 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 309;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 309 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 310;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 310 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_local size #0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 311;
    let test = eq el #0L in
    if not test then failwithf "test 311 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 312;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 312 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 313;
    let test = raises in
    if not test then failwithf "test 313 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 314;
    let test = raises in
    if not test then failwithf "test 314 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 315;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 315 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 316;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 316 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 317;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 317 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 318;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 318 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_local size #0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 319;
    let test = eq el #0n in
    if not test then failwithf "test 319 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 320;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 320 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 321;
    let test = raises in
    if not test then failwithf "test 321 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 322;
    let test = raises in
    if not test then failwithf "test 322 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 323;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 323 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 324;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 324 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 325;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 325 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 326;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 326 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_local size (#{ a = #0L; b = #0. } : ur1) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 327;
    let test = eq el (#{ a = #0L; b = #0. } : ur1) in
    if not test then failwithf "test 327 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 328;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 328 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 329;
    let test = raises in
    if not test then failwithf "test 329 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 330;
    let test = raises in
    if not test then failwithf "test 330 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 331;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 331 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 332;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 332 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 333;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 333 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 334;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 334 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_local size (#{ a = #0L } : ur3) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 335;
    let test = eq el (#{ a = #0L } : ur3) in
    if not test then failwithf "test 335 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 336;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 336 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 337;
    let test = raises in
    if not test then failwithf "test 337 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 338;
    let test = raises in
    if not test then failwithf "test 338 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 339;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 339 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 340;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 340 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 341;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 341 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 342;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 342 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_local size (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 343;
    let test = eq el (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
    if not test then failwithf "test 343 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 344;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 344 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 345;
    let test = raises in
    if not test then failwithf "test 345 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 346;
    let test = raises in
    if not test then failwithf "test 346 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 347;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 347 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 348;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 348 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 349;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 349 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 350;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 350 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_local size #(#0., #0l, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 351;
    let test = eq el #(#0., #0l, #0L) in
    if not test then failwithf "test 351 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 352;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 352 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 353;
    let test = raises in
    if not test then failwithf "test 353 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 354;
    let test = raises in
    if not test then failwithf "test 354 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 355;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 355 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 356;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 356 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 357;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 357 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 358;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 358 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_local size #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 359;
    let test = eq el #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
    if not test then failwithf "test 359 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 360;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 360 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 361;
    let test = raises in
    if not test then failwithf "test 361 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 362;
    let test = raises in
    if not test then failwithf "test 362 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 363;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 363 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 364;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 364 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 365;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 365 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 366;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 366 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_local size #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 367;
    let test = eq el #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
    if not test then failwithf "test 367 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 368;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 368 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 369;
    let test = raises in
    if not test then failwithf "test 369 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 370;
    let test = raises in
    if not test then failwithf "test 370 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 371;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 371 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 372;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 372 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 373;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 373 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 374;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 374 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************)
  (*   float32   *)
  (***************)
  let eq = (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) in
  let mk_value i = Float32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32 array = makearray_dynamic_local size 0.s in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 375;
    let test = eq el 0.s in
    if not test then failwithf "test 375 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 376;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 376 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 377;
    let test = raises in
    if not test then failwithf "test 377 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 378;
    let test = raises in
    if not test then failwithf "test 378 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 379;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 379 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 380;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 380 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 381;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 381 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 382;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 382 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   float   *)
  (*************)
  let eq = (fun a b -> Float.equal (globalize a) (globalize b)) in
  let mk_value i = Float.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float array = makearray_dynamic_local size 0. in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 383;
    let test = eq el 0. in
    if not test then failwithf "test 383 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 384;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 384 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 385;
    let test = raises in
    if not test then failwithf "test 385 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 386;
    let test = raises in
    if not test then failwithf "test 386 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 387;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 387 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 388;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 388 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 389;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 389 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 390;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 390 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int32   *)
  (*************)
  let eq = (fun a b -> Int32.equal (globalize a) (globalize b)) in
  let mk_value i = Int32.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32 array = makearray_dynamic_local size 0l in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 391;
    let test = eq el 0l in
    if not test then failwithf "test 391 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 392;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 392 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 393;
    let test = raises in
    if not test then failwithf "test 393 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 394;
    let test = raises in
    if not test then failwithf "test 394 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 395;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 395 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 396;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 396 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 397;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 397 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 398;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 398 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   int64   *)
  (*************)
  let eq = (fun a b -> Int64.equal (globalize a) (globalize b)) in
  let mk_value i = Int64.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64 array = makearray_dynamic_local size 0L in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 399;
    let test = eq el 0L in
    if not test then failwithf "test 399 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 400;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 400 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 401;
    let test = raises in
    if not test then failwithf "test 401 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 402;
    let test = raises in
    if not test then failwithf "test 402 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 403;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 403 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 404;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 404 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 405;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 405 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 406;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 406 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*****************)
  (*   nativeint   *)
  (*****************)
  let eq = (fun a b -> Nativeint.equal (globalize a) (globalize b)) in
  let mk_value i = Nativeint.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint array = makearray_dynamic_local size 0n in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 407;
    let test = eq el 0n in
    if not test then failwithf "test 407 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 408;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 408 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 409;
    let test = raises in
    if not test then failwithf "test 409 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 410;
    let test = raises in
    if not test then failwithf "test 410 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 411;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 411 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 412;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 412 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 413;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 413 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 414;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 414 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   int   *)
  (***********)
  let eq = (fun a b -> Int.equal a b) in
  let mk_value i = i in
  (* 1. Create an array of size [size] *)
  let a : int array = makearray_dynamic_local size 0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 415;
    let test = eq el 0 in
    if not test then failwithf "test 415 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 416;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 416 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 417;
    let test = raises in
    if not test then failwithf "test 417 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i 0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 418;
    let test = raises in
    if not test then failwithf "test 418 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 419;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 419 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 420;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 420 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 421;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 421 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 422;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 422 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************)
  (*   enum3   *)
  (*************)
  let eq = (fun a b -> match a, b with A3_0, A3_0 | A3_1, A3_1 | A3_2, A3_2 -> true | _ -> false) in
  let mk_value i = (match Int.rem i 3 with 0 -> A3_0 | 1 -> A3_1 | 2 -> A3_2 | _ -> assert false) in
  (* 1. Create an array of size [size] *)
  let a : enum3 array = makearray_dynamic_local size A3_0 in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 423;
    let test = eq el A3_0 in
    if not test then failwithf "test 423 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 424;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 424 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 425;
    let test = raises in
    if not test then failwithf "test 425 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i A3_0 with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 426;
    let test = raises in
    if not test then failwithf "test 426 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 427;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 427 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 428;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 428 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 429;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 429 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 A3_0 in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 430;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 430 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur2   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = i } : ur2) in
  (* 1. Create an array of size [size] *)
  let a : ur2 array = makearray_dynamic_local size (#{ a = #0L; b = 0 } : ur2) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 431;
    let test = eq el (#{ a = #0L; b = 0 } : ur2) in
    if not test then failwithf "test 431 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 432;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 432 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 433;
    let test = raises in
    if not test then failwithf "test 433 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = 0 } : ur2) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 434;
    let test = raises in
    if not test then failwithf "test 434 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 435;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 435 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 436;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 436 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 437;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 437 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = 0 } : ur2) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 438;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 438 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**********************)
  (*   #(int * int64)   *)
  (**********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64.equal (globalize a) (globalize b)) a1 b1) in
  let mk_value i = #(i, Int64.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int * int64) array = makearray_dynamic_local size #(0, 0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 439;
    let test = eq el #(0, 0L) in
    if not test then failwithf "test 439 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 440;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 440 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 441;
    let test = raises in
    if not test then failwithf "test 441 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0, 0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 442;
    let test = raises in
    if not test then failwithf "test 442 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 443;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 443 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 444;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 444 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 445;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 445 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0, 0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 446;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 446 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************************************************************************************************************)
  (*   #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32)   *)
  (**************************************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun a b -> Int64.equal (globalize a) (globalize b)) a b|_->false) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int32.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (Float32.to_float a) (Float32.to_float b)) a0 b0 && (fun a b -> match a, b with None,None -> true | Some a,Some b -> (fun (a0, a1) (b0, b1) -> (fun a b -> Nativeint.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Nativeint.equal (globalize a) (globalize b)) a1 b1) a b|_->false) a1 b1) a3 b3 && (fun a b -> Int32.equal (globalize a) (globalize b)) a4 b4) in
  let mk_value i = #((if i == 0 then None else Some (Int64.of_int i)), #(i, Int32.of_int i, Float.of_int i), Float.of_int i, #(Float32.of_int i, (if i == 0 then None else Some ((Nativeint.of_int i, Nativeint.of_int i)))), Int32.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(int64 option * #(int * int32 * float) * float * #(float32 * (nativeint * nativeint) option) * int32) array = makearray_dynamic_local size #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 447;
    let test = eq el #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
    if not test then failwithf "test 447 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 448;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 448 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 449;
    let test = raises in
    if not test then failwithf "test 449 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 450;
    let test = raises in
    if not test then failwithf "test 450 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 451;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 451 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 452;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 452 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 453;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 453 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(None, #(0, 0l, 0.), 0., #(0.s, None), 0l) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 454;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 454 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float * float * float)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) in
  let mk_value i = #(Float.of_int i, Float.of_int i, Float.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float * float * float) array = makearray_dynamic_local size #(0., 0., 0.) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 455;
    let test = eq el #(0., 0., 0.) in
    if not test then failwithf "test 455 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 456;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 456 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 457;
    let test = raises in
    if not test then failwithf "test 457 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., 0., 0.) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 458;
    let test = raises in
    if not test then failwithf "test 458 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 459;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 459 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 460;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 460 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 461;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 461 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., 0., 0.) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 462;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 462 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*************************************************************************)
  (*   #(float * #(float * float) * #(float * #(float * float * float)))   *)
  (*************************************************************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1) a1 b1 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float.equal (globalize a) (globalize b)) a0 b0 && (fun a b -> Float.equal (globalize a) (globalize b)) a1 b1 && (fun a b -> Float.equal (globalize a) (globalize b)) a2 b2) a1 b1) a2 b2) in
  let mk_value i = #(Float.of_int i, #(Float.of_int i, Float.of_int i), #(Float.of_int i, #(Float.of_int i, Float.of_int i, Float.of_int i))) in
  (* 1. Create an array of size [size] *)
  let a : #(float * #(float * float) * #(float * #(float * float * float))) array = makearray_dynamic_local size #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 463;
    let test = eq el #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
    if not test then failwithf "test 463 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 464;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 464 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 465;
    let test = raises in
    if not test then failwithf "test 465 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(0., #(0., 0.), #(0., #(0., 0., 0.))) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 466;
    let test = raises in
    if not test then failwithf "test 466 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 467;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 467 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 468;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 468 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 469;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 469 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(0., #(0., 0.), #(0., #(0., 0., 0.))) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 470;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 470 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************************)
  (*   #(float# * int * int64#)   *)
  (********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int.equal a b) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int * int64#) array = makearray_dynamic_local size #(#0., 0, #0L) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 471;
    let test = eq el #(#0., 0, #0L) in
    if not test then failwithf "test 471 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 472;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 472 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 473;
    let test = raises in
    if not test then failwithf "test 473 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., 0, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 474;
    let test = raises in
    if not test then failwithf "test 474 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 475;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 475 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 476;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 476 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 477;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 477 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., 0, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 478;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 478 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***************************************************************************************)
  (*   #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int)   *)
  (***************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int.equal a b) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int.equal a b) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int * int64#) * float32# * #(int32# * #(float32# * float#)) * int) array = makearray_dynamic_local size #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 479;
    let test = eq el #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
    if not test then failwithf "test 479 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 480;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 480 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 481;
    let test = raises in
    if not test then failwithf "test 481 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 482;
    let test = raises in
    if not test then failwithf "test 482 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 483;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 483 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 484;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 484 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 485;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 485 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(0, #0L), #0.s, #(#0l, #(#0.s, #0.)), 0) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 486;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 486 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (********************)
  (*   #(ur2 * ur1)   *)
  (********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun (#{ a = a1; b = b1 } : ur2) (#{ a = a2; b = b2 } : ur2) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Int.equal a b) b1 b2) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #((#{ a = Int64_u.of_int i; b = i } : ur2), (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(ur2 * ur1) array = makearray_dynamic_local size #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    mark_test_run 487;
    let test = eq el #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
    if not test then failwithf "test 487 failed %d %d" size i;
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 488;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 488 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 489;
    let test = raises in
    if not test then failwithf "test 489 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 490;
    let test = raises in
    if not test then failwithf "test 490 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 491;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 491 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 492;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 492 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 493;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 493 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #((#{ a = #0L; b = 0 } : ur2), (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 494;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 494 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_uninit size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 495;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 495 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 496;
    let test = raises in
    if not test then failwithf "test 496 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 497;
    let test = raises in
    if not test then failwithf "test 497 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 498;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 498 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 499;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 499 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 500;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 500 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 501;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 501 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 502;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 502 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 503;
    let test = raises in
    if not test then failwithf "test 503 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 504;
    let test = raises in
    if not test then failwithf "test 504 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 505;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 505 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 506;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 506 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 507;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 507 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 508;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 508 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 509;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 509 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 510;
    let test = raises in
    if not test then failwithf "test 510 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 511;
    let test = raises in
    if not test then failwithf "test 511 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 512;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 512 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 513;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 513 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 514;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 514 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 515;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 515 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 516;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 516 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 517;
    let test = raises in
    if not test then failwithf "test 517 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 518;
    let test = raises in
    if not test then failwithf "test 518 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 519;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 519 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 520;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 520 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 521;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 521 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 522;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 522 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 523;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 523 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 524;
    let test = raises in
    if not test then failwithf "test 524 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 525;
    let test = raises in
    if not test then failwithf "test 525 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 526;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 526 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 527;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 527 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 528;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 528 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 529;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 529 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 530;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 530 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 531;
    let test = raises in
    if not test then failwithf "test 531 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 532;
    let test = raises in
    if not test then failwithf "test 532 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 533;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 533 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 534;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 534 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 535;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 535 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 536;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 536 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 537;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 537 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 538;
    let test = raises in
    if not test then failwithf "test 538 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 539;
    let test = raises in
    if not test then failwithf "test 539 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 540;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 540 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 541;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 541 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 542;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 542 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 543;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 543 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 544;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 544 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 545;
    let test = raises in
    if not test then failwithf "test 545 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 546;
    let test = raises in
    if not test then failwithf "test 546 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 547;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 547 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 548;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 548 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 549;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 549 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 550;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 550 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 551;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 551 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 552;
    let test = raises in
    if not test then failwithf "test 552 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 553;
    let test = raises in
    if not test then failwithf "test 553 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 554;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 554 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 555;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 555 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 556;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 556 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 557;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 557 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 558;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 558 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 559;
    let test = raises in
    if not test then failwithf "test 559 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 560;
    let test = raises in
    if not test then failwithf "test 560 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 561;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 561 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 562;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 562 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 563;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 563 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 564;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 564 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_uninit size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 565;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 565 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 566;
    let test = raises in
    if not test then failwithf "test 566 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 567;
    let test = raises in
    if not test then failwithf "test 567 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 568;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 568 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 569;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 569 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 570;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 570 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 571;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 571 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

let test_makearray_dynamic_uninit_local size =
  (****************)
  (*   float32#   *)
  (****************)
  let eq = (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) in
  let mk_value i = Float32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float32# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 572;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 572 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 573;
    let test = raises in
    if not test then failwithf "test 573 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0.s with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 574;
    let test = raises in
    if not test then failwithf "test 574 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 575;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 575 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 576;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 576 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 577;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 577 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0.s in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 578;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 578 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   float#   *)
  (**************)
  let eq = (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) in
  let mk_value i = Float_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : float# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 579;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 579 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 580;
    let test = raises in
    if not test then failwithf "test 580 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0. with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 581;
    let test = raises in
    if not test then failwithf "test 581 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 582;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 582 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 583;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 583 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 584;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 584 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0. in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 585;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 585 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int32#   *)
  (**************)
  let eq = (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) in
  let mk_value i = Int32_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int32# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 586;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 586 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 587;
    let test = raises in
    if not test then failwithf "test 587 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0l with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 588;
    let test = raises in
    if not test then failwithf "test 588 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 589;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 589 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 590;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 590 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 591;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 591 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0l in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 592;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 592 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (**************)
  (*   int64#   *)
  (**************)
  let eq = (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) in
  let mk_value i = Int64_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : int64# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 593;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 593 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 594;
    let test = raises in
    if not test then failwithf "test 594 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0L with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 595;
    let test = raises in
    if not test then failwithf "test 595 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 596;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 596 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 597;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 597 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 598;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 598 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0L in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 599;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 599 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (******************)
  (*   nativeint#   *)
  (******************)
  let eq = (fun a b -> Nativeint_u.(equal (add #0n a) (add #0n b))) in
  let mk_value i = Nativeint_u.of_int i in
  (* 1. Create an array of size [size] *)
  let a : nativeint# array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 600;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 600 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 601;
    let test = raises in
    if not test then failwithf "test 601 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #0n with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 602;
    let test = raises in
    if not test then failwithf "test 602 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 603;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 603 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 604;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 604 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 605;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 605 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #0n in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 606;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 606 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur1   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) in
  let mk_value i = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1) in
  (* 1. Create an array of size [size] *)
  let a : ur1 array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 607;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 607 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 608;
    let test = raises in
    if not test then failwithf "test 608 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L; b = #0. } : ur1) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 609;
    let test = raises in
    if not test then failwithf "test 609 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 610;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 610 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 611;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 611 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 612;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 612 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L; b = #0. } : ur1) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 613;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 613 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur3   *)
  (***********)
  let eq = (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) in
  let mk_value i = (#{ a = Int64_u.of_int i } : ur3) in
  (* 1. Create an array of size [size] *)
  let a : ur3 array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 614;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 614 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 615;
    let test = raises in
    if not test then failwithf "test 615 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = #0L } : ur3) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 616;
    let test = raises in
    if not test then failwithf "test 616 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 617;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 617 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 618;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 618 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 619;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 619 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = #0L } : ur3) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 620;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 620 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********)
  (*   ur4   *)
  (***********)
  let eq = (fun (#{ a = a1; b = b1 } : ur4) (#{ a = a2; b = b2 } : ur4) -> (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 a2 && (fun (#{ a = a1 } : ur3) (#{ a = a2 } : ur3) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2) b1 b2) in
  let mk_value i = (#{ a = (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1); b = (#{ a = Int64_u.of_int i } : ur3) } : ur4) in
  (* 1. Create an array of size [size] *)
  let a : ur4 array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 621;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 621 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 622;
    let test = raises in
    if not test then failwithf "test 622 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 623;
    let test = raises in
    if not test then failwithf "test 623 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 624;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 624 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 625;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 625 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 626;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 626 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 (#{ a = (#{ a = #0L; b = #0. } : ur1); b = (#{ a = #0L } : ur3) } : ur4) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 627;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 627 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************************)
  (*   #(float# * int32# * int64#)   *)
  (***********************************)
  let eq = (fun #(a0, a1, a2) #(b0, b1, b2) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a1 b1 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a2 b2) in
  let mk_value i = #(Float_u.of_int i, Int32_u.of_int i, Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * int32# * int64#) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 628;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 628 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 629;
    let test = raises in
    if not test then failwithf "test 629 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #0l, #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 630;
    let test = raises in
    if not test then failwithf "test 630 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 631;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 631 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 632;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 632 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 633;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 633 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #0l, #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 634;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 634 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (*********************************************************************************************)
  (*   #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#)   *)
  (*********************************************************************************************)
  let eq = (fun #(a0, a1, a2, a3, a4) #(b0, b1, b2, b3, b4) -> (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 b1) a1 b1 && (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a2 b2 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int32_u.(equal (add #0l a) (add #0l b))) a0 b0 && (fun #(a0, a1) #(b0, b1) -> (fun a b -> Float32_u.(equal (add #0.s a) (add #0.s b))) a0 b0 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) a1 b1) a1 b1) a3 b3 && (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a4 b4) in
  let mk_value i = #(Float_u.of_int i, #(Int64_u.of_int i, Int64_u.of_int i), Float32_u.of_int i, #(Int32_u.of_int i, #(Float32_u.of_int i, Float_u.of_int i)), Int64_u.of_int i) in
  (* 1. Create an array of size [size] *)
  let a : #(float# * #(int64# * int64#) * float32# * #(int32# * #(float32# * float#)) * int64#) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 635;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 635 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 636;
    let test = raises in
    if not test then failwithf "test 636 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 637;
    let test = raises in
    if not test then failwithf "test 637 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 638;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 638 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 639;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 639 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 640;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 640 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0., #(#0L, #0L), #0.s, #(#0l, #(#0.s, #0.)), #0L) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 641;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 641 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  (***********************)
  (*   #(int64# * ur1)   *)
  (***********************)
  let eq = (fun #(a0, a1) #(b0, b1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a0 b0 && (fun (#{ a = a1; b = b1 } : ur1) (#{ a = a2; b = b2 } : ur1) -> (fun a b -> Int64_u.(equal (add #0L a) (add #0L b))) a1 a2 && (fun a b -> Float_u.(equal (add #0. a) (add #0. b))) b1 b2) a1 b1) in
  let mk_value i = #(Int64_u.of_int i, (#{ a = Int64_u.of_int i; b = Float_u.of_int i } : ur1)) in
  (* 1. Create an array of size [size] *)
  let a : #(int64# * ur1) array = makearray_dynamic_uninit_local size in
  (* 2. For uninitialized arrays, element values are unspecified *)
  (* 2. For initialized arrays, check all elements have the correct value *)
  for i = 0 to size - 1 do
    let el = get a i in
    let _ = el in ()
  done;
  (* 3. Fill [a] with distinct values and read back those values *)
  for i = 0 to size - 1 do
    set a i (mk_value i);
  done;
  Gc.compact ();
  for i = 0 to size - 1 do
    mark_test_run 642;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 642 failed %d %d" size i;
  done;
  iter (bad_indices size) ~f:(fun i ->
    (* 4. Getting bad indices errors *)
    let raises =
      match get a i with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 643;
    let test = raises in
    if not test then failwithf "test 643 failed %d %d" size i;
    (* 5. Setting bad indices errors *)
    let raises =
      match set a i #(#0L, (#{ a = #0L; b = #0. } : ur1)) with
      | exception Invalid_argument _ -> true
      | _ -> false
    in
    mark_test_run 644;
    let test = raises in
    if not test then failwithf "test 644 failed %d %d" size i;
  ) [@nontail];
  Gc.compact ();
  (* 6. Array contents were unaffacted by setting bad indices *)
  for i = 0 to size - 1 do
    mark_test_run 645;
    let test = eq (get a i) (mk_value i) in
    if not test then failwithf "test 645 failed %d %d" size i;
  done;
  (* 7. Overlapping blits *)
  iter (blit_offsets size) ~f:(fun ofs1 ->
    iter (blit_offsets size) ~f:(fun ofs2 ->
      iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2:size) ~f:(fun len ->
        unsafe_blit a ofs1 a ofs2 len;
        for i = 0 to size - 1 do
          let expected_src_i =
            if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else i
          in
          mark_test_run 646;
          let test = eq (get a i) (mk_value expected_src_i) in
          if not test then failwithf "test 646 failed %d %d %d %d %d" size ofs1 ofs2 len i;
        done;
        (* Reset array *)
        for i = 0 to size - 1 do
          set a i (mk_value i);
        done;
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 8. Blits to heap arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let a2 = makearray_dynamic size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 647;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 647 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();
  (* 9. Blits to local arrays *)
  iter (sizes) ~f:(fun size2 ->
    iter (blit_offsets size) ~f:(fun ofs1 ->
      iter (blit_offsets size2) ~f:(fun ofs2 ->
        iter (blit_lens ~ofs1 ~ofs2 ~size1:size ~size2) ~f:(fun len ->
          let local_ a2 = makearray_dynamic_local size2 #(#0L, (#{ a = #0L; b = #0. } : ur1)) in
          unsafe_blit a ofs1 a2 ofs2 len;
          for i = 0 to size2 - 1 do
            let expected_src_i =
              if i >= ofs2 && i < ofs2 + len then i - ofs2 + ofs1 else 0
            in
            mark_test_run 648;
            let test = eq (get a2 i) (mk_value expected_src_i) in
            if not test then failwithf "test 648 failed %d %d %d %d %d %d" size size2 ofs1 ofs2 len i;
          done;
        ) [@nontail];
      ) [@nontail];
    ) [@nontail];
  ) [@nontail];
  Gc.compact ();

  ()

(* Main tests *)
let () =
  print_endline "test_makearray_dynamic";
  iter sizes ~f:test_makearray_dynamic;
  print_endline "test_makearray_dynamic_local";
  iter sizes ~f:test_makearray_dynamic_local;
  print_endline "test_makearray_dynamic_uninit";
  iter sizes ~f:test_makearray_dynamic_uninit;
  print_endline "test_makearray_dynamic_uninit_local";
  iter sizes ~f:test_makearray_dynamic_uninit_local;
  ()
;;

for i = 1 to 648 do
  if not (List.mem ~set:!tests_run i) then failwithf "test %d not run" i
done;;
let () = Printf.printf "All tests passed.%!\n";;
