module Stdlib = struct
  external register_named_value : string -> 'a -> unit
    = "caml_register_named_value"

  let () =
    (* for runtime/fail_nat.c *)
    register_named_value "Pervasives.array_bound_error"
      (Invalid_argument "index out of bounds")

  external raise : exn -> 'a = "%raise"

  external raise_notrace : exn -> 'a = "%raise_notrace"

  let failwith s = raise (Failure s)

  let invalid_arg s = raise (Invalid_argument s)

  exception Exit

  exception Match_failure = Match_failure

  exception Assert_failure = Assert_failure

  exception Invalid_argument = Invalid_argument

  exception Failure = Failure

  exception Not_found = Not_found

  exception Out_of_memory = Out_of_memory

  exception Stack_overflow = Stack_overflow

  exception Sys_error = Sys_error

  exception End_of_file = End_of_file

  exception Division_by_zero = Division_by_zero

  exception Sys_blocked_io = Sys_blocked_io

  exception Undefined_recursive_module = Undefined_recursive_module

  (* Composition operators *)

  external ( |> ) : 'a -> ('a -> 'b) -> 'b = "%revapply"

  external ( @@ ) : ('a -> 'b) -> 'a -> 'b = "%apply"

  (* Debugging *)

  external __LOC__ : string = "%loc_LOC"

  external __FILE__ : string = "%loc_FILE"

  external __LINE__ : int = "%loc_LINE"

  external __MODULE__ : string = "%loc_MODULE"

  external __POS__ : string * int * int * int = "%loc_POS"

  external __LOC_OF__ : 'a -> string * 'a = "%loc_LOC"

  external __LINE_OF__ : 'a -> int * 'a = "%loc_LINE"

  external __POS_OF__ : 'a -> (string * int * int * int) * 'a = "%loc_POS"

  (* Comparisons *)

  external ( = ) : 'a -> 'a -> bool = "%equal"

  external ( <> ) : 'a -> 'a -> bool = "%notequal"

  external ( < ) : 'a -> 'a -> bool = "%lessthan"

  external ( > ) : 'a -> 'a -> bool = "%greaterthan"

  external ( <= ) : 'a -> 'a -> bool = "%lessequal"

  external ( >= ) : 'a -> 'a -> bool = "%greaterequal"

  external compare : 'a -> 'a -> int = "%compare"

  let min x y = if x <= y then x else y

  let max x y = if x >= y then x else y

  external ( == ) : 'a -> 'a -> bool = "%eq"

  external ( != ) : 'a -> 'a -> bool = "%noteq"

  (* Boolean operations *)

  external not : bool -> bool = "%boolnot"

  external ( & ) : bool -> bool -> bool = "%sequand"

  external ( && ) : bool -> bool -> bool = "%sequand"

  external ( or ) : bool -> bool -> bool = "%sequor"

  external ( || ) : bool -> bool -> bool = "%sequor"

  (* Integer operations *)

  external ( ~- ) : int -> int = "%negint"

  external ( ~+ ) : int -> int = "%identity"

  external succ : int -> int = "%succint"

  external pred : int -> int = "%predint"

  external ( + ) : int -> int -> int = "%addint"

  external ( - ) : int -> int -> int = "%subint"

  external ( * ) : int -> int -> int = "%mulint"

  external ( / ) : int -> int -> int = "%divint"

  external ( mod ) : int -> int -> int = "%modint"

  let abs x = if x >= 0 then x else -x

  external ( land ) : int -> int -> int = "%andint"

  external ( lor ) : int -> int -> int = "%orint"

  external ( lxor ) : int -> int -> int = "%xorint"

  let lnot x = x lxor -1

  external ( lsl ) : int -> int -> int = "%lslint"

  external ( lsr ) : int -> int -> int = "%lsrint"

  external ( asr ) : int -> int -> int = "%asrint"

  let max_int = -1 lsr 1

  let min_int = max_int + 1

  (* Floating-point operations *)
end

open Stdlib

let char_hex n =
  Char.unsafe_chr (n + if n < 10 then Char.code '0' else Char.code 'a' - 10)

let to_hex d =
  if String.length d <> 16 then invalid_arg "Digest.to_hex";
  let result = Bytes.create 32 in
  for i = 0 to 15 do
    let x = Char.code d.[i] in
    Bytes.unsafe_set result (i * 2) (char_hex (x lsr 4));
    Bytes.unsafe_set result ((i * 2) + 1) (char_hex (x land 0x0f))
  done;
  Bytes.unsafe_to_string result
