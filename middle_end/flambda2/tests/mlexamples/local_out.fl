let $camlLocal__const_block9 = Block 0 (3, 0) in
let $camlLocal__const_block11 = Block 0 (2, $camlLocal__const_block9) in
let $camlLocal__const_block13 = Block 0 (1, $camlLocal__const_block11) in
let $camlLocal__const_block44 = Block 0 (1, 0) in
let $camlLocal__immstring50 = "local.ml" in
let $camlLocal__const_block52 = Block 0 ($camlLocal__immstring50, 18, 9) in
let $camlLocal__Pmakeblock55 =
  Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlLocal__const_block52)
in
let $camlLocal__const_block66 = Block 0 ($camlLocal__immstring50, 20, 9) in
let $camlLocal__Pmakeblock69 =
  Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlLocal__const_block66)
in
let $camlLocal__const_block89 = Block 0 ($camlLocal__immstring50, 25, 2) in
let $camlLocal__Pmakeblock92 =
  Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlLocal__const_block89)
in
let $camlLocal__const_block161 = Block 0 (4, 0) in
let $camlLocal__const_block163 = Block 0 (3, $camlLocal__const_block161) in
let $camlLocal__const_block165 = Block 0 (2, $camlLocal__const_block163) in
let $camlLocal__const_block167 = Block 0 (1, $camlLocal__const_block165) in
let $camlLocal__const_block169 = Block 0 (0, $camlLocal__const_block167) in
let $camlLocal__const_block176 = Block 0 ($camlLocal__immstring50, 49, 2) in
let $camlLocal__Pmakeblock179 =
  Block 0 ($`*predef*`.caml_exn_Assert_failure, $camlLocal__const_block176)
in
let code return_local_0 deleted in
let code map_local_1 deleted in
let code length_2 deleted in
let code `anon-fn[local.ml:24,27--43]_3` deleted in
let code rev_app_4 deleted in
let code find_span_6 deleted in
let code spans_5 deleted in
let code is_even_7 deleted in
let code loopify(never) size(1) newer_version_of(return_local_0)
      return_local_0_1 (param : imm tagged)
        my_closure my_region my_ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  cont k ($camlLocal__const_block13)
in
let $camlLocal__return_local_8 = closure return_local_0_1 @return_local in
let $camlLocal__map_local_9 =
  closure map_local_1_1 @map_local
and code rec loopify(never) size(31) newer_version_of(map_local_1)
      map_local_1_1 (f, l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure my_region my_ghost_region my_depth
        -> k * k1
        : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
  let prim = %is_int l in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      ((let Pfield = %block_load (1) l in
        apply direct(map_local_1_1 &my_region &my_ghost_region)
          ($camlLocal__map_local_9 ~ depth my_depth -> succ my_depth
           : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
            (f, Pfield)
            -> k2 * k1)
         where k2 (apply_result : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
           ((let Pfield = %block_load (0) l in
             apply f (Pfield) -> k2 * k1)
              where k2 (apply_result_1) =
                let Pmakeblock =
                  %Block 0 &my_region (apply_result_1, apply_result)
                in
                cont k (Pmakeblock)))
in
let $camlLocal__length_10 =
  closure length_2_1 @length
and code rec loopify(never) size(19) newer_version_of(length_2)
      length_2_1 (l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
        my_closure my_region my_ghost_region my_depth
        -> k * k1
        : imm tagged =
  let prim = %is_int l in
  switch prim
    | 0 -> k2
    | 1 -> k (0)
    where k2 =
      ((let Pfield = %block_load (1) l in
        apply direct(length_2_1)
          ($camlLocal__length_10 ~ depth my_depth -> succ my_depth
           : _ -> imm tagged)
            (Pfield)
            -> k2 * k1)
         where k2 (apply_result : imm tagged) =
           let Paddint = 1 + apply_result in
           cont k (Paddint))
in
apply direct(length_2_1)
  ($camlLocal__length_10 : _ -> imm tagged)
    ($camlLocal__const_block44)
    -> k1 * error
  where k1 (apply_result : imm tagged) =
    let prim = %phys_eq (apply_result, 1) in
    switch prim
      | 0 -> error pop(regular error) ($camlLocal__Pmakeblock55)
      | 1 -> k
  where k =
    let `region` = %begin_region in
    let `ghost_region` = %begin_ghost_region in
    (apply direct(length_2_1) inlining_state(depth(30))
       ($camlLocal__length_10 ~ depth unroll 1 2 -> unroll 0 3
        : _ -> imm tagged)
         (0)
         -> k1 * error
       where k1 (apply_result : imm tagged) =
         let Paddint = 1 + apply_result in
         let Paddint_1 = 1 + Paddint in
         let Paddint_2 = 1 + Paddint_1 in
         let prim = %phys_eq (Paddint_2, 3) in
         switch prim
           | 0 -> error pop(regular error) ($camlLocal__Pmakeblock69)
           | 1 -> k
       where k =
         let `unit` = %end_region `region` in
         let `unit` = %end_ghost_region `ghost_region` in
         let region_1 = %begin_region in
         let ghost_region_1 = %begin_ghost_region in
         ((let code loopify(never) size(3) newer_version_of(`anon-fn[local.ml:24,27--43]_3`)
                 `anon-fn[local.ml:24,27--43]_3_1` (i : imm tagged)
                   my_closure my_region my_ghost_region my_depth
                   -> k2 * k3
                   : imm tagged =
             let Paddint = i + 1 in
             cont k2 (Paddint)
           in
           let $`camlLocal__anon-fn[local.ml:24,27--43]_11` =
             closure `anon-fn[local.ml:24,27--43]_3_1`
               @`anon-fn[local.ml:24,27--43]`
           in
           apply direct(map_local_1_1 &region_1 &ghost_region_1)
             ($camlLocal__map_local_9
              : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
               ($`camlLocal__anon-fn[local.ml:24,27--43]_11`,
                $camlLocal__const_block13)
               -> k1 * error)
            where k1 (ms : [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
              (apply direct(length_2_1)
                 ($camlLocal__length_10 : _ -> imm tagged) (ms) -> k1 * error
                 where k1 (apply_result : imm tagged) =
                   let prim = %phys_eq (apply_result, 3) in
                   switch prim
                     | 0 -> error
                              pop(regular error)
                              ($camlLocal__Pmakeblock92)
                     | 1 -> k)
            where k =
              let unit_1 = %end_region region_1 in
              let unit_1 = %end_ghost_region ghost_region_1 in
              let code rec loopify(done) size(22) newer_version_of(rev_app_4)
                    rev_app_4_1
                      (l1 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                       l2 : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                      my_closure my_region my_ghost_region my_depth
                      -> k * k1
                      : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
                cont self (l1, l2)
                  where rec self
                              (l1_1 :
                                 [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                               l2_1 :
                                 [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                    let prim = %is_int l1_1 in
                    (switch prim
                       | 0 -> k2
                       | 1 -> k (l2_1)
                       where k2 =
                         let Pfield = %block_load (0) l1_1 in
                         let Pmakeblock = %Block 0 (Pfield, l2_1) in
                         let Pfield_1 = %block_load (1) l1_1 in
                         cont self (Pfield_1, Pmakeblock))
              in
              let $camlLocal__rev_app_12 = closure rev_app_4_1 @rev_app in
              let code rec loopify(never) size(36) newer_version_of(spans_5)
                    spans_5_1
                      (break_here,
                       l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                      my_closure my_region my_ghost_region my_depth
                      -> k * k1
                      : [ 0 | 0 of val * [ 0 | 0 of val * val ] ] =
                let region_2 = %begin_region in
                let ghost_region_2 = %begin_ghost_region in
                (let prim = %is_int l in
                 switch prim
                   | 0 -> k3
                   | 1 -> k2 (0)
                   where k3 =
                     (apply direct(find_span_6_1 &region_2 &ghost_region_2)
                        ($camlLocal__find_span_14 ~ depth my_depth -> succ my_depth
                         : _ ->
                           [ 0 of [ 0 | 0 of val * val ] *
                               [ 0 | 0 of val * val ] ]
                         )
                          (break_here, l, 0)
                          -> k3 * k1
                        where k3
                                (`*match*` :
                                   [ 0 of [ 0 | 0 of val * val ] *
                                       [ 0 | 0 of val * val ] ]) =
                          ((let Pfield = %block_load (1) `*match*` in
                            apply direct(spans_5_1)
                              ($camlLocal__spans_13 ~ depth my_depth -> succ my_depth
                               : _ ->
                                 [ 0 | 0 of val * [ 0 | 0 of val * val ] ]
                               )
                                (break_here, Pfield)
                                -> k3 * k1)
                             where k3
                                     (apply_result :
                                        [ 0
                                        | 0 of val * [ 0 | 0 of val * val ] ]) =
                               ((let Pfield = %block_load (0) `*match*` in
                                 apply direct(rev_app_4_1)
                                   ($camlLocal__rev_app_12
                                    : _ ->
                                      [ 0 | 0 of val * [ 0 | 0 of val * val ]
                                      ]
                                    )
                                     (Pfield, 0)
                                     -> k3 * k1)
                                  where k3
                                          (apply_result_1 :
                                             [ 0
                                             | 0 of val *
                                                 [ 0 | 0 of val * val ] ]) =
                                    let Pmakeblock =
                                      %Block 0 (apply_result_1, apply_result)
                                    in
                                    cont k2 (Pmakeblock)))))
                  where k2
                          (region_return :
                             [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                    let unit_2 = %end_region region_2 in
                    let unit_2 = %end_ghost_region ghost_region_2 in
                    cont k (region_return)
              and $camlLocal__spans_13 =
                closure spans_5_1 @spans
              and $camlLocal__find_span_14 =
                closure find_span_6_1 @find_span
              and code rec loopify(never) size(58) newer_version_of(find_span_6)
                    find_span_6_1
                      (break_here,
                       l : [ 0 | 0 of val * [ 0 | 0 of val * val ] ],
                       acc : [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                      my_closure my_region my_ghost_region my_depth
                      -> k * k1
                      : [ 0 of [ 0 | 0 of val * val ] *
                            [ 0 | 0 of val * val ] ] =
                let prim = %is_int l in
                switch prim
                  | 0 -> k2
                  | 1 -> k3
                  where k3 =
                    let Pmakeblock = %Block 0 &my_region (acc, 0) in
                    cont k (Pmakeblock)
                  where k2 =
                    let l_1 = %block_load (1) l in
                    let a = %block_load (0) l in
                    let acc_1 = %Block 0 &my_region (a, acc) in
                    (apply break_here (a) -> k3 * k1
                       where k3 (param : imm tagged) =
                         let unboxed_field = %untag_imm param in
                         cont k2 (unboxed_field)
                       where k2 (unboxed_field : imm) =
                         let naked_immediate = unboxed_field in
                         (switch naked_immediate
                            | 0 -> k2
                            | 1 -> k3
                            where k3 =
                              let Pmakeblock =
                                %Block 0 &my_region (acc_1, l_1)
                              in
                              cont k (Pmakeblock)
                            where k2 =
                              apply direct(find_span_6_1 &my_region &my_ghost_region)
                                ($camlLocal__find_span_14 ~ depth my_depth -> succ my_depth
                                 : _ ->
                                   [ 0 of [ 0 | 0 of val * val ] *
                                       [ 0 | 0 of val * val ] ]
                                 )
                                  (break_here, l_1, acc_1)
                                  -> k * k1))
              in
              let code loopify(never) size(9) newer_version_of(is_even_7)
                    is_even_7_1 (i : imm tagged)
                      my_closure my_region my_ghost_region my_depth
                      -> k * k1
                      : imm tagged =
                let Pmodint = i % 2 in
                let prim = %phys_eq (Pmodint, 0) in
                let Pintcomp = %Tag_imm prim in
                cont k (Pintcomp)
              in
              let $camlLocal__is_even_15 = closure is_even_7_1 @is_even in
              (apply direct(spans_5_1)
                 ($camlLocal__spans_13
                  : _ -> [ 0 | 0 of val * [ 0 | 0 of val * val ] ])
                   ($camlLocal__is_even_15, $camlLocal__const_block169)
                   -> k1 * error
                 where k1
                         (even_spans :
                            [ 0 | 0 of val * [ 0 | 0 of val * val ] ]) =
                   (apply direct(length_2_1)
                      ($camlLocal__length_10 : _ -> imm tagged)
                        (even_spans)
                        -> k1 * error
                      where k1 (apply_result : imm tagged) =
                        let prim = %phys_eq (apply_result, 3) in
                        switch prim
                          | 0 -> error
                                   pop(regular error)
                                   ($camlLocal__Pmakeblock179)
                          | 1 -> k)
                 where k =
                   let $camlLocal =
                     Block 0 ($camlLocal__return_local_8,
                              $camlLocal__map_local_9,
                              $camlLocal__length_10,
                              $camlLocal__rev_app_12,
                              $camlLocal__spans_13,
                              $camlLocal__find_span_14,
                              $camlLocal__is_even_15)
                   in
                   cont done ($camlLocal))))
