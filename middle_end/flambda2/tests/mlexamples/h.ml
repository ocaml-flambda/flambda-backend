(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Stdlib = struct
  external register_named_value : string -> 'a -> unit
    = "caml_register_named_value"

  external raise : exn -> 'a = "%raise"

  external raise_notrace : exn -> 'a = "%raise_notrace"

  let failwith s = raise (Failure s)

  let invalid_arg s = raise (Invalid_argument s)

  (* Composition operators *)

  external ( |> ) : 'a -> ('a -> 'b) -> 'b = "%revapply"

  external ( @@ ) : ('a -> 'b) -> 'a -> 'b = "%apply"

  (* Debugging *)

  external __LOC__ : string = "%loc_LOC"

  external __FILE__ : string = "%loc_FILE"

  external __LINE__ : int = "%loc_LINE"

  external __MODULE__ : string = "%loc_MODULE"

  external __POS__ : string * int * int * int = "%loc_POS"

  external __LOC_OF__ : 'a -> string * 'a = "%loc_LOC"

  external __LINE_OF__ : 'a -> int * 'a = "%loc_LINE"

  external __POS_OF__ : 'a -> (string * int * int * int) * 'a = "%loc_POS"

  (* Comparisons *)

  external ( = ) : 'a -> 'a -> bool = "%equal"

  external ( <> ) : 'a -> 'a -> bool = "%notequal"

  external ( < ) : 'a -> 'a -> bool = "%lessthan"

  external ( > ) : 'a -> 'a -> bool = "%greaterthan"

  external ( <= ) : 'a -> 'a -> bool = "%lessequal"

  external ( >= ) : 'a -> 'a -> bool = "%greaterequal"

  external compare : 'a -> 'a -> int = "%compare"

  external ( == ) : 'a -> 'a -> bool = "%eq"

  external ( != ) : 'a -> 'a -> bool = "%noteq"

  (* Boolean operations *)

  external not : bool -> bool = "%boolnot"

  external ( & ) : bool -> bool -> bool = "%sequand"

  external ( && ) : bool -> bool -> bool = "%sequand"

  external ( or ) : bool -> bool -> bool = "%sequor"

  external ( || ) : bool -> bool -> bool = "%sequor"

  (* Integer operations *)

  external ( ~- ) : int -> int = "%negint"

  external ( ~+ ) : int -> int = "%identity"

  external succ : int -> int = "%succint"

  external pred : int -> int = "%predint"

  external ( + ) : int -> int -> int = "%addint"

  external ( - ) : int -> int -> int = "%subint"

  external ( * ) : int -> int -> int = "%mulint"

  external ( / ) : int -> int -> int = "%divint"

  external ( mod ) : int -> int -> int = "%modint"

  (* Floating-point operations *)

  external ( ~-. ) : float -> float = "%negfloat"

  external ( ~+. ) : float -> float = "%identity"

  external ( +. ) : float -> float -> float = "%addfloat"

  external ( -. ) : float -> float -> float = "%subfloat"

  external ( *. ) : float -> float -> float = "%mulfloat"

  external ( /. ) : float -> float -> float = "%divfloat"

  external ( ** ) : float -> float -> float = "caml_power_float" "pow"
    [@@unboxed] [@@noalloc]

  external exp : float -> float = "caml_exp_float" "exp" [@@unboxed] [@@noalloc]

  external expm1 : float -> float = "caml_expm1_float" "caml_expm1"
    [@@unboxed] [@@noalloc]

  external acos : float -> float = "caml_acos_float" "acos"
    [@@unboxed] [@@noalloc]

  external asin : float -> float = "caml_asin_float" "asin"
    [@@unboxed] [@@noalloc]

  external atan : float -> float = "caml_atan_float" "atan"
    [@@unboxed] [@@noalloc]

  external atan2 : float -> float -> float = "caml_atan2_float" "atan2"
    [@@unboxed] [@@noalloc]

  external hypot : float -> float -> float = "caml_hypot_float" "caml_hypot"
    [@@unboxed] [@@noalloc]

  external cos : float -> float = "caml_cos_float" "cos" [@@unboxed] [@@noalloc]

  external cosh : float -> float = "caml_cosh_float" "cosh"
    [@@unboxed] [@@noalloc]

  external log : float -> float = "caml_log_float" "log" [@@unboxed] [@@noalloc]

  external log10 : float -> float = "caml_log10_float" "log10"
    [@@unboxed] [@@noalloc]

  external log1p : float -> float = "caml_log1p_float" "caml_log1p"
    [@@unboxed] [@@noalloc]

  external sin : float -> float = "caml_sin_float" "sin" [@@unboxed] [@@noalloc]

  external sinh : float -> float = "caml_sinh_float" "sinh"
    [@@unboxed] [@@noalloc]

  external sqrt : float -> float = "caml_sqrt_float" "sqrt"
    [@@unboxed] [@@noalloc]

  external tan : float -> float = "caml_tan_float" "tan" [@@unboxed] [@@noalloc]

  external tanh : float -> float = "caml_tanh_float" "tanh"
    [@@unboxed] [@@noalloc]

  external ceil : float -> float = "caml_ceil_float" "ceil"
    [@@unboxed] [@@noalloc]

  external floor : float -> float = "caml_floor_float" "floor"
    [@@unboxed] [@@noalloc]

  external abs_float : float -> float = "%absfloat"

  external copysign : float -> float -> float
    = "caml_copysign_float" "caml_copysign"
    [@@unboxed] [@@noalloc]

  external mod_float : float -> float -> float = "caml_fmod_float" "fmod"
    [@@unboxed] [@@noalloc]

  external frexp : float -> float * int = "caml_frexp_float"

  external ldexp : (float[@unboxed]) -> (int[@untagged]) -> (float[@unboxed])
    = "caml_ldexp_float" "caml_ldexp_float_unboxed"
    [@@noalloc]

  external modf : float -> float * float = "caml_modf_float"

  external float : int -> float = "%floatofint"

  external float_of_int : int -> float = "%floatofint"

  external truncate : float -> int = "%intoffloat"

  external int_of_float : float -> int = "%intoffloat"

  external float_of_bits : int64 -> float
    = "caml_int64_float_of_bits" "caml_int64_float_of_bits_unboxed"
    [@@unboxed] [@@noalloc]
end

open Stdlib
(* Hash tables *)

external seeded_hash_param : int -> int -> int -> 'a -> int = "caml_hash_exn"

external old_hash_param : int -> int -> 'a -> int = "caml_hash_univ_param"
  [@@noalloc]

type ('a, 'b) t =
  { mutable size : int;
    (* number of entries *)
    mutable data : ('a, 'b) bucketlist array;
    (* the buckets *)
    mutable seed : int;
    (* for randomization *)
    mutable initial_size : int (* initial array size *)
  }

and ('a, 'b) bucketlist =
  | Empty
  | Cons of
      { mutable key : 'a;
        mutable data : 'b;
        mutable next : ('a, 'b) bucketlist
      }

let ongoing_traversal h =
  Obj.size (Obj.repr (Sys.opaque_identity h)) < 4
  (* compatibility with old hash tables *)
  || h.initial_size < 0

let flip_ongoing_traversal h = h.initial_size <- -h.initial_size

let[@inline never] filter_map_inplace_bucket _ _ _ _ _ = ()

let filter_map_inplace f htab =
  let d = htab.data in
  let old_trav = ongoing_traversal htab in
  if not old_trav then flip_ongoing_traversal htab;
  try
    for i = 0 to Array.length d - 1 do
      filter_map_inplace_bucket f htab i Empty htab.data.(i)
    done
  with exn when not old_trav -> flip_ongoing_traversal htab
